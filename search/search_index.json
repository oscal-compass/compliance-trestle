{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Compliance-trestle (also known as <code>trestle</code>)","text":"<p>Trestle is an ensemble of tools that enable the creation, validation, and governance of documentation artifacts for compliance needs. It leverages NIST's OSCAL as a standard data format for interchange between tools and people, and provides an opinionated approach to OSCAL adoption.</p> <p>Trestle is designed to operate as a CICD pipeline running on top of compliance artifacts in <code>git</code>, to provide transparency for the state of compliance across multiple stakeholders in an environment friendly to developers. Trestle passes the generated artifacts on to tools that orchestrate the enforcement, measurement, and reporting of compliance.</p> <p>It also provides tooling to manage OSCAL documents in a more human-friendly manner. By splitting large OSCAL data structures into smaller and easier to edit sub-structures, creation and maintenance of these artifacts can follow normal <code>git</code> workflows including peer review via pull request, versioning, releases/tagging.</p> <p>Trestle provides three separate but related functions in the compliance space:</p> <ul> <li>Manage OSCAL documents to allow editing and manipulation while making sure the schemas are enforced</li> <li>Transform documents from other formats to OSCAL</li> <li>Provide support and governance to author compliance content as markdown and drawio.</li> </ul> <p>Trestle provides tooling to help orchestrate the compliance process across a number of dimensions:</p> <ul> <li>Help manage OSCAL documents in a more human-friendly manner by expanding the large OSCAL data structures into smaller and easier to edit sub-structures while making sure the schemas are enforced.</li> <li>Transform documents from other formats to OSCAL</li> <li>Provide governance for markdown documents and enforce consistency of format and content based on specified templates</li> <li>Tooling manage authoring and governance of markdown and drawio files withn a repository.</li> <li>Support within trestle to streamline management within a managed git environment.</li> <li>An underlying object model that supports developers interacting with OSCAL artefacts.</li> </ul>"},{"location":"#important-note","title":"Important Note:","text":"<p>The current version of trestle supports NIST OSCAL 1.0.0-4.  There was a breaking change in OSCAL moving from version 1.0.0 to 1.0.2 mainly due to <code>prop</code> becoming <code>props</code> in AssessmentResults.  As a result, the current development path of trestle requires OSCAL 1.0.4, but for those who require OSCAL 1.0.0 please use trestle version 0.37.x.  That version is stable but will not have any features added, and we encourage users to move to OSCAL 1.0.4.</p> <p>OSCAL version 1.0.0 files are still handled on import but any AssessmentResults must conform to the OSCAL 1.0.4 schema, with props instead of prop.  And all files created by trestle will be output as OSCAL version 1.0.4.</p>"},{"location":"#why-trestle","title":"Why Trestle","text":"<p>Compliance suffers from being a complex topic that is hard to articulate simply. It involves complete and accurate execution of multiple procedures across many disciplines (e.g. IT, HR, management) with periodic verification and audit of those procedures against controls.</p> <p>While it is possible to manage the description of controls and how an organisation implements them in ad hoc ways with general tools (spreadsheets, documents), this is hard to maintain for multiple accreditations and, in the IT domain at least, creates a barrier between the compliance efforts and the people doing daily work (DevOps staff).</p> <p>Trestle aims to reduce or remove this barrier by bringing the maintenance of control descriptions into the DevOps domain. The goal is to have changes to the system (for example, updates to configuration management) easily related to the controls impacted, and to enable modification of those controls as required in concert with the system changes.</p> <p>Trestle implicitly provides a core opinionated workflow driven by its pipeline to allow standardized interlocks with other compliance tooling platforms.</p>"},{"location":"#machine-readable-compliance-format","title":"Machine readable compliance format","text":"<p>Compliance activities at scale, whether size of estate or number of accreditations, require automation to be successful and repeatable. OSCAL as a standard allows teams to bridge between the \"Governance\" layer and operational tools.</p> <p>By building human managed artifacts into OSCAL, Trestle is not only able to validate the integrity of the artifacts that people generate - it also enables reuse and sharing of artifacts, and furthermore can provide suitable input into tools that automate operational compliance.</p>"},{"location":"#supported-oscal-elements-and-extensions","title":"Supported OSCAL elements and extensions","text":"<p><code>trestle</code> implicitly supports all OSCAL schemas for use within the object model. The development roadmap for <code>trestle</code> includes adding workflow around specific elements / objects that is opinionated.</p>"},{"location":"#supported-file-formats-for-oscal-objects","title":"Supported file formats for OSCAL objects.","text":"<p>OSCAL supports <code>xml</code>, <code>json</code> and <code>yaml</code> with their metaschema tooling. Trestle natively supports only <code>json</code> and <code>yaml</code> formats at this time.</p> <p>Future roadmap anticipates that support for xml import and upstream references will be enabled. However, it is expected that full support will remain only for <code>json</code> and  <code>yaml</code>.</p> <p>Users needing to import XML OSCAL artifacts are recommended to look at NIST's XML to json conversion page here.</p>"},{"location":"#python-codebase-easy-installation-via-pip","title":"Python codebase, easy installation via pip","text":"<p>Trestle runs on most all python platforms (e.g. Linux, Mac, Windows) and is available on PyPi so it is easily installed via pip.  It is under active development and new releases are made available regularly.</p>"},{"location":"#development-status","title":"Development status","text":"<p>Compliance trestle is currently stable and is based on NIST OSCAL version 1.0.4, with active development continuing.</p>"},{"location":"#contributing-to-trestle","title":"Contributing to Trestle","text":"<p>Our project welcomes external contributions. Please consult contributing to get started.</p>"},{"location":"#license-authors","title":"License &amp; Authors","text":"<p>If you would like to see the detailed LICENSE click here. Consult contributors for a list of authors and maintainers for the core team.</p> <pre><code># Copyright (c) 2020 IBM Corp. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n</code></pre>"},{"location":"cli/","title":"trestle CLI Overview and OSCAL Usecases","text":"<p>The trestle CLI has three primary use cases:</p> <ul> <li>Serve as tooling to generate and manipulate OSCAL files directly by an end user. The objective is to reduce the complexity of creating and editing workflows. Example commands are: <code>trestle import</code>, <code>trestle create</code>, <code>trestle split</code>, <code>trestle merge</code>.</li> <li>Act as an automation tool that, by design, can be an integral part of a CI/CD pipeline e.g. <code>trestle validate</code>, <code>trestle tasks</code>.</li> <li>Allow governance of markdown documents so they conform to specific style or structure requirements.</li> </ul> <p>To support each of these use cases trestle creates an opinionated directory structure to manage governed documents.</p>"},{"location":"cli/#opinionated-directory-structure","title":"Opinionated directory structure","text":"<p>Trestle relies on an opinionated directory structure (trestle workspace), similar to <code>git</code>, <code>go</code>, or <code>auditree</code>, to manage the workflow. Most trestle commands are restricted to working within an initialized directory tree.</p> <p>The directory structure setup by trestle has three major elements:</p> <ul> <li>A <code>.trestle</code> hidden folder.</li> <li>A <code>dist</code> folder.</li> <li>Folders for each of the top level OSCAL models.</li> </ul> <p>The outline of the schema is below:</p> <pre><code>.\n\u251c\u2500\u2500 .trestle\n\u251c\u2500\u2500 dist\n\u2502   \u251c\u2500\u2500 catalogs\n\u2502   \u251c\u2500\u2500 profiles\n\u2502   \u251c\u2500\u2500 component-definitions\n\u2502   \u251c\u2500\u2500 system-security-plans\n\u2502   \u251c\u2500\u2500 assessment-plans\n\u2502   \u251c\u2500\u2500 assessment-results\n\u2502   \u2514\u2500\u2500 plan-of-action-and-milestones\n\u251c\u2500\u2500 catalogs\n\u251c\u2500\u2500 profiles\n\u251c\u2500\u2500 component-definitions\n\u251c\u2500\u2500 system-security-plans\n\u251c\u2500\u2500 assessment-plans\n\u251c\u2500\u2500 assessment-results\n\u2514\u2500\u2500 plan-of-action-and-milestones\n</code></pre> <p><code>.trestle</code> directory is a special directory containing various trestle artefacts to help run various other commands. Examples include configuration files, caches and templates.</p> <p><code>dist</code> directory will contain the assembled version of the top level models located on the source model directories.</p> <p>The bulk of the folder structure is used to represent each of the top level schemas or top level models such as <code>catalogs</code> and <code>profiles</code>. For each of these directories the following root structure is maintained:</p> <pre><code>\u251c\u2500\u2500 .trestle\n\u2514\u2500\u2500 TOP_LEVEL_MODEL_PLURAL\n    \u2514\u2500\u2500 NAME_OF_MODEL_INSTANCE\n        \u2514\u2500\u2500 TOP_LEVEL_MODEL_NAME.{json,yaml,yml}\n</code></pre> <p>which appears, for a catalog a user decides is titled nist-800-53, as:</p> <pre><code>\u251c\u2500\u2500 .trestle\n\u2514\u2500\u2500 catalogs\n    \u2514\u2500\u2500 nist-800-53\n        \u2514\u2500\u2500 catalog.json\n</code></pre> <p>In most of the places in the documentation we use <code>json</code> format for specifying model files, but they are equally applicable to <code>yaml</code> format also. The default format is <code>json</code>, and <code>yaml</code> is supported on best effort basis. Within one model directory the two different formats should not be mixed.</p>"},{"location":"cli/#support-for-subdivided-document-structures","title":"Support for subdivided document structures","text":"<p>The files constructed by OSCAL can run into tens of thousands of lines of yaml or formatted json. At this size the files become completely unmanageable for users. To combat this, trestle can <code>trestle split</code> a file into many smaller files and later merge those split files together.</p> <p>Directory structures such as the one below can represent OSCAL document structures. Users are strongly encourage to rely on split and merge to code these structures.</p> <p>Users can query the contents of files using <code>trestle describe</code>, and probe the contents more deeply using it in combination with element paths.</p> <pre><code>.\n\u251c\u2500\u2500 .trestle\n\u251c\u2500\u2500 dist \n\u2502   \u2514\u2500\u2500 catalogs\n\u2502       \u2514\u2500\u2500 nist800-53.json \n\u2514\u2500\u2500 catalogs\n    \u2514\u2500\u2500 nist800-53\n        \u251c\u2500\u2500 catalog.json\n        \u2514\u2500\u2500 catalog\n            \u251c\u2500\u2500 metadata.json\n            \u251c\u2500\u2500 metadata\n            \u2502   \u251c\u2500\u2500 revision-history\n            \u2502   \u2502   \u251c\u2500\u2500 00000__revision-history.json\n            \u2502   \u2502   \u251c\u2500\u2500 00001__revision-history.json\n            \u2502   \u2502   \u2514\u2500\u2500 00002__revision-history.json   \n            \u2502   \u2514\u2500\u2500 responsible-parties\n            \u2502       \u251c\u2500\u2500 creator__responsible-party.json\n            \u2502       \u2514\u2500\u2500 contact__responsible-party.json       \n            \u2514\u2500\u2500 groups\n                \u251c\u2500\u2500 00000__group.json        \n                \u251c\u2500\u2500 00000__group\n                \u2502   \u2514\u2500\u2500 controls\n                \u2502       \u251c\u2500\u2500 00000__control.json\n                \u2502       \u2514\u2500\u2500 00001__control.json\n                \u251c\u2500\u2500 00001__group.json \n                \u2514\u2500\u2500 00001__group\n                    \u2514\u2500\u2500 controls\n                        \u251c\u2500\u2500 00000__control.json\n                        \u2514\u2500\u2500 00001__control.json\n...\n</code></pre>"},{"location":"cli/#specifying-attributes-elements-within-trestle-commands","title":"Specifying attributes / elements within trestle commands.","text":"<p>OSCAL models are rich and contain multiple nested data structures. Given this, a mechanism is required to address elements /attributes within an oscal object.</p> <p>This accessing method is called 'element path' and is similar to jsonPath. Commands provide element path by a <code>-e</code> argument where available, e.g. trestle split -f catalog.json -e 'catalog.metadata.*'. This path is used whenever specifying an attribute or model, rather than exposing trestle's underlying object model name. Users can refer to NIST's json outline to understand object names in trestle.</p>"},{"location":"cli/#rules-for-element-path","title":"Rules for element path","text":"<ol> <li>Element path is an expression of the attribute names, in json form , concatenated by a period (<code>.</code>).</li> <li>E.g. The metadata in a catalog is referred to as <code>catalog.metadata</code></li> <li>Element paths are relative to the file.</li> <li>e.g. For <code>metadata.json</code> roles would be referred to as <code>metadata.roles</code>, from the catalog file that would be <code>catalog.metadata.roles</code></li> <li>Arrays can be handled by a wild card <code>*</code> or a numerical index for a specific index.</li> <li><code>catalog.groups.*</code> to refer to each group in a catalog</li> <li><code>catalog.groups.*.controls.*</code> to refer to 'for each control under a top level group'</li> <li>For NIST 800-53 <code>catalog.groups.0.controls.0.</code></li> <li>On *nix platforms if using the wildcard the element path argument should be wrapped in quotes to prevent problems with the shell interpreting the wild card before trestle can</li> <li>When dealing with an array based object, the array syntax may be skipped when passing a model</li> <li>e.g. a control could be <code>catalog.controls.control</code> or <code>catalog.groups.controls.control</code></li> <li>This syntax is required as OSCAL, across the schema, has conflicting element definitions.</li> </ol>"},{"location":"cli/#a-note-for-software-developers-using-trestle","title":"A note for software developers using trestle.","text":"<p>Trestle provides utilities for converting from element path to trestle's python object model. The (slightly simplified) model is:</p> <ol> <li>Class attributes are converted from <code>dash-case</code> to <code>dash_case</code> (aka snake_case)</li> <li>Class names are converted from <code>dash-case</code> to <code>DashCase</code> (aka CamelCase)</li> </ol>"},{"location":"cli/#trestle-version","title":"<code>trestle version</code>","text":"<p>This command will return the current version of Trestle and OSCAL it is using.</p> <p>Running <code>trestle version</code> will return:</p> <p>Trestle version v2.0.0 based on OSCAL version 1.0.4</p> <p>It can also be used to retrieve the metadata version of the OSCAL object:</p> <pre><code>\"catalog\": {\n\n\"uuid\": \"fa3f44a8-25cd-4f6a-8175-7afe647df7ed\",\n\n\"metadata\": {\n\n\"title\": \"Catalog1\",\n\n\"last-modified\": \"2023-01-11T17:04:02.840910+00:00\",\n\n\"version\": \"0.1.10\", &lt;&lt;&lt; this version here\n\n\"oscal-version\": \"1.0.4\"\n\n},\n...\n</code></pre> <ul> <li><code>-t or --type</code> - a type of the OSCAL object (can be either catalog, profile, component-definition, system-security-plan, etc)</li> <li><code>-n or --name</code> - a name of the OSCAL object</li> </ul> <p>Running <code>trestle version -n nist -t catalog</code> will return:</p> <p>Version of OSCAL object of nist catalog is: 1.0.0</p>"},{"location":"cli/#trestle-init","title":"<code>trestle init</code>","text":"<p>This command will create (initialize) a trestle workspace in the current directory with the necessary directory structure and trestle artefacts. This command has multiple modes that it can run in:</p> <ul> <li><code>--full</code></li> <li><code>--local</code></li> <li><code>--govdocs</code></li> </ul> <p>By default <code>trestle init</code> will run in the <code>--full</code> mode.</p> <p><code>--full</code> mode is meant to be used when full functionality of Trestle is used i.e. managing OSCAL models locally, govern documents or using Trestle for API purposes. <code>dist</code> repository will be used when <code>trestle assemble</code> command is used. Running <code>trestle init --full</code> will create the directory structure below for different artefacts:</p> <pre><code>.\n\u251c\u2500\u2500 .trestle\n\u251c\u2500\u2500 dist\n\u2502   \u251c\u2500\u2500 catalogs\n\u2502   \u251c\u2500\u2500 profiles\n\u2502   \u251c\u2500\u2500 component-definitions\n\u2502   \u251c\u2500\u2500 system-security-plans\n\u2502   \u251c\u2500\u2500 assessment-plans\n\u2502   \u251c\u2500\u2500 assessment-results\n\u2502   \u2514\u2500\u2500 plan-of-action-and-milestones\n\u251c\u2500\u2500 catalogs\n\u251c\u2500\u2500 profiles\n\u251c\u2500\u2500 component-definitions\n\u251c\u2500\u2500 system-security-plans\n\u251c\u2500\u2500 assessment-plans\n\u251c\u2500\u2500 assessment-results\n\u2514\u2500\u2500 plan-of-action-and-milestones\n</code></pre> <p><code>--local</code> mode is meant to be used when Trestle is used to only manage OSCAL models locally. Running <code>trestle init --local</code> will create the directory structure below for different artefacts:</p> <pre><code>.\n\u251c\u2500\u2500 .trestle\n\u251c\u2500\u2500 catalogs\n\u251c\u2500\u2500 profiles\n\u251c\u2500\u2500 component-definitions\n\u251c\u2500\u2500 system-security-plans\n\u251c\u2500\u2500 assessment-plans\n\u251c\u2500\u2500 assessment-results\n\u2514\u2500\u2500 plan-of-action-and-milestones\n</code></pre> <p><code>--govdocs</code> mode is meant to be used when Trestle is only used to govern documents. Running <code>trestle init --govdocs</code> will create the directory structure below:</p> <pre><code>.\n\u251c\u2500\u2500 .trestle\n</code></pre> <p><code>.trestle</code> directory is a special directory containing various trestle artefacts to help run various other commands.</p> <p><code>dist</code> directory will contain the merged or assembled version of the top level models located on the source model directories which are: <code>catalogs</code>, <code>profiles</code>, <code>component-definitions</code>, <code>system-security-plans</code>, <code>assessment-plans</code>, <code>assessment-results</code> and <code>plan-of-action-and-milestones</code>.</p> <p>Notice that trestle is a highly opinionated tool and, therefore, the names of the files and directories that are created by any of the <code>trestle</code> commands and subcommands MUST NOT be changed manually.</p>"},{"location":"cli/#trestle-create","title":"<code>trestle create</code>","text":"<p>This command will create a bare-bones sample file for one of the top level OSCAL models, and it can also create new elements within an existing file.  For example, <code>trestle create -t catalog -o nist800-53</code> will create a sample catalog file, <code>catalog.json</code> in the catalog subdirectory, <code>nist800-53</code> as shown below:</p> <pre><code>.\n\u251c\u2500\u2500 .trestle\n\u2514\u2500\u2500 catalogs\n    \u2514\u2500\u2500 nist800-53\n        \u2514\u2500\u2500 catalog.json\n...\n</code></pre> <p>The <code>-t</code> specifies the type of the model to create, which can be one of catalog, profile, component-definition, system-security-plan, assessment-plan, assessment-results, plan-of-action-and-milestones.  Each type will be created in its corresponding directory, such as catalogs, profiles, etc.</p> <p>The following additional options are supported:</p> <ul> <li><code>-o or --output</code>: specifies the name/alias of a model. It is used as the prefix for the output filename under the <code>dist</code> directory and for naming the source subdirectories under  <code>catalogs</code>, <code>profiles</code>, <code>component-definitions</code>, <code>system-security-plans</code>, <code>assessment-plans</code>, <code>assessment-results</code> or <code>plan-of-action-and-milestones</code>.</li> </ul> <p>The user can edit the parts of the generated OSCAL model by modifying the sample content in those directories.</p> <p>Passing <code>-iof</code> or <code>--include-optional-fields</code> will make <code>trestle create</code> generate a richer model containing all optional fields until finding recursion in the model (e.g controls within control).</p> <p>In addition, <code>trestle create</code> can create new components within an existing file by specifying the existing file name and the corresponding element path to create within that file.</p> <p>For example,</p> <p><code>$TRESTLE_BASEDIR/catalogs/nist800-53$ trestle create -f ./catalog.json -e catalog.metadata.roles</code></p> <p>will add the following property under the <code>metadata</code> property for a catalog that will be written to the appropriate file under <code>catalogs/nist800-53</code> directory:</p> <pre><code>{\n\"roles\": [\n{\n\"id\": \"REPLACE_ME\",\n\"title\": \"REPLACE_ME\"\n}\n]\n}\n</code></pre> <p>Default values for mandatory datatypes will be like below. All UUID's will be populated by default whether or not they are mandatory.</p> <pre><code>  - DateTime: &lt;Current date-time&gt;\n- Boolean: false\n- Integer: 0\n- String: REPLACE_ME\n- Float/Double: 0.00\n- Id field: Auto generated UUID\n</code></pre> <p>Again, passing <code>-iof</code> or <code>--include-optional-fields</code> will make <code>trestle create</code> generate a richer version of the element being created, by including optional fields.</p>"},{"location":"cli/#trestle-import","title":"<code>trestle import</code>","text":"<p>This command allows users to import existing OSCAL files so that they can be managed using trestle. For example <code>trestle import -f /local_dir/existing_catalog.json -o my_existing_catalog</code> will import <code>existing_catalog.json</code> into a new folder under <code>catalogs</code> as shown below:</p> <pre><code>.\n\u251c\u2500\u2500 .trestle\n\u2514\u2500\u2500 catalogs\n    \u2514\u2500\u2500 my_existing_catalog\n        \u2514\u2500\u2500 catalog.json\n...\n</code></pre> <p>The following options are supported:</p> <ul> <li><code>-f or --file</code>: specifies the path of an existing OSCAL file or URL to a remote file.</li> <li><code>-o or --output</code>: specifies the name/alias of a model. It is used as the prefix for the output filename under the <code>dist</code> directory and for naming the source subdirectories under  <code>catalogs</code>, <code>profiles</code>, <code>component-definitions</code>, <code>system-security-plans</code>, <code>assessment-plans</code>, <code>assessment-results</code> or <code>plan-of-action-and-milestones</code>.</li> </ul> <p>The <code>--file</code> option may be an absolute or relative path, and it may be a URL.  For details on allowed formats please see the documentation for the <code>href</code> command.  The file must be imported from outside the current trestle directory or an error will result.</p> <p>The import subcommand can determine the type of the model that is to be imported by the contents of the file.  But the file name must end with an allowed json or yaml extension: <code>.json, .yaml, .yml</code></p> <p>During the import process the file must pass the <code>validate</code> test described below for the command, <code>validate</code>.  If the file does not pass validation a warning will be given describing the nature of the problem and the import will fail.</p> <p>Once a file has been imported it can be split into a rich tree of sub-components as shown at the top of this document.  But the file must be imported first.</p>"},{"location":"cli/#trestle-replicate","title":"<code>trestle replicate</code>","text":"<p>This command allows users to replicate a certain OSCAL model (file and directory structure). For example <code>trestle replicate catalog -n cat1 -o cat11</code> will replicate the Catalog cat1 into <code>cat11</code> directory. It can also regenerate all the UUIDs as required.</p>"},{"location":"cli/#trestle-split","title":"<code>trestle split</code>","text":"<p>This command allows users to further decompose a trestle model into additional subcomponents.</p> <p>The following options are currently supported:</p> <ul> <li><code>-f or --file</code>: this is optional and specifies the file path of the json/yaml file containing the elements that will be split.</li> <li><code>-e or --elements</code>: specifies the model subcomponent element(s) (JSON/YAML property path) that is/are going to be split. Multiple elements can be specified at once using a comma-separated value, e.g <code>-e 'catalog.metadata,catalog.groups'</code>.  Make sure to include the quotes that enclose the comma-separated paths.</li> </ul> <p>If the element is of JSON/YAML type array list and you want trestle to create a separate subcomponent file per array item, the element needs to be suffixed with <code>.*</code>, e.g. <code>-e 'catalog.groups.*'</code>. If the suffix is not specified, split will place all array items in only one separate subcomponent file, e.g. <code>'groups.json'</code>.  Again, make sure to include the quotes around the elements.</p> <p>If you just want to split a file into all its constituent parts and the file does not contain a simple list of objects, you can still use <code>*</code> and the file will be split into all its non-trivial elements.  Thus if you split a catalog with <code>-e catalog.*</code> the result will be a new directory, <code>catalog</code>, containing files representing the large items, <code>back-matter.json, groups.json and metadata.json</code>, but there will still be a <code>catalog.json</code> file containing just the catalog's <code>uuid</code>.  Small items such as strings and dates cannot be split off and will remain in the original model file that is being split.</p> <p>Here are some examples.  Starting with a single catalog file, <code>my_catalog/catalog.json</code>, if you do <code>trestle split -f catalog.json -e 'catalog.*'</code> you end up with:</p> <pre><code>catalogs\n \u2517 my_catalog\n \u2503 \u2523 catalog\n \u2503 \u2503 \u2523 back-matter.json\n \u2503 \u2503 \u2523 groups.json\n \u2503 \u2503 \u2517 metadata.json\n \u2503 \u2517 catalog.json\n</code></pre> <p>If you then split roles out of metadata as a single file containing a list of roles, <code>trestle split -f catalog/metadata.json -e 'metadata.roles'</code> you would end up with:</p> <pre><code>catalogs\n \u2517 my_catalog\n \u2503 \u2523 catalog\n \u2503 \u2503 \u2523 metadata\n \u2503 \u2503 \u2503 \u2517 roles.json\n \u2503 \u2503 \u2523 back-matter.json\n \u2503 \u2503 \u2523 groups.json\n \u2503 \u2503 \u2517 metadata.json\n \u2503 \u2517 catalog.json\n</code></pre> <p>If instead you had specified <code>-e 'metadata.roles.*'</code> you would get:</p> <pre><code>my_catalog\n \u2523 catalog\n \u2503 \u2523 metadata\n \u2503 \u2503 \u2517 roles\n \u2503 \u2503 \u2503 \u2523 00000__role.json\n \u2503 \u2503 \u2503 \u2517 00001__role.json\n \u2503 \u2523 back-matter.json\n \u2503 \u2523 groups.json\n \u2503 \u2517 metadata.json\n \u2517 catalog.json\n</code></pre> <p>You can see there is no <code>roles.json</code> file anymore and instead there is a subdirectory, <code>roles</code> containing a list of files, one for each <code>role</code>.</p> <p>If the <code>-f or --file</code> option is not specified, the file to split will be determined from the elements specified, in the context of the current working directory.  The current directory must be within a specific model (e.g. <code>catalog</code> or <code>profile</code>), and the element paths must either be absolute (e.g. <code>catalog.metadata.roles</code>) or relative to the current working directory.  For example, if you are in <code>catalogs/mycat/catalog/groups</code> and you want to split the file <code>00000__group.json</code>, you must use <code>-f</code> to specify the filename, and the element path can either be absolute, as <code>catalog.group.*</code>, or you can set the current working directory to where the file is and use element path <code>group.*</code>.  This makes it easier to specify splits when deep in a directory structure.</p> <p>Every subdirectory in a trestle directory model should have a corresponding <code>.json</code> or <code>.yaml</code> file with the same name, except when that subdirectory corresponds to a list of items, such as <code>catalog.groups</code>. When those subcomponents are split/expanded each file or subdirectory under them represents an item of the collection. Because of that, if a corresponding <code>groups.json | groups.yaml</code> file were to exist, its contents would just be an empty representation of that collection and the user would need to be careful never to edit that file. Therefore, we decided not to create that corresponding file in those cases. Following the same logic, another exception is when all the fields from a <code>.json | .yaml</code> file are split, leaving the original file as an empty object. In that case, the file would be deleted as well.</p> <p>To inspect a file to see what elements can be split from it, use the <code>describe</code> command described below.  It is also useful for inspection of files created by the split operation.</p>"},{"location":"cli/#trestle-merge","title":"<code>trestle merge</code>","text":"<p>The trestle merge command is the reversal of <code>trestle split</code>. This command allows users to reverse the decomposition of a trestle model by aggregating subcomponents scattered across multiple files or directories into the parent JSON/YAML file. To merge a model, you have to first change working directory to the root model component directory that you want to merge a sub-component model into. The following option is required:</p> <ul> <li><code>-e or --elements</code>: specifies the properties (JSON/YAML path) that will be merged, relative to the current working directory. This must contain at least 2 elements, where the last element is the model/sub-component to be merged into the second from last component.</li> </ul> <p>For example, in the command <code>trestle merge -e 'catalog.metadata'</code>, executed in the same directory where <code>catalog.json</code> or the split <code>catalog</code> directory exists, the property <code>metadata</code> from <code>metadata.json</code> would be moved/merged into <code>catalog.json</code>. If the <code>metadata</code> model has already been split into smaller sub-component models previously, those smaller sub-components are first recusively merged into <code>metadata</code>, before merging <code>metadata</code> subcomponent into <code>catalog</code>. To specify merging every sub-component split from a component, <code>.*</code> can be used. For example, <code>trestle merge -e 'catalog.*'</code> command, issued from the directory where <code>catalog.json</code> or<code>catalog</code> directory exists, will merge every single sub-component of that catalog back into the <code>catalog.json</code>.</p>"},{"location":"cli/#trestle-describe","title":"<code>trestle describe</code>","text":"<p>This command lets users inspect model files to explore contents using an optional element path.  The command can work well in concert with <code>split</code> to show what each file contains, and probe within the contents to determine sub-components that can be extracted as separate files.</p> <p>Unlike split, describe only describes the contents of a single item, so the element path may not contain wildcards (<code>*</code>) or commas.</p> <p>For example, if a catalog file has been imported to <code>catalogs/my_catalog/catalog.json</code> then the commmand, <code>trestle describe -f catalog.json</code> might yield:</p> <pre><code>#Model file catalog.json is of type catalog.Catalog and contains\nuuid: 613fca2d-704a-42e7-8e2b-b206fb92b456\nmetadata: common.Metadata\nparams: None\ncontrols: None\ngroups: list of 20 items of type catalog.Group\nback_matter: common.BackMatter\n</code></pre> <p>Note that contents are listed even when they are empty (and therefore optional) so the full potential contents can be seen.  Also note that if an item corresponds to a list of elements, the number and type of elements is provided.  Finally, if an item is a simple string such as <code>id</code>, <code>uuid</code> or <code>title</code>, the string is shown directly up to a maximum of 100 characters.  If the string is clipped it will be indicated by <code>[truncated]</code> at the end of the string.</p> <p>An element path can be specified to probe the contents, as in <code>trestle describe -f catalog.json -e 'catalog.metadata.roles'</code>.  A possible response is:</p> <pre><code>Model file catalog.json at element path catalog.metadata.roles is a list of 2 items of type common.Role\n</code></pre> <p>You can also query individual elements, and elements of an element, e.g. <code>trestle describe -f catalog.json -e 'catalog.groups.5.controls.3'</code></p> <pre><code># Model file catalog.json at element path catalog.groups.5.controls.3 is of type catalog.Control and contains:\nid: cp-4\nclass_: SP800-53\ntitle: Contingency Plan Testing\nparams: list of 2 items of type common.Parameter\nprops: list of 2 items of type common.Property\nlinks: list of 14 items of type common.Link\nparts: list of 2 items of type common.Part\ncontrols: list of 5 items of type catalog.Control\n</code></pre> <p>(Note that the numbering starts at 0, so the <code>.3</code> corresponds to the 4th element.)</p> <p>In all output from <code>describe</code> the type of the item shown corresponds to the python file and class of the corresponding OSCAL model in trestle.</p> <p>If you split items off a model so they end up in a subdirectory, the original file is referred to as a \"stripped\" model, with parts of it stripped off and only some elements remaining.  For example, if you do <code>trestle split -f catalog.json -e 'catalog.metadata'</code> it will split off metadata from the original <code>catalog.json</code> file and place it in <code>catalog/metadata.json</code>.  If you then do <code>trestle describe -f catalog.json</code> on the new file, it will say something like:</p> <pre><code># Model file catalog.json is of type stripped.Catalog and contains:\nuuid: 613fca2d-704a-42e7-8e2b-b206fb92b456\nparams: None\ncontrols: None\ngroups: list of 20 items of type catalog.Group\nback_matter: common.BackMatter\n</code></pre> <p>Note that the type of the file is now <code>stripped.Catalog</code> and it no longer contains <code>metadata</code>.  Even though metadata is no longer in the original <code>.json</code> file, trestle is still aware it is present in the model since it is properly placed as its own file in the subdirectory, <code>catalog</code>.</p>"},{"location":"cli/#trestle-partial-object-validate","title":"<code>trestle partial-object-validate</code>","text":"<p>OSCAL objects may be extremely large. Some systems may only be able to produce partial OSCAL objects. For example, the tanium-result-to-oscal-ar task produces the <code>results</code> attribute of an <code>assessment-results</code> object.</p> <p><code>trestle partial-object-validate</code> allows the validation of any sub-element/attribute using element path.</p> <p>Using the example above <code>trestle partial-object-validate -f results.json -e assessment-results.results</code>.</p> <p>The file is not required to be in the trestle directory or required to be a specific file name.</p>"},{"location":"cli/#example-valid-element-paths","title":"Example valid element-paths","text":"<p>All element paths must be absolute e.g.: <code>catalog.metadata</code> <code>catalog</code> <code>catalog.groups</code> <code>catalog.groups.group.controls.control.controls.control</code> Remembering in the end you only care about the end type. So in this scenario <code>catalog.groups.group.controls.control.controls.control</code> is equivalent to <code>catalog.controls.control</code>.</p>"},{"location":"cli/#trestle-href","title":"<code>trestle href</code>","text":"<p>This command changes the href of an Import in a profile and is needed when generating an SSP (system security plan) with the author tool, <code>ssp-generate</code>. The Imports in a profile are used to load associated catalogs of controls and profiles, and must be available at the corresponding href uri.  If an imported catalog is in the trestle directory then the href should be changed with a command of the form:</p> <pre><code>trestle href -n my_profile -hr trestle://catalogs/my_catalog/catalog.json\n</code></pre> <p>Similarly, if the item imported is a profile, a corresponding href should point to a json file in the <code>profiles</code> directory.</p> <p>Note that catalogs or profiles in the trestle directory are indicated by the <code>trestle://</code> prefix, followed by the path from the top level models directory to the actual catalog file.  The profile itself, which is having its imports modified, is just indicated by its name with the <code>-n</code> option.</p> <p>If the profile has more than one import, you can display the corresponding hrefs with:</p> <pre><code>trestle href -n my_profile\n</code></pre> <p>This will give a numbered list of the hrefs.  You can then change them individually by providing the corresponding item number:</p> <pre><code>trestle href -n my_profile -i 1 -hr trestle://catalogs/my_catalog/catalog.json\n</code></pre> <p>This will change the href indexed as <code>1</code> when the list was displayed.  The href's are indexed starting from 0.</p> <p>The <code>trestle href</code> command can also be used to change the value back to the intended one prior to distribution of the profile.</p> <p>The provided href can be of form <code>trestle://</code>, <code>https://</code>, <code>sftp://</code>, or <code>file:///</code>.  If <code>file:///</code> is used, the path provided must be absolute - and on Windows it must include the drive letter followed by a slash.  The only time a relative path is allowed is with the <code>trestle://</code> heading.</p> <p>A username and password may be embedded in the url for <code>https://</code>, and a CA certificate path will be searched from environment variables <code>REQUESTS_CA_BUNDLE</code> and <code>CURL_CA_BUNDLE</code> in that order.</p> <p>Authorization for <code>sftp://</code> access relies on the user's private key being either active via <code>ssh-agent</code> or supplied via the environment variable <code>SSH_KEY</code>. In the latter case it must not require a passphrase prompt.</p>"},{"location":"cli/#trestle-assemble","title":"<code>trestle assemble</code>","text":"<p>This command assembles all contents (files and directories) representing a specific model into a single OSCAL file located under <code>dist</code> folder. For example,</p> <p><code>$TRESTLE_BASEDIR$ trestle assemble catalog -n nist800-53</code></p> <p>will traverse the <code>catalogs/nist800-53</code> directory and its children and combine all data into a OSCAL file that will be written to <code>dist/catalogs/nist800-53.json</code>. Note that the parts of catalog <code>nist800-53</code> can be written in either YAML/JSON (e.g. based on the file extension), however, the output will be generated as YAML/JSON as desired. Trestle will infer the content type from the file extension and create the model representation appropriately in memory and then output in the desired format. Trestle assemble will also validate content as it assembles the files and make sure the contents are syntactically correct.</p>"},{"location":"cli/#trestle-remove","title":"<code>trestle remove</code>","text":"<p>The trestle remove command is the reversal of <code>trestle create -f filename.json -e element_path</code>, as it will remove the corresponding element from the specified file.</p>"},{"location":"cli/#trestle-validate","title":"<code>trestle validate</code>","text":"<p>Trestle validate checks the integrity of one or more OSCAL files in a number of ways.</p> <p><code>validate</code> returns a non-zero return code if there is any validation problem detected in a file.</p> <p>The current list of validation modes that get checked internally are:</p> Mode Purpose duplicates Detect whether disallowed duplicate uuid's are present oscal_version Confirm that the oscal version of the file is supported refs Confirm that all references in responsible parties are found in roles catalog Confirm all parameter ids in a catalog are unique links Confirm referenced resources are 1:1 with resources in backmatter <p>You can validate a single model file by specifying its full path:</p> <p><code>trestle validate -f catalogs/my_cat/catalog.json</code></p> <p>or by specifying its model name and type:</p> <p><code>trestle validate -t catalog -n my_cat</code></p> <p>In addition to validating a single file you can validate all files of a given type with the <code>-t</code> option and no file name:</p> <p><code>trestle validate -t catalog</code></p> <p>And you can validate all models with the <code>-a</code> option:</p> <p><code>trestle validate -a</code></p> <p>Note that when you <code>Import</code> a file it will perform a full validation on it first, and if it does not pass validation the file cannot be imported.</p> <p>By default validate will display warning messages and a message indicating the file is valid, but you can suppress those messages with the <code>-q --quiet</code> option.</p> <p>The links validator is special because it always returns success that the file is valid - but it will list any inconsistencies it finds between the references to links, and corresponding links in the backmatter.</p>"},{"location":"cli/#trestle-tasks","title":"<code>trestle tasks</code>","text":"<p>Open Shift Compliance Operator and Tanium are supported as 3rd party tools.</p>"},{"location":"cli/#trestle-task-osco-result-to-oscal-ar","title":"<code>trestle task osco-result-to-oscal-ar</code>","text":"<p>The trestle task osco-result-to-oscal-ar command facilitates transformation of OpenShift Compliance Operator (OSCO) scan results .yaml files into OSCAL partial results .json files. Specify required config parameters to indicate the location of the input and the output. Specify optional config parameters to indicate the name of the oscal-metadata.yaml file, if any, and whether overwriting of existing output is permitted.</p> <p> Example command invocation: </p> <p><code>$TRESTLE_BASEDIR$ trestle task osco-result-to-oscal-ar -c /home/user/task.config</code></p> <p> Example config: </p> <p>/home/user/task.config</p> <pre><code>[task.osco-result-to-oscal-ar]\n\ninput-dir =  /home/user/git/evidence/osco/input\noutput-dir = /home/user/git/evidence/oscal/output\noscal-metadata = oscal-metadata.yaml\noutput-overwrite = true\n</code></pre> <p>input</p> <p> Example input directory contents listing: </p> <p>/home/user/git/evidence/osco/input</p> <pre><code>-rw-rw-r--. 1 user user  3832 Feb  2 09:36 oscal-metadata.yaml\n-rw-rw-r--. 1 user user 49132 Feb  2 06:12 ssg-ocp4-ds-cis-111.222.333.444-pod.yaml\n-rw-rw-r--. 1 user user 52747 Feb  2 06:41 ssg-ocp4-ds-cis-111.222.333.555-pod.yaml\n</code></pre> <p> Example input OSCO scan result file contents (snippet): </p> <p>ssg-ocp4-ds-cis-111.222.333.444-pod.yaml</p> display sample <pre><code>apiVersion: v1\ndata:\nexit-code: '2'\nresults: |\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;TestResult xmlns=\"https://checklists.nist.gov/xccdf/1.2\" \nid=\"xccdf_org.open-scap_testresult_xccdf_org.ssgproject.content_profile_cis\"\nstart-time=\"2020-08-03T02:26:26+00:00\" end-time=\"2020-08-03T02:26:26+00:00\"\nversion=\"0.1.52\"\ntest-system=\"cpe:/a:redhat:openscap:1.3.3\"&gt;\n&lt;benchmark href=\"/content/ssg-ocp4-ds.xml\" id=\"xccdf_org.ssgproject.content_benchmark_OCP-4\"/&gt;\n&lt;title&gt;OSCAP Scan Result&lt;/title&gt;\n&lt;profile idref=\"xccdf_org.ssgproject.content_profile_cis\"/&gt;\n&lt;target&gt;kube-br7qsa3d0vceu2so1a90-roksopensca-default-0000026b.iks.mycorp&lt;/target&gt;\n&lt;target-facts&gt;\n&lt;fact name=\"urn:xccdf:fact:identifier\" type=\"string\"&gt;chroot:///host&lt;/fact&gt;\n&lt;fact name=\"urn:xccdf:fact:scanner:name\" type=\"string\"&gt;OpenSCAP&lt;/fact&gt;\n&lt;fact name=\"urn:xccdf:fact:scanner:version\" type=\"string\"&gt;1.3.3&lt;/fact&gt;\n&lt;/target-facts&gt;\n&lt;target-id-ref system=\"https://scap.nist.gov/schema/asset-identification/1.1\" name=\"asset0\" href=\"\"/&gt;\n&lt;platform idref=\"cpe:/a:redhat:openshift_container_platform:4.1\"/&gt;\n&lt;platform idref=\"cpe:/a:machine\"/&gt;\n&lt;set-value idref=\"xccdf_org.ssgproject.content_value_ocp_data_root\"&gt;/kubernetes-api-resources&lt;/set-value&gt;\n&lt;set-value idref=\"xccdf_org.ssgproject.content_value_var_kube_authorization_mode\"&gt;Webhook&lt;/set-value&gt;\n&lt;set-value idref=\"xccdf_org.ssgproject.content_value_var_streaming_connection_timeouts\"&gt;5m&lt;/set-value&gt;\n&lt;rule-result idref=\"xccdf_org.ssgproject.content_rule_ocp_idp_no_htpasswd\" time=\"2020-08-03T02:26:26+00:00\" severity=\"medium\" weight=\"1.000000\"&gt;\n&lt;result&gt;notselected&lt;/result&gt;\n&lt;ident system=\"https://nvd.nist.gov/cce/index.cfm\"&gt;CCE-84209-6&lt;/ident&gt;\n&lt;/rule-result&gt;\n&lt;rule-result idref=\"xccdf_org.ssgproject.content_rule_accounts_restrict_service_account_tokens\" time=\"2020-08-03T02:26:26+00:00\" severity=\"medium\" weight=\"1.000000\"&gt;\n&lt;result&gt;notchecked&lt;/result&gt;\n&lt;message severity=\"info\"&gt;No candidate or applicable check found.&lt;/message&gt;\n&lt;/rule-result&gt;\n&lt;rule-result idref=\"xccdf_org.ssgproject.content_rule_accounts_unique_service_account\" time=\"2020-08-03T02:26:26+00:00\" severity=\"medium\" weight=\"1.000000\"&gt;\n&lt;result&gt;notchecked&lt;/result&gt;\n&lt;message severity=\"info\"&gt;No candidate or applicable check found.&lt;/message&gt;\n&lt;/rule-result&gt;\n\n...\n\n&lt;/TestResult&gt;\nkind: ConfigMap\nmetadata:\nannotations:\ncompliance-remediations/processed: ''\ncompliance.openshift.io/scan-error-msg: ''\ncompliance.openshift.io/scan-result: NON-COMPLIANT\nopenscap-scan-result/node: 111.222.333.444\ncreationTimestamp: '2020-08-03T02:26:34Z'\nlabels:\ncompliance-scan: ssg-ocp4-ds-cis\nname: ssg-ocp4-ds-cis-111.222.333.444-pod\nnamespace: openshift-compliance\nresourceVersion: '22693328'\nselfLink: /api/v1/namespaces/openshift-compliance/configmaps/ssg-ocp4-ds-cis-111.222.333.444-pod\nuid: 1da3ea81-0a25-4512-ad86-7ac360246b5d\n</code></pre> <p></p> <p> Example input OSCAL metadata file contents: </p> <p>oscal-metadata.yaml</p> display sample <pre><code>ssg-ocp4-ds-cis-111.222.333.444-pod:\nlocker: https://github.mycorp.com/degenaro/evidence-locker\nnamespace: xccdf\nbenchmark: CIS Kubernetes Benchmark\nsubject-references:\ncomponent:\nuuid-ref: 56666738-0f9a-4e38-9aac-c0fad00a5821\ntype: component\ntitle: Red Hat OpenShift Kubernetes\ninventory-item:\nuuid-ref: 46aADFAC-A1fd-4Cf0-a6aA-d1AfAb3e0d3e\ntype: inventory-item\ntitle: Pod\nproperties:\ntarget: kube-br7qsa3d0vceu2so1a90-roksopensca-default-0000026b.iks.mycorp\ntarget-ip: 111.222.333.444\ncluster-name: ROKS-OpenSCAP-1\ncluster-type: openshift\ncluster-region: us-south\n\nssg-rhel7-ds-cis-111.222.333.444-pod:\nlocker: https://github.mycorp.com/degenaro/evidence-locker\nnamespace: xccdf\nbenchmark: CIS Kubernetes Benchmark\nsubject-references:\ncomponent:\nuuid-ref: 89cfe7a7-ce6b-4699-aa7b-2f5739c72001\ntype: component\ntitle: RedHat Enterprise Linux 7.8\ninventory-item:\nuuid-ref: 46aADFAC-A1fd-4Cf0-a6aA-d1AfAb3e0d3e\ntype: inventory-item\ntitle: VM\nproperties:\ntarget: kube-br7qsa3d0vceu2so1a90-roksopensca-default-0000026b.iks.mycorp\ntarget-ip: 111.222.333.444\ncluster-name: ROKS-OpenSCAP-1\ncluster-type: openshift\ncluster-region: us-south\n</code></pre> <p>metadata format</p> <p>The oscal-metadata.yaml file comprises one or more mappings. Below is shown the format of a single mapping. The items in angle brackets are to be replaced with desired values for augmenting the produced OSCAL.</p> <p>The mapping whose name matches the <code>[metadata][name]</code> in the evidence for the corresponding embedded XML, if any, will be used for augmenting the produced OSCAL.</p> <pre><code>name:\nlocker: &lt;locker&gt;\nnamespace: &lt;namespace&gt;\nbenchmark: &lt;benchmark&gt;\nsubject-references:\ncomponent:\nuuid-ref: &lt;uuid-ref-component&gt;\ntype: &lt;component-type&gt;\ntitle: &lt;component-title&gt;\ninventory-item:\nuuid-ref: &lt;uuid-ref-inventory-item&gt;\ntype: &lt;inventory-item-type&gt;\ntitle: &lt;inventory-item-title&gt;\nproperties:\ntarget: &lt;target&gt;\ncluster-name: &lt;cluster-name&gt;\ncluster-type: &lt;cluster-type&gt;\ncluster-region: &lt;cluster-region&gt;\n</code></pre> <p>output</p> <p> Example output directory contents listing: </p> <p>/home/user/git/evidence/oscal/output</p> <pre><code>-rw-rw-r--. 1 user user 49132 Feb  3 10:59 ssg-ocp4-ds-cis-111.222.333.444-pod.json\n-rw-rw-r--. 1 user user 52747 Feb  3 10:59 ssg-ocp4-ds-cis-111.222.333.555-pod.json\n</code></pre> <p> Example output OSCAL Observations file contents (snippet): </p> <p>ssg-ocp4-ds-cis-111.222.333.444-pod.json</p> display sample <pre><code>{\n\"observations\": [\n{\n\"uuid\": \"56666738-0f9a-4e38-9aac-c0fad00a5821\",\n\"title\": \"xccdf_org.ssgproject.content_rule_ocp_idp_no_htpasswd\",\n\"description\": \"xccdf_org.ssgproject.content_rule_ocp_idp_no_htpasswd\",\n\"props\": [\n{\n\"name\": \"benchmark\",\n\"ns\": \"dns://osco\",\n\"class\": \"source\",\n\"value\": \"CIS Kubernetes Benchmark\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"56666738-0f9a-4e38-9aac-c0fad00a5821\",\n\"type\": \"component\",\n\"title\": \"Red Hat OpenShift Kubernetes\"\n},\n{\n\"uuid-ref\": \"46aADFAC-A1fd-4Cf0-a6aA-d1AfAb3e0d3e\",\n\"type\": \"inventory-item\",\n\"title\": \"Pod\",\n\"props\": [\n{\n\"name\": \"target\",\n\"ns\": \"dns://osco\",\n\"class\": \"inventory-item\",\n\"value\": \"kube-br7qsa3d0vceu2so1a90-roksopensca-default-0000026b.iks.mycorp\"\n},\n{\n\"name\": \"target-ip\",\n\"ns\": \"dns://osco\",\n\"class\": \"inventory-item\",\n\"value\": \"111.222.333.444\"\n},\n{\n\"name\": \"cluster-name\",\n\"ns\": \"dns://osco\",\n\"class\": \"inventory-item\",\n\"value\": \"ROKS-OpenSCAP-1\"\n},\n{\n\"name\": \"cluster-type\",\n\"ns\": \"dns://osco\",\n\"class\": \"inventory-item\",\n\"value\": \"openshift\"\n},\n{\n\"name\": \"cluster-region\",\n\"ns\": \"dns://osco\",\n\"class\": \"inventory-item\",\n\"value\": \"us-south\"\n}\n]\n}\n],\n\"relevant-evidence\": [\n{\n\"href\": \"https://github.mycorp.com/degenaro/evidence-locker\",\n\"description\": \"Evidence location.\",\n\"props\": [\n{\n\"name\": \"rule\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"id\",\n\"value\": \"xccdf_org.ssgproject.content_rule_ocp_idp_no_htpasswd\"\n},\n{\n\"name\": \"time\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"timestamp\",\n\"value\": \"2020-08-03T02:26:26+00:00\"\n},\n{\n\"name\": \"result\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"result\",\n\"value\": \"notselected\"\n}\n]\n}\n]\n}\n]\n}\n</code></pre>"},{"location":"cli/#trestle-task-tanium-result-to-oscal-ar","title":"<code>trestle task tanium-result-to-oscal-ar</code>","text":"<p>The trestle task tanium-result-to-oscal-ar command facilitates transformation of Tanuim reports, each input file comprising individual lines consumable as json, into OSCAL partial results .json files. Specify required config parameters to indicate the location of the input and the output. Specify optional config parameter output-overwrite to indicate whether overwriting of existing output is permitted. Specify optional config parameter timestamp as ISO 8601 formated string (e.g., 2021-02-24T19:31:13+00:00) to override the timestamp attached to each Observation.</p> <p> Example command invocation: </p> <p><code>$TRESTLE_BASEDIR$ trestle task tanium-result-to-oscal-ar -c /home/user/task.config</code></p> <p> Example config: </p> <p>/home/user/task.config</p> <pre><code>[task.tanium-result-to-oscal-ar]\n\ninput-dir =  /home/user/git/compliance/tanium/input\noutput-dir = /home/user/git/compliance/oscal/output\noutput-overwrite = true\n</code></pre> <p>input</p> <p> Example input directory contents listing: </p> <p>/home/user/git/compliance/tanium/input</p> <pre><code>-rw-rw-r--. 1 degenaro degenaro 1830 Mar  7 08:23 Tanium.comply-nist-results\n</code></pre> <p>Tanium.comply-nist-results</p> display sample <pre><code>{\n\"IP Address\": \"fe80::3cd5:564b:940e:49ab\",\n\"Computer Name\": \"cmp-wn-2106.demo.tanium.local\",\n\"Comply - JovalCM Results[c2dc8749]\": [\n{\n\"Benchmark\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\",\n\"Benchmark Version\": \"1.5.0.1\",\n\"Profile\": \"Windows 10 - NIST 800-53\",\n\"ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1_L1_Ensure_Enforce_password_history_is_set_to_24_or_more_passwords\",\n\"Result\": \"pass\",\n\"Custom ID\": \"800-53: IA-5\",\n\"Version\": \"version: 1\"\n}\n],\n\"Count\": \"1\",\n\"Age\": \"600\"\n}\n</code></pre> <pre><code>{\n\"IP Address\": \"10.8.69.11\",\n\"Computer Name\": \"\",\n\"Comply - JovalCM Results[c2dc8749]\": [\n{\n\"Benchmark\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\",\n\"Benchmark Version\": \"1.5.0.1\",\n\"Profile\": \"Windows 10 - NIST 800-53\",\n\"ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.2_L1_Ensure_Maximum_password_age_is_set_to_60_or_fewer_days_but_not_0\",\n\"Result\": \"pass\",\n\"Custom ID\": \"800-53: IA-5\",\n\"Version\": \"version: 1\"\n}\n],\n\"Count\": \"1\",\n\"Age\": \"600\"\n}\n</code></pre> <pre><code>{\n\"IP Address\": \"10.8.69.11\",\n\"Computer Name\": \"cmp-wn-2106.demo.tanium.local\",\n\"Comply - JovalCM Results[c2dc8749]\": [\n{\n\"Benchmark\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\",\n\"Benchmark Version\": \"1.5.0.1\",\n\"Profile\": \"Windows 10 - NIST 800-53\",\n\"ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.3_L1_Ensure_Minimum_password_age_is_set_to_1_or_more_days\",\n\"Result\": \"fail\",\n\"Custom ID\": \"800-53: IA-5\",\n\"Version\": \"version: 1\"\n}\n],\n\"Count\": \"1\",\n\"Age\": \"600\"\n}\n</code></pre> <pre><code>{\n\"IP Address\": \"10.8.69.11\",\n\"Computer Name\": \"cmp-wn-2106.demo.tanium.local\",\n\"Comply - JovalCM Results[c2dc8749]\": [\n{\n\"Benchmark\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\",\n\"Benchmark Version\": \"1.5.0.1\",\n\"Profile\": \"Windows 10 - NIST 800-53\",\n\"ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.4_L1_Ensure_Minimum_password_length_is_set_to_14_or_more_characters\",\n\"Result\": \"pass\",\n\"Custom ID\": \"800-53: IA-5\",\n\"Version\": \"version: 1\"\n}\n],\n\"Count\": \"1\",\n\"Age\": \"600\"\n}\n</code></pre> <p>output</p> <p> Example output directory contents listing: </p> <p>/home/user/git/compliance/oscal/output</p> <pre><code>-rw-rw-r--. 1 degenaro degenaro 6479 Mar  7 08:25 Tanium.oscal.json\n</code></pre> <p>Tanium.oscal.json</p> display sample <pre><code>{\n\"results\": [\n{\n\"uuid\": \"0ed0791e-5454-4d07-919f-15a0d806a5a8\",\n\"title\": \"Tanium\",\n\"description\": \"Tanium\",\n\"start\": \"2021-04-13T00:16:20.000+00:00\",\n\"local-definitions\": {\n\"inventory-items\": [\n{\n\"uuid\": \"da8b87f6-2068-415f-94bb-e14e31b4f5c2\",\n\"description\": \"inventory\",\n\"props\": [\n{\n\"name\": \"computer-name\",\n\"ns\": \"dns://tanium\",\n\"value\": \"cmp-wn-2106.demo.tanium.local\",\n\"class\": \" inventory-item\"\n},\n{\n\"name\": \"computer-ip\",\n\"ns\": \"dns://tanium\",\n\"value\": \"fe80::3cd5:564b:940e:49ab\",\n\"class\": \" inventory-item\"\n},\n{\n\"name\": \"profile\",\n\"ns\": \"dns://tanium\",\n\"value\": \"Windows 10\",\n\"class\": \" inventory-item\"\n}\n]\n},\n{\n\"uuid\": \"f3ab87b2-70c1-4332-991e-c003d4314c0b\",\n\"description\": \"inventory\",\n\"props\": [\n{\n\"name\": \"computer-name\",\n\"ns\": \"dns://tanium\",\n\"value\": \"\",\n\"class\": \" inventory-item\"\n},\n{\n\"name\": \"computer-ip\",\n\"ns\": \"dns://tanium\",\n\"value\": \"10.8.69.11\",\n\"class\": \" inventory-item\"\n},\n{\n\"name\": \"profile\",\n\"ns\": \"dns://tanium\",\n\"value\": \"Windows 10\",\n\"class\": \" inventory-item\"\n}\n]\n}\n]\n},\n\"reviewed-controls\": {\n\"control-selections\": [\n{}\n]\n},\n\"observations\": [\n{\n\"uuid\": \"b3250b66-fe6f-4ac0-be99-cb4ff093dc31\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1_L1_Ensure_Enforce_password_history_is_set_to_24_or_more_passwords\",\n\"props\": [\n{\n\"name\": \"benchmark\",\n\"ns\": \"dns://tanium\",\n\"value\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\",\n\"class\": \"source\"\n},\n{\n\"name\": \"rule\",\n\"ns\": \"dns://xccdf\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1_L1_Ensure_Enforce_password_history_is_set_to_24_or_more_passwords\",\n\"class\": \"id\"\n},\n{\n\"name\": \"result\",\n\"ns\": \"dns://xccdf\",\n\"value\": \"pass\",\n\"class\": \"result\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"da8b87f6-2068-415f-94bb-e14e31b4f5c2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-04-13T00:16:20.000+00:00\"\n},\n{\n\"uuid\": \"5ae9c133-c32d-44c5-b52e-5af4513cb94a\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.2_L1_Ensure_Maximum_password_age_is_set_to_60_or_fewer_days_but_not_0\",\n\"props\": [\n{\n\"name\": \"benchmark\",\n\"ns\": \"dns://tanium\",\n\"value\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\",\n\"class\": \"source\"\n},\n{\n\"name\": \"rule\",\n\"ns\": \"dns://xccdf\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.2_L1_Ensure_Maximum_password_age_is_set_to_60_or_fewer_days_but_not_0\",\n\"class\": \"id\"\n},\n{\n\"name\": \"result\",\n\"ns\": \"dns://xccdf\",\n\"value\": \"pass\",\n\"class\": \"result\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"f3ab87b2-70c1-4332-991e-c003d4314c0b\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-04-13T00:16:20.000+00:00\"\n},\n{\n\"uuid\": \"8d021edc-176e-4373-a3c4-a19e954c1e4d\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.3_L1_Ensure_Minimum_password_age_is_set_to_1_or_more_days\",\n\"props\": [\n{\n\"name\": \"benchmark\",\n\"ns\": \"dns://tanium\",\n\"value\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\",\n\"class\": \"source\"\n},\n{\n\"name\": \"rule\",\n\"ns\": \"dns://xccdf\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.3_L1_Ensure_Minimum_password_age_is_set_to_1_or_more_days\",\n\"class\": \"id\"\n},\n{\n\"name\": \"result\",\n\"ns\": \"dns://xccdf\",\n\"value\": \"fail\",\n\"class\": \"result\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"f3ab87b2-70c1-4332-991e-c003d4314c0b\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-04-13T00:16:20.000+00:00\"\n},\n{\n\"uuid\": \"36aa7551-d047-4f4a-9853-6ac63cfc9e48\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.4_L1_Ensure_Minimum_password_length_is_set_to_14_or_more_characters\",\n\"props\": [\n{\n\"name\": \"benchmark\",\n\"ns\": \"dns://tanium\",\n\"value\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\",\n\"class\": \"source\"\n},\n{\n\"name\": \"rule\",\n\"ns\": \"dns://xccdf\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.4_L1_Ensure_Minimum_password_length_is_set_to_14_or_more_characters\",\n\"class\": \"id\"\n},\n{\n\"name\": \"result\",\n\"ns\": \"dns://xccdf\",\n\"value\": \"pass\",\n\"class\": \"result\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"f3ab87b2-70c1-4332-991e-c003d4314c0b\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-04-13T00:16:20.000+00:00\"\n}\n],\n\"findings\": [\n{\n\"uuid\": \"ba4e264f-0aee-4ead-9ee3-6161c5cc4ecb\",\n\"title\": \"800-53: IA-5\",\n\"description\": \"800-53: IA-5\",\n\"target\": {\n\"type\": \"objective-id\",\n\"id-ref\": \"800-53: IA-5\",\n\"props\": [\n{\n\"name\": \"profile\",\n\"ns\": \"dns://tanium\",\n\"value\": \"NIST 800-53\",\n\"class\": \"source\"\n},\n{\n\"name\": \"id-ref\",\n\"ns\": \"dns://tanium\",\n\"value\": \"800-53: IA-5\",\n\"class\": \"source\"\n},\n{\n\"name\": \"result\",\n\"ns\": \"dns://xccdf\",\n\"value\": \"FAIL\",\n\"class\": \"STRVALUE\"\n}\n],\n\"status\": \"not-satisfied\"\n},\n\"related-observations\": [\n{\n\"observation-uuid\": \"b3250b66-fe6f-4ac0-be99-cb4ff093dc31\"\n},\n{\n\"observation-uuid\": \"5ae9c133-c32d-44c5-b52e-5af4513cb94a\"\n},\n{\n\"observation-uuid\": \"8d021edc-176e-4373-a3c4-a19e954c1e4d\"\n},\n{\n\"observation-uuid\": \"36aa7551-d047-4f4a-9853-6ac63cfc9e48\"\n}\n]\n}\n]\n}\n]\n}\n</code></pre>"},{"location":"cli/#trestle-task-xlsx-to-oscal-cd","title":"<code>trestle task xlsx-to-oscal-cd</code>","text":"<p>The trestle task xlsx-to-oscal-cd command facilitates transformation of an excel spreadsheet into an OSCAL component-definition.json file. Specify in the config:</p> <ul> <li> location of catalog file <li> location of spreadsheet file <li> work sheet name in the spreadsheet file <li> output directory to write the component-definition.json file <li> whether or not to overwrite an existing component-definition.json file <li> the organization name <li> the organization remarks <li> the namespace <li> comma separated mappings from name to class <li> the catalog URL <li> the catalog title  <p> Example command invocation: </p> <p><code>$TRESTLE_BASEDIR$ trestle task xlsx-to-oscal-cd -c /home/user/task-xlsx-to-oscal-cd.config</code></p> <p> Example config: </p> <p>/home/user/task-xlsx-to-oscal-cd.config</p> <pre><code>[task.xlsx-to-oscal-cd]\n\ncatalog-file = nist-content/nist.gov/SP800-53/rev4/json/NIST_SP-800-53_rev4_catalog.json\nspread-sheet-file = /home/user/compliance/data/spread-sheet/good.xlsx\nwork-sheet-name = example_best_practices_controls\noutput-dir = /home/user/compliance/data/tasks/xlsx/output\noutput-overwrite = true\n\norg-name = International Business Machines\norg-remarks = IBM\nnamespace = https://ibm.github.io/compliance-trestle/schemas/oscal/cd/ibm-cloud\nproperty-name-to-class = goal_name_id:scc_goal_name_id, goal_version:scc_goal_version\ncatalog-url = https://github.com/usnistgov/oscal-content/blob/master/nist.gov/SP800-53/rev4/json/NIST_SP-800-53_rev4_catalog.json\ncatalog-title = NIST Special Publication 800-53 Revision 4\n</code></pre> <p>catalog-file</p> <p> Example catalog-file: </p> <p>nist-content/nist.gov/SP800-53/rev4/json/NIST_SP-800-53_rev4_catalog.json</p> <p>spread-sheet-file</p> <p> Example spread-sheet-file: </p> <p>/home/user/compliance/data/spread-sheet/good.xlsx</p> <p>output</p> <p> Example component-definition.json: </p> <p>/home/user/compliance/data/tasks/xlsx/output/component-definition.json</p>"},{"location":"cli/#spreadsheet-to-component-definition-mapping","title":"spreadsheet to component definition mapping","text":"display mapping table spreadsheet column name component definition path comments  ControlId <ul> <li>implemented_requirement.property[name='goal_name_id'].value      <ul> <li>only used if column 'goal_name_id' is empty      ControlText <ul> <li>implemented_requirement.property[name='goal_name_id'].remarks      <ul> <li>transformation code replaces \"Check whether\" with \"Ensure\" in text      Nist Mappings <ul> <li>implemented_requirement.description      <ul> <li>heading may span multiple columns     <li>one value expected per column     <li>each entry is separated into control + statements (if any)      ResourceTitle <ul> <li>component.title         <li>component.description     <li>component.control-implementation.description + {text}      <ul> </ul> goal_name_id <ul> <li>implemented_requirement.property[name='goal_name_id'].value      <ul> </ul> Version <ul> <li>implemented_requirement.property[name='goal_version'].value      <ul> <li>Value from spreadsheet is not currently used.      <li>Value '1.0' is hard coded.      Parameter [optional parameter] <ul> <li>implemented_requirement.set_parameter.param_id      <ul> <li>The expected text is in two parts separated by '\\n'.     <li>The text following the '\\n' is the value used.      Values [alternatives] <ul> <li>implemented_requirement.set_parameter.values      <ul> <li>The expected text is of the following format:      <li>v0, [v1, v2...]     <li>The value v0 is used."},{"location":"cli/#trestle-task-xlsx-to-oscal-profile","title":"<code>trestle task xlsx-to-oscal-profile</code>","text":"<p>The trestle task xlsx-to-oscal-profile command facilitates transformation of an excel spreadsheet into an OSCAL profile.json file. Specify in the config:</p> <ul> <li> the href URL of the spreadsheet <li> file system location of spreadsheet file <li> work sheet name in the spreadsheet file <li> output directory to write the profile.json file <li> whether or not to overwrite an existing profile.json file <li> the profile title  <p> Example command invocation: </p> <p><code>$TRESTLE_BASEDIR$ trestle task xlsx-to-oscal-profile -c /home/user/task-xlsx-to-oscal-profile.config</code></p> <p> Example config: </p> <p>/home/user/task-xlsx-to-oscal-profile.config</p> <pre><code>[task.xlsx-to-oscal-profile]\n\nspread-sheet-url = https://github.mycorp.com/spread-sheets/good.xlsx\nspread-sheet-file = /home/user/compliance/data/spread-sheet/good.xlsx\nwork-sheet-name = example_best_practices_controls\noutput-dir = /home/user/compliance/data/tasks/xlsx/output\noutput-overwrite = true\n\nprofile-title = IBM Best Practices SCC GOALS\n</code></pre> <p>spread-sheet-file</p> <p> Example spread-sheet-file: </p> <p>/home/user/compliance/data/spread-sheet/good.xlsx</p> <p>output</p> <p> Example profile.json: </p> <p>/home/user/compliance/data/tasks/xlsx/output/profile.json</p>"},{"location":"demonstrations-content/","title":"Trestle demonstration projects and content","text":"<p>Trestle has a number of demonstrations setup in the IBM/compliance-trestle-demos repository which is intended to be a single point of call for demonstrations and content.</p> <p>If you are interested in contributing a demonstration / content open a PR to the demonstration repo and a PR to this page.</p> <p>Demonstrations, where practical, should include instructions on how they were created.</p>"},{"location":"demonstrations-content/#current-demonstrations","title":"Current demonstrations","text":""},{"location":"demonstrations-content/#simple-sdk-examples","title":"Simple sdk examples.","text":"<p>This folder contains a number of small examples for using the trestle OSCAL sdks.</p>"},{"location":"demonstrations-content/#australian-government-information-security-manual-ism","title":"Australian government Information Security Manual (ISM)","text":"<p>This demonstration uses trestle as an SDK for generating OSCAL files. This demonstration downloads all currently available versions of the Australian Government ISM from ACSC and converts those documents to a set of OSCAL catalogs and profiles. Read more about the demo here.</p>"},{"location":"demonstrations-content/#arc42-architectural-template-enforcement-using-trestle-author","title":"arc42 architectural template enforcement using trestle author.","text":"<p>arc42 have created a set of open-source architecture documentation templates. This demonstration uses <code>trestle author</code> to enforce use of the (modified) arc42 templates.</p> <p>A CICD pipeline (using github actions) is used for this demonstration. The full repository, including working CICD is here. Read more about the demo here.</p>"},{"location":"demonstrations-content/#trestle-flask-microservice-demonstration","title":"Trestle flask microservice demonstration.","text":"<p><code>trestle</code> uses a python library called pydantic to form the underlying OSCAL object models. flask-pydantic introduces a mechanism which integrates pydantic models into flask, providing automated user input validation in one line of code. This demo accepts a catalog as a POSTed object, throwing errors if the catalog does not meet the schema, and returns the catalog in the response. Find the demonstration here.</p>"},{"location":"demonstrations-content/#creating-a-cis-controls-catalog-from-an-excel-spreadsheet","title":"Creating a CIS controls catalog from an excel spreadsheet.","text":"<p>The Centre for Internet Security (CIS) produce a number of cross industry standards for IT security including their platform specific benchmarks and a suite of controls. This demo converts a spreadsheet of those controls into a a catalog and three profiles.</p>"},{"location":"demonstrations-content/#creating-an-ssp-using-trestle-author","title":"Creating an SSP using trestle author.","text":"<p><code>trestle author ssp-generate</code> and <code>trestle author ssp-assemble</code> allow users to generate first a set of markdown documents to allow easy editing of control responses and second to reassemble that information up into an OSCAL ssp document. This is a 'baseline' demonstration with more sophisticated updates expected in the near term.</p>"},{"location":"demonstrations-content/#trestle-repository-api-trestlecorerepository","title":"Trestle Repository API (<code>trestle.core.repository</code>)","text":"<p><code>trestle.core.repository</code> is an API which abstracts users from the file system of a trestle repository. It provides a way for external developers to access a trestle repository without relying on presumptions (such as cwd being within the repository). Find the demo here.</p>"},{"location":"demonstrations-content/#converting-a-spreadsheet-into-a-component-definition","title":"Converting a spreadsheet into a <code>component-definition</code>","text":"<p>Plenty of compliance content exists today in spreadsheets. This demonstration show how to use the xlsx-to-oscal-component-definition MVP functionality.</p>"},{"location":"demonstrations-content/#task-examples","title":"Task examples","text":""},{"location":"demonstrations-content/#spreadsheet-to-component-definition","title":"Spreadsheet to component definition","text":""},{"location":"errors/","title":"Known errors and limitations","text":""},{"location":"errors/#uft-8-encoding-only","title":"uft-8 encoding only","text":"<p>Trestle supports only utf8 as a file text-encoding. If non-utf8 files are encountered, errors will be reported / thrown. Trestle provides a script that may be used to convert files to utf8 in a destructive manner that may change the file contents.</p> <p>WARNING: This script is potentially destructive and may remove / damage content. Ensure you have a backup before use.</p>"},{"location":"license/","title":"License","text":"<pre><code>                                 Apache License\n                           Version 2.0, January 2004\n                        https://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n</code></pre>"},{"location":"maintainers/","title":"Maintainers","text":"<p>Trestle was designed and open sourced by a team based at IBM Research and others around the world.  The list includes:</p> <p>Christopher Butler - butler54</p> <p>Bruno Marques - brunomarq</p> <p>Lenin Mehedy - leninmehedy</p> <p>Simon Metson - drsm79</p> <p>Frank Suits - fsuits</p> <p>Jeff Tan - jeffdmgit</p> <p>Nebula Alam - aNebula</p> <p>Vikas Agarwal vikas-agarwal76</p> <p>Lou Degenaro degenaro</p> <p>Ekaterina Nikonova enikonovad</p> <p>Alejandro Jose Leiva Palomo AleJo2995</p>"},{"location":"mkdocs_code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"mkdocs_code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"mkdocs_code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"mkdocs_code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"mkdocs_code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"mkdocs_code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at avikas@in.ibm.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"mkdocs_code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"python_trestle_setup/","title":"Install trestle in a python virtual environment","text":"<p>There are a few things you need to to start using trestle:</p> <ul> <li>Make sure you have a working and recent Python environment</li> <li>Set up a Python virtual environment</li> <li>Download and install trestle</li> <li>Confirm it is working properly</li> <li>Create a trestle workspace</li> </ul>"},{"location":"python_trestle_setup/#confirm-you-have-python-installed","title":"Confirm you have python installed","text":"<ul> <li>Ensure you have a modern Python (3.7, 3.8, 3.9).</li> </ul> <pre><code>$ python -V\nPython 3.8.3\n</code></pre>"},{"location":"python_trestle_setup/#setup-a-virtual-environment","title":"Setup a virtual environment","text":"<p>There are many ways to do this on Windows, Mac and Linux and with different Python installations, so please consult the documentation associated with your platform.  Below is how it works on a typical Linux platform.</p> <pre><code>$ cd\n$ python -m venv venv.trestle\n$ source venv.trestle/bin/activate\n(venv.trestle)$\n</code></pre> <ul> <li>Ensure you have a modern pip (19.x or greater).</li> </ul> <pre><code>(venv.trestle)$ python -m pip --version\npip 19.2.3 from /home...\n</code></pre> <p>You should probably upgrade your pip to the latest version with:</p> <pre><code>(venv.trestle)$ python -m pip install --upgrade pip\n</code></pre> <p>Details can be found at Installation - pip documentation</p>"},{"location":"python_trestle_setup/#install-trestle","title":"Install trestle","text":"<ul> <li>Install compliance-trestle.</li> </ul> <pre><code>(venv.trestle)$ python -m pip install compliance-trestle\nLooking in indexes: https://pypi.org/simple,...\n</code></pre>"},{"location":"python_trestle_setup/#confirm-trestle-is-installed-properly","title":"Confirm trestle is installed properly","text":"<ul> <li>Check trestle viability (and view help).</li> </ul> <pre><code>(venv.trestle)$ trestle -h\nusage: trestle [-h]\n{assemble,author,create,describe,href,import,init,merge,partial-object-validate,remove,replicate,split,task,validate,version}\n...\n</code></pre> Full help text <pre><code>Manage OSCAL files in a human friendly manner.\n\npositional arguments:\n  {assemble,author,create,describe,href,import,init,merge,partial-object-validate,remove,replicate,split,task,validate,version}\nassemble            Assemble all subcomponents from a specified trestle model into a single JSON/YAML file under\n                        dist.\n    author              trestle author, a collection of commands for authoring compliance content outside of OSCAL.\n    create              Create a sample OSCAL model in trestle project or create new elements within a given model.\n    describe            Describe contents of a model file including optional element path.\n    href                Change href of import in profile to point to catalog in trestle project. This command is\n                        needed when generating an SSP with a profile that imports a catalog from a temporary location\n                        different from the final intended location of the catalog. Omit the href argument to see the\n                        list of current imports in the profile.\n    import              Import an existing full OSCAL model into the trestle project.\n    init                Initialize a trestle working directory.\n    merge               Merge subcomponents on a trestle model.\n    partial-object-validate\n                        Direct validation any oscal object in a file, including list objects.\n    remove              Remove a subcomponent to an existing model.\n    replicate           Replicate a top level model within the trestle directory structure.\n    split               Split subcomponents on a trestle model.\n    task                Run arbitrary trestle tasks in a simple and extensible methodology.\n    validate            Validate contents of a trestle model in different modes.\n    version             Output version info for trestle and OSCAL.\n\noptional arguments:\n  -h, --help            show this help message and exit\n</code></pre>"},{"location":"python_trestle_setup/#create-a-trestle-workspace","title":"Create a trestle workspace","text":"<ul> <li>Create trestle workspace.</li> </ul> <pre><code>(venv.trestle)$ mkdir trestle.workspace\n(venv.trestle)$ cd trestle.workspace\n(venv.trestle)$ trestle init\nInitialized trestle project successfully in /home/&lt;user&gt;/trestle.workspace\n</code></pre> <p>Congratulations! You now have a working trestle workspace for safe manipulation of OSCAL documents!</p>"},{"location":"trestle_author/","title":"Trestle CLI for Governance of Authored Documents","text":"<p>This document is organized in a multiple collapsable sections for ease of use. Start by reading the overview and setting up the Trestle workspace and then proceed to other sections, to learn more about Trestle authoring capabilities.</p>"},{"location":"trestle_author/#contents","title":"Contents","text":"1. Overview 2. Setting up the Trestle workspace 3. Authoring of Documents Documents Structural Enforcement 4. Authoring of OSCAL Models"},{"location":"trestle_author/#overview","title":"Overview","text":"<p>The premise of trestle is to support managing compliance artifacts as code. When this is considered, many organisations using <code>{github|gitlab|bitbucket}</code> rely on markdown documents for documentary artifacts that may either directly or indirectly support compliance efforts.</p> <p>To support this, trestle has the concept of 'governing' documents that are authored documents: Where structural conditions are enforced on the markdown documents to allow automation and to ensure business processes are met.</p> <p>Living in the <code>GitOps</code> world this capability is anchored with <code>markdown</code> files as the core of the workflows. Currently <code>drawio</code> files are also supported for a subset of enforcement mechanisms.</p> Setting Up Templates and Documents Via CLI <p>Trestle allows the setup of templates and governed documents in a several different ways based on the nature of the needed governance.</p> <p>Definitions used in this section:</p> <ul> <li>document - a markdown or drawio file that needs to be validated against some template.</li> <li>template - an individual markdown or drawio file containing metadata and/or headings against which the documents will be validated.</li> <li>task - a name of the folders containing documents and their respective templates.</li> <li>template folder - an individual folder containing the templates that documents needs to be validated against.</li> </ul> <p>You can set up multiple different tasks and types of validations in the same workspace.</p> <p>Setup Trestle for:</p> docs - Validating documents against one specific template (one template per task) Template Versioning"},{"location":"trestle_author/#why-is-this-capability-in-trestle","title":"Why is this capability in trestle?","text":"<p>While trestle provides editing support for OSCAL there is an unfortunate truth that for some compliance workflows:</p> <ol> <li>OSCAL does not cover the lower level operational workflows.</li> <li>Some users will not be comfortable editing in json/yaml/xml formats</li> </ol> <p>The markdown centric workflows allow transition path where capability is being developed</p>"},{"location":"trestle_author/#setting-up-the-trestle-workspace","title":"Setting up the Trestle workspace","text":"<p>To work with governed documents, you would need to initialize the Trestle workspace and create your first governed document and template.</p> <p>To create a trestle workspace that will contain all your templates and governed documents:</p> <pre><code>mkdir my_workspace\ncd my_workspace\ntrestle init --govdocs\n&gt;&gt;&gt; Initialized trestle project successfully in [user_path]/my_workspace\n</code></pre> <p>The templates will be located in the <code>/my_workspace/.trestle/author/</code>. Please note that if you use MacOS or Linux distribution, by default <code>.trestle</code> will be hidden. You will need to reconfigure your system to show hidden folders if you want to see them listed.</p>"},{"location":"trestle_author/#markdown-structural-enforcement","title":"Markdown structural enforcement","text":"<p>Trestle templating enforces the documents to follow a specific structure. There are two ways in which structure is enforced in a document against template:</p> <ol> <li>Enforcing a YAML header (metadata) structure at the top of the markdown document.</li> <li>Enforcing a heading structure within the markdown document.</li> </ol> <p>Each document is validated against a specific template, see CLI section below on information on how to specify which template the document should be validated against.</p>"},{"location":"trestle_author/#enforcing-yaml-header-metadata-structure","title":"Enforcing YAML header (metadata) structure","text":"<p>Each template and document contains metadata in form of a YAML header that is placed on top. When the document is created (i.e. <code>trestle docs setup</code>) the metadata is copied from the template to the newly created document.</p> <p>Below is an example of a markdown file that contains YAML header:</p> <pre><code>---\ngroceries:\ngrocery1:\n  name: apple\n  type: fruit\n  bought-in: Local market\ngrocery2:\n  name: potato\n  type: vegetable\n  bought-in: Local market\ndate: 01-01-2022\nnot-important-field: not important\nx-trestle-version: 1.0.0\nx-trestle-ignore: not-important-field, bought-in\n---\n# The rest of my document\n</code></pre> <p>Each field in the YAML header follows the <code>key: value</code> format. For YAML header we validate the structure and the presence of the \"keys\" and not the \"values\".</p> <p>The document YAML header(metadata) is said to be valid against the template, if and only if:</p> <ol> <li>It contains all keys from the template EXCEPT the keys that either:</li> <li>Start with <code>x-trestle</code></li> <li>Are listed under the <code>x-trestle-ignore</code> key (i.e. <code>x-trestle-ignore: not-important-field, bought-in</code>)</li> <li>The version under <code>x-trestle-template-version:</code> key is matching the template.</li> <li>No new keys were added to the document.</li> </ol> <p>For example, this change to the YAML header above is acceptable:</p> <pre><code>---\ngroceries:\n  grocery1:\n      name: pear\n      type: fruit\n      bought-in: Superstore\n  grocery2:\n      name: potato\n      type: vegetable\n      bought-in: Local market\ndate: 10-10-2023\nnot-important-field: not important\nx-trestle-version: 1.0.0\nx-trestle-ignore: not-important-field, bought-in\n---\n# The rest of my document\n</code></pre>"},{"location":"trestle_author/#enforcing-heading-structure","title":"Enforcing heading structure","text":"<p>Markdown headings are considered to be nested based on the heading level (i.e. number of <code>#</code>). For example, <code>## 1.1 Lower level heading</code> is below <code># 1. top level heading</code>.</p> <p>The document body is said to be valid against the template, if and only if,</p> <ol> <li>It contains all the headings provided in the template.</li> <li>No new headings were added at the top level (i.e. <code># New heading</code> is not allowed).</li> <li>All original headings are in the same order as in the template.</li> <li>All headings must be in the hierarchical order (i.e. <code># Heading</code> then <code>### Heading</code> then <code>## Heading</code> is invalid).</li> <li>If the <code>--governed-heading</code> option is provided, then document is valid if no keys has changed in the specified governed section.</li> </ol> <p>For example, consider this template as our starting point:</p> <pre><code># Template heading 1\nSome text\n# Template heading 2\n## Template sub heading\n</code></pre> <p>Now we added new sections and ended up with the following document: (note: this document will be valid against the template above)</p> <pre><code># Template heading 1\nContent for heading one\n## Non-required sub header\nContent for non-required sub header\n# Template heading 2\nContent for heading two\n## Template sub heading\nContent for template sub heading\n### non required sub-sub heading\nThis sub-sub heading is okay\n</code></pre> <p>However, violations such as adding or removing a heading at the top level are not acceptable:</p> <pre><code># Template heading 1\nContent for heading one\n## Non-required sub header\nContent for non-required sub header\n# Template heading 2\nContent for heading two\n## Template sub heading\nContent for template sub heading\n# Top level heading that is not okay &lt;&lt;&lt; NOT OKAY\n</code></pre> <p>For each of the headings - the text of the heading is enforced with one caveat:</p> <ul> <li>If the template heading text is wrapped in curly brackets <code>{}</code> then the name is not measured e.g. <code># {Insert title here}</code>.</li> </ul> folders - Validating documents against multiple templates and ensuring folder structure (multiple individual templates per task)  headers - Validate only the headers against a global or a specific template"},{"location":"trestle_author/#drawio-enforcement-mechanisms","title":"Drawio enforcement mechanisms","text":"<p>Drawio or diagrams.net is a diagramming platform which has significant use for architecture diagrams. In the context of governance of content, trestle is supporting enforcement of metadata.</p> <p>Drawio (or <code>mxgraph</code>) files have a set of data fields. In a drawio file this is available in the edit menu as edit data. The diagram below shows how to access the (meta)data.</p> <p></p> <p>The data presents as a set of key-value pairs which can be edited (see below). The data is bound to each tab in a drawio file. The trestle CLI currently expects that metadata (whether from the template or file to be measured) is in the first tab when editing the draw io file.</p> <p></p>"},{"location":"trestle_author/#validating-documents-against-one-specific-template","title":"Validating documents against one specific template","text":"<p>In this section we describe the functionality of <code>trestle author docs</code> command.</p> <p><code>author docs</code> is designed to support enforcing and generating templating markdown files within a single folder based on a task name. Currently <code>author docs</code> supports markdown files only.</p>"},{"location":"trestle_author/#creating-new-tasktemplate","title":"Creating new task/template","text":"<p>To create a new task with the necessary directory structures for running governed docs validation, run:</p> <p>trestle author docs setup -tn my_task_name</p> <p>This will create a template folder and a single template: <code>TRESTLE_ROOT/.trestle/author/my_task_name/0.0.1/template.md</code>. As well as an empty document folder: <code>TRESTLE_ROOT/my_task_name/</code> The template will be applied to all markdown files in the task i.e.: <code>TRESTLE_ROOT/my_task_name/*.md</code>.</p>"},{"location":"trestle_author/#extra-options","title":"Extra options","text":"<ul> <li>You can create different versions of the template by specifying the version via <code>--template-version</code> flag. See <code>Template Versioning</code> section for more information.   By default if no version is provided <code>0.0.1</code> will be used.</li> </ul>"},{"location":"trestle_author/#creating-new-document-for-the-task","title":"Creating new document for the task","text":"<p>To create a new document that confirms to a template run:</p> <p>trestle author docs create-sample -tn my_task_name</p> <p>This will create a sample document in: <code>TRESTLE_ROOT/my_task_name/my_task_name_000.md</code>. Once created this document will be a complete copy of the template, however you can modify this file with your own content.</p>"},{"location":"trestle_author/#extra-options_1","title":"Extra options","text":"<ul> <li>This command has no extra options</li> </ul>"},{"location":"trestle_author/#validating-the-template","title":"Validating the template","text":"<p>To ensure that the markdown in the template is parseable run:</p> <p>trestle author docs template-validate -tn my_task_name</p>"},{"location":"trestle_author/#extra-options_2","title":"Extra options","text":"<ul> <li>If <code>--governed-heading 'heading name'</code> (<code>-gh</code>) is passed it ensures that the required heading exists.</li> <li>If <code>--header-validate</code> (<code>-hv</code>) is passed the header will be validated as well.</li> <li>If <code>--header-only-validate</code> (<code>-hov</code>) only the header and NOT the body will be validated</li> </ul>"},{"location":"trestle_author/#validating-the-documents-against-the-template","title":"Validating the documents against the template","text":"<p>To validate the documents against a template run:</p> <p>trestle author docs validate -tn my_task_name</p> <p>This will take the <code>TRESTLE_ROOT/.trestle/author/my_task_name/template.md</code> template and validate all markdown files here: <code>TRESTLE_ROOT/my_task_name/*.md</code>.</p> <p>Running the command will validate that markdown body in the document is valid against the template. Please note that by default the header will not be validated. See extra options for more validation options. To learn more on what exactly is validated please refer to <code>Documents Structural Enforcement</code> section in this document.</p>"},{"location":"trestle_author/#extra-options_3","title":"Extra options","text":"<ul> <li>If <code>--governed-heading</code> (<code>-gh</code>) is passed it will ensure that the governed content was not modified. Governed content comes in the key: value format:</li> </ul> <pre><code>     # Governed section\n     **Content Type:**  Foo\n     **Author(s):**  Bah\n     **Executive Owner:**  Stuff\n     **Technical Approver:**   John Doe (approved)\n     **Version:** 1.0.1\n</code></pre> <p>Running <code>trestle author docs validate -tn docs_task -gh=\"Governed section\"</code> will ensure this content is present in the document.</p> <ul> <li>If <code>--ignore ^_.*</code> (<code>-ig</code>) is passed it will validate all files except folders and files that start with underscore <code>_</code>. Use this option when you would like to ignore any folders or files that match given regular expression.</li> <li>If <code>--header-validate</code> (<code>-hv</code>) is passed the header will be validated as well.</li> <li>If <code>--header-only-validate</code> (<code>-hov</code>) is passed only the header and NOT the body will be validated.</li> <li>If <code>--readme-validate</code> (<code>-rv</code>) is passed README.md will be validated as well, otherwise it is ignored.</li> <li>If <code>--recurse</code> (<code>-r</code>) is passed the documents in the subfolders will also be validated. By default <code>author docs</code> only indexes a flat directory.</li> <li>If <code>--template-version 1.0.0</code> (<code>-tv</code>) is passed the header field <code>x-trestle-template-version</code> will be ignored and document will be forcefully validated against template of version <code>1.0.0</code>.   Use this for testing purposes only when you need to validate the document against a specific template. By default the template version will be determined based on <code>x-trestle-template-version</code> in the document.</li> </ul>"},{"location":"trestle_author/#validating-against-multiple-templates","title":"Validating against multiple templates","text":"<p>In this section we describe the functionality of <code>trestle author folders</code> command.</p> <p><code>author folders</code> is designed to allow the assembly of groups of templates where each folder contains unique content. This command will validate that both: structure (i.e. all template documents are present) and content is preserved in the folder. Trestle author folders supports validation of both markdown and drawio files. Note that headers / metadata must be specified in each applicable template.</p>"},{"location":"trestle_author/#creating-new-task-folder","title":"Creating new task folder","text":"<p>To create a new task folder run:</p> <p>trestle author folders setup -tn my_task_2</p> <p>This will create a template folder with the following structure:</p> <pre><code>trestle_root\n\u2523 .trestle\n\u2503 \u2523 author\n\u2503 \u2503 \u2523 my_task_2\n\u2503 \u2503 \u2503 \u2523 0.0.1\n\u2503 \u2503 \u2503 \u2503 \u2523 a_template.md\n\u2503 \u2503 \u2503 \u2503 \u2523 another_template.md\n\u2503 \u2503 \u2503 \u2503 \u2517 arhitecture.drawio\n\u2503 \u2517 config.ini\n</code></pre> <p>Each task folder is required to meet template requirements for all: <code>a_template.md</code>, <code>another_template.md</code>, and <code>template.drawio</code>. The names, numbers, and nesting of folders is user specifiable, however, unlike <code>docs</code> the names must be carried over to each instances.</p>"},{"location":"trestle_author/#extra-options_4","title":"Extra options","text":"<ul> <li>You can create different versions of the template by specifying the version via <code>--template-version</code> flag. See <code>Template Versioning</code> section for more information.   By default if no version is provided <code>0.0.1</code> will be used.</li> </ul>"},{"location":"trestle_author/#creating-new-documents-for-the-task","title":"Creating new documents for the task","text":"<p>Following the similar structure of <code>docs</code>, measurement occurs in the <code>my_task_2</code> where this structure is enforced for every directory.</p> <p>To create a new folder with documents for the task run:</p> <p>trestle author folders create-sample -tn my_task_2</p> <p>This will create a subfolder in the <code>my_task_2</code> with the same content as in template folder. Running it twice will result in:</p> <pre><code>trestle_root\n \u2523 .trestle\n \u2523 my_task_2\n \u2503 \u2523 sample_folder_0\n \u2503 \u2503 \u2523 a_template.md\n \u2503 \u2503 \u2523 arhitecture.drawio\n \u2503 \u2503 \u2517 another_template.md\n\n \u2503 \u2517 sample_folder_1\n \u2503 \u2503 \u2523 a_template.md\n \u2503 \u2503 \u2523 arhitecture.drawio\n \u2503 \u2503 \u2517 another_template.md\n</code></pre>"},{"location":"trestle_author/#extra-options_5","title":"Extra options","text":"<ul> <li>This command has no extra options</li> </ul>"},{"location":"trestle_author/#validating-the-templates","title":"Validating the templates","text":"<p>To validate the documents against the template run:</p> <p>trestle author folders template-validate -tn my_task_2</p> <p>This will ensure that the respective template files are parseable.</p>"},{"location":"trestle_author/#extra-options_6","title":"Extra options","text":"<ul> <li>This command has no extra options</li> </ul>"},{"location":"trestle_author/#validating-the-documents-against-templates","title":"Validating the documents against templates","text":"<p>The validation in <code>trestle author folder</code> runs similarly as in <code>docs</code> but now each document will be validated against the template with the same name as in the template folder.</p> <p>To validate the documents against their respective templates, run:</p> <p>trestle author folders validate -tn my_task_name</p> <p>This will validate all files. Please note that all files from the template folder must be present in the individual document folders.</p>"},{"location":"trestle_author/#extra-options_7","title":"Extra options","text":"<ul> <li>If <code>--governed-heading</code> (<code>-gh</code>) is passed it will ensure that the governed content was not modified. Governed content comes in the key: value format:   <pre><code>   # Governed section\n   **Content Type:**  Foo\n   **Author(s):**  Bah\n   **Executive Owner:**  Stuff\n   **Technical Approver:**   John Doe (approved)\n   **Version:** 1.0.1\n</code></pre></li> </ul> <p>Running <code>trestle author docs validate -tn docs_task -gh=\"Governed section\"</code> will ensure this content is present in the document.</p> <ul> <li>If <code>--ignore ^_.*</code> (<code>-ig</code>) is passed it will validate all files except folders and files that start with underscore <code>_</code>. Use this option when you would like to ignore any folders or files that match given regular expression.</li> <li>If <code>--header-validate</code> (<code>-hv</code>) is passed the header will be validated as well.</li> <li>If <code>--header-only-validate</code> (<code>-hov</code>) is passed only the header and NOT the body will be validated.</li> <li>If <code>--readme-validate</code> (<code>-rv</code>) is passed README.md will be validated as well, otherwise it is ignored.</li> <li>If <code>--recurse</code> (<code>-r</code>) is passed the documents in the subfolders will also be validated. By default <code>author docs</code> only indexes a flat directory.</li> <li>If <code>--template-version 1.0.0</code> (<code>-tv</code>) is passed the header field <code>x-trestle-template-version</code> will be ignored and document will be forcefully validated against template of version <code>1.0.0</code>.   Use this for testing purposes only when you need to validate the document against a specific template. By default the template version will be determined based on <code>x-trestle-template-version</code> in the document.</li> </ul>"},{"location":"trestle_author/#validate-only-the-headers-against-a-global-or-a-specific-template","title":"Validate only the headers against a global or a specific template.","text":"<p>In this section we describe the functionality of <code>trestle author headers</code> command.</p> <p>Trestle author headers supports a slightly different usecase than that of <code>docs</code> and <code>folders</code> above as only the YAML headers will be validated. This command can be useful when one does not care about the markdown structure and might want to use global templates (templates that are shared across multiple tasks).</p> <p>With <code>headers</code> template folder can contain both .md and .drawio files and each file will be validated against the template that matches the extension. Also <code>headers</code> allow user to have <code>global</code> templates that can be shared across multiple tasks.</p>"},{"location":"trestle_author/#creating-new-tasktemplate_1","title":"Creating new task/template","text":"<p>To create a new task run:</p> <p>trestle author headers setup -tn my_task_3</p> <p>This will create a template folder with the following format:</p> <pre><code>trestle_root\n\u2523 .trestle\n\u2503 \u2523 author\n\u2503 \u2503 \u2523 my_task_3\n\u2503 \u2503 \u2503 \u2523 0.0.1\n\u2503 \u2503 \u2503 \u2503 \u2523 template.md\n\u2503 \u2503 \u2503 \u2503 \u2517 template.drawio\n\u2503 \u2517 config.ini\n</code></pre>"},{"location":"trestle_author/#extra-options_8","title":"Extra options","text":"<ul> <li>If <code>--global</code> (<code>-g</code>) is passed then <code>__global__</code> then it will create <code>trestle_root/.trestle/author/__global__</code> folder. Use this when you would like to use same template for multiple tasks.   <pre><code>trestle_root\n\u2523 .trestle\n\u2503 \u2523 author\n\u2503 \u2503 \u2523 __global__\n\u2503 \u2503 \u2503 \u2523 0.0.1\n\u2503 \u2503 \u2503 \u2503 \u2523 template.md\n\u2503 \u2503 \u2503 \u2503 \u2517 template.drawio\n\u2503 \u2517 config.ini\n</code></pre></li> <li>You can create different versions of the template by specifying the version via <code>--template-version</code> flag. See <code>Template Versioning</code> section for more information.   By default if no version is provided <code>0.0.1</code> will be used.</li> </ul>"},{"location":"trestle_author/#creating-new-documents","title":"Creating new documents","text":"<p>As of now this command does not support the automatic creation of the sample documents.</p>"},{"location":"trestle_author/#validating-the-templates_1","title":"Validating the templates","text":"<p>To validate the documents against the template run:</p> <p>trestle author headers template-validate -tn my_task_3</p> <p>This will ensure that the respective template files are parseable.</p>"},{"location":"trestle_author/#extra-options_9","title":"Extra options","text":"<ul> <li>This command has no extra options</li> </ul>"},{"location":"trestle_author/#validating-the-documents","title":"Validating the documents","text":"<p>To validate the documents against the template run:</p> <p>trestle author headers validate -tn my_task_3</p> <p>This will validate all files within the directory against the templates (of the matching task name) by matching the extensions. Please note that only headers will be validated. There is no option to validate the body.</p>"},{"location":"trestle_author/#extra-options_10","title":"Extra options","text":"<ul> <li>If <code>--global</code> (<code>-g</code>) is passed it will create <code>trestle_root/.trestle/author/__global__</code> folder. Use this when you would like to use same template for multiple tasks.</li> <li>If <code>--ignore ^_.*</code> (<code>-ig</code>) is passed it will validate all files except folders and files that start with underscore <code>_</code>. Use this option when you would like to ignore any folders or files that match given regular expression.</li> <li>If <code>--readme-validate</code> (<code>-rv</code>) is passed README.md will be validated as well, otherwise it is ignored.</li> <li>If <code>--recurse</code> (<code>-r</code>) is passed the documents in the subfolders will also be validated. By default <code>author docs</code> only indexes a flat directory.</li> <li>If <code>--template-version 1.0.0</code> (<code>-tv</code>) is passed the header field <code>x-trestle-template-version</code> will be ignored and document will be forcefully validated against template of version <code>1.0.0</code>.   Use this for testing purposes only when you need to validate the document against a specific template. By default the template version will be determined based on <code>x-trestle-template-version</code> in the document.</li> </ul>"},{"location":"trestle_author/#template-versioning","title":"Template versioning","text":""},{"location":"trestle_author/#prerequisite","title":"Prerequisite:","text":"<p>This section assumes that you have an existing Trestle workspace initialized, with existing template and governed documents. Please follow steps in the section <code>Setting up the Trestle Workspace</code> if you don't have one.</p> <p>Trestle provides the capability to version the templates and the documents via <code>x-trestle-template-version</code> field in the header.</p> <p>Consider an example where we have a governed document called <code>Decision 1</code> that we now need to update to contain a new header field <code>approved-status</code> and a new required heading <code>Heading n</code> at the end, as demonstrated in the Figure below: </p> <p>The intended workflow in this scenario is to:</p> <p>1.Create a new version of the <code>decisions</code> template:</p> <pre><code>cd my_workspace \ntrestle author docs setup -tn decisions -tv 0.1.1\n&gt;&gt;&gt; Set template version to 0.1.1.\n&gt;&gt;&gt; Template file setup for task decisions at .trestle/author/decisions/0.1.1/template.md\n&gt;&gt;&gt; Task directory is decisions\n</code></pre> <p>Add the new required content to the newly created template. In our example simply copy-paste all content from the <code>.trestle/author/decisions/0.1.0/template.md</code> and add the newly required fields.</p> <p>2.Create a new instance of that template.</p> <pre><code>trestle author docs create-sample -tn decisions -tv 0.1.1\n&gt;&gt;&gt; Set template version to 0.1.1.\n</code></pre> <p>This step will create a copy of the template of version 0.1.1.</p> <p>Now you will need to fill the documents with the updated information and new fields.</p> <p>3.(Optional) Delete the old document.</p> <p>Now that you have a new version of the document, you can delete the old one if you no longer need it. You can also keep it if you would like to maintain a history of updates.</p> <p>4.Run validation.</p> <p>After filling the contents to the new version of the template, you can run the validation to ensure that everything works as expected.</p> <pre><code>trestle author docs validate -tn decisions\n&gt;&gt;&gt; Instances will be validated against template version specified in their headers.\n&gt;&gt;&gt; VALID: decisions/decision_000.md\n</code></pre>"},{"location":"trestle_author/#oscal-authoring","title":"OSCAL Authoring","text":""},{"location":"trestle_author/#catalog-authoring","title":"Catalog authoring","text":"<p>CLI evocation:</p> <ol> <li>To generate markdowns for editing a catalog</li> </ol> <p>trestle author catalog-generate</p> <ol> <li>To assemble markdowns to a JSON catalog</li> </ol> <p>trestle author catalog-assemble</p> <p>The <code>catalog</code> author commands allow you to convert a control catalog to markdown and edit its control statement, then assemble markdown back into an OSCAL catalog with the modifications to the statement.  Items in the statement may be edited or added.  For more details on its usage please see the catalog authoring tutorial.</p>"},{"location":"trestle_author/#profile-authoring","title":"Profile authoring","text":"<p>CLI evocation:</p> <ol> <li>To generate markdowns for editing a profile</li> </ol> <p>trestle author profile-generate</p> <ol> <li>To assemble markdowns to a JSON profile</li> </ol> <p>trestle author profile-assemble</p> <p>The <code>profile</code> author commands allow you to edit additions made by a profile to its imported controls that end up in the final resolved profile catalog.  Only the additions may be edited or added to the generated markdown control files - and those additions can then be assembled into a new version of the original profile, with those additions.  For more details on its usage please see the profile authoring tutorial.</p>"},{"location":"trestle_author/#ssp-authoring","title":"SSP authoring","text":"<p>CLI evocation:</p> <ol> <li>To generate markdowns for editing SSP</li> </ol> <p>trestle author ssp-generate</p> <ol> <li>To assemble markdowns to a JSON SSP</li> </ol> <p>trestle author ssp-assemble</p> <p>The <code>ssp-generate</code> sub-command creates a partial SSP (System Security Plan) from a profile and optional yaml header file.  <code>ssp-assemble</code> can then assemble the markdown files into a single json SSP file.</p> <p>For more details on its usage please see the ssp authoring tutorial.</p>"},{"location":"trestle_author/#ssp-content-filtering","title":"SSP Content Filtering","text":"<p>CLI evocation:</p> <p>trestle author ssp-filter</p> <p>The <code>ssp-filter</code> sub-command takes a given SSP and filters its contents based on a given profile, list of components, and/or control implementation status.</p> <p>If filtering by profile, the SSP is assumed to contain a superset of controls needed by the profile, and the filter operation generates a new SSP with just the controls needed by that profile.  If the profile references a control not in the SSP, the routine fails with an error.</p> <p>If filtering by components, a colon-delimited list of components should be provided, with <code>This system</code> as the default name for the overall required component for the entire system.  Case and spaces are ignored in the component names, so the names could be specified as <code>--components \"this system: my component\"</code>.  The resulting, filtered ssp will have updated implementated requirements with filtered by_components on each requirement, and filtered by_components on each statement.</p> <p>If filtering by control implementation status, a comma-demilited list of implementation status values should be provided. These values must comply with the OSCAL SSP format references's allowed values, which are as follows: implemented, partial, planned, alternative, and not-applicable.</p> <p>You may filter by a combination of a profile, list of component names, and implementation statuses.</p> <p>As with the other related author commands, if an existing destination file already exists, it is not updated if no changes would be made.</p> <p>For more details on its usage please see the ssp-filter tutorial.</p>"},{"location":"trestle_author_jinja/","title":"Trestle author jinja - output templating support for oscal documents.","text":"<p>Unfortunately OSCAL documents are not yet universally accepted. Therefore to support various OSCAL and non-OSCAL compliance workflows <code>trestle author jinja</code> is designed to provide end users with the ability to use jinja to produce customized output. This complements the more structured commands <code>trestle author catalog-{assemble|generate}</code>, <code>trestle author profile-{assemble|generate}</code> and <code>trestle author ssp-{assemble|generate}</code> and allows arbitrary use of jinja.</p>"},{"location":"trestle_author_jinja/#jinja-and-jinja-extensions-provided-by-trestle","title":"Jinja and jinja extensions provided by trestle.","text":"<p>Jinja is a powerful templating engine that is both more flexible that pure 'Moustache' approaches, and not coupled to a particular web application server (as an example Django templates). Users are encouraged to review the template designer documentation for jinja as all core functionality is exposed.</p> <p>Trestle's implementation of the Jinja command works in the following way:</p> <ol> <li>The template search space, by default, is relative to the current working directory.</li> <li>Trestle can inject a lookup table, into the jinja variables to contain booleans / substitutions required by end users using Moustache style variable substitutions.</li> <li>Trestle can provide a number of interfaces to OSCAL objects, currently a resolved catalog and a SSP, into jinja.</li> <li>Trestle supports custom jinja tags for importing.</li> <li>The jinja templating is recursive, to ensure all jinja tags are resolved as appropriate.</li> </ol> <p>More details will be on each of these points below.</p>"},{"location":"trestle_author_jinja/#cli-invocation","title":"CLI invocation","text":"<p>Note the examples here use markdown, however, jinja can quite easily target xml or html if used w/o specific markdown content. <code>trestle author jinja -i input_template.md.jinja -o output_file.md -ssp SSP_NAME -p PROFILE_NAME -lut lookup_table.yaml -elp lut.prefix</code></p> <ul> <li><code>-i</code> input file path, relative to cwd. Users are encouraged to use the <code>file_name.target_extension.jinja</code> best practice as it helps mitigate issues, however is not required.</li> <li><code>-o</code> final output path, relative to cwd.</li> <li><code>-ssp</code> (optional) ssp name (in the trestle project). When used the jinja template will have a <code>ssp_md_writer</code> variable exposed to use.</li> <li><code>-p</code> (optional) profile name (in the trestle project). When used the jinja template will have <code>resolved_catalog</code> and <code>catalog_interface</code> variables to use.</li> <li><code>-lut</code> (optional) loads yaml into a dictionary in python for which each (top level) variable is available in jinja.</li> <li><code>-elp</code> (optional) a period separated prefix for the variables in the lookup table. E.g. if the lut contained <code>banana: yellow</code> and the prefix was <code>fruit.tropical</code> using <code>{{ fruit.tropical.banana }}</code> would print out <code>yellow</code> in the jinja template.</li> <li><code>-bf</code> (optional) use to provide a custom formatting of the substituted parameters in the text with brackets or markup formatting. Use dot (.) to indicate where the parameter value will be written. E.g. <code>-bf *.*</code> to italicize all substituted parameters, <code>-bf Prefix:.</code> to add <code>Prefix:</code> to all parameters, and <code>-bf [.]</code> to put square brackets around the parameters.</li> <li><code>-vap</code> (optional) use to specify a <code>--value-assigned-prefix</code> in front of parameters that have values assigned by the profile.  An example would include the organization doing the   assignment, e.g. <code>-vap \"ACME Assignment:\"</code>  This is identical to the behavior of <code>profile-resolve</code>.</li> <li><code>-vnap</code> (optional) use to specify a <code>--value-not-assigned-prefix</code> in front of parameters that do not have values assigned by the profile.  An example would be <code>-vap \"Assignment:\"</code>  This is identical to the behavior of <code>profile-resolve</code>.</li> </ul>"},{"location":"trestle_author_jinja/#sample-jinja-templates","title":"Sample jinja templates","text":"<p>Below is a sample jinja template for SSP.</p> template Description Optional args required Simple SSP template Sample ssp jinja template which prints out all control responses and includes a front-matter section <code>-ssp</code> and <code>-p</code> for the ssp json and corresponding profile, respectively. Also requires a <code>frontmatter.md</code> file"},{"location":"trestle_author_jinja/#variable-availability-in-the-jinja-template","title":"Variable availability in the jinja template.","text":""},{"location":"trestle_author_jinja/#lut","title":"LUT","text":"<p>The lookup table is primarily used for string substitution and to provide variables for basic logic operations in jinja e.g.</p> <p>The LUT:</p> <pre><code>names:\nOSCAL: Open Security Compliance Assessment Language\ntrestle_pip: compliance-trestle\ntrestle_module: trestle\nvariables:\nmac_os: true\n</code></pre> <p>The Jinja template:</p> <pre><code>Install via pip install {{ names.trestle_pip }} and invoke at the python REPL by import {{ names.trestle_module }}\n\n{% if variables.mac_os %}\nUsers are recommended to use homebrew to install the latest python 3 and then install python within a venv.\n{% endif %}\n</code></pre> <p>The output:</p> <pre><code>Install via pip install compliance-trestle and invoke at the python REPL by import trestle\n\nUsers are recommended to use homebrew to install the latest python 3 and then install python within a venv.\n</code></pre> <p>Users are free to use the LUT to inject more complex variables (arrays of data etc) to use at their own will using standard jinja templating.</p>"},{"location":"trestle_author_jinja/#resolved-catalog-interface-profile","title":"Resolved catalog interface (profile)","text":"<p>Passing <code>-p</code> exposes a catalog, resolved from the profile, at <code>catalog</code> and a <code>trestle.core.catalog_interface.CatalogInterface</code> at <code>catalog_interface</code>.</p> <p>This allows user to perform various task such as iterating ove reach group and printing the group title.</p> <pre><code>{% for group in catalog_interface.get_all_groups_from_catalog() +%}\n## {{ group.title }} {{ group.class }} \\({{ group.id|upper }}\\)\n</code></pre>"},{"location":"trestle_author_jinja/#ssp-interface","title":"SSP interface.","text":"<p>If <code>-ssp</code> is passed a variable within the jinja template called <code>ssp_md_writer</code> is made available which is an instance of <code>trestle.core.ssp_io.SSPMarkdownWriter</code>. <code>-ssp</code> requires that <code>-p</code> has also been set.</p> <p>This as allows users, as an example to print out a control response, as markdown</p> <pre><code>#### What is the solution and how is it implemented?\n{{ ssp_md_writer.get_control_response('my_control_id', 3)}}\n</code></pre>"},{"location":"trestle_author_jinja/#custom-jinja-tags","title":"Custom Jinja tags.","text":"<p>Trestle provides custom jinja tags for use specifically with markdown: <code>mdsection_include</code> and <code>md_clean_include</code>.</p> <p><code>md_clean_include</code> is similar to the native <code>{% include 'sub_template' %}</code> that jinja provides except for the following:</p> <ol> <li><code>md_clean_include</code> will look for yaml headers in the markdown content and exclude it from the template</li> <li><code>md_clean_include</code> can be used with an optional keyword argument <code>heading_level</code> argument</li> <li><code>{% md_clean_include 'path_to_file.md' heading_level=2 %}</code></li> <li>The heading level argument adjusts to (based on the number of hashes) the most significant heading in the document, if headings exist.</li> </ol> <p><code>mdsection_include</code> is similar to the native <code>md_clean_include</code> except that.:</p> <ol> <li> <p><code>mdsection_include</code> requires an second positional argument which is the title of a heading, from a markdown file, which you want the content from.</p> </li> <li> <p>E.g:  <code>{% mdsection_include 'test_markdown.md' '# Header we want' %}</code></p> </li> <li> <p><code>mdsection_include</code> can be used with an optional keyword argument <code>heading_level</code> argument similar to <code>md_clean_include</code></p> </li> <li> <p><code>{% mdsection_include 'test_markdown.md' '# Header we want' %}</code></p> </li> <li>The heading level argument adjusts to (based on the number of hashes) the most significant heading in the chosen section, if headings exist.</li> </ol> <p><code>md_datestamp</code> inserts a date stamp into the output. By default the date is in the format '%Y-%m-%d', e.g. '2021-12-28' and is followed by a double newline to prevent subsequent headings failing to parse correctly. E.g: <code>{% md_datestamp %}</code> results in a date in the format '2021-12-28' being inserted. <code>md_datestamp</code> can be used with the following optional keyword arguments:</p> <ol> <li><code>format</code> where a python datetime strftime format string is provided to format the output. E.g. <code>{% md_datestamp format='%B %d, %Y' %}</code> results in <code>December 28, 2021</code> being inserted.</li> <li><code>newline</code> is a boolean to control the addition of a double newline after the inserted date string. For example <code>{% md_datestamp newline=false %}</code> inserts a date in the default format, without additional newlines.</li> </ol>"},{"location":"trestle_author_jinja/#generate-controls-as-individual-markdown-pages","title":"Generate controls as individual markdown pages.","text":"<p>Trestle's Jinja functionality allows its users to generate individual markdown pages for each control from a resolved profile catalog. Such functionality can be used later on to pack individual pages into docs of various formats.</p> <p>When <code>--docs-profile</code> or <code>-dp</code> flag is provided as part of the <code>trestle author jinja</code> command, the provided Jinja template will be used to generate a markdown page for each control in each group.</p> <p>For example, suppose we would like to generate the markdown page for each control that would contain <code>Control Objective</code>, <code>Control Statement</code>, <code>Expected Evidence</code>, <code>Implementation Guidance</code> and say <code>Table of Parameters</code> used for this control. To achieve that, we can create a simple Jinja template that would be used to generate each page:</p> <pre><code># Control Page\n\n{{ control_writer.write_control_with_sections(\n   control,\n   profile,\n   group_title, \n   ['statement', 'objective', 'expected_evidence', 'implementation_guidance', 'table_of_parameters'], \n   {\n      'statement':'Control Statement',\n      'objective':'Control Objective', \n      'expected_evidence':'Expected Evidence', \n      'implementation_guidance':'Implementation Guidance', \n      'table_of_parameters':'Control Parameters'\n   }\n   ) \n\n   | safe\n}}\n</code></pre> <p>The template above, would call a control writer that would print the required sections (specified in the list) with the provided headers (specified in the dictionary).</p> <p>We can then generate individual markdown pages by executing: <code>trestle author jinja -i profile_to_docs.md.jinja -o controls -p some_profile -dp</code></p> <p>This will create a folder named <code>controls</code>, that would contain a folder per each group and a markdown file per each control in that group. Each markdown file would be formatted using the Jinja template above.</p> <p>The generated markdown files can then be assembled to the docs of the desired format by adding an indexing page.</p>"},{"location":"api_reference/trestle.cli/","title":"cli","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.cli/#trestle.cli","title":"<code>trestle.cli</code>","text":"<p>Starting point for the Trestle CLI.</p>"},{"location":"api_reference/trestle.cli/#trestle.cli.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.cli/#trestle.cli-classes","title":"Classes","text":""},{"location":"api_reference/trestle.cli/#trestle.cli.Trestle","title":"<code> Trestle            (CommandBase)         </code>","text":"<p>Manage OSCAL files in a human friendly manner.</p> Source code in <code>trestle/cli.py</code> <pre><code>class Trestle(CommandBase):\n\"\"\"Manage OSCAL files in a human friendly manner.\"\"\"\n\n    subcommands = [\n        AssembleCmd,\n        AuthorCmd,\n        CreateCmd,\n        DescribeCmd,\n        HrefCmd,\n        ImportCmd,\n        InitCmd,\n        MergeCmd,\n        PartialObjectValidate,\n        RemoveCmd,\n        ReplicateCmd,\n        SplitCmd,\n        TaskCmd,\n        ValidateCmd,\n        VersionCmd\n    ]\n\n    discovered_plugins = {\n        name: importlib.import_module(name)\n        for finder,\n        name,\n        ispkg in pkgutil.iter_modules()\n        if name.startswith('trestle_')\n    }\n\n    logger.debug(discovered_plugins)\n    # This block is uncovered as trestle cannot find plugins in it's unit tests - it is the base module.\n    for plugin, value in discovered_plugins.items():  # pragma: nocover\n        for _, module, _ in pkgutil.iter_modules([pathlib.Path(value.__path__[0], 'commands')]):\n            logger.debug(module)\n            command_module = importlib.import_module(f'{plugin}.commands.{module}')\n            clsmembers = inspect.getmembers(command_module, inspect.isclass)\n            logger.debug(clsmembers)\n            for _, cmd_cls in clsmembers:\n                # add commands (derived from CommandPlusDocs or CommandBase) to subcommands list\n                if issubclass(cmd_cls, CommandBase):\n                    # don't add CommandPlusDocs or CommandBase\n                    if cmd_cls is not CommandPlusDocs and cmd_cls is not CommandBase:\n                        subcommands.append(cmd_cls)\n                        logger.info(f'{cmd_cls} added to subcommands from plugin {plugin}')\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument('-v', '--verbose', help=const.DISPLAY_VERBOSE_OUTPUT, action='count', default=0)\n        self.add_argument(\n            '-tr', '--trestle-root', help='Path of trestle root dir', type=pathlib.Path, default=pathlib.Path.cwd()\n        )\n</code></pre>"},{"location":"api_reference/trestle.cli/#trestle.cli.Trestle.discovered_plugins","title":"<code>discovered_plugins</code>","text":""},{"location":"api_reference/trestle.cli/#trestle.cli.Trestle.subcommands","title":"<code>subcommands</code>","text":""},{"location":"api_reference/trestle.cli/#trestle.cli-functions","title":"Functions","text":""},{"location":"api_reference/trestle.cli/#trestle.cli.run","title":"<code>run()</code>","text":"<p>Run the trestle cli.</p> Source code in <code>trestle/cli.py</code> <pre><code>def run() -&gt; None:\n\"\"\"Run the trestle cli.\"\"\"\n    log.set_global_logging_levels()\n    logger.debug('Main entry point.')\n\n    exit(Trestle().run())\n</code></pre>"},{"location":"api_reference/trestle.common.common_types/","title":"common_types","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types","title":"<code>trestle.common.common_types</code>","text":"<p>Special types are defined here.</p>"},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.FixedUuidModel","title":"<code>FixedUuidModel</code>","text":""},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.OBT","title":"<code>OBT</code>","text":""},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.TG","title":"<code>TG</code>","text":""},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.TG2","title":"<code>TG2</code>","text":""},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.TopLevelOscalModel","title":"<code>TopLevelOscalModel</code>","text":""},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.TypeWithByComps","title":"<code>TypeWithByComps</code>","text":""},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.TypeWithParamId","title":"<code>TypeWithParamId</code>","text":""},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.TypeWithParts","title":"<code>TypeWithParts</code>","text":""},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.TypeWithProps","title":"<code>TypeWithProps</code>","text":""},{"location":"api_reference/trestle.common.common_types/#trestle.common.common_types.TypeWithSetParams","title":"<code>TypeWithSetParams</code>","text":""},{"location":"api_reference/trestle.common.const/","title":"const","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.const/#trestle.common.const","title":"<code>trestle.common.const</code>","text":"<p>Core constants module containing all constants.</p>"},{"location":"api_reference/trestle.common.const/#trestle.common.const-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.AFTER_HASHES_REGEX","title":"<code>AFTER_HASHES_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ALIAS_PATH_SEPARATOR","title":"<code>ALIAS_PATH_SEPARATOR: str</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ALLOWED_EXTENSIONS_IN_DIRS","title":"<code>ALLOWED_EXTENSIONS_IN_DIRS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_DESC_ELEMENT","title":"<code>ARG_DESC_ELEMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_DESC_FILE","title":"<code>ARG_DESC_FILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_DESC_ITEM","title":"<code>ARG_DESC_ITEM</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_DESC_MODE","title":"<code>ARG_DESC_MODE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_ELEMENT","title":"<code>ARG_ELEMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_ELEMENT_SHORT","title":"<code>ARG_ELEMENT_SHORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_FILE","title":"<code>ARG_FILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_FILE_SHORT","title":"<code>ARG_FILE_SHORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_ITEM","title":"<code>ARG_ITEM</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_ITEM_SHORT","title":"<code>ARG_ITEM_SHORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_MODE","title":"<code>ARG_MODE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_MODE_SHORT","title":"<code>ARG_MODE_SHORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_VALIDATE","title":"<code>ARG_VALIDATE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ARG_VALIDATE_SHORT","title":"<code>ARG_VALIDATE_SHORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.BUG_REPORT","title":"<code>BUG_REPORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.CACHE_ABS_DIR","title":"<code>CACHE_ABS_DIR</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.CLOSE_COMMENT","title":"<code>CLOSE_COMMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.COMPONENT_VALUES","title":"<code>COMPONENT_VALUES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.COMP_DEF_RULES_PARAM_VALS_TAG","title":"<code>COMP_DEF_RULES_PARAM_VALS_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.COMP_DEF_RULES_TAG","title":"<code>COMP_DEF_RULES_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.CONTROL_HEADER","title":"<code>CONTROL_HEADER</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.CONTROL_IMPLEMENTATION","title":"<code>CONTROL_IMPLEMENTATION</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.CONTROL_OBJECTIVE_HEADER","title":"<code>CONTROL_OBJECTIVE_HEADER</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.CONTROL_ORIGINATION","title":"<code>CONTROL_ORIGINATION</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.CONTROL_REGEX","title":"<code>CONTROL_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.CONTROL_STATEMENT_HEADER","title":"<code>CONTROL_STATEMENT_HEADER</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.DAY_SECONDS","title":"<code>DAY_SECONDS: int</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.DISPLAY_NAME","title":"<code>DISPLAY_NAME</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.DISPLAY_VERBOSE_OUTPUT","title":"<code>DISPLAY_VERBOSE_OUTPUT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.DRAWIO_FILE_EXT","title":"<code>DRAWIO_FILE_EXT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.EDITABLE_CONTENT","title":"<code>EDITABLE_CONTENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ELEMENT_WILDCARD","title":"<code>ELEMENT_WILDCARD</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.FIELDS_SET","title":"<code>FIELDS_SET</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.FILE_DIGIT_PREFIX_LENGTH","title":"<code>FILE_DIGIT_PREFIX_LENGTH</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.FILE_ENCODING","title":"<code>FILE_ENCODING</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.FILE_URI","title":"<code>FILE_URI</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.FILTER_BY_COMPONENTS","title":"<code>FILTER_BY_COMPONENTS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.FILTER_BY_PROFILE","title":"<code>FILTER_BY_PROFILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.FILTER_EXCLUDE_COMPONENTS","title":"<code>FILTER_EXCLUDE_COMPONENTS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.GENERATE_RESOLVED_CATALOG","title":"<code>GENERATE_RESOLVED_CATALOG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HEADER_RULE_ID","title":"<code>HEADER_RULE_ID</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_ALLOWED_SECTIONS","title":"<code>HELP_ALLOWED_SECTIONS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_COMPDEFS","title":"<code>HELP_COMPDEFS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_FO_OUTPUT","title":"<code>HELP_FO_OUTPUT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_MARKDOWN_NAME","title":"<code>HELP_MARKDOWN_NAME</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_OVERWRITE_HEADER_VALUES","title":"<code>HELP_OVERWRITE_HEADER_VALUES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_REGENERATE","title":"<code>HELP_REGENERATE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_REQUIRED_SECTIONS","title":"<code>HELP_REQUIRED_SECTIONS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_SECTIONS","title":"<code>HELP_SECTIONS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_SET_PARAMS","title":"<code>HELP_SET_PARAMS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_VERSION","title":"<code>HELP_VERSION</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HELP_YAML_PATH","title":"<code>HELP_YAML_PATH</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HOUR_SECONDS","title":"<code>HOUR_SECONDS: int</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HREF","title":"<code>HREF</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.HTTPS_URI","title":"<code>HTTPS_URI</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.IDX_SEP","title":"<code>IDX_SEP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.IMPLEMENTATION_STATUS","title":"<code>IMPLEMENTATION_STATUS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.IMPLEMENTATION_STATUS_HEADER","title":"<code>IMPLEMENTATION_STATUS_HEADER</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.IMPLEMENTATION_STATUS_REMARKS_HEADER","title":"<code>IMPLEMENTATION_STATUS_REMARKS_HEADER</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.IMPLEMENTED_REQUIREMENT","title":"<code>IMPLEMENTED_REQUIREMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.INIT_FULL_HELP","title":"<code>INIT_FULL_HELP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.INIT_FULL_LONG","title":"<code>INIT_FULL_LONG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.INIT_FULL_SHORT","title":"<code>INIT_FULL_SHORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.INIT_GOVDOCS_HELP","title":"<code>INIT_GOVDOCS_HELP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.INIT_GOVDOCS_LONG","title":"<code>INIT_GOVDOCS_LONG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.INIT_GOVDOCS_SHORT","title":"<code>INIT_GOVDOCS_SHORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.INIT_LOCAL_HELP","title":"<code>INIT_LOCAL_HELP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.INIT_LOCAL_LONG","title":"<code>INIT_LOCAL_LONG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.INIT_LOCAL_SHORT","title":"<code>INIT_LOCAL_SHORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.IOF_HELP","title":"<code>IOF_HELP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.IOF_LONG","title":"<code>IOF_LONG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.IOF_SHORT","title":"<code>IOF_SHORT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.LEV_AUTH_UUID","title":"<code>LEV_AUTH_UUID</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MARKDOWN_FILE_EXT","title":"<code>MARKDOWN_FILE_EXT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MARKDOWN_URL_REGEX","title":"<code>MARKDOWN_URL_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MATCH_ALL_EXCEPT_LETTERS_UNDERSCORE_SPACE_REGEX","title":"<code>MATCH_ALL_EXCEPT_LETTERS_UNDERSCORE_SPACE_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_DIR_A_PLAN","title":"<code>MODEL_DIR_A_PLAN</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_DIR_A_RESULT","title":"<code>MODEL_DIR_A_RESULT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_DIR_CATALOG","title":"<code>MODEL_DIR_CATALOG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_DIR_COMPDEF","title":"<code>MODEL_DIR_COMPDEF</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_DIR_LIST","title":"<code>MODEL_DIR_LIST</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_DIR_POAM","title":"<code>MODEL_DIR_POAM</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_DIR_PROFILE","title":"<code>MODEL_DIR_PROFILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_DIR_SSP","title":"<code>MODEL_DIR_SSP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_DIR_TO_MODEL_MODULE","title":"<code>MODEL_DIR_TO_MODEL_MODULE</code>","text":"<p>Map of model type to oscal module.</p>"},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_MODULE_A_PLAN","title":"<code>MODEL_MODULE_A_PLAN</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_MODULE_A_RESULT","title":"<code>MODEL_MODULE_A_RESULT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_MODULE_CATALOG","title":"<code>MODEL_MODULE_CATALOG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_MODULE_COMPDEF","title":"<code>MODEL_MODULE_COMPDEF</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_MODULE_LIST","title":"<code>MODEL_MODULE_LIST</code>","text":"<p>Map of plural form of a model type to the oscal module that contains the classes related to it.</p>"},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_MODULE_POAM","title":"<code>MODEL_MODULE_POAM</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_MODULE_PROFILE","title":"<code>MODEL_MODULE_PROFILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_MODULE_SSP","title":"<code>MODEL_MODULE_SSP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_MODULE_TO_MODEL_TYPE","title":"<code>MODEL_MODULE_TO_MODEL_TYPE</code>","text":"<p>Map of model type to model directory.</p>"},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_A_PLAN","title":"<code>MODEL_TYPE_A_PLAN</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_A_RESULT","title":"<code>MODEL_TYPE_A_RESULT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_CATALOG","title":"<code>MODEL_TYPE_CATALOG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_COMPDEF","title":"<code>MODEL_TYPE_COMPDEF</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_LIST","title":"<code>MODEL_TYPE_LIST</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_POAM","title":"<code>MODEL_TYPE_POAM</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_PROFILE","title":"<code>MODEL_TYPE_PROFILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_SSP","title":"<code>MODEL_TYPE_SSP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_TO_MODEL_DIR","title":"<code>MODEL_TYPE_TO_MODEL_DIR</code>","text":"<p>Element path separator</p>"},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODEL_TYPE_TO_MODEL_MODULE","title":"<code>MODEL_TYPE_TO_MODEL_MODULE</code>","text":"<p>Map of model module to model type.</p>"},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODULE_NAME_A_PLAN","title":"<code>MODULE_NAME_A_PLAN</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODULE_NAME_A_RESULT","title":"<code>MODULE_NAME_A_RESULT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODULE_NAME_CATALOG","title":"<code>MODULE_NAME_CATALOG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODULE_NAME_COMPDEF","title":"<code>MODULE_NAME_COMPDEF</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODULE_NAME_POAM","title":"<code>MODULE_NAME_POAM</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODULE_NAME_PROFILE","title":"<code>MODULE_NAME_PROFILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.MODULE_NAME_SSP","title":"<code>MODULE_NAME_SSP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.NAME","title":"<code>NAME</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.NAMESPACE_FEDRAMP","title":"<code>NAMESPACE_FEDRAMP</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.NAMESPACE_NIST","title":"<code>NAMESPACE_NIST</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.NCNAME_REGEX","title":"<code>NCNAME_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.NCNAME_UTF8_FIRST_CHAR_OPTIONS","title":"<code>NCNAME_UTF8_FIRST_CHAR_OPTIONS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.NCNAME_UTF8_OTHER_CHAR_OPTIONS","title":"<code>NCNAME_UTF8_OTHER_CHAR_OPTIONS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.OBJECTIVE_PART","title":"<code>OBJECTIVE_PART</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ONE","title":"<code>ONE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ONE_OR_MORE_HYPHENED","title":"<code>ONE_OR_MORE_HYPHENED</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ONE_OR_MORE_SPACED","title":"<code>ONE_OR_MORE_SPACED</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PACKAGE_OSCAL","title":"<code>PACKAGE_OSCAL</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PARAMETER_DESCRIPTION","title":"<code>PARAMETER_DESCRIPTION</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PARAMETER_ID","title":"<code>PARAMETER_ID</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PARAMETER_VALUE_ALTERNATIVES","title":"<code>PARAMETER_VALUE_ALTERNATIVES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PARAM_VALUES_TAG","title":"<code>PARAM_VALUES_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PART_REGEX","title":"<code>PART_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PROFILE","title":"<code>PROFILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PROFILE_ADD_REQUIRED_SECTION_FOR_CONTROL_TEXT","title":"<code>PROFILE_ADD_REQUIRED_SECTION_FOR_CONTROL_TEXT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PROFILE_VALUES","title":"<code>PROFILE_VALUES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.PROPERTY_REGEX","title":"<code>PROPERTY_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.REMARKS","title":"<code>REMARKS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.REPLACE_ME","title":"<code>REPLACE_ME</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.RESOLUTION_SOURCE","title":"<code>RESOLUTION_SOURCE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.RESPONSIBLE_ROLE","title":"<code>RESPONSIBLE_ROLE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.RESPONSIBLE_ROLES","title":"<code>RESPONSIBLE_ROLES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.ROOT","title":"<code>ROOT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.RULES_PARAMS_TAG","title":"<code>RULES_PARAMS_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.RULES_WARNING","title":"<code>RULES_WARNING</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.RULE_DESCRIPTION","title":"<code>RULE_DESCRIPTION</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.RULE_ID","title":"<code>RULE_ID</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SAMPLE_UUID_STR","title":"<code>SAMPLE_UUID_STR</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SECTIONS_TAG","title":"<code>SECTIONS_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SET_PARAMS_TAG","title":"<code>SET_PARAMS_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SFTP_URI","title":"<code>SFTP_URI</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SORT_ID","title":"<code>SORT_ID</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_ADD_IMPLEMENTATION_FOR_CONTROL_TEXT","title":"<code>SSP_ADD_IMPLEMENTATION_FOR_CONTROL_TEXT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_ADD_IMPLEMENTATION_FOR_ITEM_TEXT","title":"<code>SSP_ADD_IMPLEMENTATION_FOR_ITEM_TEXT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_ADD_IMPLEMENTATION_FOR_STATEMENT_TEXT","title":"<code>SSP_ADD_IMPLEMENTATION_FOR_STATEMENT_TEXT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_ADD_IMPLEMENTATION_PREFIX","title":"<code>SSP_ADD_IMPLEMENTATION_PREFIX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_ADD_THIS_SYSTEM_IMPLEMENTATION_FOR_CONTROL_TEXT","title":"<code>SSP_ADD_THIS_SYSTEM_IMPLEMENTATION_FOR_CONTROL_TEXT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_FEDRAMP_TAG","title":"<code>SSP_FEDRAMP_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_MAIN_COMP_NAME","title":"<code>SSP_MAIN_COMP_NAME</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_MD_HRULE_LINE","title":"<code>SSP_MD_HRULE_LINE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_MD_IMPLEMENTATION_QUESTION","title":"<code>SSP_MD_IMPLEMENTATION_QUESTION</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_MD_LEAVE_BLANK_TEXT","title":"<code>SSP_MD_LEAVE_BLANK_TEXT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_SYSTEM_CONTROL_IMPLEMENTATION_TEXT","title":"<code>SSP_SYSTEM_CONTROL_IMPLEMENTATION_TEXT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.SSP_VALUES","title":"<code>SSP_VALUES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATEMENT","title":"<code>STATEMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_ALL","title":"<code>STATUS_ALL</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_ALTERNATIVE","title":"<code>STATUS_ALTERNATIVE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_COMPLETION_DATE","title":"<code>STATUS_COMPLETION_DATE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_DISPOSITION","title":"<code>STATUS_DISPOSITION</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_IMPLEMENTED","title":"<code>STATUS_IMPLEMENTED</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_INHERITED","title":"<code>STATUS_INHERITED</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_NOT_APPLICABLE","title":"<code>STATUS_NOT_APPLICABLE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_OPERATIONAL","title":"<code>STATUS_OPERATIONAL</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_OTHER","title":"<code>STATUS_OTHER</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_PARTIAL","title":"<code>STATUS_PARTIAL</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_PARTIALLY_IMPLEMENTED","title":"<code>STATUS_PARTIALLY_IMPLEMENTED</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_PLANNED","title":"<code>STATUS_PLANNED</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_PLANNED_COMPLETION_DATE","title":"<code>STATUS_PLANNED_COMPLETION_DATE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_PROMPT","title":"<code>STATUS_PROMPT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_REMARKS","title":"<code>STATUS_REMARKS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_UNDER_DEVELOPMENT","title":"<code>STATUS_UNDER_DEVELOPMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.STATUS_UNDER_MAJOR_MODIFICATION","title":"<code>STATUS_UNDER_MAJOR_MODIFICATION</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TABLE_OF_PARAMS_PART","title":"<code>TABLE_OF_PARAMS_PART</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TEMPLATE_VERSION_REGEX","title":"<code>TEMPLATE_VERSION_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.THIS_SYSTEM_AS_KEY","title":"<code>THIS_SYSTEM_AS_KEY</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.THIS_SYSTEM_PROMPT","title":"<code>THIS_SYSTEM_PROMPT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TITLE","title":"<code>TITLE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRANSFORM_TYPES","title":"<code>TRANSFORM_TYPES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_ADD_PROPS_TAG","title":"<code>TRESTLE_ADD_PROPS_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_CACHE_DIR","title":"<code>TRESTLE_CACHE_DIR</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_CONFIG_DIR","title":"<code>TRESTLE_CONFIG_DIR</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_CONFIG_FILE","title":"<code>TRESTLE_CONFIG_FILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_DIST_DIR","title":"<code>TRESTLE_DIST_DIR</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_GENERIC_NS","title":"<code>TRESTLE_GENERIC_NS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_GLOBAL_TAG","title":"<code>TRESTLE_GLOBAL_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_HREF_HEADING","title":"<code>TRESTLE_HREF_HEADING</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_HREF_REGEX","title":"<code>TRESTLE_HREF_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_IMP_STATUS_TAG","title":"<code>TRESTLE_IMP_STATUS_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_INHERITED_PROPS_TAG","title":"<code>TRESTLE_INHERITED_PROPS_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_INHERITED_PROPS_TRACKER","title":"<code>TRESTLE_INHERITED_PROPS_TRACKER</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_KEEP_FILE","title":"<code>TRESTLE_KEEP_FILE</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_PROPS_TAG","title":"<code>TRESTLE_PROPS_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.TRESTLE_TAG","title":"<code>TRESTLE_TAG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.UNIX_CACHE_ROOT","title":"<code>UNIX_CACHE_ROOT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.UUID_REGEX","title":"<code>UUID_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.VALUES","title":"<code>VALUES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.VALUE_ASSIGNED_PREFIX","title":"<code>VALUE_ASSIGNED_PREFIX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.VALUE_NOT_ASSIGNED_PREFIX","title":"<code>VALUE_NOT_ASSIGNED_PREFIX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.VAL_MODE_ALL","title":"<code>VAL_MODE_ALL</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.VAL_MODE_CATALOG","title":"<code>VAL_MODE_CATALOG</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.VAL_MODE_DUPLICATES","title":"<code>VAL_MODE_DUPLICATES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.VAL_MODE_LINKS","title":"<code>VAL_MODE_LINKS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.VAL_MODE_REFS","title":"<code>VAL_MODE_REFS</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.VAL_MODE_RULES","title":"<code>VAL_MODE_RULES</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.WEBSITE_ROOT","title":"<code>WEBSITE_ROOT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.WINDOWS_DRIVE_LETTER_REGEX","title":"<code>WINDOWS_DRIVE_LETTER_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.WINDOWS_DRIVE_URI_REGEX","title":"<code>WINDOWS_DRIVE_URI_REGEX</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.WINDOWS_PLATFORM_STR","title":"<code>WINDOWS_PLATFORM_STR</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.YAML_PROFILE_VALUES_COMMENT","title":"<code>YAML_PROFILE_VALUES_COMMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.YAML_PROPS_COMMENT","title":"<code>YAML_PROPS_COMMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.YAML_RULE_PARAM_VALUES_COMPONENT_COMMENT","title":"<code>YAML_RULE_PARAM_VALUES_COMPONENT_COMMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.YAML_RULE_PARAM_VALUES_SSP_COMMENT","title":"<code>YAML_RULE_PARAM_VALUES_SSP_COMMENT</code>","text":""},{"location":"api_reference/trestle.common.const/#trestle.common.const.YAML_SSP_VALUES_COMMENT","title":"<code>YAML_SSP_VALUES_COMMENT</code>","text":""},{"location":"api_reference/trestle.common.err/","title":"err","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.err/#trestle.common.err","title":"<code>trestle.common.err</code>","text":"<p>Trestle core errors module.</p>"},{"location":"api_reference/trestle.common.err/#trestle.common.err-classes","title":"Classes","text":""},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleError","title":"<code> TrestleError            (RuntimeError)         </code>","text":"<p>General framework (non-application) related errors.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <code>str</code> <p>Human readable string describing the exception.</p> Source code in <code>trestle/common/err.py</code> <pre><code>class TrestleError(RuntimeError):\n\"\"\"\n    General framework (non-application) related errors.\n\n    Attributes:\n        msg (str): Human readable string describing the exception.\n    \"\"\"\n\n    def __init__(self, msg: str):\n\"\"\"Intialization for TresleError.\n\n        Args:\n            msg (str): The error message\n        \"\"\"\n        RuntimeError.__init__(self)\n        self.msg = msg\n\n    def __str__(self) -&gt; str:\n\"\"\"Return Trestle error message if asked for a string.\"\"\"\n        return self.msg\n</code></pre>"},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleError-methods","title":"Methods","text":""},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleError.__init__","title":"<code>__init__(self, msg)</code>  <code>special</code>","text":"<p>Intialization for TresleError.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The error message</p> required Source code in <code>trestle/common/err.py</code> <pre><code>def __init__(self, msg: str):\n\"\"\"Intialization for TresleError.\n\n    Args:\n        msg (str): The error message\n    \"\"\"\n    RuntimeError.__init__(self)\n    self.msg = msg\n</code></pre>"},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleError.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Return Trestle error message if asked for a string.</p> Source code in <code>trestle/common/err.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return Trestle error message if asked for a string.\"\"\"\n    return self.msg\n</code></pre>"},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleIncorrectArgsError","title":"<code> TrestleIncorrectArgsError            (TrestleError)         </code>","text":"<p>General error for incorrect args passed to Trestle command.</p> Source code in <code>trestle/common/err.py</code> <pre><code>class TrestleIncorrectArgsError(TrestleError):\n\"\"\"General error for incorrect args passed to Trestle command.\"\"\"\n\n    def __init__(self, msg: str):\n\"\"\"\n        Initialize TrestleIncorrectArgsError.\n\n        Args:\n            msg (str): The error message\n        \"\"\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleIncorrectArgsError-methods","title":"Methods","text":""},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleIncorrectArgsError.__init__","title":"<code>__init__(self, msg)</code>  <code>special</code>","text":"<p>Initialize TrestleIncorrectArgsError.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The error message</p> required Source code in <code>trestle/common/err.py</code> <pre><code>def __init__(self, msg: str):\n\"\"\"\n    Initialize TrestleIncorrectArgsError.\n\n    Args:\n        msg (str): The error message\n    \"\"\"\n    super().__init__(msg)\n</code></pre>"},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleNotFoundError","title":"<code> TrestleNotFoundError            (TrestleError)         </code>","text":"<p>General framework related not found error.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <code>str</code> <p>Human readable string describing the exception.</p> Source code in <code>trestle/common/err.py</code> <pre><code>class TrestleNotFoundError(TrestleError):\n\"\"\"\n    General framework related not found error.\n\n    Attributes:\n        msg (str): Human readable string describing the exception.\n    \"\"\"\n\n    def __init__(self, msg: str):\n\"\"\"\n        Intialize TresleNotFoundError.\n\n        Args:\n            msg: The error message\n        \"\"\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleNotFoundError-methods","title":"Methods","text":""},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleNotFoundError.__init__","title":"<code>__init__(self, msg)</code>  <code>special</code>","text":"<p>Intialize TresleNotFoundError.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The error message</p> required Source code in <code>trestle/common/err.py</code> <pre><code>def __init__(self, msg: str):\n\"\"\"\n    Intialize TresleNotFoundError.\n\n    Args:\n        msg: The error message\n    \"\"\"\n    super().__init__(msg)\n</code></pre>"},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleRootError","title":"<code> TrestleRootError            (TrestleError)         </code>","text":"<p>General error for trestle workspace root/setup errors.</p> Source code in <code>trestle/common/err.py</code> <pre><code>class TrestleRootError(TrestleError):\n\"\"\"General error for trestle workspace root/setup errors.\"\"\"\n\n    def __init__(self, msg: str):\n\"\"\"\n        Initialize TrestleRootError.\n\n        Args:\n            msg (str): The error message\n        \"\"\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleRootError-methods","title":"Methods","text":""},{"location":"api_reference/trestle.common.err/#trestle.common.err.TrestleRootError.__init__","title":"<code>__init__(self, msg)</code>  <code>special</code>","text":"<p>Initialize TrestleRootError.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The error message</p> required Source code in <code>trestle/common/err.py</code> <pre><code>def __init__(self, msg: str):\n\"\"\"\n    Initialize TrestleRootError.\n\n    Args:\n        msg (str): The error message\n    \"\"\"\n    super().__init__(msg)\n</code></pre>"},{"location":"api_reference/trestle.common.err/#trestle.common.err-functions","title":"Functions","text":""},{"location":"api_reference/trestle.common.err/#trestle.common.err.handle_generic_command_exception","title":"<code>handle_generic_command_exception(exception, logger, msg='Exception occured during execution')</code>","text":"<p>Print out error message based on the verbosity and return appropriate status code.</p> Source code in <code>trestle/common/err.py</code> <pre><code>def handle_generic_command_exception(\n    exception: Exception, logger: Logger, msg: str = 'Exception occured during execution'\n) -&gt; int:\n\"\"\"Print out error message based on the verbosity and return appropriate status code.\"\"\"\n    if get_current_verbosity_level(logger) == 0:\n        logger.error(msg + f': {exception}')\n    else:\n        logger.exception(msg + f': {exception}')\n\n    return _exception_to_error_code(exception)\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/","title":"file_utils","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils","title":"<code>trestle.common.file_utils</code>","text":"<p>Trestle file system utils.</p>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils-functions","title":"Functions","text":""},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.check_oscal_directories","title":"<code>check_oscal_directories(root_path)</code>","text":"<p>Identify the state of the trestle workspace.</p> <p>Traverses trestle workspace and looks for unexpected files or directories. Additional files are allowed in the Trestle root but not inside the model folders.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def check_oscal_directories(root_path: pathlib.Path) -&gt; bool:\n\"\"\"\n    Identify the state of the trestle workspace.\n\n    Traverses trestle workspace and looks for unexpected files or directories.\n    Additional files are allowed in the Trestle root but not inside the model folders.\n    \"\"\"\n    trestle_dir_walk = os.walk(root_path)\n    is_valid = True\n\n    for _, dirs, _ in trestle_dir_walk:\n        for d in dirs:\n            if d in MODEL_DIR_LIST:\n                is_valid = _verify_oscal_folder(root_path / d)\n                if not is_valid:\n                    break\n    return is_valid\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.extract_project_model_path","title":"<code>extract_project_model_path(path)</code>","text":"<p>Get the base path of the trestle model project.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def extract_project_model_path(path: pathlib.Path) -&gt; Optional[pathlib.Path]:\n\"\"\"Get the base path of the trestle model project.\"\"\"\n    if len(path.parts) &gt; 2:\n        for i in range(2, len(path.parts)):\n            current = pathlib.Path(path.parts[0]).joinpath(*path.parts[1:i + 1])\n            if _is_valid_project_model_path(current):\n                return current\n    return None\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.extract_trestle_project_root","title":"<code>extract_trestle_project_root(path)</code>","text":"<p>Get the trestle workspace root folder in the path.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def extract_trestle_project_root(path: pathlib.Path) -&gt; Optional[pathlib.Path]:\n\"\"\"Get the trestle workspace root folder in the path.\"\"\"\n    while len(path.parts) &gt; 1:  # it must not be the system root directory\n        if is_valid_project_root(path):\n            return path\n        path = path.parent\n    return None\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.get_contextual_file_type","title":"<code>get_contextual_file_type(path)</code>","text":"<p>Return the file content type for files in the given directory, if it's a trestle workspace.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def get_contextual_file_type(path: pathlib.Path) -&gt; FileContentType:\n\"\"\"Return the file content type for files in the given directory, if it's a trestle workspace.\"\"\"\n    if not _is_valid_project_model_path(path):\n        raise err.TrestleError(f'Trestle workspace not found at path {path}')\n\n    for file_or_directory in iterdir_without_hidden_files(path):\n        if file_or_directory.is_file():\n            return FileContentType.to_content_type(file_or_directory.suffix)\n\n    for file_or_directory in path.iterdir():\n        if file_or_directory.is_dir():\n            return get_contextual_file_type(file_or_directory)\n\n    raise err.TrestleError('No files found in the project.')\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.insert_text_in_file","title":"<code>insert_text_in_file(file_path, tag, text)</code>","text":"<p>Insert text lines after line containing tag.</p> <p>Return True on success, False tag not found. Text is a string with appropriate \\n line endings. If tag is none just add at end of file. This will only open file once if tag is not found.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def insert_text_in_file(file_path: pathlib.Path, tag: Optional[str], text: str) -&gt; bool:\nr\"\"\"Insert text lines after line containing tag.\n\n    Return True on success, False tag not found.\n    Text is a string with appropriate \\n line endings.\n    If tag is none just add at end of file.\n    This will only open file once if tag is not found.\n    \"\"\"\n    if not file_path.exists():\n        raise TrestleError(f'Test file {file_path} not found.')\n    if tag:\n        lines: List[str] = []\n        with file_path.open('r', encoding=const.FILE_ENCODING) as f:\n            lines = f.readlines()\n        for ii, line in enumerate(lines):\n            if line.find(tag) &gt;= 0:\n                lines.insert(ii + 1, text)\n                with file_path.open('w', encoding=const.FILE_ENCODING) as f:\n                    f.writelines(lines)\n                return True\n    else:\n        with file_path.open('a', encoding=const.FILE_ENCODING) as f:\n            f.writelines(text)\n        return True\n    return False\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.is_directory_name_allowed","title":"<code>is_directory_name_allowed(name)</code>","text":"<p>Determine whether a directory name, which is a 'non-core-OSCAL activity/directory is allowed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name which is assumed may take the form of a relative path for task/subtasks.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the name is allowed or not allowed (interferes with assumed project directories such as catalogs).</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def is_directory_name_allowed(name: str) -&gt; bool:\n\"\"\"Determine whether a directory name, which is a 'non-core-OSCAL activity/directory is allowed.\n\n    args:\n        name: the name which is assumed may take the form of a relative path for task/subtasks.\n\n    Returns:\n        Whether the name is allowed or not allowed (interferes with assumed project directories such as catalogs).\n    \"\"\"\n    # Task must not use an OSCAL directory\n    # Task must not self-interfere with a project\n    pathed_name = pathlib.Path(name)\n\n    root_path = pathed_name.parts[0]\n    if root_path in const.MODEL_TYPE_TO_MODEL_DIR.values():\n        logger.warning('Task name is the same as an OSCAL schema name.')\n        return False\n    if root_path[0] == '.':\n        logger.warning('Task name must not start with \".\"')\n        return False\n    if pathed_name.suffix != '':\n        # Does it look like a file\n        logger.warning('Task name must not look like a file path (e.g. contain a suffix')\n        return False\n    if '__global__' in pathed_name.parts:\n        logger.warning('Task name cannot contain __global__')\n        return False\n    return True\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.is_hidden","title":"<code>is_hidden(file_path)</code>","text":"<p>Determine whether a file is hidden based on the appropriate os attributes.</p> <p>This function will only work for the current file path only (e.g. not if a parent is hidden).</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>The file path for which we are testing whether the file / directory is hidden.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the file is file/directory is hidden.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def is_hidden(file_path: pathlib.Path) -&gt; bool:\n\"\"\"\n    Determine whether a file is hidden based on the appropriate os attributes.\n\n    This function will only work for the current file path only (e.g. not if a parent is hidden).\n\n    Args:\n        file_path: The file path for which we are testing whether the file / directory is hidden.\n\n    Returns:\n        Whether or not the file is file/directory is hidden.\n    \"\"\"\n    # as far as trestle is concerned all .* files are hidden even on windows, regardless of attributes\n    if file_path.stem.startswith('.'):\n        return True\n    # Handle windows\n    if is_windows():  # pragma: no cover\n        attribute = win32api.GetFileAttributes(str(file_path))\n        return attribute &amp; (win32con.FILE_ATTRIBUTE_HIDDEN | win32con.FILE_ATTRIBUTE_SYSTEM)\n    return False\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.is_local_and_visible","title":"<code>is_local_and_visible(file_path)</code>","text":"<p>Is the file or dir local (not a symlink) and not hidden.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def is_local_and_visible(file_path: pathlib.Path) -&gt; bool:\n\"\"\"Is the file or dir local (not a symlink) and not hidden.\"\"\"\n    return not (is_hidden(file_path) or is_symlink(file_path))\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.is_symlink","title":"<code>is_symlink(file_path)</code>","text":"<p>Is the file path a symlink.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def is_symlink(file_path: pathlib.Path) -&gt; bool:\n\"\"\"Is the file path a symlink.\"\"\"\n    if is_windows():\n        return file_path.suffix == '.lnk'\n    return file_path.is_symlink()\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.is_valid_project_root","title":"<code>is_valid_project_root(path)</code>","text":"<p>Check if the path is a valid trestle workspace root.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def is_valid_project_root(path: pathlib.Path) -&gt; bool:\n\"\"\"Check if the path is a valid trestle workspace root.\"\"\"\n    trestle_dir = path / const.TRESTLE_CONFIG_DIR\n    return trestle_dir.exists() and trestle_dir.is_dir()\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.is_windows","title":"<code>is_windows()</code>","text":"<p>Check if current operating system is Windows.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def is_windows() -&gt; bool:\n\"\"\"Check if current operating system is Windows.\"\"\"\n    return platform.system() == const.WINDOWS_PLATFORM_STR\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.iterdir_without_hidden_files","title":"<code>iterdir_without_hidden_files(directory_path)</code>","text":"<p>Get iterator over all paths in the given directory_path excluding hidden files.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path</code> <p>The directory to iterate through.</p> required <p>Returns:</p> Type Description <code>Iterable[pathlib.Path]</code> <p>Iterator over the files in the directory excluding hidden files.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def iterdir_without_hidden_files(directory_path: pathlib.Path) -&gt; Iterable[pathlib.Path]:\n\"\"\"\n    Get iterator over all paths in the given directory_path excluding hidden files.\n\n    Args:\n        directory_path: The directory to iterate through.\n\n    Returns:\n        Iterator over the files in the directory excluding hidden files.\n    \"\"\"\n    filtered_paths = list(filter(lambda p: not is_hidden(p) or p.is_dir(), pathlib.Path.iterdir(directory_path)))\n\n    return filtered_paths.__iter__()\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.load_file","title":"<code>load_file(file_path)</code>","text":"<p>Load JSON or YAML file content into a dict.</p> <p>This is not intended to be the default load mechanism. It should only be used if a OSCAL object type is unknown but the context a user is in.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def load_file(file_path: pathlib.Path) -&gt; Dict[str, Any]:\n\"\"\"\n    Load JSON or YAML file content into a dict.\n\n    This is not intended to be the default load mechanism. It should only be used\n    if a OSCAL object type is unknown but the context a user is in.\n    \"\"\"\n    content_type = FileContentType.to_content_type(file_path.suffix)\n    with file_path.open('r', encoding=const.FILE_ENCODING) as f:\n        if content_type == FileContentType.YAML:\n            yaml = YAML(typ='safe')\n            return yaml.load(f)\n        if content_type == FileContentType.JSON:\n            return json.load(f)\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.make_hidden_file","title":"<code>make_hidden_file(file_path)</code>","text":"<p>Make hidden file.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def make_hidden_file(file_path: pathlib.Path) -&gt; None:\n\"\"\"Make hidden file.\"\"\"\n    if not file_path.name.startswith('.') and not is_windows():\n        file_path = file_path.parent / ('.' + file_path.name)\n\n    file_path.touch()\n    if is_windows():\n        atts = win32api.GetFileAttributes(str(file_path))\n        win32api.SetFileAttributes(str(file_path), win32con.FILE_ATTRIBUTE_HIDDEN | atts)\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.prune_empty_dirs","title":"<code>prune_empty_dirs(file_path, pattern)</code>","text":"<p>Remove directories with no subdirs and with no files matching pattern.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def prune_empty_dirs(file_path: pathlib.Path, pattern: str) -&gt; None:\n\"\"\"Remove directories with no subdirs and with no files matching pattern.\"\"\"\n    deleted: Set[str] = set()\n    # this traverses from leaf nodes upward so only needs one traversal\n    for current_dir, subdirs, _ in os.walk(str(file_path), topdown=False):\n        true_dirs = [subdir for subdir in subdirs if os.path.join(current_dir, subdir) not in deleted]\n        if not true_dirs and not any(glob.glob(f'{current_dir}/{pattern}')):\n            shutil.rmtree(current_dir)\n            deleted.add(current_dir)\n</code></pre>"},{"location":"api_reference/trestle.common.file_utils/#trestle.common.file_utils.relative_resolve","title":"<code>relative_resolve(candidate, cwd)</code>","text":"<p>Resolve a candidate file path relative to a provided cwd.</p> <p>This is to circumvent bad behaviour for resolve on windows platforms where the path must exist.</p> <p>If a relative dir is passed it presumes the directory is relative to the PROVIDED cwd. If relative expansions exist (e.g. ../) the final result must still be within the cwd.</p> <p>If an absolute path is provided it tests whether the path is within the cwd or not.</p> Source code in <code>trestle/common/file_utils.py</code> <pre><code>def relative_resolve(candidate: pathlib.Path, cwd: pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Resolve a candidate file path relative to a provided cwd.\n\n    This is to circumvent bad behaviour for resolve on windows platforms where the path must exist.\n\n    If a relative dir is passed it presumes the directory is relative to the PROVIDED cwd.\n    If relative expansions exist (e.g. ../) the final result must still be within the cwd.\n\n    If an absolute path is provided it tests whether the path is within the cwd or not.\n\n    \"\"\"\n    # Expand user first if applicable.\n    candidate = candidate.expanduser()\n\n    if not cwd.is_absolute():\n        raise TrestleError('Error handling current working directory. CWD is expected to be absolute.')\n\n    if not candidate.is_absolute():\n        new = pathlib.Path(cwd / candidate).resolve()\n    else:\n        new = candidate.resolve()\n    try:\n        new.relative_to(cwd)\n    except ValueError:\n        raise TrestleError(f'Provided dir {candidate} is not relative to {cwd}')\n    return new\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/","title":"list_utils","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils","title":"<code>trestle.common.list_utils</code>","text":"<p>Trestle List Utils.</p>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils-functions","title":"Functions","text":""},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.as_dict","title":"<code>as_dict(dict_or_none)</code>","text":"<p>Convert dict or None object to itself or an empty dict if none.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def as_dict(dict_or_none: Optional[Dict[TG, TG2]]) -&gt; Dict[TG, TG2]:\n\"\"\"Convert dict or None object to itself or an empty dict if none.\"\"\"\n    return dict_or_none if dict_or_none else {}\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.as_filtered_list","title":"<code>as_filtered_list(list_or_none, filter_condition)</code>","text":"<p>Convert to list and filter based on the condition.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def as_filtered_list(list_or_none: Optional[List[TG]], filter_condition: Callable[[TG], bool]) -&gt; List[TG]:\n\"\"\"Convert to list and filter based on the condition.\"\"\"\n    result_list = as_list(list_or_none)\n    result_list = list(filter(filter_condition, result_list))\n    return result_list\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.as_list","title":"<code>as_list(list_or_none)</code>","text":"<p>Convert list or None object to itself or an empty list if none.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def as_list(list_or_none: Optional[List[TG]]) -&gt; List[TG]:\n\"\"\"Convert list or None object to itself or an empty list if none.\"\"\"\n    return list_or_none if list_or_none else []\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.comma_colon_sep_to_dict","title":"<code>comma_colon_sep_to_dict(string_or_none)</code>","text":"<p>Convert optional comma and colon-sep list to dict.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def comma_colon_sep_to_dict(string_or_none: Optional[str]) -&gt; Dict[str, str]:\n\"\"\"Convert optional comma and colon-sep list to dict.\"\"\"\n    entries = comma_sep_to_list(string_or_none)\n    dic = {}\n    for entry in entries:\n        # if more than one colon include any colons in the value after the first one\n        token = entry.split(':', 1)\n        if len(token) == 1:\n            dic[token[0].strip()] = token[0].strip()\n        else:\n            dic[token[0].strip()] = token[1].strip()\n    return dic\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.comma_sep_to_list","title":"<code>comma_sep_to_list(string_or_none)</code>","text":"<p>Convert optional comma-sep string to list of strings and strip.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def comma_sep_to_list(string_or_none: Optional[str]) -&gt; List[str]:\n\"\"\"Convert optional comma-sep string to list of strings and strip.\"\"\"\n    string_or_none = string_or_none.strip() if string_or_none else None\n    return list(map(str.strip, string_or_none.split(','))) if string_or_none else []\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.deep_append","title":"<code>deep_append(dic, path, value)</code>","text":"<p>Append to list in dict.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def deep_append(dic: Dict[str, Any], path: List[str], value: Any) -&gt; None:\n\"\"\"Append to list in dict.\"\"\"\n    if not path:\n        raise TrestleError('Error appending value in deep append with empty path.')\n    for node in path[:-1]:\n        dic[node] = dic.get(node, {})\n        dic = dic[node]\n    if path[-1] not in dic:\n        dic[path[-1]] = []\n    dic[path[-1]].append(value)\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.deep_get","title":"<code>deep_get(dic, path, default=None)</code>","text":"<p>Get value from deep in dictionary.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def deep_get(dic: Dict[str, Any], path: List[str], default: Any = None) -&gt; Any:\n\"\"\"Get value from deep in dictionary.\"\"\"\n    if not path:\n        raise TrestleError('Error getting value in deep get with empty path.')\n    for node in path[:-1]:\n        if node not in dic:\n            return default\n        dic = dic[node]\n    return dic.get(path[-1], default)\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.deep_set","title":"<code>deep_set(dic, path, value, pop_if_none=True)</code>","text":"<p>Set value deep in dictionary.</p> <p>pop_if_none will cause the key to be removed if value is None</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def deep_set(dic: Dict[str, Any], path: List[str], value: Any, pop_if_none: bool = True) -&gt; None:\n\"\"\"\n    Set value deep in dictionary.\n\n    pop_if_none will cause the key to be removed if value is None\n    \"\"\"\n    if not path:\n        raise TrestleError('Error setting value in deep set with empty path.')\n    for node in path[:-1]:\n        dic[node] = dic.get(node, {})\n        dic = dic[node]\n    if value or not pop_if_none:\n        dic[path[-1]] = value\n    else:\n        dic.pop(path[-1], None)\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.deep_update","title":"<code>deep_update(dic, path, dic_value)</code>","text":"<p>Update the dict based on path.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def deep_update(dic: Dict[str, Any], path: List[str], dic_value: Dict[str, Any]) -&gt; None:\n\"\"\"Update the dict based on path.\"\"\"\n    if not path:\n        raise TrestleError('Error updating value in deep update with empty path.')\n    for node in path:\n        dic[node] = dic.get(node, {})\n        dic = dic[node]\n    dic.update(dic_value)\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.delete_item_from_list","title":"<code>delete_item_from_list(item_list, value, key)</code>","text":"<p>Remove the first matching item if it is present in a list based on the callable key matching the query value.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def delete_item_from_list(item_list: List[TG], value: TG2, key: Callable[[TG], TG2]) -&gt; List[TG]:\n\"\"\"Remove the first matching item if it is present in a list based on the callable key matching the query value.\"\"\"\n    keys = [key(item) for item in item_list]\n    if value in keys:\n        index = keys.index(value)\n        del item_list[index]\n    return item_list\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.delete_list_from_list","title":"<code>delete_list_from_list(item_list, indices)</code>","text":"<p>Delete a list of items from a list based on indices.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def delete_list_from_list(item_list: List[TG], indices: List[int]) -&gt; None:\n\"\"\"Delete a list of items from a list based on indices.\"\"\"\n    for index in sorted(indices, reverse=True):\n        del item_list[index]\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.get_default","title":"<code>get_default(item, default)</code>","text":"<p>Return the default value for the item if it is not set.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def get_default(item: TG, default: TG) -&gt; TG:\n\"\"\"Return the default value for the item if it is not set.\"\"\"\n    return item if item else default\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.get_item_from_list","title":"<code>get_item_from_list(item_list, value, key, remove=False)</code>","text":"<p>Get first item from list if present based on key matching value with option to remove it from the list.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def get_item_from_list(item_list: Optional[List[TG]],\n                       value: TG2,\n                       key: Callable[[TG], TG2],\n                       remove: bool = False) -&gt; Optional[TG]:\n\"\"\"Get first item from list if present based on key matching value with option to remove it from the list.\"\"\"\n    if not item_list:\n        return None\n    keys = [key(item) for item in item_list]\n    item = None\n    if value in keys:\n        index = keys.index(value)\n        item = item_list[index]\n        if remove:\n            del item_list[index]\n    return item\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.is_ordered_sublist","title":"<code>is_ordered_sublist(needle, haystack)</code>","text":"<p>Determine if needle is exactly contained in haystack.</p> <p>The needle list comprises an ordered list of strings. The haystack list comprises an ordered list of strings that is to be searched. If the strings in the needle appear in the haystack in that exact order then return true, else false.</p> <p>Examples:</p> <p>needle=['a','b','c'], haystack=['x','y','a','b','c','z'], result = True needle=['a','b','c'], haystack=['x','y','a','b','z','c'], result = False</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def is_ordered_sublist(needle: List[str], haystack: List[str]) -&gt; bool:\n\"\"\"Determine if needle is exactly contained in haystack.\n\n    The needle list comprises an ordered list of strings.\n    The haystack list comprises an ordered list of strings that is to be searched.\n    If the strings in the needle appear in the haystack in that exact order then\n    return true, else false.\n\n    Examples:\n    needle=['a','b','c'], haystack=['x','y','a','b','c','z'], result = True\n    needle=['a','b','c'], haystack=['x','y','a','b','z','c'], result = False\n    \"\"\"\n    return ' '.join(needle) in ' '.join(haystack)\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.join_key_to_list_dicts","title":"<code>join_key_to_list_dicts(dict1, dict2)</code>","text":"<p>Join two dicts of str to List.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def join_key_to_list_dicts(dict1: Dict, dict2: Dict) -&gt; Dict:\n\"\"\"Join two dicts of str to List.\"\"\"\n    # merge like keys\n    dict3 = {key: dict1[key] + dict2.get(key, []) for key in dict1}\n    # merge unlike keys\n    dict3.update({key: dict2[key] for key in dict2 if key not in dict3})\n    return dict3\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.merge_dicts","title":"<code>merge_dicts(dest, src)</code>","text":"<p>Merge the two dicts with priority to src.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def merge_dicts(dest: Optional[Dict[str, str]], src: Optional[Dict[str, str]]) -&gt; Dict[str, str]:\n\"\"\"Merge the two dicts with priority to src.\"\"\"\n    return {**as_dict(dest), **as_dict(src)}\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.none_if_empty","title":"<code>none_if_empty(list_)</code>","text":"<p>Convert to None if empty list.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def none_if_empty(list_: List[TG]) -&gt; Optional[List[TG]]:\n\"\"\"Convert to None if empty list.\"\"\"\n    return list_ if list_ else None\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.pop_item_from_list","title":"<code>pop_item_from_list(item_list, value, key)</code>","text":"<p>Pop first matching item from a list if it is present based on the key matching the value.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def pop_item_from_list(item_list: Optional[List[TG]], value: TG2, key: Callable[[TG], TG2]) -&gt; Optional[TG]:\n\"\"\"Pop first matching item from a list if it is present based on the key matching the value.\"\"\"\n    return get_item_from_list(item_list, value, key, True)\n</code></pre>"},{"location":"api_reference/trestle.common.list_utils/#trestle.common.list_utils.set_or_pop","title":"<code>set_or_pop(dic, key, value)</code>","text":"<p>Set if value is non-empty list or not None otherwise remove.</p> Source code in <code>trestle/common/list_utils.py</code> <pre><code>def set_or_pop(dic: Dict[str, Any], key: str, value: Any) -&gt; None:\n\"\"\"Set if value is non-empty list or not None otherwise remove.\"\"\"\n    if value:\n        dic[key] = value\n    else:\n        dic.pop(key, None)\n</code></pre>"},{"location":"api_reference/trestle.common.load_validate/","title":"load_validate","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.load_validate/#trestle.common.load_validate","title":"<code>trestle.common.load_validate</code>","text":"<p>Function to load and validate files while avoiding circular imports.</p>"},{"location":"api_reference/trestle.common.load_validate/#trestle.common.load_validate.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.common.load_validate/#trestle.common.load_validate-functions","title":"Functions","text":""},{"location":"api_reference/trestle.common.load_validate/#trestle.common.load_validate.load_validate_model_name","title":"<code>load_validate_model_name(trestle_root, model_name, model_class, file_content_type=None)</code>","text":"<p>Load a model by its name and type and validate it.</p> Source code in <code>trestle/common/load_validate.py</code> <pre><code>def load_validate_model_name(\n    trestle_root: Path,\n    model_name: str,\n    model_class: TG,\n    file_content_type: Optional[FileContentType] = None\n) -&gt; Tuple[TG, Path]:\n\"\"\"Load a model by its name and type and validate it.\"\"\"\n    model_path = ModelUtils.get_model_path_for_name_and_class(trestle_root, model_name, model_class, file_content_type)\n    model = load_validate_model_path(trestle_root, model_path)\n    return model, model_path\n</code></pre>"},{"location":"api_reference/trestle.common.load_validate/#trestle.common.load_validate.load_validate_model_path","title":"<code>load_validate_model_path(trestle_root, model_path)</code>","text":"<p>Load a model by its path and validate it.</p> Source code in <code>trestle/common/load_validate.py</code> <pre><code>def load_validate_model_path(trestle_root: Path, model_path: Path) -&gt; TopLevelOscalModel:\n\"\"\"Load a model by its path and validate it.\"\"\"\n    _, _, model = ModelUtils.load_distributed(model_path, trestle_root)\n    args = argparse.Namespace(mode=const.VAL_MODE_ALL, quiet=True)\n    validator: Validator = validator_factory.get(args)\n    if not validator.model_is_valid(model, True, trestle_root):\n        logger.warning(f'Model loaded at {model_path} fails validation, but is being loaded anyway.')\n    return model\n</code></pre>"},{"location":"api_reference/trestle.common.log/","title":"log","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.log/#trestle.common.log","title":"<code>trestle.common.log</code>","text":"<p>Common logging utilities.</p>"},{"location":"api_reference/trestle.common.log/#trestle.common.log-classes","title":"Classes","text":""},{"location":"api_reference/trestle.common.log/#trestle.common.log.SpecificLevelFilter","title":"<code> SpecificLevelFilter            (Filter)         </code>","text":"<p>Filter for the same level as provided by setLevel for a log handler.</p> <p>Python by default logs all levels above to a given destination. This makes it easy to split levels where you might log all levels to file and only errors to std.err, however, does not allow logging a specific level elsewhere.</p> Source code in <code>trestle/common/log.py</code> <pre><code>class SpecificLevelFilter(logging.Filter):\n\"\"\"\n    Filter for the same level as provided by setLevel for a log handler.\n\n    Python by default logs all levels above to a given destination. This makes it easy to split levels where you might\n    log all levels to file and only errors to std.err, however, does not allow logging a specific level elsewhere.\n    \"\"\"\n\n    def __init__(self, level: int) -&gt; None:\n\"\"\"Initialize providing maximum level to be pushed through the filter.\"\"\"\n        self._level = level\n\n    def filter(self, log_record: logging.LogRecord) -&gt; bool:  # noqa: A003\n\"\"\"Filter log messages.\"\"\"\n        return log_record.levelno == self._level\n</code></pre>"},{"location":"api_reference/trestle.common.log/#trestle.common.log.SpecificLevelFilter-methods","title":"Methods","text":""},{"location":"api_reference/trestle.common.log/#trestle.common.log.SpecificLevelFilter.__init__","title":"<code>__init__(self, level)</code>  <code>special</code>","text":"<p>Initialize providing maximum level to be pushed through the filter.</p> Source code in <code>trestle/common/log.py</code> <pre><code>def __init__(self, level: int) -&gt; None:\n\"\"\"Initialize providing maximum level to be pushed through the filter.\"\"\"\n    self._level = level\n</code></pre>"},{"location":"api_reference/trestle.common.log/#trestle.common.log.SpecificLevelFilter.filter","title":"<code>filter(self, log_record)</code>","text":"<p>Filter log messages.</p> Source code in <code>trestle/common/log.py</code> <pre><code>def filter(self, log_record: logging.LogRecord) -&gt; bool:  # noqa: A003\n\"\"\"Filter log messages.\"\"\"\n    return log_record.levelno == self._level\n</code></pre>"},{"location":"api_reference/trestle.common.log/#trestle.common.log.Trace","title":"<code> Trace        </code>","text":"<p>Class allowing low priority trace message when verbose &gt; 1 and log level below DEBUG.</p> Source code in <code>trestle/common/log.py</code> <pre><code>class Trace():\n\"\"\"Class allowing low priority trace message when verbose &gt; 1 and log level below DEBUG.\"\"\"\n\n    def __init__(self, logger: logging.Logger) -&gt; None:\n\"\"\"Store the main logger with its module name.\"\"\"\n        self._logger = logger\n\n    def log(self, msg: str) -&gt; None:\n\"\"\"Output the trace msg if log level is below DEBUG.\"\"\"\n        level = self._logger.getEffectiveLevel()\n        if level &lt; logging.DEBUG:\n            self._logger.debug(msg)\n</code></pre>"},{"location":"api_reference/trestle.common.log/#trestle.common.log.Trace-methods","title":"Methods","text":""},{"location":"api_reference/trestle.common.log/#trestle.common.log.Trace.__init__","title":"<code>__init__(self, logger)</code>  <code>special</code>","text":"<p>Store the main logger with its module name.</p> Source code in <code>trestle/common/log.py</code> <pre><code>def __init__(self, logger: logging.Logger) -&gt; None:\n\"\"\"Store the main logger with its module name.\"\"\"\n    self._logger = logger\n</code></pre>"},{"location":"api_reference/trestle.common.log/#trestle.common.log.Trace.log","title":"<code>log(self, msg)</code>","text":"<p>Output the trace msg if log level is below DEBUG.</p> Source code in <code>trestle/common/log.py</code> <pre><code>def log(self, msg: str) -&gt; None:\n\"\"\"Output the trace msg if log level is below DEBUG.\"\"\"\n    level = self._logger.getEffectiveLevel()\n    if level &lt; logging.DEBUG:\n        self._logger.debug(msg)\n</code></pre>"},{"location":"api_reference/trestle.common.log/#trestle.common.log-functions","title":"Functions","text":""},{"location":"api_reference/trestle.common.log/#trestle.common.log.get_current_verbosity_level","title":"<code>get_current_verbosity_level(logger)</code>","text":"<p>Get the current verbosity level based on logging level.</p> Source code in <code>trestle/common/log.py</code> <pre><code>def get_current_verbosity_level(logger: logging.Logger) -&gt; int:\n\"\"\"Get the current verbosity level based on logging level.\"\"\"\n    level = logger.getEffectiveLevel()\n    if level &lt; logging.DEBUG:\n        return 2\n    elif level == logging.DEBUG:\n        return 1\n    return 0\n</code></pre>"},{"location":"api_reference/trestle.common.log/#trestle.common.log.set_global_logging_levels","title":"<code>set_global_logging_levels(level=20)</code>","text":"<p>Initialise logging.</p> <p>Should only be invoked by the CLI classes or similar.</p> Source code in <code>trestle/common/log.py</code> <pre><code>def set_global_logging_levels(level: int = logging.INFO) -&gt; None:\n\"\"\"Initialise logging.\n\n    Should only be invoked by the CLI classes or similar.\n    \"\"\"\n    # This line stops default root loggers setup for a python context from logging extra messages.\n    # DO NOT USE THIS COMMAND directly from an SDK. Handle logs levels based on your own application\n    _logger.propagate = False\n    # Remove handlers\n    _logger.handlers.clear()\n    # set global level\n    _logger.setLevel(level)\n    # Create standard out\n    console_out_handler = logging.StreamHandler(sys.stdout)\n    console_out_handler.setLevel(logging.INFO)\n    console_out_handler.addFilter(SpecificLevelFilter(logging.INFO))\n\n    console_debug_handler = logging.StreamHandler(sys.stdout)\n    console_debug_handler.setLevel(logging.DEBUG)\n    console_debug_handler.addFilter(SpecificLevelFilter(logging.DEBUG))\n\n    console_error_handler = logging.StreamHandler(sys.stderr)\n    console_error_handler.setLevel(logging.WARNING)\n    # create formatters\n    error_formatter = logging.Formatter('%(name)s:%(lineno)d %(levelname)s: %(message)s')\n    debug_formatter = logging.Formatter('%(name)s:%(lineno)d %(levelname)s: %(message)s')\n    console_debug_handler.setFormatter(debug_formatter)\n    console_error_handler.setFormatter(error_formatter)\n    # add ch to logger\n    _logger.addHandler(console_out_handler)\n    _logger.addHandler(console_error_handler)\n    _logger.addHandler(console_debug_handler)\n</code></pre>"},{"location":"api_reference/trestle.common.log/#trestle.common.log.set_log_level_from_args","title":"<code>set_log_level_from_args(args)</code>","text":"<p>Vanity function to automatically set log levels based on verbosity flags.</p> Source code in <code>trestle/common/log.py</code> <pre><code>def set_log_level_from_args(args: argparse.Namespace) -&gt; None:\n\"\"\"Vanity function to automatically set log levels based on verbosity flags.\"\"\"\n    if args.verbose &gt; 1:\n        # these msgs only output by trace calls\n        set_global_logging_levels(_get_trace_level())\n    elif args.verbose == 1:\n        set_global_logging_levels(logging.DEBUG)\n    else:\n        set_global_logging_levels(logging.INFO)\n        sys.excepthook = _exception_handler\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/","title":"model_utils","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils","title":"<code>trestle.common.model_utils</code>","text":"<p>Common utilities for the OSCAL models and directories.</p>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils-classes","title":"Classes","text":""},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils","title":"<code> ModelUtils        </code>","text":"<p>Utilities for the OSCAL models input and output.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>class ModelUtils:\n\"\"\"Utilities for the OSCAL models input and output.\"\"\"\n\n    @staticmethod\n    def load_distributed(\n        abs_path: Path,\n        abs_trestle_root: Path,\n        collection_type: Optional[Type[Any]] = None\n    ) -&gt; Tuple[Type[OscalBaseModel], str, Union[OscalBaseModel, List[OscalBaseModel], Dict[str, OscalBaseModel]]]:\n\"\"\"\n        Given path to a model, load the model.\n\n        If the model is decomposed/split/distributed,the decomposed models are loaded recursively.\n\n        Args:\n            abs_path: The path to the file/directory to be loaded.\n            abs_trestle_root: The trestle workspace root directory.\n            collection_type: The type of collection model, if it is a collection model.\n                typing.List is the only collection type handled or expected.\n                Defaults to None.\n\n        Returns:\n            Return a tuple of Model Type (e.g. class 'trestle.oscal.catalog.Catalog'),\n            Model Alias (e.g. 'catalog.metadata') and Instance of the Model.\n            If the model is decomposed/split/distributed, the instance of the model contains\n            the decomposed models loaded recursively.\n\n        Note:\n            This does not validate the model.  You must either validate the model separately or use the load_validate\n            utilities.\n        \"\"\"\n        # if trying to load file that does not exist, load path instead\n        if not abs_path.exists():\n            abs_path = abs_path.with_name(abs_path.stem)\n\n        if not abs_path.exists():\n            raise TrestleNotFoundError(f'File {abs_path} not found for load.')\n\n        if collection_type:\n            # If the path contains a list type model\n            if collection_type is list:\n                return ModelUtils._load_list(abs_path, abs_trestle_root)\n            # the only other collection type in OSCAL is dict, and it only applies to include_all,\n            # which is too granular ever to be loaded by this routine\n            else:\n                raise TrestleError(f'Collection type {collection_type} not recognized for distributed load.')\n\n        # Get current model\n        primary_model_type, primary_model_alias = ModelUtils.get_stripped_model_type(abs_path, abs_trestle_root)\n        primary_model_instance: Optional[OscalBaseModel] = None\n\n        # is this an attempt to load an actual json or yaml file?\n        content_type = FileContentType.path_to_content_type(abs_path)\n        # if file is sought but it doesn't exist, ignore and load as decomposed model\n        if FileContentType.is_readable_file(content_type) and abs_path.exists():\n            primary_model_instance = primary_model_type.oscal_read(abs_path)\n        # Is model decomposed?\n        decomposed_dir = abs_path.with_name(abs_path.stem)\n\n        if decomposed_dir.exists():\n            aliases_not_to_be_stripped = []\n            instances_to_be_merged: List[OscalBaseModel] = []\n\n            for local_path in sorted(trestle.common.file_utils.iterdir_without_hidden_files(decomposed_dir)):\n                if local_path.is_file():\n                    model_type, model_alias, model_instance = ModelUtils.load_distributed(local_path, abs_trestle_root)\n                    aliases_not_to_be_stripped.append(model_alias.split('.')[-1])\n                    instances_to_be_merged.append(model_instance)\n\n                elif local_path.is_dir():\n                    model_type, model_alias = ModelUtils.get_stripped_model_type(local_path, abs_trestle_root)\n                    # Only load the directory if it is a collection model. Otherwise do nothing - it gets loaded when\n                    # iterating over the model file\n\n                    # If a model is just a container for a list e.g.\n                    # class Foo(OscalBaseModel):  noqa: E800\n                    #      __root__: List[Bar]    noqa: E800\n                    # You need to test whether first a root key exists\n                    # then whether the outer_type of root is a collection.\n                    # Alternative is to do a try except to avoid the error for an unknown key.\n\n                    if model_type.is_collection_container():\n                        # This directory is a decomposed List or Dict\n                        collection_type = model_type.get_collection_type()\n                        model_type, model_alias, model_instance = ModelUtils.load_distributed(local_path,\n                                                                                              abs_trestle_root,\n                                                                                              collection_type)\n                        aliases_not_to_be_stripped.append(model_alias.split('.')[-1])\n                        instances_to_be_merged.append(model_instance)\n            primary_model_dict = {}\n            if primary_model_instance is not None:\n                primary_model_dict = primary_model_instance.__dict__\n\n            merged_model_type, merged_model_alias = ModelUtils.get_stripped_model_type(abs_path,\n                                                                                       abs_trestle_root,\n                                                                                       aliases_not_to_be_stripped)\n\n            # The following use of top_level is to allow loading of a top level model by name only, e.g. MyCatalog\n            # There may be a better overall way to approach this.\n            top_level = len(merged_model_alias.split('.')) == 1\n\n            for i in range(len(aliases_not_to_be_stripped)):\n                alias = aliases_not_to_be_stripped[i]\n                instance = instances_to_be_merged[i]\n                if hasattr(instance, '__dict__') and '__root__' in instance.__dict__ and isinstance(instance,\n                                                                                                    OscalBaseModel):\n                    instance = instance.__dict__['__root__']\n                if top_level and not primary_model_dict:\n                    primary_model_dict = instance.__dict__\n                else:\n                    primary_model_dict[alias] = instance\n\n            merged_model_instance = merged_model_type(**primary_model_dict)  # type: ignore\n            return merged_model_type, merged_model_alias, merged_model_instance\n        return primary_model_type, primary_model_alias, primary_model_instance\n\n    @staticmethod\n    def load_model_for_class(\n        trestle_root: pathlib.Path,\n        model_name: str,\n        model_class: TG,\n        file_content_type: Optional[FileContentType] = None\n    ) -&gt; Tuple[TG, pathlib.Path]:\n\"\"\"Load a model by name and model class and infer file content type if not specified.\n\n        If you need to load an existing model but its content type may not be known, use this method.\n        But the file content type should be specified if it is somehow known.\n\n        Note:  This does not validate the model.  If you want to validate the model use the load_validate utilities.\n        \"\"\"\n        root_model_path = ModelUtils._root_path_for_top_level_model(trestle_root, model_name, model_class)\n        if file_content_type is None:\n            file_content_type = FileContentType.path_to_content_type(root_model_path)\n        if not FileContentType.is_readable_file(file_content_type):\n            raise TrestleError(f'Unable to load model {model_name} without specifying json or yaml.')\n        full_model_path = root_model_path.with_suffix(FileContentType.to_file_extension(file_content_type))\n        _, _, model = ModelUtils.load_distributed(full_model_path, trestle_root)\n        return model, full_model_path\n\n    @staticmethod\n    def load_model_for_type(trestle_root: pathlib.Path, model_type: str, model_name: str) -&gt; Tuple[TG, pathlib.Path]:\n\"\"\"Load model for the given type and name.\"\"\"\n        dir_name = ModelUtils.model_type_to_model_dir(model_type)\n        model_path = trestle_root / dir_name / model_name\n\n        if not model_path.exists():\n            raise TrestleError(f'No model is found at path: {model_path}.')\n\n        _, _, oscal_object = ModelUtils.load_distributed(model_path, trestle_root)\n\n        return oscal_object, model_path\n\n    @staticmethod\n    def save_top_level_model(\n        model: TopLevelOscalModel, trestle_root: pathlib.Path, model_name: str, file_content_type: FileContentType\n    ) -&gt; None:\n\"\"\"Save a model by name and infer model type by inspection.\n\n        You don't need to specify the model type (catalog, profile, etc.) but you must specify the file content type.\n        If the model directory does not exist, it is created.\n        \"\"\"\n        root_model_path = ModelUtils._root_path_for_top_level_model(trestle_root, model_name, model)\n        full_model_path = root_model_path.with_suffix(FileContentType.to_file_extension(file_content_type))\n        if not full_model_path.parent.exists():\n            full_model_path.parent.mkdir(parents=True, exist_ok=True)\n        model.oscal_write(full_model_path)\n\n    @staticmethod\n    def get_relative_model_type(relative_path: pathlib.Path) -&gt; Tuple[Type[OscalBaseModel], str]:\n\"\"\"\n        Given the relative path of a file with respect to 'trestle_root' return the oscal model type.\n\n        Args:\n            relative_path: Relative path of the model with respect to the root directory of the trestle workspace.\n        Returns:\n            Type of Oscal Model for the provided model\n            Alias of that oscal model.\n        \"\"\"\n        if len(relative_path.parts) &lt; 2:\n            raise TrestleError(\n                'Insufficient path length to be a valid relative path w.r.t trestle workspace root directory.'\n            )\n        model_dir = relative_path.parts[0]\n        model_relative_path = pathlib.Path(*relative_path.parts[2:])  # catalogs, profiles, etc\n\n        if model_dir in const.MODEL_DIR_LIST:\n            module_name = const.MODEL_DIR_TO_MODEL_MODULE[model_dir]\n        else:\n            raise TrestleError(f'No valid trestle model type directory (e.g. catalogs) found for {model_dir}.')\n\n        model_type, model_alias = ModelUtils.get_root_model(module_name)\n        full_alias = model_alias\n\n        for index, part in enumerate(model_relative_path.parts):\n            alias = ModelUtils._extract_alias(part)\n            if index &gt; 0 or model_alias != alias:\n                model_alias = alias\n                full_alias = f'{full_alias}.{model_alias}'\n                if utils.is_collection_field_type(model_type):\n                    model_type = utils.get_inner_type(model_type)\n                else:\n                    model_type = model_type.alias_to_field_map()[alias].outer_type_\n\n        return model_type, full_alias\n\n    @staticmethod\n    def get_stripped_model_type(\n        absolute_path: pathlib.Path,\n        absolute_trestle_root: pathlib.Path,\n        aliases_not_to_be_stripped: List[str] = None\n    ) -&gt; Tuple[Type[OscalBaseModel], str]:\n\"\"\"\n        Get the stripped contextual model class and alias based on the contextual path.\n\n        This function relies on the directory structure of the trestle model being edited to determine, based on the\n        existing files and folder, which fields should be stripped from the model type represented by the\n        path passed in as a parameter.\n        \"\"\"\n        if aliases_not_to_be_stripped is None:\n            aliases_not_to_be_stripped = []\n        singular_model_type, model_alias = ModelUtils.get_relative_model_type(\n            absolute_path.relative_to(absolute_trestle_root))\n        logger.debug(f'singular model type {singular_model_type} model alias {model_alias}')\n\n        # Stripped models do not apply to collection types such as List[] and Dict{}\n        # if model type is a list or dict, generate a new wrapping model for it\n        if utils.is_collection_field_type(singular_model_type):\n            malias = model_alias.split('.')[-1]\n            class_name = alias_to_classname(malias, AliasMode.JSON)\n            logger.debug(f'collection field type class name {class_name} and alias {malias}')\n            model_type = create_model(class_name, __base__=OscalBaseModel, __root__=(singular_model_type, ...))\n            logger.debug(f'model_type created: {model_type}')\n            model_type = cast(Type[OscalBaseModel], model_type)\n            return model_type, model_alias\n\n        malias = model_alias.split('.')[-1]\n        logger.debug(f'not collection field type, malias: {malias}')\n        if absolute_path.is_dir() and malias != ModelUtils._extract_alias(absolute_path.name):\n            split_subdir = absolute_path / malias\n        else:\n            split_subdir = absolute_path.parent / absolute_path.with_suffix('').name\n\n        aliases_to_be_stripped = set()\n        if split_subdir.exists():\n            for f in iterdir_without_hidden_files(split_subdir):\n                alias = ModelUtils._extract_alias(f.name)\n                if alias not in aliases_not_to_be_stripped:\n                    aliases_to_be_stripped.add(alias)\n\n        logger.debug(f'aliases to be stripped: {aliases_to_be_stripped}')\n        if len(aliases_to_be_stripped) &gt; 0:\n            model_type = singular_model_type.create_stripped_model_type(\n                stripped_fields_aliases=list(aliases_to_be_stripped)\n            )\n            logger.debug(f'model_type: {model_type}')\n            return model_type, model_alias\n        return singular_model_type, model_alias\n\n    @staticmethod\n    def model_type_to_model_dir(model_type: str) -&gt; str:\n\"\"\"Get plural model directory from model type.\"\"\"\n        if model_type not in const.MODEL_TYPE_LIST:\n            raise err.TrestleError(f'Not a valid model type: {model_type}.')\n        return const.MODEL_TYPE_TO_MODEL_DIR[model_type]\n\n    @staticmethod\n    def get_models_of_type(model_type: str, root: pathlib.Path) -&gt; List[str]:\n\"\"\"Get list of model names for requested type in trestle directory.\"\"\"\n        if model_type not in const.MODEL_TYPE_LIST:\n            raise err.TrestleError(f'Model type {model_type} is not supported')\n        # search relative to project root\n        trestle_root = extract_trestle_project_root(root)\n        if not trestle_root:\n            logger.error(f'Given directory {root} is not within a trestle project.')\n            raise err.TrestleError('Given directory is not within a trestle project.')\n\n        # contruct path to the model file name\n        model_dir_name = ModelUtils.model_type_to_model_dir(model_type)\n        root_model_dir = trestle_root / model_dir_name\n        model_list = []\n        for f in root_model_dir.glob('*/'):\n            # only look for proper json and yaml files\n            if not ModelUtils._should_ignore(f.stem):\n                if not f.is_dir():\n                    logger.warning(\n                        f'Ignoring validation of misplaced file {f.name} '\n                        + f'found in the model directory, {model_dir_name}.'\n                    )\n                else:\n                    model_list.append(f.stem)\n        return model_list\n\n    @staticmethod\n    def get_all_models(root: pathlib.Path) -&gt; List[Tuple[str, str]]:\n\"\"\"Get list of all models in trestle directory as tuples (model_type, model_name).\"\"\"\n        full_list = []\n        for model_type in const.MODEL_TYPE_LIST:\n            models = ModelUtils.get_models_of_type(model_type, root)\n            for m in models:\n                full_list.append((model_type, m))\n        return full_list\n\n    @staticmethod\n    def get_model_path_for_name_and_class(\n        trestle_root: pathlib.Path,\n        model_name: str,\n        model_class: Type[TopLevelOscalModel],\n        file_content_type: Optional[FileContentType] = None\n    ) -&gt; Optional[pathlib.Path]:\n\"\"\"\n        Find the full path of a model given its name, model type and file content type.\n\n        If file_content_type is given it will not inspect the file system or confirm the needed path and file exists.\n        \"\"\"\n        if file_content_type is None:\n            root_model_path = ModelUtils._root_path_for_top_level_model(trestle_root, model_name, model_class)\n            file_content_type = FileContentType.path_to_content_type(root_model_path)\n            if not FileContentType.is_readable_file(file_content_type):\n                return None\n\n            return root_model_path.with_suffix(FileContentType.to_file_extension(file_content_type))\n\n        root_path = ModelUtils._root_path_for_top_level_model(trestle_root, model_name, model_class)\n        return root_path.with_suffix(FileContentType.to_file_extension(file_content_type))\n\n    @staticmethod\n    def get_singular_alias(alias_path: str, relative_path: Optional[pathlib.Path] = None) -&gt; str:\n\"\"\"\n        Get the alias in the singular form from a jsonpath.\n\n        If contextual_mode is True and contextual_path is None, it assumes alias_path\n        is relative to the directory the user is running trestle from.\n\n        Args:\n            alias_path: The current alias element path as a string\n            relative_path: Optional relative path (w.r.t. trestle_root) to cater for relative element paths.\n        Returns:\n            Alias as a string\n        \"\"\"\n        if len(alias_path.strip()) == 0:\n            raise err.TrestleError(f'Invalid jsonpath {alias_path}')\n\n        singular_alias: str = ''\n\n        full_alias_path = alias_path\n        if relative_path:\n            logger.debug(f'get_singular_alias contextual mode: {str}')\n            _, full_model_alias = ModelUtils.get_relative_model_type(relative_path)\n            first_alias_a = full_model_alias.split('.')[-1]\n            first_alias_b = alias_path.split('.')[0]\n            if first_alias_a == first_alias_b:\n                full_model_alias = '.'.join(full_model_alias.split('.')[:-1])\n            full_alias_path = '.'.join([full_model_alias, alias_path]).strip('.')\n\n        path_parts = full_alias_path.split(const.ALIAS_PATH_SEPARATOR)\n        logger.debug(f'path parts: {path_parts}')\n\n        model_types = []\n\n        root_model_alias = path_parts[0]\n        found = False\n        for module_name in const.MODEL_TYPE_TO_MODEL_MODULE.values():\n            model_type, model_alias = ModelUtils.get_root_model(module_name)\n            if root_model_alias == model_alias:\n                found = True\n                model_types.append(model_type)\n                break\n\n        if not found:\n            raise err.TrestleError(f'{root_model_alias} is an invalid root model alias.')\n\n        if len(path_parts) == 1:\n            return root_model_alias\n\n        model_type = model_types[0]\n        # go through path parts skipping first one\n        for i in range(1, len(path_parts)):\n            if utils.is_collection_field_type(model_type):\n                # if it is a collection type and last part is * then break\n                if i == len(path_parts) - 1 and path_parts[i] == '*':\n                    break\n                # otherwise get the inner type of items in the collection\n                model_type = utils.get_inner_type(model_type)\n                # and bump i\n                i = i + 1\n            else:\n                path_part = path_parts[i]\n                field_map = model_type.alias_to_field_map()\n                if path_part not in field_map:\n                    continue\n                field = field_map[path_part]\n                model_type = field.outer_type_\n            model_types.append(model_type)\n\n        last_alias = path_parts[-1]\n        if last_alias == '*':\n            last_alias = path_parts[-2]\n\n        # generic model and not list, so return itself fixme doc\n        if not utils.is_collection_field_type(model_type):\n            return last_alias\n\n        parent_model_type = model_types[-2]\n        try:\n            field_map = parent_model_type.alias_to_field_map()\n            field = field_map[last_alias]\n            outer_type = field.outer_type_\n            inner_type = utils.get_inner_type(outer_type)\n            inner_type_name = inner_type.__name__\n            singular_alias = str_utils.classname_to_alias(inner_type_name, AliasMode.JSON)\n        except Exception as e:\n            raise err.TrestleError(f'Error in json path {alias_path}: {e}')\n\n        return singular_alias\n\n    @staticmethod\n    def get_root_model(module_name: str) -&gt; Tuple[Type[Any], str]:\n\"\"\"Get the root model class and alias based on the module.\"\"\"\n        try:\n            module = importlib.import_module(module_name)\n        except ModuleNotFoundError as e:\n            raise err.TrestleError(str(e))\n\n        if hasattr(module, 'Model'):\n            model_metadata = next(iter(module.Model.__fields__.values()))\n            return model_metadata.type_, model_metadata.alias\n        raise err.TrestleError('Invalid module')\n\n    @staticmethod\n    def _root_path_for_top_level_model(\n        trestle_root: pathlib.Path, model_name: str, model_class: Union[TopLevelOscalModel, Type[TopLevelOscalModel]]\n    ) -&gt; pathlib.Path:\n\"\"\"\n        Find the root path to a model given its name and class - with no suffix.\n\n        This is a private method used only to construct the root filepath based on model name and type.\n        It does not check for existence or content type and it does not create the directory if it does not exist.\n        \"\"\"\n        if not hasattr(model_class, '__module__') or model_class.__module__ not in const.MODEL_MODULE_LIST:\n            raise TrestleError(f'Unable to determine model type for model {model_name} with class {model_class}')\n        model_alias = const.MODEL_MODULE_TO_MODEL_TYPE[model_class.__module__]\n        model_dir = trestle_root / f'{const.MODEL_TYPE_TO_MODEL_DIR[model_alias]}/{model_name}'\n        return model_dir / model_alias\n\n    @staticmethod\n    def _extract_alias(string_dir: str) -&gt; str:\n\"\"\"\n        Extract alias from filename or directory name removing extensions and prefixes related to dict and list.\n\n        As we need to do this for multiple parts of a path operating on strings is easier.\n        \"\"\"\n        alias = string_dir.split('.')[0].split(\n            const.IDX_SEP\n        )[-1]  # get suffix of file or directory name representing list or dict item\n        return alias\n\n    @staticmethod\n    def _should_ignore(name: str) -&gt; bool:\n\"\"\"Check if the file or directory should be ignored or not.\"\"\"\n        return name[0] == '.' or name[0] == '_'\n\n    @staticmethod\n    def _load_list(abs_path: Path, abs_trestle_root: Path) -&gt; Tuple[Type[OscalBaseModel], str, List[OscalBaseModel]]:\n\"\"\"Given path to a directory of list(array) models, load the distributed models.\"\"\"\n        aliases_not_to_be_stripped = []\n        instances_to_be_merged: List[OscalBaseModel] = []\n        collection_model_type, collection_model_alias = ModelUtils.get_stripped_model_type(abs_path, abs_trestle_root)\n        for path in sorted(trestle.common.file_utils.iterdir_without_hidden_files(abs_path)):\n\n            # ASSUMPTION HERE: if it is a directory, there's a file that can not be decomposed further.\n            if path.is_dir():\n                continue\n            _, model_alias, model_instance = ModelUtils.load_distributed(path, abs_trestle_root)\n\n            instances_to_be_merged.append(model_instance)\n            aliases_not_to_be_stripped.append(model_alias.split('.')[-1])\n\n        return collection_model_type, collection_model_alias, instances_to_be_merged\n\n    @staticmethod\n    def _parameter_to_dict_recurse(obj: Union[OscalBaseModel, str], partial: bool) -&gt; Union[str, Dict[str, Any]]:\n\"\"\"\n        Convert obj to dict containing only string values with recursion.\n\n        Args:\n            obj: The parameter or its consituent parts in recursive calls\n            partial: Whether to convert the entire param or just the parts needed for markdown header\n\n        Returns:\n            The converted parameter as dictionary\n        \"\"\"\n        main_fields = ['id', 'label', 'values', 'select', 'choice', 'how_many']\n        if isinstance(obj, common.Remarks):\n            return obj.__root__\n        if isinstance(obj, common.HowMany):\n            return obj.value\n        # it is either a string already or we cast it to string\n        if not hasattr(obj, const.FIELDS_SET):\n            return str(obj)\n        # it is an oscal object and we need to recurse within its attributes\n        res = {}\n        for field in obj.__fields_set__:\n            if partial and field not in main_fields:\n                continue\n            attr = getattr(obj, field)\n            if not attr:\n                continue\n            if isinstance(attr, list):\n                new_list = []\n                for item in attr:\n                    new_list.append(ModelUtils._parameter_to_dict_recurse(item, partial))\n                res[field] = new_list\n            elif isinstance(attr, str):\n                res[field] = attr\n            else:\n                res[field] = ModelUtils._parameter_to_dict_recurse(attr, partial)\n        return res\n\n    @staticmethod\n    def parameter_to_dict(obj: Union[OscalBaseModel, str], partial: bool) -&gt; Union[str, Dict[str, Any]]:\n\"\"\"\n        Convert obj to dict containing only string values, storing only the fields that have values set.\n\n        Args:\n            obj: The parameter or its consituent parts in recursive calls\n            partial: Whether to convert the entire param or just the parts needed for markdown header\n\n        Returns:\n            The converted parameter as dictionary, with values as None if not present\n        \"\"\"\n        res = ModelUtils._parameter_to_dict_recurse(obj, partial)\n        if 'values' not in res:\n            res['values'] = None\n        return res\n\n    @staticmethod\n    def _string_to_howmany(count_str: str) -&gt; Optional[str]:\n        clean_str = count_str.lower().strip().replace('-', ' ').replace('_', ' ')\n        if clean_str == const.ONE:\n            return common.HowMany.one\n        if clean_str == const.ONE_OR_MORE_SPACED:\n            return common.HowMany.one_or_more\n        return None\n\n    @staticmethod\n    def dict_to_parameter(param_dict: Dict[str, Any]) -&gt; common.Parameter:\n\"\"\"\n        Convert dict with only string values to Parameter with handling for HowMany and with validity checks.\n\n        Args:\n            param_dict: Dictionary of pure string values representing Parameter contents\n\n        Returns:\n            A valid OSCAL Parameter\n\n        Notes:\n            This handles both partial and full parameter dictionaries\n            It checks for validity of the values if a select and HowMany is specified\n            There is special handling for values: If it is a single string it is converted to list of one ParameterValue\n            But if it is a list of strings is regarded as a list of values and is converted to a list of ParameterValues\n        \"\"\"\n        values = param_dict.get('values', [])\n        # special handling when only one value present - convert to list of 1\n        if isinstance(values, str):\n            values = [values]\n            param_dict['values'] = values\n        if 'select' in param_dict and 'how_many' in param_dict['select']:\n            count_str = param_dict['select']['how_many']\n            how_many = ModelUtils._string_to_howmany(count_str)\n            if how_many is None:\n                raise TrestleError(f'Unrecognized HowMany value {how_many} in Parameter: should be one-or-more or one.')\n            param_dict['select']['how_many'] = how_many\n            if how_many == const.ONE and len(values) &gt; 1:\n                logger.warning(f'Parameter specifies HowMany=1 but has {len(values)} values given.')\n            choices = param_dict['select'].get('choice', [])\n            if choices and values:\n                for value in values:\n                    if value not in choices:\n                        logger.warning(f\"Parameter {param_dict['id']} has value \\\"{value}\\\" not in choices: {choices}.\")\n        props = param_dict.get('props', [])\n        if const.DISPLAY_NAME in param_dict:\n            display_name = param_dict.pop(const.DISPLAY_NAME)\n            props.append(common.Property(name=const.DISPLAY_NAME, value=display_name, ns=const.TRESTLE_GENERIC_NS))\n\n        if 'ns' in param_dict:\n            param_dict.pop('ns')\n        param = common.Parameter(**param_dict)\n        param.props = none_if_empty(props)\n        return param\n\n    @staticmethod\n    def last_modified_at_time(timestamp: Optional[datetime] = None) -&gt; common.LastModified:\n\"\"\"Generate a LastModified set to timestamp or now.\"\"\"\n        timestamp = timestamp if timestamp else datetime.now().astimezone()\n        return timestamp\n\n    @staticmethod\n    def update_last_modified(model: TopLevelOscalModel, timestamp: Optional[datetime] = None) -&gt; None:\n\"\"\"Update the LastModified timestamp in top level model to now.\"\"\"\n        timestamp = timestamp if timestamp else datetime.now().astimezone()\n        model.metadata.last_modified = timestamp\n\n    @staticmethod\n    def model_age(model: TopLevelOscalModel) -&gt; int:\n\"\"\"Find time in seconds since LastModified timestamp.\"\"\"\n        # default to one year if no last_modified\n        age_seconds = const.DAY_SECONDS * 365\n        if model.metadata.last_modified:\n            dt = datetime.now().astimezone() - model.metadata.last_modified\n            age_seconds = dt.seconds\n        return age_seconds\n\n    @staticmethod\n    def find_values_by_name(object_of_interest: Any, name_of_interest: str) -&gt; List[Any]:\n\"\"\"Traverse object and return list of values of specified name.\"\"\"\n        loe = []\n        if isinstance(object_of_interest, BaseModel):\n            value = getattr(object_of_interest, name_of_interest, None)\n            if value is not None:\n                loe.append(value)\n            fields = getattr(object_of_interest, const.FIELDS_SET, None)\n            if fields is not None:\n                for field in fields:\n                    loe.extend(\n                        ModelUtils.find_values_by_name(getattr(object_of_interest, field, None), name_of_interest)\n                    )\n        elif type(object_of_interest) is list:\n            for item in object_of_interest:\n                loe.extend(ModelUtils.find_values_by_name(item, name_of_interest))\n        elif type(object_of_interest) is dict:\n            if name_of_interest in object_of_interest:\n                loe.append(object_of_interest[name_of_interest])\n            for item in object_of_interest.values():\n                loe.extend(ModelUtils.find_values_by_name(item, name_of_interest))\n        return loe\n\n    @staticmethod\n    def has_no_duplicate_values_by_name(object_of_interest: BaseModel, name_of_interest: str) -&gt; bool:\n\"\"\"Determine if duplicate values of type exist in object.\"\"\"\n        loe = ModelUtils.find_values_by_name(object_of_interest, name_of_interest)\n        set_loe = set(loe)\n        if len(loe) == len(set_loe):\n            return True\n        items = {}\n        for item in loe:\n            items[item] = items.get(item, 0) + 1\n        # now print items\n        for item, instances in items.items():\n            if instances &gt; 1:\n                logger.warning(f'Duplicate detected of item {item} with {instances} instances.')\n        return False\n\n    @staticmethod\n    def find_uuid_refs(object_of_interest: BaseModel) -&gt; Set[str]:\n\"\"\"Find uuid references made in prose and links.\"\"\"\n        # hrefs have form #foo or #uuid\n        uuid_strs = ModelUtils.find_values_by_name(object_of_interest, 'href')\n\n        # prose has uuid refs in markdown form: [foo](#bar) or [foo](#uuid)\n        prose_list = ModelUtils.find_values_by_name(object_of_interest, 'prose')\n        for prose in prose_list:\n            matches = re.findall(const.MARKDOWN_URL_REGEX, prose)\n            # the [1] is to extract the inner of 3 capture patterns\n            new_uuids = [match[1] for match in matches]\n            uuid_strs.extend(new_uuids)\n\n        # collect the strings that start with # and are potential uuids\n        uuid_strs = [uuid_str for uuid_str in uuid_strs if uuid_str and uuid_str[0] == '#']\n\n        # go through all matches and build set of those that are uuids\n        uuid_set = {uuid_match for uuid_str in uuid_strs for uuid_match in re.findall(const.UUID_REGEX, uuid_str[1:])}\n        return uuid_set\n\n    @staticmethod\n    def _regenerate_uuids_in_place(object_of_interest: Any, uuid_lut: Dict[str, str]) -&gt; Tuple[Any, Dict[str, str]]:\n\"\"\"Update all uuids in model that require updating.\n\n        Go through the model and replace all dicts with key == 'uuid' and replace the value with a new uuid4.\n        Build a lookup table of the updates that were made.\n        This function does not update the corresponding refs to those uuid's.  That is done by update_uuid_refs\n        Note that this function needs to be started off with uuid_lut == {}, i.e. an empty dict.\n        After that it recurses and grows the lut.\n\n        Args:\n            object_of_interest: pydantic.BaseModel, list, dict or str will be updated\n            uuid_lut: dict of the growing lut of old:new uuid's.  First call must be made with value {}\n\n        Returns:\n            The updated object_of_interest with new uuid's (but refs to them are not updated)\n            The final lookup table of old:new uuid's\n\n        \"\"\"\n        uuid_str = 'uuid'\n        # Certain types are known not to need updating and should not change\n        # Resources are identified by uuid, and the corresponding href will have # in front of the uuid string\n        # Neither of these should change\n        # If other similar types are found they should be added to the FixedUuidModel typevar to prevent updating\n        if isinstance(object_of_interest, common.Resource):\n            pass\n        elif isinstance(object_of_interest, BaseModel):\n            # fields has names of all fields in model\n            fields = getattr(object_of_interest, const.FIELDS_SET, None)\n            for field in fields:\n                new_object = None\n                if field == uuid_str:\n                    orig_uuid = getattr(object_of_interest, field)\n                    if orig_uuid:\n                        new_object = str(uuid.uuid4())\n                        uuid_lut[orig_uuid] = new_object\n                else:\n                    new_object, uuid_lut = ModelUtils._regenerate_uuids_in_place(\n                        object_of_interest.__dict__[field],\n                        uuid_lut\n                    )\n                object_of_interest.__dict__[field] = new_object\n        elif type(object_of_interest) is list:\n            new_list = []\n            for item in object_of_interest:\n                new_item, uuid_lut = ModelUtils._regenerate_uuids_in_place(item, uuid_lut)\n                new_list.append(new_item)\n            object_of_interest = new_list\n        elif type(object_of_interest) is dict:\n            new_dict = {}\n            for key, value in object_of_interest.items():\n                if key == uuid_str:\n                    new_val = str(uuid.uuid4())\n                    new_dict[uuid_str] = new_val\n                    uuid_lut[value] = new_val\n                else:\n                    new_value, uuid_lut = ModelUtils._regenerate_uuids_in_place(value, uuid_lut)\n                    new_dict[key] = new_value\n            object_of_interest = new_dict\n        return object_of_interest, uuid_lut\n\n    @staticmethod\n    def _update_new_uuid_refs(object_of_interest: Any, uuid_lut: Dict[str, str]) -&gt; Tuple[Any, int]:\n\"\"\"Update all refs to uuids that were changed.\"\"\"\n        n_refs_updated = 0\n        if isinstance(object_of_interest, BaseModel):\n            fields = getattr(object_of_interest, const.FIELDS_SET, None)\n            for field in fields:\n                new_object, n_new_updates = ModelUtils._update_new_uuid_refs(\n                    object_of_interest.__dict__[field],\n                    uuid_lut\n                )\n                n_refs_updated += n_new_updates\n                object_of_interest.__dict__[field] = new_object\n        elif type(object_of_interest) is list:\n            new_list = []\n            for item in object_of_interest:\n                new_item, n_new_updates = ModelUtils._update_new_uuid_refs(item, uuid_lut)\n                n_refs_updated += n_new_updates\n                new_list.append(new_item)\n            object_of_interest = new_list\n        elif type(object_of_interest) is dict:\n            new_dict = {}\n            for key, value in object_of_interest.items():\n                if isinstance(value, str):\n                    if value in uuid_lut:\n                        new_dict[key] = uuid_lut[value]\n                        n_refs_updated += 1\n                    else:\n                        new_dict[key] = value\n                else:\n                    new_value, n_new_updates = ModelUtils._update_new_uuid_refs(value, uuid_lut)\n                    n_refs_updated += n_new_updates\n                    new_dict[key] = new_value\n            object_of_interest = new_dict\n        elif isinstance(object_of_interest, str):\n            if object_of_interest in uuid_lut:\n                n_refs_updated += 1\n                object_of_interest = uuid_lut[object_of_interest]\n        return object_of_interest, n_refs_updated\n\n    @staticmethod\n    def regenerate_uuids(object_of_interest: Any) -&gt; Tuple[Any, Dict[str, str], int]:\n\"\"\"Regenerate all uuids in object and update corresponding references.\n\n        Find all dicts with key == 'uuid' and replace the value with a new uuid4.\n        Build a corresponding lookup table as you go, of old:new uuid values.\n        Then make a second pass through the object and replace all string values\n        present in the lookup table with the new value.\n\n        Args:\n            object_of_interest: pydantic.BaseModel, list, dict or str will be updated\n\n        Returns:\n            The updated object with new uuid's and refs\n            The final lookup table of old:new uuid's\n            A count of the number of refs that were updated\n        \"\"\"\n        new_object, uuid_lut = ModelUtils._regenerate_uuids_in_place(object_of_interest, {})\n        new_object, n_refs_updated = ModelUtils._update_new_uuid_refs(new_object, uuid_lut)\n        return new_object, uuid_lut, n_refs_updated\n\n    @staticmethod\n    def fields_set_non_none(obj: BaseModel) -&gt; Set[str]:\n\"\"\"Find the fields set with Nones and empty items removed.\"\"\"\n        return set(as_filtered_list(list(obj.__fields_set__), lambda f: getattr(obj, f)))\n\n    @staticmethod\n    def _objects_differ(\n        obj_a: Any, obj_b: Any, ignore_type_list: List[Any], ignore_name_list: List[str], ignore_all_uuid: bool\n    ) -&gt; bool:\n\"\"\"\n        Compare two objects with option to ignore given types.\n\n        This does not check for tuples or other structures that won't be found in JSON.\n        \"\"\"\n        obj_a_type = type(obj_a)\n        obj_b_type = type(obj_b)\n        if bool(obj_a) != bool(obj_b) or obj_a_type != obj_b_type:\n            return True\n        if not bool(obj_a):\n            return False\n        if obj_a_type in ignore_type_list:\n            return False\n        if obj_a_type is str:\n            return obj_a != obj_b\n        elif isinstance(obj_a, BaseModel):\n            fields_a = ModelUtils.fields_set_non_none(obj_a)\n            fields_b = ModelUtils.fields_set_non_none(obj_b)\n            if fields_a != fields_b:\n                return True\n            for field in list_utils.as_filtered_list(fields_a, lambda f: f not in ignore_name_list):\n                if ignore_all_uuid and 'uuid' in field:\n                    continue\n                if ModelUtils._objects_differ(getattr(obj_a, field),\n                                              getattr(obj_b, field),\n                                              ignore_type_list,\n                                              ignore_name_list,\n                                              ignore_all_uuid):\n                    return True\n        elif obj_a_type is list:\n            if len(obj_a) != len(obj_b):\n                return True\n            for item_a, item_b in zip(obj_a, obj_b):\n                if ModelUtils._objects_differ(item_a, item_b, ignore_type_list, ignore_name_list, ignore_all_uuid):\n                    return True\n        elif obj_a_type is dict:\n            if obj_a.keys() != obj_b.keys():\n                return True\n            for key, val in obj_a.items():\n                if ignore_all_uuid and 'uuid' in key:\n                    continue\n                if key not in ignore_name_list and ModelUtils._objects_differ(\n                        val, obj_b[key], ignore_type_list, ignore_name_list, ignore_all_uuid):\n                    return True\n        elif obj_a != obj_b:\n            return True\n        return False\n\n    @staticmethod\n    def models_are_equivalent(\n        model_a: Optional[TopLevelOscalModel],\n        model_b: Optional[TopLevelOscalModel],\n        ignore_all_uuid: bool = False\n    ) -&gt; bool:\n\"\"\"\n        Test if models are equivalent except for last modified and possibly uuid.\n\n        If a model has had uuids regenerated, then all uuids *and references to them* are updated.  This means that\n        special handling is required if a model has had uuids regenerated - when checking equivalence.\n        \"\"\"\n        uuid_type_list = [\n            common.LastModified,\n            common.LocationUuid,\n            common.PartyUuid,\n            common.RelatedRisk,\n            common.Source,\n            assessment_plan.RelatedObservation,\n            assessment_results.RelatedObservation,\n            poam.RelatedObservation,\n            poam.RelatedObservation1\n        ]\n        type_list = uuid_type_list if ignore_all_uuid else [common.LastModified]\n        return not ModelUtils._objects_differ(model_a, model_b, type_list, ['last_modified'], ignore_all_uuid)\n\n    @staticmethod\n    def get_title_from_model_uri(trestle_root: pathlib.Path, uri: str) -&gt; str:\n\"\"\"Get title from model at uri.\"\"\"\n        try:\n            fetcher = cache.FetcherFactory.get_fetcher(trestle_root, uri)\n            model, _ = fetcher.get_oscal()\n            return model.metadata.title\n        except TrestleError as e:\n            logger.warning(f'Error finding title for model at uri {uri}: {e}')\n            raise\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils-methods","title":"Methods","text":""},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.dict_to_parameter","title":"<code>dict_to_parameter(param_dict)</code>  <code>staticmethod</code>","text":"<p>Convert dict with only string values to Parameter with handling for HowMany and with validity checks.</p> <p>Parameters:</p> Name Type Description Default <code>param_dict</code> <code>Dict[str, Any]</code> <p>Dictionary of pure string values representing Parameter contents</p> required <p>Returns:</p> Type Description <code>Parameter</code> <p>A valid OSCAL Parameter</p> <p>Notes</p> <p>This handles both partial and full parameter dictionaries It checks for validity of the values if a select and HowMany is specified There is special handling for values: If it is a single string it is converted to list of one ParameterValue But if it is a list of strings is regarded as a list of values and is converted to a list of ParameterValues</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef dict_to_parameter(param_dict: Dict[str, Any]) -&gt; common.Parameter:\n\"\"\"\n    Convert dict with only string values to Parameter with handling for HowMany and with validity checks.\n\n    Args:\n        param_dict: Dictionary of pure string values representing Parameter contents\n\n    Returns:\n        A valid OSCAL Parameter\n\n    Notes:\n        This handles both partial and full parameter dictionaries\n        It checks for validity of the values if a select and HowMany is specified\n        There is special handling for values: If it is a single string it is converted to list of one ParameterValue\n        But if it is a list of strings is regarded as a list of values and is converted to a list of ParameterValues\n    \"\"\"\n    values = param_dict.get('values', [])\n    # special handling when only one value present - convert to list of 1\n    if isinstance(values, str):\n        values = [values]\n        param_dict['values'] = values\n    if 'select' in param_dict and 'how_many' in param_dict['select']:\n        count_str = param_dict['select']['how_many']\n        how_many = ModelUtils._string_to_howmany(count_str)\n        if how_many is None:\n            raise TrestleError(f'Unrecognized HowMany value {how_many} in Parameter: should be one-or-more or one.')\n        param_dict['select']['how_many'] = how_many\n        if how_many == const.ONE and len(values) &gt; 1:\n            logger.warning(f'Parameter specifies HowMany=1 but has {len(values)} values given.')\n        choices = param_dict['select'].get('choice', [])\n        if choices and values:\n            for value in values:\n                if value not in choices:\n                    logger.warning(f\"Parameter {param_dict['id']} has value \\\"{value}\\\" not in choices: {choices}.\")\n    props = param_dict.get('props', [])\n    if const.DISPLAY_NAME in param_dict:\n        display_name = param_dict.pop(const.DISPLAY_NAME)\n        props.append(common.Property(name=const.DISPLAY_NAME, value=display_name, ns=const.TRESTLE_GENERIC_NS))\n\n    if 'ns' in param_dict:\n        param_dict.pop('ns')\n    param = common.Parameter(**param_dict)\n    param.props = none_if_empty(props)\n    return param\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.fields_set_non_none","title":"<code>fields_set_non_none(obj)</code>  <code>staticmethod</code>","text":"<p>Find the fields set with Nones and empty items removed.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef fields_set_non_none(obj: BaseModel) -&gt; Set[str]:\n\"\"\"Find the fields set with Nones and empty items removed.\"\"\"\n    return set(as_filtered_list(list(obj.__fields_set__), lambda f: getattr(obj, f)))\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.find_uuid_refs","title":"<code>find_uuid_refs(object_of_interest)</code>  <code>staticmethod</code>","text":"<p>Find uuid references made in prose and links.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef find_uuid_refs(object_of_interest: BaseModel) -&gt; Set[str]:\n\"\"\"Find uuid references made in prose and links.\"\"\"\n    # hrefs have form #foo or #uuid\n    uuid_strs = ModelUtils.find_values_by_name(object_of_interest, 'href')\n\n    # prose has uuid refs in markdown form: [foo](#bar) or [foo](#uuid)\n    prose_list = ModelUtils.find_values_by_name(object_of_interest, 'prose')\n    for prose in prose_list:\n        matches = re.findall(const.MARKDOWN_URL_REGEX, prose)\n        # the [1] is to extract the inner of 3 capture patterns\n        new_uuids = [match[1] for match in matches]\n        uuid_strs.extend(new_uuids)\n\n    # collect the strings that start with # and are potential uuids\n    uuid_strs = [uuid_str for uuid_str in uuid_strs if uuid_str and uuid_str[0] == '#']\n\n    # go through all matches and build set of those that are uuids\n    uuid_set = {uuid_match for uuid_str in uuid_strs for uuid_match in re.findall(const.UUID_REGEX, uuid_str[1:])}\n    return uuid_set\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.find_values_by_name","title":"<code>find_values_by_name(object_of_interest, name_of_interest)</code>  <code>staticmethod</code>","text":"<p>Traverse object and return list of values of specified name.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef find_values_by_name(object_of_interest: Any, name_of_interest: str) -&gt; List[Any]:\n\"\"\"Traverse object and return list of values of specified name.\"\"\"\n    loe = []\n    if isinstance(object_of_interest, BaseModel):\n        value = getattr(object_of_interest, name_of_interest, None)\n        if value is not None:\n            loe.append(value)\n        fields = getattr(object_of_interest, const.FIELDS_SET, None)\n        if fields is not None:\n            for field in fields:\n                loe.extend(\n                    ModelUtils.find_values_by_name(getattr(object_of_interest, field, None), name_of_interest)\n                )\n    elif type(object_of_interest) is list:\n        for item in object_of_interest:\n            loe.extend(ModelUtils.find_values_by_name(item, name_of_interest))\n    elif type(object_of_interest) is dict:\n        if name_of_interest in object_of_interest:\n            loe.append(object_of_interest[name_of_interest])\n        for item in object_of_interest.values():\n            loe.extend(ModelUtils.find_values_by_name(item, name_of_interest))\n    return loe\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.get_all_models","title":"<code>get_all_models(root)</code>  <code>staticmethod</code>","text":"<p>Get list of all models in trestle directory as tuples (model_type, model_name).</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef get_all_models(root: pathlib.Path) -&gt; List[Tuple[str, str]]:\n\"\"\"Get list of all models in trestle directory as tuples (model_type, model_name).\"\"\"\n    full_list = []\n    for model_type in const.MODEL_TYPE_LIST:\n        models = ModelUtils.get_models_of_type(model_type, root)\n        for m in models:\n            full_list.append((model_type, m))\n    return full_list\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.get_model_path_for_name_and_class","title":"<code>get_model_path_for_name_and_class(trestle_root, model_name, model_class, file_content_type=None)</code>  <code>staticmethod</code>","text":"<p>Find the full path of a model given its name, model type and file content type.</p> <p>If file_content_type is given it will not inspect the file system or confirm the needed path and file exists.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef get_model_path_for_name_and_class(\n    trestle_root: pathlib.Path,\n    model_name: str,\n    model_class: Type[TopLevelOscalModel],\n    file_content_type: Optional[FileContentType] = None\n) -&gt; Optional[pathlib.Path]:\n\"\"\"\n    Find the full path of a model given its name, model type and file content type.\n\n    If file_content_type is given it will not inspect the file system or confirm the needed path and file exists.\n    \"\"\"\n    if file_content_type is None:\n        root_model_path = ModelUtils._root_path_for_top_level_model(trestle_root, model_name, model_class)\n        file_content_type = FileContentType.path_to_content_type(root_model_path)\n        if not FileContentType.is_readable_file(file_content_type):\n            return None\n\n        return root_model_path.with_suffix(FileContentType.to_file_extension(file_content_type))\n\n    root_path = ModelUtils._root_path_for_top_level_model(trestle_root, model_name, model_class)\n    return root_path.with_suffix(FileContentType.to_file_extension(file_content_type))\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.get_models_of_type","title":"<code>get_models_of_type(model_type, root)</code>  <code>staticmethod</code>","text":"<p>Get list of model names for requested type in trestle directory.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef get_models_of_type(model_type: str, root: pathlib.Path) -&gt; List[str]:\n\"\"\"Get list of model names for requested type in trestle directory.\"\"\"\n    if model_type not in const.MODEL_TYPE_LIST:\n        raise err.TrestleError(f'Model type {model_type} is not supported')\n    # search relative to project root\n    trestle_root = extract_trestle_project_root(root)\n    if not trestle_root:\n        logger.error(f'Given directory {root} is not within a trestle project.')\n        raise err.TrestleError('Given directory is not within a trestle project.')\n\n    # contruct path to the model file name\n    model_dir_name = ModelUtils.model_type_to_model_dir(model_type)\n    root_model_dir = trestle_root / model_dir_name\n    model_list = []\n    for f in root_model_dir.glob('*/'):\n        # only look for proper json and yaml files\n        if not ModelUtils._should_ignore(f.stem):\n            if not f.is_dir():\n                logger.warning(\n                    f'Ignoring validation of misplaced file {f.name} '\n                    + f'found in the model directory, {model_dir_name}.'\n                )\n            else:\n                model_list.append(f.stem)\n    return model_list\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.get_relative_model_type","title":"<code>get_relative_model_type(relative_path)</code>  <code>staticmethod</code>","text":"<p>Given the relative path of a file with respect to 'trestle_root' return the oscal model type.</p> <p>Parameters:</p> Name Type Description Default <code>relative_path</code> <code>Path</code> <p>Relative path of the model with respect to the root directory of the trestle workspace.</p> required <p>Returns:</p> Type Description <code>Tuple[Type[trestle.core.base_model.OscalBaseModel], str]</code> <p>Type of Oscal Model for the provided model Alias of that oscal model.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef get_relative_model_type(relative_path: pathlib.Path) -&gt; Tuple[Type[OscalBaseModel], str]:\n\"\"\"\n    Given the relative path of a file with respect to 'trestle_root' return the oscal model type.\n\n    Args:\n        relative_path: Relative path of the model with respect to the root directory of the trestle workspace.\n    Returns:\n        Type of Oscal Model for the provided model\n        Alias of that oscal model.\n    \"\"\"\n    if len(relative_path.parts) &lt; 2:\n        raise TrestleError(\n            'Insufficient path length to be a valid relative path w.r.t trestle workspace root directory.'\n        )\n    model_dir = relative_path.parts[0]\n    model_relative_path = pathlib.Path(*relative_path.parts[2:])  # catalogs, profiles, etc\n\n    if model_dir in const.MODEL_DIR_LIST:\n        module_name = const.MODEL_DIR_TO_MODEL_MODULE[model_dir]\n    else:\n        raise TrestleError(f'No valid trestle model type directory (e.g. catalogs) found for {model_dir}.')\n\n    model_type, model_alias = ModelUtils.get_root_model(module_name)\n    full_alias = model_alias\n\n    for index, part in enumerate(model_relative_path.parts):\n        alias = ModelUtils._extract_alias(part)\n        if index &gt; 0 or model_alias != alias:\n            model_alias = alias\n            full_alias = f'{full_alias}.{model_alias}'\n            if utils.is_collection_field_type(model_type):\n                model_type = utils.get_inner_type(model_type)\n            else:\n                model_type = model_type.alias_to_field_map()[alias].outer_type_\n\n    return model_type, full_alias\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.get_root_model","title":"<code>get_root_model(module_name)</code>  <code>staticmethod</code>","text":"<p>Get the root model class and alias based on the module.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef get_root_model(module_name: str) -&gt; Tuple[Type[Any], str]:\n\"\"\"Get the root model class and alias based on the module.\"\"\"\n    try:\n        module = importlib.import_module(module_name)\n    except ModuleNotFoundError as e:\n        raise err.TrestleError(str(e))\n\n    if hasattr(module, 'Model'):\n        model_metadata = next(iter(module.Model.__fields__.values()))\n        return model_metadata.type_, model_metadata.alias\n    raise err.TrestleError('Invalid module')\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.get_singular_alias","title":"<code>get_singular_alias(alias_path, relative_path=None)</code>  <code>staticmethod</code>","text":"<p>Get the alias in the singular form from a jsonpath.</p> <p>If contextual_mode is True and contextual_path is None, it assumes alias_path is relative to the directory the user is running trestle from.</p> <p>Parameters:</p> Name Type Description Default <code>alias_path</code> <code>str</code> <p>The current alias element path as a string</p> required <code>relative_path</code> <code>Optional[pathlib.Path]</code> <p>Optional relative path (w.r.t. trestle_root) to cater for relative element paths.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Alias as a string</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef get_singular_alias(alias_path: str, relative_path: Optional[pathlib.Path] = None) -&gt; str:\n\"\"\"\n    Get the alias in the singular form from a jsonpath.\n\n    If contextual_mode is True and contextual_path is None, it assumes alias_path\n    is relative to the directory the user is running trestle from.\n\n    Args:\n        alias_path: The current alias element path as a string\n        relative_path: Optional relative path (w.r.t. trestle_root) to cater for relative element paths.\n    Returns:\n        Alias as a string\n    \"\"\"\n    if len(alias_path.strip()) == 0:\n        raise err.TrestleError(f'Invalid jsonpath {alias_path}')\n\n    singular_alias: str = ''\n\n    full_alias_path = alias_path\n    if relative_path:\n        logger.debug(f'get_singular_alias contextual mode: {str}')\n        _, full_model_alias = ModelUtils.get_relative_model_type(relative_path)\n        first_alias_a = full_model_alias.split('.')[-1]\n        first_alias_b = alias_path.split('.')[0]\n        if first_alias_a == first_alias_b:\n            full_model_alias = '.'.join(full_model_alias.split('.')[:-1])\n        full_alias_path = '.'.join([full_model_alias, alias_path]).strip('.')\n\n    path_parts = full_alias_path.split(const.ALIAS_PATH_SEPARATOR)\n    logger.debug(f'path parts: {path_parts}')\n\n    model_types = []\n\n    root_model_alias = path_parts[0]\n    found = False\n    for module_name in const.MODEL_TYPE_TO_MODEL_MODULE.values():\n        model_type, model_alias = ModelUtils.get_root_model(module_name)\n        if root_model_alias == model_alias:\n            found = True\n            model_types.append(model_type)\n            break\n\n    if not found:\n        raise err.TrestleError(f'{root_model_alias} is an invalid root model alias.')\n\n    if len(path_parts) == 1:\n        return root_model_alias\n\n    model_type = model_types[0]\n    # go through path parts skipping first one\n    for i in range(1, len(path_parts)):\n        if utils.is_collection_field_type(model_type):\n            # if it is a collection type and last part is * then break\n            if i == len(path_parts) - 1 and path_parts[i] == '*':\n                break\n            # otherwise get the inner type of items in the collection\n            model_type = utils.get_inner_type(model_type)\n            # and bump i\n            i = i + 1\n        else:\n            path_part = path_parts[i]\n            field_map = model_type.alias_to_field_map()\n            if path_part not in field_map:\n                continue\n            field = field_map[path_part]\n            model_type = field.outer_type_\n        model_types.append(model_type)\n\n    last_alias = path_parts[-1]\n    if last_alias == '*':\n        last_alias = path_parts[-2]\n\n    # generic model and not list, so return itself fixme doc\n    if not utils.is_collection_field_type(model_type):\n        return last_alias\n\n    parent_model_type = model_types[-2]\n    try:\n        field_map = parent_model_type.alias_to_field_map()\n        field = field_map[last_alias]\n        outer_type = field.outer_type_\n        inner_type = utils.get_inner_type(outer_type)\n        inner_type_name = inner_type.__name__\n        singular_alias = str_utils.classname_to_alias(inner_type_name, AliasMode.JSON)\n    except Exception as e:\n        raise err.TrestleError(f'Error in json path {alias_path}: {e}')\n\n    return singular_alias\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.get_stripped_model_type","title":"<code>get_stripped_model_type(absolute_path, absolute_trestle_root, aliases_not_to_be_stripped=None)</code>  <code>staticmethod</code>","text":"<p>Get the stripped contextual model class and alias based on the contextual path.</p> <p>This function relies on the directory structure of the trestle model being edited to determine, based on the existing files and folder, which fields should be stripped from the model type represented by the path passed in as a parameter.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef get_stripped_model_type(\n    absolute_path: pathlib.Path,\n    absolute_trestle_root: pathlib.Path,\n    aliases_not_to_be_stripped: List[str] = None\n) -&gt; Tuple[Type[OscalBaseModel], str]:\n\"\"\"\n    Get the stripped contextual model class and alias based on the contextual path.\n\n    This function relies on the directory structure of the trestle model being edited to determine, based on the\n    existing files and folder, which fields should be stripped from the model type represented by the\n    path passed in as a parameter.\n    \"\"\"\n    if aliases_not_to_be_stripped is None:\n        aliases_not_to_be_stripped = []\n    singular_model_type, model_alias = ModelUtils.get_relative_model_type(\n        absolute_path.relative_to(absolute_trestle_root))\n    logger.debug(f'singular model type {singular_model_type} model alias {model_alias}')\n\n    # Stripped models do not apply to collection types such as List[] and Dict{}\n    # if model type is a list or dict, generate a new wrapping model for it\n    if utils.is_collection_field_type(singular_model_type):\n        malias = model_alias.split('.')[-1]\n        class_name = alias_to_classname(malias, AliasMode.JSON)\n        logger.debug(f'collection field type class name {class_name} and alias {malias}')\n        model_type = create_model(class_name, __base__=OscalBaseModel, __root__=(singular_model_type, ...))\n        logger.debug(f'model_type created: {model_type}')\n        model_type = cast(Type[OscalBaseModel], model_type)\n        return model_type, model_alias\n\n    malias = model_alias.split('.')[-1]\n    logger.debug(f'not collection field type, malias: {malias}')\n    if absolute_path.is_dir() and malias != ModelUtils._extract_alias(absolute_path.name):\n        split_subdir = absolute_path / malias\n    else:\n        split_subdir = absolute_path.parent / absolute_path.with_suffix('').name\n\n    aliases_to_be_stripped = set()\n    if split_subdir.exists():\n        for f in iterdir_without_hidden_files(split_subdir):\n            alias = ModelUtils._extract_alias(f.name)\n            if alias not in aliases_not_to_be_stripped:\n                aliases_to_be_stripped.add(alias)\n\n    logger.debug(f'aliases to be stripped: {aliases_to_be_stripped}')\n    if len(aliases_to_be_stripped) &gt; 0:\n        model_type = singular_model_type.create_stripped_model_type(\n            stripped_fields_aliases=list(aliases_to_be_stripped)\n        )\n        logger.debug(f'model_type: {model_type}')\n        return model_type, model_alias\n    return singular_model_type, model_alias\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.get_title_from_model_uri","title":"<code>get_title_from_model_uri(trestle_root, uri)</code>  <code>staticmethod</code>","text":"<p>Get title from model at uri.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef get_title_from_model_uri(trestle_root: pathlib.Path, uri: str) -&gt; str:\n\"\"\"Get title from model at uri.\"\"\"\n    try:\n        fetcher = cache.FetcherFactory.get_fetcher(trestle_root, uri)\n        model, _ = fetcher.get_oscal()\n        return model.metadata.title\n    except TrestleError as e:\n        logger.warning(f'Error finding title for model at uri {uri}: {e}')\n        raise\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.has_no_duplicate_values_by_name","title":"<code>has_no_duplicate_values_by_name(object_of_interest, name_of_interest)</code>  <code>staticmethod</code>","text":"<p>Determine if duplicate values of type exist in object.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef has_no_duplicate_values_by_name(object_of_interest: BaseModel, name_of_interest: str) -&gt; bool:\n\"\"\"Determine if duplicate values of type exist in object.\"\"\"\n    loe = ModelUtils.find_values_by_name(object_of_interest, name_of_interest)\n    set_loe = set(loe)\n    if len(loe) == len(set_loe):\n        return True\n    items = {}\n    for item in loe:\n        items[item] = items.get(item, 0) + 1\n    # now print items\n    for item, instances in items.items():\n        if instances &gt; 1:\n            logger.warning(f'Duplicate detected of item {item} with {instances} instances.')\n    return False\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.last_modified_at_time","title":"<code>last_modified_at_time(timestamp=None)</code>  <code>staticmethod</code>","text":"<p>Generate a LastModified set to timestamp or now.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef last_modified_at_time(timestamp: Optional[datetime] = None) -&gt; common.LastModified:\n\"\"\"Generate a LastModified set to timestamp or now.\"\"\"\n    timestamp = timestamp if timestamp else datetime.now().astimezone()\n    return timestamp\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.load_distributed","title":"<code>load_distributed(abs_path, abs_trestle_root, collection_type=None)</code>  <code>staticmethod</code>","text":"<p>Given path to a model, load the model.</p> <p>If the model is decomposed/split/distributed,the decomposed models are loaded recursively.</p> <p>Parameters:</p> Name Type Description Default <code>abs_path</code> <code>Path</code> <p>The path to the file/directory to be loaded.</p> required <code>abs_trestle_root</code> <code>Path</code> <p>The trestle workspace root directory.</p> required <code>collection_type</code> <code>Optional[Type[Any]]</code> <p>The type of collection model, if it is a collection model. typing.List is the only collection type handled or expected. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Type[trestle.core.base_model.OscalBaseModel], str, Union[trestle.core.base_model.OscalBaseModel, List[trestle.core.base_model.OscalBaseModel], Dict[str, trestle.core.base_model.OscalBaseModel]]]</code> <p>Return a tuple of Model Type (e.g. class 'trestle.oscal.catalog.Catalog'), Model Alias (e.g. 'catalog.metadata') and Instance of the Model. If the model is decomposed/split/distributed, the instance of the model contains the decomposed models loaded recursively.</p> <p>Note</p> <p>This does not validate the model.  You must either validate the model separately or use the load_validate utilities.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef load_distributed(\n    abs_path: Path,\n    abs_trestle_root: Path,\n    collection_type: Optional[Type[Any]] = None\n) -&gt; Tuple[Type[OscalBaseModel], str, Union[OscalBaseModel, List[OscalBaseModel], Dict[str, OscalBaseModel]]]:\n\"\"\"\n    Given path to a model, load the model.\n\n    If the model is decomposed/split/distributed,the decomposed models are loaded recursively.\n\n    Args:\n        abs_path: The path to the file/directory to be loaded.\n        abs_trestle_root: The trestle workspace root directory.\n        collection_type: The type of collection model, if it is a collection model.\n            typing.List is the only collection type handled or expected.\n            Defaults to None.\n\n    Returns:\n        Return a tuple of Model Type (e.g. class 'trestle.oscal.catalog.Catalog'),\n        Model Alias (e.g. 'catalog.metadata') and Instance of the Model.\n        If the model is decomposed/split/distributed, the instance of the model contains\n        the decomposed models loaded recursively.\n\n    Note:\n        This does not validate the model.  You must either validate the model separately or use the load_validate\n        utilities.\n    \"\"\"\n    # if trying to load file that does not exist, load path instead\n    if not abs_path.exists():\n        abs_path = abs_path.with_name(abs_path.stem)\n\n    if not abs_path.exists():\n        raise TrestleNotFoundError(f'File {abs_path} not found for load.')\n\n    if collection_type:\n        # If the path contains a list type model\n        if collection_type is list:\n            return ModelUtils._load_list(abs_path, abs_trestle_root)\n        # the only other collection type in OSCAL is dict, and it only applies to include_all,\n        # which is too granular ever to be loaded by this routine\n        else:\n            raise TrestleError(f'Collection type {collection_type} not recognized for distributed load.')\n\n    # Get current model\n    primary_model_type, primary_model_alias = ModelUtils.get_stripped_model_type(abs_path, abs_trestle_root)\n    primary_model_instance: Optional[OscalBaseModel] = None\n\n    # is this an attempt to load an actual json or yaml file?\n    content_type = FileContentType.path_to_content_type(abs_path)\n    # if file is sought but it doesn't exist, ignore and load as decomposed model\n    if FileContentType.is_readable_file(content_type) and abs_path.exists():\n        primary_model_instance = primary_model_type.oscal_read(abs_path)\n    # Is model decomposed?\n    decomposed_dir = abs_path.with_name(abs_path.stem)\n\n    if decomposed_dir.exists():\n        aliases_not_to_be_stripped = []\n        instances_to_be_merged: List[OscalBaseModel] = []\n\n        for local_path in sorted(trestle.common.file_utils.iterdir_without_hidden_files(decomposed_dir)):\n            if local_path.is_file():\n                model_type, model_alias, model_instance = ModelUtils.load_distributed(local_path, abs_trestle_root)\n                aliases_not_to_be_stripped.append(model_alias.split('.')[-1])\n                instances_to_be_merged.append(model_instance)\n\n            elif local_path.is_dir():\n                model_type, model_alias = ModelUtils.get_stripped_model_type(local_path, abs_trestle_root)\n                # Only load the directory if it is a collection model. Otherwise do nothing - it gets loaded when\n                # iterating over the model file\n\n                # If a model is just a container for a list e.g.\n                # class Foo(OscalBaseModel):  noqa: E800\n                #      __root__: List[Bar]    noqa: E800\n                # You need to test whether first a root key exists\n                # then whether the outer_type of root is a collection.\n                # Alternative is to do a try except to avoid the error for an unknown key.\n\n                if model_type.is_collection_container():\n                    # This directory is a decomposed List or Dict\n                    collection_type = model_type.get_collection_type()\n                    model_type, model_alias, model_instance = ModelUtils.load_distributed(local_path,\n                                                                                          abs_trestle_root,\n                                                                                          collection_type)\n                    aliases_not_to_be_stripped.append(model_alias.split('.')[-1])\n                    instances_to_be_merged.append(model_instance)\n        primary_model_dict = {}\n        if primary_model_instance is not None:\n            primary_model_dict = primary_model_instance.__dict__\n\n        merged_model_type, merged_model_alias = ModelUtils.get_stripped_model_type(abs_path,\n                                                                                   abs_trestle_root,\n                                                                                   aliases_not_to_be_stripped)\n\n        # The following use of top_level is to allow loading of a top level model by name only, e.g. MyCatalog\n        # There may be a better overall way to approach this.\n        top_level = len(merged_model_alias.split('.')) == 1\n\n        for i in range(len(aliases_not_to_be_stripped)):\n            alias = aliases_not_to_be_stripped[i]\n            instance = instances_to_be_merged[i]\n            if hasattr(instance, '__dict__') and '__root__' in instance.__dict__ and isinstance(instance,\n                                                                                                OscalBaseModel):\n                instance = instance.__dict__['__root__']\n            if top_level and not primary_model_dict:\n                primary_model_dict = instance.__dict__\n            else:\n                primary_model_dict[alias] = instance\n\n        merged_model_instance = merged_model_type(**primary_model_dict)  # type: ignore\n        return merged_model_type, merged_model_alias, merged_model_instance\n    return primary_model_type, primary_model_alias, primary_model_instance\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.load_model_for_class","title":"<code>load_model_for_class(trestle_root, model_name, model_class, file_content_type=None)</code>  <code>staticmethod</code>","text":"<p>Load a model by name and model class and infer file content type if not specified.</p> <p>If you need to load an existing model but its content type may not be known, use this method. But the file content type should be specified if it is somehow known.</p> <p>Note:  This does not validate the model.  If you want to validate the model use the load_validate utilities.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef load_model_for_class(\n    trestle_root: pathlib.Path,\n    model_name: str,\n    model_class: TG,\n    file_content_type: Optional[FileContentType] = None\n) -&gt; Tuple[TG, pathlib.Path]:\n\"\"\"Load a model by name and model class and infer file content type if not specified.\n\n    If you need to load an existing model but its content type may not be known, use this method.\n    But the file content type should be specified if it is somehow known.\n\n    Note:  This does not validate the model.  If you want to validate the model use the load_validate utilities.\n    \"\"\"\n    root_model_path = ModelUtils._root_path_for_top_level_model(trestle_root, model_name, model_class)\n    if file_content_type is None:\n        file_content_type = FileContentType.path_to_content_type(root_model_path)\n    if not FileContentType.is_readable_file(file_content_type):\n        raise TrestleError(f'Unable to load model {model_name} without specifying json or yaml.')\n    full_model_path = root_model_path.with_suffix(FileContentType.to_file_extension(file_content_type))\n    _, _, model = ModelUtils.load_distributed(full_model_path, trestle_root)\n    return model, full_model_path\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.load_model_for_type","title":"<code>load_model_for_type(trestle_root, model_type, model_name)</code>  <code>staticmethod</code>","text":"<p>Load model for the given type and name.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef load_model_for_type(trestle_root: pathlib.Path, model_type: str, model_name: str) -&gt; Tuple[TG, pathlib.Path]:\n\"\"\"Load model for the given type and name.\"\"\"\n    dir_name = ModelUtils.model_type_to_model_dir(model_type)\n    model_path = trestle_root / dir_name / model_name\n\n    if not model_path.exists():\n        raise TrestleError(f'No model is found at path: {model_path}.')\n\n    _, _, oscal_object = ModelUtils.load_distributed(model_path, trestle_root)\n\n    return oscal_object, model_path\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.model_age","title":"<code>model_age(model)</code>  <code>staticmethod</code>","text":"<p>Find time in seconds since LastModified timestamp.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef model_age(model: TopLevelOscalModel) -&gt; int:\n\"\"\"Find time in seconds since LastModified timestamp.\"\"\"\n    # default to one year if no last_modified\n    age_seconds = const.DAY_SECONDS * 365\n    if model.metadata.last_modified:\n        dt = datetime.now().astimezone() - model.metadata.last_modified\n        age_seconds = dt.seconds\n    return age_seconds\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.model_type_to_model_dir","title":"<code>model_type_to_model_dir(model_type)</code>  <code>staticmethod</code>","text":"<p>Get plural model directory from model type.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef model_type_to_model_dir(model_type: str) -&gt; str:\n\"\"\"Get plural model directory from model type.\"\"\"\n    if model_type not in const.MODEL_TYPE_LIST:\n        raise err.TrestleError(f'Not a valid model type: {model_type}.')\n    return const.MODEL_TYPE_TO_MODEL_DIR[model_type]\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.models_are_equivalent","title":"<code>models_are_equivalent(model_a, model_b, ignore_all_uuid=False)</code>  <code>staticmethod</code>","text":"<p>Test if models are equivalent except for last modified and possibly uuid.</p> <p>If a model has had uuids regenerated, then all uuids and references to them are updated.  This means that special handling is required if a model has had uuids regenerated - when checking equivalence.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef models_are_equivalent(\n    model_a: Optional[TopLevelOscalModel],\n    model_b: Optional[TopLevelOscalModel],\n    ignore_all_uuid: bool = False\n) -&gt; bool:\n\"\"\"\n    Test if models are equivalent except for last modified and possibly uuid.\n\n    If a model has had uuids regenerated, then all uuids *and references to them* are updated.  This means that\n    special handling is required if a model has had uuids regenerated - when checking equivalence.\n    \"\"\"\n    uuid_type_list = [\n        common.LastModified,\n        common.LocationUuid,\n        common.PartyUuid,\n        common.RelatedRisk,\n        common.Source,\n        assessment_plan.RelatedObservation,\n        assessment_results.RelatedObservation,\n        poam.RelatedObservation,\n        poam.RelatedObservation1\n    ]\n    type_list = uuid_type_list if ignore_all_uuid else [common.LastModified]\n    return not ModelUtils._objects_differ(model_a, model_b, type_list, ['last_modified'], ignore_all_uuid)\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.parameter_to_dict","title":"<code>parameter_to_dict(obj, partial)</code>  <code>staticmethod</code>","text":"<p>Convert obj to dict containing only string values, storing only the fields that have values set.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[trestle.core.base_model.OscalBaseModel, str]</code> <p>The parameter or its consituent parts in recursive calls</p> required <code>partial</code> <code>bool</code> <p>Whether to convert the entire param or just the parts needed for markdown header</p> required <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The converted parameter as dictionary, with values as None if not present</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef parameter_to_dict(obj: Union[OscalBaseModel, str], partial: bool) -&gt; Union[str, Dict[str, Any]]:\n\"\"\"\n    Convert obj to dict containing only string values, storing only the fields that have values set.\n\n    Args:\n        obj: The parameter or its consituent parts in recursive calls\n        partial: Whether to convert the entire param or just the parts needed for markdown header\n\n    Returns:\n        The converted parameter as dictionary, with values as None if not present\n    \"\"\"\n    res = ModelUtils._parameter_to_dict_recurse(obj, partial)\n    if 'values' not in res:\n        res['values'] = None\n    return res\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.regenerate_uuids","title":"<code>regenerate_uuids(object_of_interest)</code>  <code>staticmethod</code>","text":"<p>Regenerate all uuids in object and update corresponding references.</p> <p>Find all dicts with key == 'uuid' and replace the value with a new uuid4. Build a corresponding lookup table as you go, of old:new uuid values. Then make a second pass through the object and replace all string values present in the lookup table with the new value.</p> <p>Parameters:</p> Name Type Description Default <code>object_of_interest</code> <code>Any</code> <p>pydantic.BaseModel, list, dict or str will be updated</p> required <p>Returns:</p> Type Description <code>The updated object with new uuid's and refs The final lookup table of old</code> <p>new uuid's A count of the number of refs that were updated</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef regenerate_uuids(object_of_interest: Any) -&gt; Tuple[Any, Dict[str, str], int]:\n\"\"\"Regenerate all uuids in object and update corresponding references.\n\n    Find all dicts with key == 'uuid' and replace the value with a new uuid4.\n    Build a corresponding lookup table as you go, of old:new uuid values.\n    Then make a second pass through the object and replace all string values\n    present in the lookup table with the new value.\n\n    Args:\n        object_of_interest: pydantic.BaseModel, list, dict or str will be updated\n\n    Returns:\n        The updated object with new uuid's and refs\n        The final lookup table of old:new uuid's\n        A count of the number of refs that were updated\n    \"\"\"\n    new_object, uuid_lut = ModelUtils._regenerate_uuids_in_place(object_of_interest, {})\n    new_object, n_refs_updated = ModelUtils._update_new_uuid_refs(new_object, uuid_lut)\n    return new_object, uuid_lut, n_refs_updated\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.save_top_level_model","title":"<code>save_top_level_model(model, trestle_root, model_name, file_content_type)</code>  <code>staticmethod</code>","text":"<p>Save a model by name and infer model type by inspection.</p> <p>You don't need to specify the model type (catalog, profile, etc.) but you must specify the file content type. If the model directory does not exist, it is created.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef save_top_level_model(\n    model: TopLevelOscalModel, trestle_root: pathlib.Path, model_name: str, file_content_type: FileContentType\n) -&gt; None:\n\"\"\"Save a model by name and infer model type by inspection.\n\n    You don't need to specify the model type (catalog, profile, etc.) but you must specify the file content type.\n    If the model directory does not exist, it is created.\n    \"\"\"\n    root_model_path = ModelUtils._root_path_for_top_level_model(trestle_root, model_name, model)\n    full_model_path = root_model_path.with_suffix(FileContentType.to_file_extension(file_content_type))\n    if not full_model_path.parent.exists():\n        full_model_path.parent.mkdir(parents=True, exist_ok=True)\n    model.oscal_write(full_model_path)\n</code></pre>"},{"location":"api_reference/trestle.common.model_utils/#trestle.common.model_utils.ModelUtils.update_last_modified","title":"<code>update_last_modified(model, timestamp=None)</code>  <code>staticmethod</code>","text":"<p>Update the LastModified timestamp in top level model to now.</p> Source code in <code>trestle/common/model_utils.py</code> <pre><code>@staticmethod\ndef update_last_modified(model: TopLevelOscalModel, timestamp: Optional[datetime] = None) -&gt; None:\n\"\"\"Update the LastModified timestamp in top level model to now.\"\"\"\n    timestamp = timestamp if timestamp else datetime.now().astimezone()\n    model.metadata.last_modified = timestamp\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/","title":"str_utils","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils","title":"<code>trestle.common.str_utils</code>","text":"<p>Trestle String Utils.</p>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils-classes","title":"Classes","text":""},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.AliasMode","title":"<code> AliasMode            (Enum)         </code>","text":"<p>Allowed formats for classname alias.</p> <p>Currently there are only two.  If others are added, check they get handled properly in the code.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>class AliasMode(enum.Enum):\n\"\"\"\n    Allowed formats for classname alias.\n\n    Currently there are only two.  If others are added, check they get handled properly in the code.\n    \"\"\"\n\n    JSON = 1\n    FIELD = 2\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.AliasMode.FIELD","title":"<code>FIELD</code>","text":""},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.AliasMode.JSON","title":"<code>JSON</code>","text":""},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils-functions","title":"Functions","text":""},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.alias_to_classname","title":"<code>alias_to_classname(alias, mode)</code>","text":"<p>Return class name based dashed or snake alias.</p> <p>This is applicable creating dynamic wrapper model for a list or dict field.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>def alias_to_classname(alias: str, mode: AliasMode) -&gt; str:\n\"\"\"\n    Return class name based dashed or snake alias.\n\n    This is applicable creating dynamic wrapper model for a list or dict field.\n    \"\"\"\n    if mode == AliasMode.JSON:\n        return _snake_to_upper_camel(alias.replace('-', '_'))\n    return _snake_to_upper_camel(alias)\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.as_string","title":"<code>as_string(string_or_none)</code>","text":"<p>Convert string or None to itself or empty string.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>def as_string(string_or_none: Optional[str]) -&gt; str:\n\"\"\"Convert string or None to itself or empty string.\"\"\"\n    return string_or_none if string_or_none else ''\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.classname_to_alias","title":"<code>classname_to_alias(classname, mode)</code>","text":"<p>Return oscal key name or field element name based on class name.</p> <p>This is applicable when asking for a singular element.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>def classname_to_alias(classname: str, mode: AliasMode) -&gt; str:\n\"\"\"\n    Return oscal key name or field element name based on class name.\n\n    This is applicable when asking for a singular element.\n    \"\"\"\n    suffix = classname.split('.')[-1]\n\n    # the alias mode is either json or field - yaml doesn't apply here\n    if mode == AliasMode.JSON:\n        # things like class_ should just be class\n        if suffix[-1] == '_':\n            suffix = suffix[:-1]\n        return _camel_to_dash(suffix).rstrip(string.digits)\n    # else alias mode is field\n    return _camel_to_snake(suffix).rstrip(string.digits)\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.dash_to_underscore","title":"<code>dash_to_underscore(name)</code>","text":"<p>Convert dash to underscore.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>def dash_to_underscore(name: str) -&gt; str:\n\"\"\"Convert dash to underscore.\"\"\"\n    return name.replace('-', '_')\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.spaces_and_caps_to_lower_single_spaces","title":"<code>spaces_and_caps_to_lower_single_spaces(spaced_str)</code>","text":"<p>Convert caps and duplicate spaces to lower with single spaces.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>def spaces_and_caps_to_lower_single_spaces(spaced_str: str) -&gt; str:\n\"\"\"Convert caps and duplicate spaces to lower with single spaces.\"\"\"\n    single_space = ' '.join(spaced_str.strip().split())\n    return single_space.lower()\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.spaces_and_caps_to_snake","title":"<code>spaces_and_caps_to_snake(spaced_str)</code>","text":"<p>Convert caps and spaces to snake.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>def spaces_and_caps_to_snake(spaced_str: str) -&gt; str:\n\"\"\"Convert caps and spaces to snake.\"\"\"\n    underscored = '_'.join(spaced_str.strip().split())\n    return underscored.lower()\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.string_from_root","title":"<code>string_from_root(item_with_root)</code>","text":"<p>Convert root to string if present.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>def string_from_root(item_with_root: Optional[Any]) -&gt; str:\n\"\"\"Convert root to string if present.\"\"\"\n    return as_string(item_with_root.__root__) if item_with_root else ''\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.strip_lower_equals","title":"<code>strip_lower_equals(str_a, str_b)</code>","text":"<p>Safe test of lower string equality allowing Nones.</p> <p>If either argument is None the result is False because the intent is to report if they are equal as actual strings.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>def strip_lower_equals(str_a: Optional[str], str_b: Optional[str]) -&gt; bool:\n\"\"\"\n    Safe test of lower string equality allowing Nones.\n\n    If either argument is None the result is False because the intent is to report if they are equal as actual strings.\n    \"\"\"\n    if str_a is None or str_b is None:\n        return False\n    return str_a.strip().lower() == str_b.strip().lower()\n</code></pre>"},{"location":"api_reference/trestle.common.str_utils/#trestle.common.str_utils.underscore_to_dash","title":"<code>underscore_to_dash(name)</code>","text":"<p>Convert underscore to dash and drop final dash if present.</p> Source code in <code>trestle/common/str_utils.py</code> <pre><code>def underscore_to_dash(name: str) -&gt; str:\n\"\"\"Convert underscore to dash and drop final dash if present.\"\"\"\n    converted = name.replace('_', '-')\n    return converted if converted[-1] != '-' else converted[:-1]\n</code></pre>"},{"location":"api_reference/trestle.common.trash/","title":"trash","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash","title":"<code>trestle.common.trash</code>","text":"<p>Trestle trash module.</p>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.TRESTLE_TRASH_DIR","title":"<code>TRESTLE_TRASH_DIR</code>","text":""},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.TRESTLE_TRASH_DIR_EXT","title":"<code>TRESTLE_TRASH_DIR_EXT</code>","text":""},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.TRESTLE_TRASH_FILE_EXT","title":"<code>TRESTLE_TRASH_FILE_EXT</code>","text":""},{"location":"api_reference/trestle.common.trash/#trestle.common.trash-functions","title":"Functions","text":""},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.get_trash_root","title":"<code>get_trash_root(path)</code>","text":"<p>Find the trestle trash root path.</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def get_trash_root(path: pathlib.Path) -&gt; Optional[pathlib.Path]:\n\"\"\"Find the trestle trash root path.\"\"\"\n    if path is None or len(path.parts) &lt;= 0:\n        return None\n\n    current = path\n    while len(current.parts) &gt; 1:  # it must not be the system root directory\n        trash_dir = current / TRESTLE_TRASH_DIR\n        if trash_dir.exists() and trash_dir.is_dir():\n            return trash_dir\n        current = current.parent\n\n    return None\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.has_parent_path","title":"<code>has_parent_path(sub_path, parent_path)</code>","text":"<p>Check if sub_path has the specified parent_dir path.</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def has_parent_path(sub_path: pathlib.Path, parent_path: pathlib.Path) -&gt; bool:\n\"\"\"Check if sub_path has the specified parent_dir path.\"\"\"\n    # sub_path should be longer than parent path\n    if len(sub_path.parts) &lt; len(parent_path.parts):\n        return False\n\n    for i, part in enumerate(parent_path.parts):\n        if part != sub_path.parts[i]:\n            return False\n    return True\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.recover","title":"<code>recover(dest_content_path, delete_trash=False)</code>","text":"<p>Recover the specified file or directory from the trash directory.</p> <p>dest_content_path: destination content path that needs to be recovered from trash It recovers the latest path content from trash if exists</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def recover(dest_content_path: pathlib.Path, delete_trash: bool = False) -&gt; None:\n\"\"\"Recover the specified file or directory from the trash directory.\n\n    dest_content_path: destination content path that needs to be recovered from trash\n    It recovers the latest path content from trash if exists\n    \"\"\"\n    if dest_content_path.suffix != '':\n        return recover_file(dest_content_path, delete_trash)\n    return recover_dir(dest_content_path, delete_trash)\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.recover_dir","title":"<code>recover_dir(dest_dir_path, delete_trash=False)</code>","text":"<p>Move the specified dir from the trash directory.</p> <p>dest_dir_path: destination path of the directory inside a trestle workspace</p> <p>It recovers the latest directory and contents from trash if exists</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def recover_dir(dest_dir_path: pathlib.Path, delete_trash: bool = False) -&gt; None:\n\"\"\"Move the specified dir from the trash directory.\n\n    dest_dir_path: destination path of the directory inside a trestle workspace\n\n    It recovers the latest directory and contents from trash if exists\n    \"\"\"\n    trash_dir_path = to_trash_dir_path(dest_dir_path)\n    if not (trash_dir_path.exists() and trash_dir_path.is_dir()):\n        raise AssertionError(f'Specified path \"{dest_dir_path}\" could not be found in trash')\n\n    # move all files/directories under sub_path\n    for item_path in pathlib.Path.iterdir(trash_dir_path):\n        if item_path.is_file():\n            recover_file(to_origin_file_path(item_path), delete_trash)\n        elif item_path.is_dir():\n            recover_dir(to_origin_dir_path(item_path), delete_trash)\n\n    if delete_trash:\n        trash_dir_path.rmdir()\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.recover_file","title":"<code>recover_file(file_path, delete_trash=False)</code>","text":"<p>Recover the specified file from the trash directory.</p> <p>It recovers the latest file from trash if exists</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def recover_file(file_path: pathlib.Path, delete_trash: bool = False) -&gt; None:\n\"\"\"Recover the specified file from the trash directory.\n\n    It recovers the latest file from trash if exists\n    \"\"\"\n    trash_file_path = to_trash_file_path(file_path)\n    if not trash_file_path.exists():\n        raise AssertionError(f'Specified path \"{file_path}\" could not be found in trash')\n\n    file_path.parent.mkdir(exist_ok=True, parents=True)\n    copyfile(trash_file_path, file_path)\n\n    if delete_trash:\n        trash_file_path.unlink()\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.store","title":"<code>store(content_path, delete_content=False)</code>","text":"<p>Move the specified file or directory to the trash directory.</p> <p>It overwrites the previous file or directory if exists</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def store(content_path: pathlib.Path, delete_content: bool = False) -&gt; None:\n\"\"\"Move the specified file or directory to the trash directory.\n\n    It overwrites the previous file or directory if exists\n    \"\"\"\n    if content_path.is_file():\n        return store_file(content_path, delete_content)\n    if content_path.is_dir():\n        return store_dir(content_path, delete_content)\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.store_dir","title":"<code>store_dir(dir_path, delete_source=False)</code>","text":"<p>Move the specified dir to the trash directory.</p> <p>It overwrites the previous directory and contents if exists</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def store_dir(dir_path: pathlib.Path, delete_source: bool = False) -&gt; None:\n\"\"\"Move the specified dir to the trash directory.\n\n    It overwrites the previous directory and contents if exists\n    \"\"\"\n    if not dir_path.is_dir():\n        raise AssertionError(f'Specified path \"{dir_path}\" is not a dir')\n\n    # move all files/directories under sub_path\n    for item_path in pathlib.Path.iterdir(dir_path):\n        if item_path.is_file():\n            store_file(item_path, delete_source)\n        elif item_path.is_dir():\n            store_dir(item_path, delete_source)\n\n    if delete_source:\n        dir_path.rmdir()\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.store_file","title":"<code>store_file(file_path, delete_source=False)</code>","text":"<p>Move the specified file to the trash directory.</p> <p>It overwrites the previous file if exists</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def store_file(file_path: pathlib.Path, delete_source: bool = False) -&gt; None:\n\"\"\"Move the specified file to the trash directory.\n\n    It overwrites the previous file if exists\n    \"\"\"\n    if not file_path.is_file():\n        raise AssertionError(f'Specified path \"{file_path}\" is not a file')\n\n    trash_file_path = to_trash_file_path(file_path)\n    trash_file_path.parent.mkdir(exist_ok=True, parents=True)\n    copyfile(file_path, trash_file_path)\n\n    if delete_source:\n        file_path.unlink()\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.to_origin_dir_path","title":"<code>to_origin_dir_path(trash_dir_path)</code>","text":"<p>Convert trash content path to origin path.</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def to_origin_dir_path(trash_dir_path: pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Convert trash content path to origin path.\"\"\"\n    if trash_dir_path.suffix != '' and trash_dir_path.suffix.endswith(TRESTLE_TRASH_FILE_EXT):\n        raise AssertionError(f'Given path \"{trash_dir_path}\" is a trash file, not a valid trash directory')\n\n    trestle_root = file_utils.extract_trestle_project_root(trash_dir_path)\n    if trestle_root is None:\n        raise AssertionError(f'Directory path \"{trash_dir_path}\" is not in a valid trestle project path')\n\n    trash_root = get_trash_root(trash_dir_path)\n    if trash_root is None:\n        raise AssertionError(f'Directory path \"{trash_dir_path}\" is not in a valid trestle trash path')\n\n    if not has_parent_path(trash_dir_path, trash_root):\n        raise AssertionError(f'Directory path \"{trash_dir_path}\" is not a valid trash dir path')\n\n    relative_path = trash_dir_path.relative_to(str(trash_root))\n\n    origin_path_parts: List[str] = []\n    for item in relative_path.parts:\n        parts = item.split(TRESTLE_TRASH_DIR_EXT)\n        origin_path_parts.append(parts[0])\n\n    origin_relative_path = pathlib.Path('/'.join(origin_path_parts))\n    origin_path = trestle_root / origin_relative_path\n    return origin_path\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.to_origin_file_path","title":"<code>to_origin_file_path(trash_file_path)</code>","text":"<p>Convert trash file path to origin file path.</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def to_origin_file_path(trash_file_path: pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Convert trash file path to origin file path.\"\"\"\n    if trash_file_path.suffix != TRESTLE_TRASH_FILE_EXT:\n        raise AssertionError(f'File path \"{trash_file_path}\" is not a valid trash file path')\n\n    origin_dir = to_origin_dir_path(trash_file_path.parent)\n    file_parts = trash_file_path.name.split(TRESTLE_TRASH_FILE_EXT)\n    origin_file_path = origin_dir / file_parts[0]\n\n    return origin_file_path\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.to_origin_path","title":"<code>to_origin_path(trash_content_path)</code>","text":"<p>Convert the trash path to origin path.</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def to_origin_path(trash_content_path: pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Convert the trash path to origin path.\"\"\"\n    if trash_content_path.suffix == TRESTLE_TRASH_FILE_EXT:\n        return to_origin_file_path(trash_content_path)\n    return to_origin_dir_path(trash_content_path)\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.to_trash_dir_path","title":"<code>to_trash_dir_path(dir_path)</code>","text":"<p>Construct the path to the trashed file.</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def to_trash_dir_path(dir_path: pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Construct the path to the trashed file.\"\"\"\n    absolute_path = dir_path.resolve()\n    root_path = file_utils.extract_trestle_project_root(absolute_path)\n    if root_path is None:\n        raise AssertionError(f'Directory path \"{absolute_path}\" is not in a valid trestle project')\n\n    trestle_trash_path = root_path / TRESTLE_TRASH_DIR\n\n    relative_path = absolute_path.relative_to(str(root_path))\n    if len(relative_path.parts) == 0:\n        trash_dir = trestle_trash_path\n    else:\n        trash_dir = trestle_trash_path / f'{relative_path}{TRESTLE_TRASH_DIR_EXT}'\n\n    return trash_dir\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.to_trash_file_path","title":"<code>to_trash_file_path(file_path)</code>","text":"<p>Construct the path to the trashed file.</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def to_trash_file_path(file_path: pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Construct the path to the trashed file.\"\"\"\n    trash_file_dir = to_trash_dir_path(file_path.parent)\n    trash_file_path = trash_file_dir / f'{file_path.name}{TRESTLE_TRASH_FILE_EXT}'\n\n    return trash_file_path\n</code></pre>"},{"location":"api_reference/trestle.common.trash/#trestle.common.trash.to_trash_path","title":"<code>to_trash_path(path)</code>","text":"<p>Convert the dir or file path to apporpriate trash file or dir path.</p> Source code in <code>trestle/common/trash.py</code> <pre><code>def to_trash_path(path: pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Convert the dir or file path to apporpriate trash file or dir path.\"\"\"\n    if path.suffix != '':\n        return to_trash_file_path(path)\n    return to_trash_dir_path(path)\n</code></pre>"},{"location":"api_reference/trestle.common.type_utils/","title":"type_utils","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.common.type_utils/#trestle.common.type_utils","title":"<code>trestle.common.type_utils</code>","text":"<p>Utilities for dealing with models.</p>"},{"location":"api_reference/trestle.common.type_utils/#trestle.common.type_utils.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.common.type_utils/#trestle.common.type_utils-functions","title":"Functions","text":""},{"location":"api_reference/trestle.common.type_utils/#trestle.common.type_utils.get_inner_type","title":"<code>get_inner_type(collection_field_type)</code>","text":"<p>Get the inner model in a generic collection model such as a List or a Dict.</p> <p>For a dict the return type is of the value and not the key.</p> <p>Parameters:</p> Name Type Description Default <code>collection_field_type</code> <code>Union[Type[List[Any]], Type[Dict[str, Any]]]</code> <p>Provided type annotation from a pydantic object</p> required <p>Returns:</p> Type Description <code>Type[Any]</code> <p>The desired type.</p> Source code in <code>trestle/common/type_utils.py</code> <pre><code>def get_inner_type(collection_field_type: Union[Type[List[Any]], Type[Dict[str, Any]]]) -&gt; Type[Any]:\n\"\"\"Get the inner model in a generic collection model such as a List or a Dict.\n\n    For a dict the return type is of the value and not the key.\n\n    Args:\n        collection_field_type: Provided type annotation from a pydantic object\n\n    Returns:\n        The desired type.\n    \"\"\"\n    try:\n        # Pydantic special cases must be dealt with here:\n        _, _, singular_type = _get_model_field_info(collection_field_type)\n        if singular_type is not None:\n            return singular_type\n        return typing_extensions.get_args(collection_field_type)[-1]\n    except Exception as e:\n        logger.debug(e)\n        raise err.TrestleError('Model type is not a Dict or List') from e\n</code></pre>"},{"location":"api_reference/trestle.common.type_utils/#trestle.common.type_utils.get_origin","title":"<code>get_origin(field_type)</code>","text":"<p>Generalized and robust get_origin function.</p> <p>This function is derived from work by pydantic, however, avoids complications from various python versions.</p> Source code in <code>trestle/common/type_utils.py</code> <pre><code>def get_origin(field_type: Type[Any]) -&gt; Optional[Type[Any]]:\n\"\"\"Generalized and robust get_origin function.\n\n    This function is derived from work by pydantic, however, avoids complications\n    from various python versions.\n    \"\"\"\n    # This executes a fallback that allows a list to be generated from a constrained list.\n    return typing_extensions.get_origin(field_type) or getattr(field_type, '__origin__', None)\n</code></pre>"},{"location":"api_reference/trestle.common.type_utils/#trestle.common.type_utils.is_collection_field_type","title":"<code>is_collection_field_type(field_type)</code>","text":"<p>Check whether a type hint is a collection type as used by OSCAL.</p> <p>Specifically this is whether the type is a list or not.</p> <p>Parameters:</p> Name Type Description Default <code>field_type</code> <code>Type[Any]</code> <p>A type or a type alias of a field typically as served via pydantic introspection</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it is a collection type list.</p> Source code in <code>trestle/common/type_utils.py</code> <pre><code>def is_collection_field_type(field_type: Type[Any]) -&gt; bool:\n\"\"\"Check whether a type hint is a collection type as used by OSCAL.\n\n    Specifically this is whether the type is a list or not.\n\n    Args:\n        field_type: A type or a type alias of a field typically as served via pydantic introspection\n\n    Returns:\n        True if it is a collection type list.\n    \"\"\"\n    # first check if it is a pydantic __root__ object\n    _, root_type, _ = _get_model_field_info(field_type)\n    if root_type == 'List':\n        return True\n    # Retrieves type from a type annotation\n    origin_type = get_origin(field_type)\n    return origin_type == list\n</code></pre>"},{"location":"api_reference/trestle.core.all_validator/","title":"all_validator","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.all_validator/#trestle.core.all_validator","title":"<code>trestle.core.all_validator</code>","text":"<p>Validate based on all registered validators.</p>"},{"location":"api_reference/trestle.core.all_validator/#trestle.core.all_validator-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.all_validator/#trestle.core.all_validator.AllValidator","title":"<code> AllValidator            (Validator)         </code>","text":"<p>Validator to confirm the model passes all registered validation tests.</p> Source code in <code>trestle/core/all_validator.py</code> <pre><code>class AllValidator(Validator):\n\"\"\"Validator to confirm the model passes all registered validation tests.\"\"\"\n\n    last_failure_msg: str\n\n    def error_msg(self) -&gt; str:\n\"\"\"Return information on which validation failed.\"\"\"\n        return self.last_failure_msg\n\n    def model_is_valid(self, model: OscalBaseModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None) -&gt; bool:\n\"\"\"\n        Validate an oscal model against all available validators in the trestle library.\n\n        args:\n            model: An Oscal model that can be passed to the validator.\n            quiet: Don't report msgs unless invalid.\n\n        returns:\n            True (valid) if the model passed all registered validators.\n        \"\"\"\n        self.last_failure_msg = self.__doc__\n        for val in vfact.validator_factory.get_all():\n            if val != self and not val.model_is_valid(model, quiet, trestle_root):\n                self.last_failure_msg = val.error_msg()\n                return False\n        return True\n</code></pre>"},{"location":"api_reference/trestle.core.all_validator/#trestle.core.all_validator.AllValidator-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.all_validator/#trestle.core.all_validator.AllValidator.error_msg","title":"<code>error_msg(self)</code>","text":"<p>Return information on which validation failed.</p> Source code in <code>trestle/core/all_validator.py</code> <pre><code>def error_msg(self) -&gt; str:\n\"\"\"Return information on which validation failed.\"\"\"\n    return self.last_failure_msg\n</code></pre>"},{"location":"api_reference/trestle.core.all_validator/#trestle.core.all_validator.AllValidator.model_is_valid","title":"<code>model_is_valid(self, model, quiet, trestle_root=None)</code>","text":"<p>Validate an oscal model against all available validators in the trestle library.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>OscalBaseModel</code> <p>An Oscal model that can be passed to the validator.</p> required <code>quiet</code> <code>bool</code> <p>Don't report msgs unless invalid.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True (valid) if the model passed all registered validators.</p> Source code in <code>trestle/core/all_validator.py</code> <pre><code>def model_is_valid(self, model: OscalBaseModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None) -&gt; bool:\n\"\"\"\n    Validate an oscal model against all available validators in the trestle library.\n\n    args:\n        model: An Oscal model that can be passed to the validator.\n        quiet: Don't report msgs unless invalid.\n\n    returns:\n        True (valid) if the model passed all registered validators.\n    \"\"\"\n    self.last_failure_msg = self.__doc__\n    for val in vfact.validator_factory.get_all():\n        if val != self and not val.model_is_valid(model, quiet, trestle_root):\n            self.last_failure_msg = val.error_msg()\n            return False\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/","title":"base_model","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model","title":"<code>trestle.core.base_model</code>","text":"<p>Pydantic base model for use within a trestle workspace and associated configuration.</p> <p>The heart of the current OSCAL model within trestle is based on pydantic (https://pydantic-docs.helpmanual.io/) which itself is a veneer on-top of python data classes.</p> <p>Functionality here defines a base-model which all trestle oscal data models inherit from. This allows additional functionality to be easily inserted.</p> <p>I can write a comment in here and you can even edit on the same line.</p>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel","title":"<code> OscalBaseModel            (TrestleBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Trestle defined pydantic base model for use with OSCAL pydantic dataclasses.</p> <p>This BaseModel provides two types of functionality: 1. Overrides default configuation of the pydantic library with behaviours required for trestle 2. Provides utility functions for trestle which are specific to OSCAL and the naming schema associated with it.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>class OscalBaseModel(TrestleBaseModel):\n\"\"\"\n    Trestle defined pydantic base model for use with OSCAL pydantic dataclasses.\n\n    This BaseModel provides two types of functionality:\n    1. Overrides default configuation of the pydantic library with behaviours required for trestle\n    2. Provides utility functions for trestle which are specific to OSCAL and the naming schema associated with it.\n    \"\"\"\n\n    class Config:\n\"\"\"Overriding configuration class for pydantic base model, for use with OSCAL data classes.\"\"\"\n\n        json_loads = orjson.loads\n        # TODO: json_dumps with orjson.dumps see #840\n\n        json_encoders = {datetime.datetime: lambda x: robust_datetime_serialization(x)}\n        allow_population_by_field_name = True\n\n        # Enforce strict schema\n        extra = Extra.forbid\n\n        # Validate on assignment of variables to ensure no escapes\n        validate_assignment = True\n\n    @classmethod\n    def create_stripped_model_type(\n        cls,\n        stripped_fields: Optional[List[str]] = None,\n        stripped_fields_aliases: Optional[List[str]] = None\n    ) -&gt; Type['OscalBaseModel']:\n\"\"\"Create a pydantic model, which is derived from the current model, but missing certain fields.\n\n        OSCAL mandates a 'strict' schema (e.g. unless otherwise stated no additional fields), and certain fields\n        are mandatory. Given this the corresponding dataclasses are also strict. Workflows with trestle require missing\n        mandatory fields. This allows creation of derivative models missing certain fields.\n\n        Args:\n            stripped_fields: The fields to be removed from the current data class.\n            stripped_fields_aliases: The fields to be removed from the current data class provided by alias.\n\n        Returns:\n            Pydantic data class thta can be used to instanciate a model.\n\n        Raises:\n            TrestleError: If user provided both stripped_fields and stripped_field_aliases or neither.\n            TrestleError: If incorrect aliases or field names are provided.\n        \"\"\"\n        if stripped_fields is not None and stripped_fields_aliases is not None:\n            raise err.TrestleError('Either \"stripped_fields\" or \"stripped_fields_aliases\" need to be passed, not both.')\n        if stripped_fields is None and stripped_fields_aliases is None:\n            raise err.TrestleError('Exactly one of \"stripped_fields\" or \"stripped_fields_aliases\" must be provided')\n\n        # create alias to field_name mapping\n        excluded_fields = []\n        if stripped_fields is not None:\n            excluded_fields = stripped_fields\n        elif stripped_fields_aliases is not None:\n            alias_to_field = cls.alias_to_field_map()\n            try:\n                excluded_fields = [alias_to_field[key].name for key in stripped_fields_aliases]\n            except KeyError as e:\n                raise err.TrestleError(f'Field {str(e)} does not exist in the model')\n\n        current_fields = cls.__fields__\n        new_fields_for_model = {}\n        # Build field list\n        for current_mfield in current_fields.values():\n            if current_mfield.name in excluded_fields:\n                continue\n            # Validate name in the field\n            # Cehcke behaviour with an alias\n            if current_mfield.required:\n                new_fields_for_model[\n                    current_mfield.name\n                ] = (current_mfield.outer_type_, Field(..., title=current_mfield.name, alias=current_mfield.alias))\n            else:\n                new_fields_for_model[current_mfield.name] = (\n                    Optional[current_mfield.outer_type_],\n                    Field(None, title=current_mfield.name, alias=current_mfield.alias)\n                )\n        new_model = create_model(cls.__name__, __base__=OscalBaseModel, **new_fields_for_model)  # type: ignore\n        # TODO: This typing cast should NOT be necessary. Potentially fixable with a fix to pydantic. Issue #175\n        new_model = cast(Type[OscalBaseModel], new_model)\n\n        return new_model\n\n    def get_field_by_alias(self, field_alias: str) -&gt; Any:\n\"\"\"Convert field alias to a field.\"\"\"\n        attr_field = self.alias_to_field_map().get(field_alias, None)\n        return attr_field\n\n    def get_field_value_by_alias(self, attr_alias: str) -&gt; Optional[Any]:\n\"\"\"Get attribute value by field alias.\"\"\"\n        # TODO: can this be restricted beyond Any easily.\n        attr_field = self.get_field_by_alias(attr_alias)\n        if isinstance(attr_field, ModelField):\n            return getattr(self, attr_field.name, None)\n\n        return None\n\n    def stripped_instance(\n        self, stripped_fields: List[str] = None, stripped_fields_aliases: List[str] = None\n    ) -&gt; 'OscalBaseModel':\n\"\"\"Return a new model instance with the specified fields being stripped.\n\n        Args:\n            stripped_fields: The fields to be removed from the current data class.\n            stripped_fields_aliases: The fields to be removed from the current data class provided by alias.\n\n        Returns:\n            The current datamodel with the fields provided removed in a derivate (run time created) data model.\n\n        Raises:\n            err.TrestleError: If user provided both stripped_fields and stripped_field_aliases or neither.\n            err.TrestleError: If incorrect aliases or field names are provided.\n        \"\"\"\n        # stripped class type\n        stripped_class: Type[OscalBaseModel] = self.create_stripped_model_type(\n            stripped_fields=stripped_fields, stripped_fields_aliases=stripped_fields_aliases\n        )\n\n        # remaining values\n        remaining_values = {}\n        for field in self.__fields__.values():\n            if field.name in stripped_class.__fields__:\n                remaining_values[field.name] = self.__dict__[field.name]\n\n        # create stripped model instance\n        # TODO: Not sure if we can avoid type escapes here\n        stripped_instance = stripped_class(**remaining_values)  # type: ignore\n\n        return stripped_instance\n\n    def oscal_dict(self) -&gt; Dict[str, Any]:\n\"\"\"Return a dictionary including the root wrapping object key.\"\"\"\n        class_name = self.__class__.__name__\n        result = {}\n        raw_dict = self.dict(by_alias=True, exclude_none=True)\n        # Additional check to avoid root serialization\n        if '__root__' in raw_dict.keys():\n            result[classname_to_alias(class_name, AliasMode.JSON)] = raw_dict['__root__']\n        else:\n            result[classname_to_alias(class_name, AliasMode.JSON)] = raw_dict\n        return result\n\n    def oscal_serialize_json_bytes(self, pretty: bool = False, wrapped: bool = True) -&gt; bytes:\n\"\"\"\n        Return an 'oscal wrapped' json object serialized in a compressed form as bytes.\n\n        Args:\n            pretty: Whether or not to pretty-print json output or have in compressed form.\n        Returns:\n            Oscal model serialized to a json object including packaging inside of a single top level key.\n        \"\"\"\n        if wrapped:\n            odict = self.oscal_dict()\n        else:\n            odict = self.dict(by_alias=True, exclude_none=True)\n        if pretty:\n            return orjson.dumps(odict, default=self.__json_encoder__, option=orjson.OPT_INDENT_2)\n        return orjson.dumps(odict, default=self.__json_encoder__)\n\n    def oscal_serialize_json(self, pretty: bool = False, wrapped: bool = True) -&gt; str:\n\"\"\"\n        Return an 'oscal wrapped' json object serialized in a compressed form as bytes.\n\n        Args:\n            pretty: Whether or not to pretty-print json output or have in compressed form.\n        Returns:\n            Oscal model serialized to a json object including packaging inside of a single top level key.\n        \"\"\"\n        # This function is provided for backwards compatibility\n        return self.oscal_serialize_json_bytes(pretty, wrapped).decode(const.FILE_ENCODING)\n\n    def oscal_write(self, path: pathlib.Path) -&gt; None:\n\"\"\"\n        Write out a pydantic data model in an oscal friendly way.\n\n        OSCAL schema mandates that top level elements are wrapped in a singular\n        json/yaml field. This function handles both json and yaml output as well\n        as formatting of the json.\n\n        Args:\n            path: The output file location for the oscal object.\n\n        Raises:\n            err.TrestleError: If a unknown file extension is provided.\n        \"\"\"\n        content_type = FileContentType.to_content_type(path.suffix)\n        # The output will have \\r\\n newlines on windows and \\n newlines elsewhere\n\n        if content_type == FileContentType.YAML:\n            write_file = pathlib.Path(path).open('w', encoding=const.FILE_ENCODING)\n            yaml = YAML(typ='safe')\n            yaml.dump(yaml.load(self.oscal_serialize_json()), write_file)\n            write_file.flush()\n            write_file.close()\n        elif content_type == FileContentType.JSON:\n            write_file = pathlib.Path(path).open('wb')\n            write_file.write(self.oscal_serialize_json_bytes(pretty=True))\n            # Flush / close required (by experience) due to flushing issues in tests.\n            write_file.flush()\n            write_file.close()\n\n    @classmethod\n    def oscal_read(cls, path: pathlib.Path) -&gt; Optional['OscalBaseModel']:\n\"\"\"\n        Read OSCAL objects.\n\n        Handles the fact OSCAL wraps top level elements and also deals with both yaml and json.\n\n        Args:\n            path: The path of the oscal object to read.\n        Returns:\n            The oscal object read into trestle oscal models.\n        \"\"\"\n        # Create the wrapper model.\n        alias = classname_to_alias(cls.__name__, AliasMode.JSON)\n\n        content_type = FileContentType.to_content_type(path.suffix)\n        logger.debug(f'oscal_read content type {content_type} and alias {alias} from {path}')\n\n        if not path.exists():\n            logger.warning(f'path does not exist in oscal_read: {path}')\n            return None\n\n        obj: Dict[str, Any] = {}\n        try:\n            if content_type == FileContentType.YAML:\n                yaml = YAML(typ='safe')\n                fh = path.open('r', encoding=const.FILE_ENCODING)\n                obj = yaml.load(fh)\n                fh.close()\n            elif content_type == FileContentType.JSON:\n                obj = load_file(\n                    path,\n                    json_loads=cls.__config__.json_loads,\n                )\n        except Exception as e:\n            raise err.TrestleError(f'Error loading file {path} {str(e)}')\n        try:\n            if not len(obj) == 1:\n                raise err.TrestleError(\n                    f'Invalid OSCAL file structure, oscal file '\n                    f'does not have a single top level key wrapping it. It has {len(obj)} keys.'\n                )\n            parsed = cls.parse_obj(obj[alias])\n        except KeyError:\n            raise err.TrestleError(f'Provided oscal file does not have top level key key: {alias}')\n        except Exception as e:\n            raise err.TrestleError(f'Error parsing file {path} {str(e)}')\n\n        return parsed\n\n    def copy_to(self, new_oscal_type: Type['OscalBaseModel']) -&gt; 'OscalBaseModel':\n\"\"\"\n        Opportunistic copy operation between similar types of data classes.\n\n        Due to the way in which oscal is constructed we get a set of similar / the same definition across various\n        oscal models. Due to the lack of guarantees that they are the same we cannot easily 'collapse' the mode.\n\n        Args:\n            new_oscal_type: The desired type of oscal model\n\n        Returns:\n            Opportunistic copy of the data into the new model type.\n        \"\"\"\n        logger.debug('Copy to started')\n        if self.__class__.__name__ == new_oscal_type.__name__:\n            logger.debug('Json based copy')\n            # Note: Json based oppportunistic copy\n            # Dev notes: Do not change this from json. Due to enums (in particular) json is the closest we can get.\n            return new_oscal_type.parse_raw(self.oscal_serialize_json(pretty=False, wrapped=False))\n\n        if ('__root__' in self.__fields__ and len(self.__fields__) == 1 and '__root__' in new_oscal_type.__fields__\n                and len(new_oscal_type.__fields__) == 1):\n            logger.debug('Root element based copy too')\n            return new_oscal_type.parse_obj(self.__root__)\n\n        # bad place here.\n        raise err.TrestleError('Provided inconsistent classes to copy to methodology.')\n\n    def copy_from(self, existing_oscal_object: 'OscalBaseModel') -&gt; None:\n\"\"\"\n        Copy operation that implicitly does type conversion.\n\n        Typically would\n        be used to set an attribute, however, does not need to be.\n\n        Deals with two scenarios:\n        1) Casting across oscal models of equivalent type. The purpose if this\n        is to cross class spaces.\n\n        2) The same as above where the item is an array style object which does\n        not correctly serialize to a dict.\n\n        3) if the from and 'to' objects are root schema elements the copy operation\n        will copy the root element to the value.\n\n        Args:\n            existing_oscal_object: The oscal object where fields are copied from.\n\n        \"\"\"\n        recast_object = existing_oscal_object.copy_to(self.__class__)\n        for raw_field in self.__dict__:\n            self.__dict__[raw_field] = recast_object.__dict__[raw_field]\n\n    @classmethod\n    def alias_to_field_map(cls) -&gt; Dict[str, ModelField]:\n\"\"\"Create a map from field alias to field.\n\n        Returns:\n            A dict which has key's of aliases and Fields as values.\n        \"\"\"\n        alias_to_field: Dict[str, ModelField] = {}\n        for field in cls.__fields__.values():\n            alias_to_field[field.alias] = field\n\n        return alias_to_field\n\n    @classmethod\n    def is_collection_container(cls) -&gt; bool:\n\"\"\"\n        Determine whether a pydantic model has being created to wrap a collection primitive (e.g a list or dict).\n\n        In performing model decomposition it is possible using trestle framework to automatically generate a model\n        which looks like\n\n        class Foo(OscalBaseModel):\n            __root__: List[Bar]\n\n        Returns:\n            Boolean on if it meets the above criteria\n\n        When these cases exist we need special handling of the type information.\n        \"\"\"\n        # Additional sanity check on field length\n        if len(cls.__fields__) == 1 and '__root__' in cls.__fields__:\n            # This is now a __root__ key only model\n            if is_collection_field_type(cls.__fields__['__root__'].outer_type_):\n                return True\n        return False\n\n    @classmethod\n    def get_collection_type(cls) -&gt; Optional[type]:\n\"\"\"\n        If the type wraps an collection, return the collection type.\n\n        Returns:\n            The collection type.\n\n        Raises:\n            err.TrestleError: if not a wrapper of the collection type.\n        \"\"\"\n        if not cls.is_collection_container():\n            raise err.TrestleError('OscalBaseModel is not wrapping a collection type')\n        return get_origin(cls.__fields__['__root__'].outer_type_)\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.Config","title":"<code> Config        </code>","text":"<p>Overriding configuration class for pydantic base model, for use with OSCAL data classes.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>class Config:\n\"\"\"Overriding configuration class for pydantic base model, for use with OSCAL data classes.\"\"\"\n\n    json_loads = orjson.loads\n    # TODO: json_dumps with orjson.dumps see #840\n\n    json_encoders = {datetime.datetime: lambda x: robust_datetime_serialization(x)}\n    allow_population_by_field_name = True\n\n    # Enforce strict schema\n    extra = Extra.forbid\n\n    # Validate on assignment of variables to ensure no escapes\n    validate_assignment = True\n</code></pre> <code>allow_population_by_field_name</code> \u00a4 <code>extra</code> \u00a4 <code>json_encoders</code> \u00a4 <code>json_loads</code> \u00a4 <code>validate_assignment</code> \u00a4"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.alias_to_field_map","title":"<code>alias_to_field_map()</code>  <code>classmethod</code>","text":"<p>Create a map from field alias to field.</p> <p>Returns:</p> Type Description <code>Dict[str, pydantic.fields.ModelField]</code> <p>A dict which has key's of aliases and Fields as values.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>@classmethod\ndef alias_to_field_map(cls) -&gt; Dict[str, ModelField]:\n\"\"\"Create a map from field alias to field.\n\n    Returns:\n        A dict which has key's of aliases and Fields as values.\n    \"\"\"\n    alias_to_field: Dict[str, ModelField] = {}\n    for field in cls.__fields__.values():\n        alias_to_field[field.alias] = field\n\n    return alias_to_field\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.copy_from","title":"<code>copy_from(self, existing_oscal_object)</code>","text":"<p>Copy operation that implicitly does type conversion.</p> <p>Typically would be used to set an attribute, however, does not need to be.</p> <p>Deals with two scenarios: 1) Casting across oscal models of equivalent type. The purpose if this is to cross class spaces.</p> <p>2) The same as above where the item is an array style object which does not correctly serialize to a dict.</p> <p>3) if the from and 'to' objects are root schema elements the copy operation will copy the root element to the value.</p> <p>Parameters:</p> Name Type Description Default <code>existing_oscal_object</code> <code>OscalBaseModel</code> <p>The oscal object where fields are copied from.</p> required Source code in <code>trestle/core/base_model.py</code> <pre><code>def copy_from(self, existing_oscal_object: 'OscalBaseModel') -&gt; None:\n\"\"\"\n    Copy operation that implicitly does type conversion.\n\n    Typically would\n    be used to set an attribute, however, does not need to be.\n\n    Deals with two scenarios:\n    1) Casting across oscal models of equivalent type. The purpose if this\n    is to cross class spaces.\n\n    2) The same as above where the item is an array style object which does\n    not correctly serialize to a dict.\n\n    3) if the from and 'to' objects are root schema elements the copy operation\n    will copy the root element to the value.\n\n    Args:\n        existing_oscal_object: The oscal object where fields are copied from.\n\n    \"\"\"\n    recast_object = existing_oscal_object.copy_to(self.__class__)\n    for raw_field in self.__dict__:\n        self.__dict__[raw_field] = recast_object.__dict__[raw_field]\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.copy_to","title":"<code>copy_to(self, new_oscal_type)</code>","text":"<p>Opportunistic copy operation between similar types of data classes.</p> <p>Due to the way in which oscal is constructed we get a set of similar / the same definition across various oscal models. Due to the lack of guarantees that they are the same we cannot easily 'collapse' the mode.</p> <p>Parameters:</p> Name Type Description Default <code>new_oscal_type</code> <code>Type[OscalBaseModel]</code> <p>The desired type of oscal model</p> required <p>Returns:</p> Type Description <code>OscalBaseModel</code> <p>Opportunistic copy of the data into the new model type.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>def copy_to(self, new_oscal_type: Type['OscalBaseModel']) -&gt; 'OscalBaseModel':\n\"\"\"\n    Opportunistic copy operation between similar types of data classes.\n\n    Due to the way in which oscal is constructed we get a set of similar / the same definition across various\n    oscal models. Due to the lack of guarantees that they are the same we cannot easily 'collapse' the mode.\n\n    Args:\n        new_oscal_type: The desired type of oscal model\n\n    Returns:\n        Opportunistic copy of the data into the new model type.\n    \"\"\"\n    logger.debug('Copy to started')\n    if self.__class__.__name__ == new_oscal_type.__name__:\n        logger.debug('Json based copy')\n        # Note: Json based oppportunistic copy\n        # Dev notes: Do not change this from json. Due to enums (in particular) json is the closest we can get.\n        return new_oscal_type.parse_raw(self.oscal_serialize_json(pretty=False, wrapped=False))\n\n    if ('__root__' in self.__fields__ and len(self.__fields__) == 1 and '__root__' in new_oscal_type.__fields__\n            and len(new_oscal_type.__fields__) == 1):\n        logger.debug('Root element based copy too')\n        return new_oscal_type.parse_obj(self.__root__)\n\n    # bad place here.\n    raise err.TrestleError('Provided inconsistent classes to copy to methodology.')\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.create_stripped_model_type","title":"<code>create_stripped_model_type(stripped_fields=None, stripped_fields_aliases=None)</code>  <code>classmethod</code>","text":"<p>Create a pydantic model, which is derived from the current model, but missing certain fields.</p> <p>OSCAL mandates a 'strict' schema (e.g. unless otherwise stated no additional fields), and certain fields are mandatory. Given this the corresponding dataclasses are also strict. Workflows with trestle require missing mandatory fields. This allows creation of derivative models missing certain fields.</p> <p>Parameters:</p> Name Type Description Default <code>stripped_fields</code> <code>Optional[List[str]]</code> <p>The fields to be removed from the current data class.</p> <code>None</code> <code>stripped_fields_aliases</code> <code>Optional[List[str]]</code> <p>The fields to be removed from the current data class provided by alias.</p> <code>None</code> <p>Returns:</p> Type Description <code>Type[OscalBaseModel]</code> <p>Pydantic data class thta can be used to instanciate a model.</p> <p>Exceptions:</p> Type Description <code>TrestleError</code> <p>If user provided both stripped_fields and stripped_field_aliases or neither.</p> <code>TrestleError</code> <p>If incorrect aliases or field names are provided.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>@classmethod\ndef create_stripped_model_type(\n    cls,\n    stripped_fields: Optional[List[str]] = None,\n    stripped_fields_aliases: Optional[List[str]] = None\n) -&gt; Type['OscalBaseModel']:\n\"\"\"Create a pydantic model, which is derived from the current model, but missing certain fields.\n\n    OSCAL mandates a 'strict' schema (e.g. unless otherwise stated no additional fields), and certain fields\n    are mandatory. Given this the corresponding dataclasses are also strict. Workflows with trestle require missing\n    mandatory fields. This allows creation of derivative models missing certain fields.\n\n    Args:\n        stripped_fields: The fields to be removed from the current data class.\n        stripped_fields_aliases: The fields to be removed from the current data class provided by alias.\n\n    Returns:\n        Pydantic data class thta can be used to instanciate a model.\n\n    Raises:\n        TrestleError: If user provided both stripped_fields and stripped_field_aliases or neither.\n        TrestleError: If incorrect aliases or field names are provided.\n    \"\"\"\n    if stripped_fields is not None and stripped_fields_aliases is not None:\n        raise err.TrestleError('Either \"stripped_fields\" or \"stripped_fields_aliases\" need to be passed, not both.')\n    if stripped_fields is None and stripped_fields_aliases is None:\n        raise err.TrestleError('Exactly one of \"stripped_fields\" or \"stripped_fields_aliases\" must be provided')\n\n    # create alias to field_name mapping\n    excluded_fields = []\n    if stripped_fields is not None:\n        excluded_fields = stripped_fields\n    elif stripped_fields_aliases is not None:\n        alias_to_field = cls.alias_to_field_map()\n        try:\n            excluded_fields = [alias_to_field[key].name for key in stripped_fields_aliases]\n        except KeyError as e:\n            raise err.TrestleError(f'Field {str(e)} does not exist in the model')\n\n    current_fields = cls.__fields__\n    new_fields_for_model = {}\n    # Build field list\n    for current_mfield in current_fields.values():\n        if current_mfield.name in excluded_fields:\n            continue\n        # Validate name in the field\n        # Cehcke behaviour with an alias\n        if current_mfield.required:\n            new_fields_for_model[\n                current_mfield.name\n            ] = (current_mfield.outer_type_, Field(..., title=current_mfield.name, alias=current_mfield.alias))\n        else:\n            new_fields_for_model[current_mfield.name] = (\n                Optional[current_mfield.outer_type_],\n                Field(None, title=current_mfield.name, alias=current_mfield.alias)\n            )\n    new_model = create_model(cls.__name__, __base__=OscalBaseModel, **new_fields_for_model)  # type: ignore\n    # TODO: This typing cast should NOT be necessary. Potentially fixable with a fix to pydantic. Issue #175\n    new_model = cast(Type[OscalBaseModel], new_model)\n\n    return new_model\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.get_collection_type","title":"<code>get_collection_type()</code>  <code>classmethod</code>","text":"<p>If the type wraps an collection, return the collection type.</p> <p>Returns:</p> Type Description <code>Optional[type]</code> <p>The collection type.</p> <p>Exceptions:</p> Type Description <code>err.TrestleError</code> <p>if not a wrapper of the collection type.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>@classmethod\ndef get_collection_type(cls) -&gt; Optional[type]:\n\"\"\"\n    If the type wraps an collection, return the collection type.\n\n    Returns:\n        The collection type.\n\n    Raises:\n        err.TrestleError: if not a wrapper of the collection type.\n    \"\"\"\n    if not cls.is_collection_container():\n        raise err.TrestleError('OscalBaseModel is not wrapping a collection type')\n    return get_origin(cls.__fields__['__root__'].outer_type_)\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.get_field_by_alias","title":"<code>get_field_by_alias(self, field_alias)</code>","text":"<p>Convert field alias to a field.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>def get_field_by_alias(self, field_alias: str) -&gt; Any:\n\"\"\"Convert field alias to a field.\"\"\"\n    attr_field = self.alias_to_field_map().get(field_alias, None)\n    return attr_field\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.get_field_value_by_alias","title":"<code>get_field_value_by_alias(self, attr_alias)</code>","text":"<p>Get attribute value by field alias.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>def get_field_value_by_alias(self, attr_alias: str) -&gt; Optional[Any]:\n\"\"\"Get attribute value by field alias.\"\"\"\n    # TODO: can this be restricted beyond Any easily.\n    attr_field = self.get_field_by_alias(attr_alias)\n    if isinstance(attr_field, ModelField):\n        return getattr(self, attr_field.name, None)\n\n    return None\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.is_collection_container","title":"<code>is_collection_container()</code>  <code>classmethod</code>","text":"<p>Determine whether a pydantic model has being created to wrap a collection primitive (e.g a list or dict).</p> <p>In performing model decomposition it is possible using trestle framework to automatically generate a model which looks like</p> <p>class Foo(OscalBaseModel):     root: List[Bar]</p> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean on if it meets the above criteria</p> <p>When these cases exist we need special handling of the type information.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>@classmethod\ndef is_collection_container(cls) -&gt; bool:\n\"\"\"\n    Determine whether a pydantic model has being created to wrap a collection primitive (e.g a list or dict).\n\n    In performing model decomposition it is possible using trestle framework to automatically generate a model\n    which looks like\n\n    class Foo(OscalBaseModel):\n        __root__: List[Bar]\n\n    Returns:\n        Boolean on if it meets the above criteria\n\n    When these cases exist we need special handling of the type information.\n    \"\"\"\n    # Additional sanity check on field length\n    if len(cls.__fields__) == 1 and '__root__' in cls.__fields__:\n        # This is now a __root__ key only model\n        if is_collection_field_type(cls.__fields__['__root__'].outer_type_):\n            return True\n    return False\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.oscal_dict","title":"<code>oscal_dict(self)</code>","text":"<p>Return a dictionary including the root wrapping object key.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>def oscal_dict(self) -&gt; Dict[str, Any]:\n\"\"\"Return a dictionary including the root wrapping object key.\"\"\"\n    class_name = self.__class__.__name__\n    result = {}\n    raw_dict = self.dict(by_alias=True, exclude_none=True)\n    # Additional check to avoid root serialization\n    if '__root__' in raw_dict.keys():\n        result[classname_to_alias(class_name, AliasMode.JSON)] = raw_dict['__root__']\n    else:\n        result[classname_to_alias(class_name, AliasMode.JSON)] = raw_dict\n    return result\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.oscal_read","title":"<code>oscal_read(path)</code>  <code>classmethod</code>","text":"<p>Read OSCAL objects.</p> <p>Handles the fact OSCAL wraps top level elements and also deals with both yaml and json.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path of the oscal object to read.</p> required <p>Returns:</p> Type Description <code>Optional[OscalBaseModel]</code> <p>The oscal object read into trestle oscal models.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>@classmethod\ndef oscal_read(cls, path: pathlib.Path) -&gt; Optional['OscalBaseModel']:\n\"\"\"\n    Read OSCAL objects.\n\n    Handles the fact OSCAL wraps top level elements and also deals with both yaml and json.\n\n    Args:\n        path: The path of the oscal object to read.\n    Returns:\n        The oscal object read into trestle oscal models.\n    \"\"\"\n    # Create the wrapper model.\n    alias = classname_to_alias(cls.__name__, AliasMode.JSON)\n\n    content_type = FileContentType.to_content_type(path.suffix)\n    logger.debug(f'oscal_read content type {content_type} and alias {alias} from {path}')\n\n    if not path.exists():\n        logger.warning(f'path does not exist in oscal_read: {path}')\n        return None\n\n    obj: Dict[str, Any] = {}\n    try:\n        if content_type == FileContentType.YAML:\n            yaml = YAML(typ='safe')\n            fh = path.open('r', encoding=const.FILE_ENCODING)\n            obj = yaml.load(fh)\n            fh.close()\n        elif content_type == FileContentType.JSON:\n            obj = load_file(\n                path,\n                json_loads=cls.__config__.json_loads,\n            )\n    except Exception as e:\n        raise err.TrestleError(f'Error loading file {path} {str(e)}')\n    try:\n        if not len(obj) == 1:\n            raise err.TrestleError(\n                f'Invalid OSCAL file structure, oscal file '\n                f'does not have a single top level key wrapping it. It has {len(obj)} keys.'\n            )\n        parsed = cls.parse_obj(obj[alias])\n    except KeyError:\n        raise err.TrestleError(f'Provided oscal file does not have top level key key: {alias}')\n    except Exception as e:\n        raise err.TrestleError(f'Error parsing file {path} {str(e)}')\n\n    return parsed\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.oscal_serialize_json","title":"<code>oscal_serialize_json(self, pretty=False, wrapped=True)</code>","text":"<p>Return an 'oscal wrapped' json object serialized in a compressed form as bytes.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>Whether or not to pretty-print json output or have in compressed form.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Oscal model serialized to a json object including packaging inside of a single top level key.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>def oscal_serialize_json(self, pretty: bool = False, wrapped: bool = True) -&gt; str:\n\"\"\"\n    Return an 'oscal wrapped' json object serialized in a compressed form as bytes.\n\n    Args:\n        pretty: Whether or not to pretty-print json output or have in compressed form.\n    Returns:\n        Oscal model serialized to a json object including packaging inside of a single top level key.\n    \"\"\"\n    # This function is provided for backwards compatibility\n    return self.oscal_serialize_json_bytes(pretty, wrapped).decode(const.FILE_ENCODING)\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.oscal_serialize_json_bytes","title":"<code>oscal_serialize_json_bytes(self, pretty=False, wrapped=True)</code>","text":"<p>Return an 'oscal wrapped' json object serialized in a compressed form as bytes.</p> <p>Parameters:</p> Name Type Description Default <code>pretty</code> <code>bool</code> <p>Whether or not to pretty-print json output or have in compressed form.</p> <code>False</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Oscal model serialized to a json object including packaging inside of a single top level key.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>def oscal_serialize_json_bytes(self, pretty: bool = False, wrapped: bool = True) -&gt; bytes:\n\"\"\"\n    Return an 'oscal wrapped' json object serialized in a compressed form as bytes.\n\n    Args:\n        pretty: Whether or not to pretty-print json output or have in compressed form.\n    Returns:\n        Oscal model serialized to a json object including packaging inside of a single top level key.\n    \"\"\"\n    if wrapped:\n        odict = self.oscal_dict()\n    else:\n        odict = self.dict(by_alias=True, exclude_none=True)\n    if pretty:\n        return orjson.dumps(odict, default=self.__json_encoder__, option=orjson.OPT_INDENT_2)\n    return orjson.dumps(odict, default=self.__json_encoder__)\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.oscal_write","title":"<code>oscal_write(self, path)</code>","text":"<p>Write out a pydantic data model in an oscal friendly way.</p> <p>OSCAL schema mandates that top level elements are wrapped in a singular json/yaml field. This function handles both json and yaml output as well as formatting of the json.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The output file location for the oscal object.</p> required <p>Exceptions:</p> Type Description <code>err.TrestleError</code> <p>If a unknown file extension is provided.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>def oscal_write(self, path: pathlib.Path) -&gt; None:\n\"\"\"\n    Write out a pydantic data model in an oscal friendly way.\n\n    OSCAL schema mandates that top level elements are wrapped in a singular\n    json/yaml field. This function handles both json and yaml output as well\n    as formatting of the json.\n\n    Args:\n        path: The output file location for the oscal object.\n\n    Raises:\n        err.TrestleError: If a unknown file extension is provided.\n    \"\"\"\n    content_type = FileContentType.to_content_type(path.suffix)\n    # The output will have \\r\\n newlines on windows and \\n newlines elsewhere\n\n    if content_type == FileContentType.YAML:\n        write_file = pathlib.Path(path).open('w', encoding=const.FILE_ENCODING)\n        yaml = YAML(typ='safe')\n        yaml.dump(yaml.load(self.oscal_serialize_json()), write_file)\n        write_file.flush()\n        write_file.close()\n    elif content_type == FileContentType.JSON:\n        write_file = pathlib.Path(path).open('wb')\n        write_file.write(self.oscal_serialize_json_bytes(pretty=True))\n        # Flush / close required (by experience) due to flushing issues in tests.\n        write_file.flush()\n        write_file.close()\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.OscalBaseModel.stripped_instance","title":"<code>stripped_instance(self, stripped_fields=None, stripped_fields_aliases=None)</code>","text":"<p>Return a new model instance with the specified fields being stripped.</p> <p>Parameters:</p> Name Type Description Default <code>stripped_fields</code> <code>List[str]</code> <p>The fields to be removed from the current data class.</p> <code>None</code> <code>stripped_fields_aliases</code> <code>List[str]</code> <p>The fields to be removed from the current data class provided by alias.</p> <code>None</code> <p>Returns:</p> Type Description <code>OscalBaseModel</code> <p>The current datamodel with the fields provided removed in a derivate (run time created) data model.</p> <p>Exceptions:</p> Type Description <code>err.TrestleError</code> <p>If user provided both stripped_fields and stripped_field_aliases or neither.</p> <code>err.TrestleError</code> <p>If incorrect aliases or field names are provided.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>def stripped_instance(\n    self, stripped_fields: List[str] = None, stripped_fields_aliases: List[str] = None\n) -&gt; 'OscalBaseModel':\n\"\"\"Return a new model instance with the specified fields being stripped.\n\n    Args:\n        stripped_fields: The fields to be removed from the current data class.\n        stripped_fields_aliases: The fields to be removed from the current data class provided by alias.\n\n    Returns:\n        The current datamodel with the fields provided removed in a derivate (run time created) data model.\n\n    Raises:\n        err.TrestleError: If user provided both stripped_fields and stripped_field_aliases or neither.\n        err.TrestleError: If incorrect aliases or field names are provided.\n    \"\"\"\n    # stripped class type\n    stripped_class: Type[OscalBaseModel] = self.create_stripped_model_type(\n        stripped_fields=stripped_fields, stripped_fields_aliases=stripped_fields_aliases\n    )\n\n    # remaining values\n    remaining_values = {}\n    for field in self.__fields__.values():\n        if field.name in stripped_class.__fields__:\n            remaining_values[field.name] = self.__dict__[field.name]\n\n    # create stripped model instance\n    # TODO: Not sure if we can avoid type escapes here\n    stripped_instance = stripped_class(**remaining_values)  # type: ignore\n\n    return stripped_instance\n</code></pre>"},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model-functions","title":"Functions","text":""},{"location":"api_reference/trestle.core.base_model/#trestle.core.base_model.robust_datetime_serialization","title":"<code>robust_datetime_serialization(input_dt)</code>","text":"<p>Return a nicely formatted string for in a format compatible with OSCAL specifications.</p> <p>Parameters:</p> Name Type Description Default <code>input_dt</code> <code>datetime</code> <p>Input datetime to convert to a string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String in isoformat to the millisecond enforcing that timezone offset is provided.</p> <p>Exceptions:</p> Type Description <code>TrestleError</code> <p>Error is raised if datetime object does not contain sufficient timezone information.</p> Source code in <code>trestle/core/base_model.py</code> <pre><code>def robust_datetime_serialization(input_dt: datetime.datetime) -&gt; str:\n\"\"\"Return a nicely formatted string for in a format compatible with OSCAL specifications.\n\n    Args:\n        input_dt: Input datetime to convert to a string.\n\n    Returns:\n        String in isoformat to the millisecond enforcing that timezone offset is provided.\n\n    Raises:\n        TrestleError: Error is raised if datetime object does not contain sufficient timezone information.\n    \"\"\"\n    # fail if the input datetime is not aware - ie it has no associated timezone\n    if input_dt.tzinfo is None:\n        raise err.TrestleError('Missing timezone in datetime')\n    if input_dt.tzinfo.utcoffset(input_dt) is None:\n        raise err.TrestleError('Missing utcoffset in datetime')\n\n    # use this leave in original timezone rather than utc\n    # return input_dt.astimezone().isoformat(timespec='milliseconds')  noqa: E800\n\n    # force it to be utc\n    return input_dt.astimezone(datetime.timezone.utc).isoformat(timespec='milliseconds')\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_api/","title":"catalog_api","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api","title":"<code>trestle.core.catalog.catalog_api</code>","text":"<p>Main entrypoint to interact with catalog in memory.</p>"},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api.CatalogAPI","title":"<code> CatalogAPI        </code>","text":"<p>Main entrypoint to interact with catalog in memory.</p> <p>Encapsulates all necessary functionality to manipulate, read and write the catalog and its markdown representation.</p> Source code in <code>trestle/core/catalog/catalog_api.py</code> <pre><code>class CatalogAPI():\n\"\"\"\n    Main entrypoint to interact with catalog in memory.\n\n    Encapsulates all necessary functionality to manipulate, read\n    and write the catalog and its markdown representation.\n    \"\"\"\n\n    def __init__(self, catalog: Optional[cat.Catalog], context: Optional[ControlContext] = None):\n\"\"\"Initialize catalog api.\"\"\"\n        if not catalog:\n            # catalog assemble initializes with no catalog but may merge into an existing one later\n            logger.debug('No catalog was provided in CatalogAPI init, generating a new one.')\n            catalog = gens.generate_sample_model(cat.Catalog)\n        self._catalog = catalog\n        self._catalog_interface = CatalogInterface(self._catalog)\n        self._writer = CatalogWriter(self._catalog_interface)\n        self._reader = CatalogReader(self._catalog_interface)\n        self._merger = CatalogMerger(self._catalog_interface)\n        self._context = context\n\n    def update_context(self, context: ControlContext):\n\"\"\"Update current context.\"\"\"\n        if not context:\n            raise TrestleError('ControlContext cannot be empty.')\n        self._context = context\n\n    def write_catalog_as_markdown(self, label_as_key=False) -&gt; None:\n\"\"\"\n        Write out the catalog controls from dict as markdown files to the specified directory.\n\n        Args:\n            label_as_key: Whether to use label_as_key for part_id to label map\n\n        Returns:\n            None\n        \"\"\"\n        # create the directory in which to write the control markdown files\n        self._context.md_root.mkdir(exist_ok=True, parents=True)\n\n        part_id_map = self._catalog_interface.get_statement_part_id_map(label_as_key=label_as_key)\n\n        if self._context.purpose == ContextPurpose.PROFILE:\n            found_alters, _, _ = self.read_additional_content_from_md(label_as_key=True)\n            self._writer.write_catalog_as_profile_markdown(self._context, part_id_map, found_alters)\n        elif self._context.purpose == ContextPurpose.COMPONENT:\n            self._writer.write_catalog_as_component_markdown(self._context, part_id_map)\n        elif self._context.purpose == ContextPurpose.SSP:\n            self._writer.write_catalog_as_ssp_markdown(self._context, part_id_map)\n        else:\n            self._writer.write_catalog_as_catalog(self._context, part_id_map)\n\n        # prune any directories that have no markdown files\n        prune_empty_dirs(self._context.md_root, '*.md')\n\n    def read_catalog_from_markdown(self, markdown_dir: pathlib.Path, is_set_parameters: bool) -&gt; cat.Catalog:\n\"\"\"Read catalog from markdown.\"\"\"\n        md_catalog = self._reader.read_catalog_from_markdown(markdown_dir, is_set_parameters)\n        md_catalog_interface = CatalogInterface(md_catalog)\n        if md_catalog_interface.get_count_of_controls_in_catalog(True) == 0:\n            raise TrestleError(f'No controls were loaded from markdown {markdown_dir}.  No catalog created.')\n\n        return md_catalog\n\n    def read_additional_content_from_md(self,\n                                        label_as_key: bool = False\n                                        ) -&gt; Tuple[List[prof.Alter], Dict[str, Any], Dict[str, str]]:\n\"\"\"Read additional content from markdown.\"\"\"\n        if not self._context:\n            raise TrestleError('Reading content from the markdown requires context to be initialized!')\n        label_map = self._catalog_interface.get_statement_part_id_map(label_as_key=label_as_key)\n\n        return self._reader.read_additional_content(\n            self._context.md_root,\n            self._context.required_sections,\n            label_map,\n            self._context.sections_dict,\n            self._context.to_markdown\n        )\n\n    def merge_catalog(self, catalog: cat.Catalog, replace_params: bool) -&gt; None:\n\"\"\"Merge one catalog into another.\"\"\"\n        return self._merger.merge_catalog(catalog, replace_params)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api.CatalogAPI-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api.CatalogAPI.__init__","title":"<code>__init__(self, catalog, context=None)</code>  <code>special</code>","text":"<p>Initialize catalog api.</p> Source code in <code>trestle/core/catalog/catalog_api.py</code> <pre><code>def __init__(self, catalog: Optional[cat.Catalog], context: Optional[ControlContext] = None):\n\"\"\"Initialize catalog api.\"\"\"\n    if not catalog:\n        # catalog assemble initializes with no catalog but may merge into an existing one later\n        logger.debug('No catalog was provided in CatalogAPI init, generating a new one.')\n        catalog = gens.generate_sample_model(cat.Catalog)\n    self._catalog = catalog\n    self._catalog_interface = CatalogInterface(self._catalog)\n    self._writer = CatalogWriter(self._catalog_interface)\n    self._reader = CatalogReader(self._catalog_interface)\n    self._merger = CatalogMerger(self._catalog_interface)\n    self._context = context\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api.CatalogAPI.merge_catalog","title":"<code>merge_catalog(self, catalog, replace_params)</code>","text":"<p>Merge one catalog into another.</p> Source code in <code>trestle/core/catalog/catalog_api.py</code> <pre><code>def merge_catalog(self, catalog: cat.Catalog, replace_params: bool) -&gt; None:\n\"\"\"Merge one catalog into another.\"\"\"\n    return self._merger.merge_catalog(catalog, replace_params)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api.CatalogAPI.read_additional_content_from_md","title":"<code>read_additional_content_from_md(self, label_as_key=False)</code>","text":"<p>Read additional content from markdown.</p> Source code in <code>trestle/core/catalog/catalog_api.py</code> <pre><code>def read_additional_content_from_md(self,\n                                    label_as_key: bool = False\n                                    ) -&gt; Tuple[List[prof.Alter], Dict[str, Any], Dict[str, str]]:\n\"\"\"Read additional content from markdown.\"\"\"\n    if not self._context:\n        raise TrestleError('Reading content from the markdown requires context to be initialized!')\n    label_map = self._catalog_interface.get_statement_part_id_map(label_as_key=label_as_key)\n\n    return self._reader.read_additional_content(\n        self._context.md_root,\n        self._context.required_sections,\n        label_map,\n        self._context.sections_dict,\n        self._context.to_markdown\n    )\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api.CatalogAPI.read_catalog_from_markdown","title":"<code>read_catalog_from_markdown(self, markdown_dir, is_set_parameters)</code>","text":"<p>Read catalog from markdown.</p> Source code in <code>trestle/core/catalog/catalog_api.py</code> <pre><code>def read_catalog_from_markdown(self, markdown_dir: pathlib.Path, is_set_parameters: bool) -&gt; cat.Catalog:\n\"\"\"Read catalog from markdown.\"\"\"\n    md_catalog = self._reader.read_catalog_from_markdown(markdown_dir, is_set_parameters)\n    md_catalog_interface = CatalogInterface(md_catalog)\n    if md_catalog_interface.get_count_of_controls_in_catalog(True) == 0:\n        raise TrestleError(f'No controls were loaded from markdown {markdown_dir}.  No catalog created.')\n\n    return md_catalog\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api.CatalogAPI.update_context","title":"<code>update_context(self, context)</code>","text":"<p>Update current context.</p> Source code in <code>trestle/core/catalog/catalog_api.py</code> <pre><code>def update_context(self, context: ControlContext):\n\"\"\"Update current context.\"\"\"\n    if not context:\n        raise TrestleError('ControlContext cannot be empty.')\n    self._context = context\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_api/#trestle.core.catalog.catalog_api.CatalogAPI.write_catalog_as_markdown","title":"<code>write_catalog_as_markdown(self, label_as_key=False)</code>","text":"<p>Write out the catalog controls from dict as markdown files to the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>label_as_key</code> <p>Whether to use label_as_key for part_id to label map</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>trestle/core/catalog/catalog_api.py</code> <pre><code>def write_catalog_as_markdown(self, label_as_key=False) -&gt; None:\n\"\"\"\n    Write out the catalog controls from dict as markdown files to the specified directory.\n\n    Args:\n        label_as_key: Whether to use label_as_key for part_id to label map\n\n    Returns:\n        None\n    \"\"\"\n    # create the directory in which to write the control markdown files\n    self._context.md_root.mkdir(exist_ok=True, parents=True)\n\n    part_id_map = self._catalog_interface.get_statement_part_id_map(label_as_key=label_as_key)\n\n    if self._context.purpose == ContextPurpose.PROFILE:\n        found_alters, _, _ = self.read_additional_content_from_md(label_as_key=True)\n        self._writer.write_catalog_as_profile_markdown(self._context, part_id_map, found_alters)\n    elif self._context.purpose == ContextPurpose.COMPONENT:\n        self._writer.write_catalog_as_component_markdown(self._context, part_id_map)\n    elif self._context.purpose == ContextPurpose.SSP:\n        self._writer.write_catalog_as_ssp_markdown(self._context, part_id_map)\n    else:\n        self._writer.write_catalog_as_catalog(self._context, part_id_map)\n\n    # prune any directories that have no markdown files\n    prune_empty_dirs(self._context.md_root, '*.md')\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/","title":"catalog_interface","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface","title":"<code>trestle.core.catalog.catalog_interface</code>","text":"<p>Provide interface to catalog allowing queries and operations at control level.</p>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface","title":"<code> CatalogInterface        </code>","text":"<p>Interface to query and modify catalog contents.</p> <p>The catalog is contained in two separate forms:  As an actual OSCAL catalog, and as a separate dict providing direct lookup of a control by id.</p> <p>The two representations should be converted as needed using provided routines: dict -&gt; cat: update_catalog_controls cat -&gt; dict: _create_control_dict</p> <p>In normal use the dict is created by the CatalogInterface constructor, changes are then made to controls in the dict, then the catalog controls are updated by pulling from the dict back into the catalog.</p> <p>This class does no direct file i/o.  i/o is performed via ControlIO.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>class CatalogInterface():\n\"\"\"\n    Interface to query and modify catalog contents.\n\n    The catalog is contained in two separate forms:  As an actual OSCAL catalog,\n    and as a separate dict providing direct lookup of a control by id.\n\n    The two representations should be converted as needed using provided routines:\n    dict -&gt; cat: update_catalog_controls\n    cat -&gt; dict: _create_control_dict\n\n    In normal use the dict is created by the CatalogInterface constructor,\n    changes are then made to controls in the dict,\n    then the catalog controls are updated by pulling from the dict back into the catalog.\n\n    This class does no direct file i/o.  i/o is performed via ControlIO.\n    \"\"\"\n\n    @dataclass\n    class ControlHandle:\n\"\"\"Convenience class for handling controls as members of a group.\n\n        group_id: id of parent group or '' if not in a group\n        group_title: title of the group\n        group_class: class of the group\n        path: path of parent groups leading to this control - without the final control_id, or [''] if in cat list\n        important to remember that controls may not be in a group and are directly attached to cat\n        control: the control itself\n        \"\"\"\n\n        group_id: str\n        group_title: Optional[str]\n        group_class: Optional[str]\n        group_path: List[str]\n        control_path: List[str]\n        control: cat.Control\n\n    def __init__(self, catalog: Optional[cat.Catalog] = None) -&gt; None:\n\"\"\"Initialize the interface with the catalog.\"\"\"\n        self._catalog = catalog\n        self._param_control_map: Dict[str, str] = {}\n        self._generate_group_index: int = 0\n        self._control_dict = self._create_control_dict() if catalog else None\n        self.loose_param_dict: Dict[str, common.Parameter] = {param.id: param\n                                                              for param in as_list(catalog.params)} if catalog else {}\n        # map control id to CompDict\n        self._control_comp_dicts: Dict[str, CompDict] = {}\n        # map control id to dict containing set parameters by component\n        self._control_comp_set_params: Dict[str, Dict[str, comp.SetParameter]] = {}\n\n    def add_comp_info(self, control_id: str, comp_name: str, label: str, comp_info: ComponentImpInfo) -&gt; None:\n\"\"\"Add comp_info for a control.\"\"\"\n        deep_set(self._control_comp_dicts, [control_id, comp_name, label], comp_info)\n\n    def get_comp_info(self, control_id: str) -&gt; CompDict:\n\"\"\"Get comp_dict for this control.\"\"\"\n        return self._control_comp_dicts.get(control_id, {})\n\n    def clear_comp_dicts(self) -&gt; None:\n\"\"\"Clear the control component dicts.\"\"\"\n        self._control_comp_dicts = {}\n\n    def add_comp_set_param(self, control_id: str, comp_name: str, set_param: comp.SetParameter) -&gt; None:\n\"\"\"Add component setparam for control with overwrite.\"\"\"\n        deep_append(self._control_comp_set_params, [control_id, comp_name], set_param)\n\n    def get_control_comp_set_params(self, control_id: str) -&gt; Dict[str, List[comp.SetParameter]]:\n\"\"\"Get dict of setparams list per component.\"\"\"\n        return self._control_comp_set_params.get(control_id, {})\n\n    def clear_set_params(self) -&gt; None:\n\"\"\"Clear the control set params.\"\"\"\n        self._control_comp_set_params = {}\n\n    def _generate_group_id(self, group: cat.Group) -&gt; str:\n\"\"\"Generate sequential group ids.\"\"\"\n        group_id = f'trestle_group_{self._generate_group_index:04d}'\n        self._generate_group_index += 1\n        logger.warning(f'Group titled \"{group.title}\" has no id and has been assigned id: {group_id}')\n        return group_id\n\n    def _add_params_to_map(self, control: cat.Control) -&gt; None:\n        # this does not need to recurse because it is called for each control in the catalog\n        for param in as_list(control.params):\n            if param.id in self._param_control_map:\n                logger.warning(\n                    f'Duplicate param id {param.id} in control {control.id} and {self._param_control_map[param.id]}.'\n                )\n            self._param_control_map[param.id] = control.id\n\n    def _add_sub_controls(\n        self, control_handle: ControlHandle, control_dict: Dict[str, ControlHandle], path: List[str]\n    ) -&gt; None:\n\"\"\"\n        Get all controls contained in this control and add it to the growing control dict.\n\n        Add all its sub-controls to the dict recursively.\n        The path does not change because only groups are in the path, and controls cannot contain groups.\n        \"\"\"\n        if control_handle.control.controls:\n            group_id = control_handle.group_id\n            group_title = control_handle.group_title\n            group_class = control_handle.group_class\n            group_path = control_handle.group_path\n            control_path = path[:]\n            control_path.append(control_handle.control.id)\n            for sub_control in control_handle.control.controls:\n                control_handle = CatalogInterface.ControlHandle(\n                    group_id=group_id,\n                    group_title=group_title,\n                    group_class=group_class,\n                    group_path=group_path,\n                    control_path=control_path,\n                    control=sub_control\n                )\n                control_dict[sub_control.id] = control_handle\n                self._add_sub_controls(control_handle, control_dict, control_path)\n\n    def _add_group_controls(self, group: cat.Group, control_dict: Dict[str, ControlHandle], path: List[str]) -&gt; None:\n\"\"\"Add all controls in the group recursively, including sub groups and sub controls.\"\"\"\n        group.id = self._generate_group_id(group) if group.id is None else group.id\n        if group.controls is not None:\n            group_path = path[:]\n            if not group_path or group_path[-1] != group.id:\n                group_path.append(group.id)\n            for control in group.controls:\n                control_handle = CatalogInterface.ControlHandle(\n                    group_id=group.id,\n                    group_title=group.title,\n                    group_class=group.class_,\n                    control=control,\n                    group_path=group_path,\n                    control_path=group_path\n                )\n                control_dict[control.id] = control_handle\n                self._add_sub_controls(control_handle, control_dict, group_path)\n        if group.groups is not None:\n            group_path = path[:]\n            group_path.append(group.id)\n            for sub_group in group.groups:\n                new_path = group_path[:]\n                sub_group.id = self._generate_group_id(sub_group) if sub_group.id is None else sub_group.id\n                new_path.append(sub_group.id)\n                self._add_group_controls(sub_group, control_dict, new_path)\n\n    def _create_control_dict(self) -&gt; Dict[str, ControlHandle]:\n        control_dict: Dict[str, CatalogInterface.ControlHandle] = {}\n        # add controls by group\n        if self._catalog.groups is not None:\n            for group in self._catalog.groups:\n                self._add_group_controls(group, control_dict, [])\n        # now add controls not in a group, if any\n        if self._catalog.controls is not None:\n            group_path = ['']\n            for control in self._catalog.controls:\n                control_handle = CatalogInterface.ControlHandle(\n                    group_id='',\n                    group_title='',\n                    group_class=const.MODEL_TYPE_CATALOG,\n                    control=control,\n                    group_path=group_path,\n                    control_path=group_path\n                )\n                control_dict[control.id] = control_handle\n                self._add_sub_controls(control_handle, control_dict, group_path)\n        for handle in control_dict.values():\n            self._add_params_to_map(handle.control)\n        return control_dict\n\n    @staticmethod\n    def _get_all_controls_in_list(controls: List[cat.Control], recurse: bool) -&gt; List[cat.Control]:\n\"\"\"Get all controls in a list with optional recursion for sub controls.\"\"\"\n        new_list: List[cat.Control] = []\n        for control in controls:\n            new_list.append(control)\n            if recurse and control.controls:\n                new_list.extend(CatalogInterface._get_all_controls_in_list(control.controls, recurse))\n        return new_list\n\n    @staticmethod\n    def _get_all_controls_in_group(group: cat.Group, recurse: bool) -&gt; List[cat.Control]:\n\"\"\"\n        Create a list of all controls in this group.\n\n        recurse specifies to recurse within controls, but groups are always recursed\n        \"\"\"\n        controls: List[cat.Control] = []\n        if group.controls:\n            controls.extend(CatalogInterface._get_all_controls_in_list(group.controls, recurse))\n        for sub_group in as_list(group.groups):\n            controls.extend(CatalogInterface._get_all_controls_in_group(sub_group, recurse))\n        return controls\n\n    def get_sorted_controls_in_group(self, group_id: str) -&gt; List[cat.Control]:\n\"\"\"Get the list of controls in a group sorted by the control sort-id.\"\"\"\n        controls: List[cat.Control] = []\n        for control in self.get_all_controls_from_dict():\n            grp_id, _, _ = self.get_group_info_by_control(control.id)\n            if grp_id == group_id:\n                controls.append(control)\n        return sorted(controls, key=lambda control: ControlInterface.get_sort_id(control))\n\n    def get_dependent_control_ids(self, control_id: str) -&gt; List[str]:\n\"\"\"Find all child ids of this control from the dict with recursion.\"\"\"\n        children: List[str] = []\n        control = self.get_control(control_id)\n        if control:\n            new_controls = self._get_all_controls_in_list(as_list(control.controls), True)\n            children.extend([con.id for con in new_controls])\n        return children\n\n    def get_control_ids(self) -&gt; List[str]:\n\"\"\"Get all control ids from the control dict.\"\"\"\n        return self._control_dict.keys()\n\n    def get_control(self, control_id: str) -&gt; Optional[cat.Control]:\n\"\"\"Get control from the control dict with this id.\"\"\"\n        return None if control_id not in self._control_dict else self._control_dict[control_id].control\n\n    @staticmethod\n    def get_control_ids_from_catalog(catalog: cat.Catalog) -&gt; List[str]:\n\"\"\"\n        Get all control ids from a catalog.\n\n        This is intended to provide a quick list of all controls in a catalog without the expense of building the\n        control dict.  So, if repeated queries are made into a catalog, it is worth instantiating a CatalogInterface\n        and associated control dict.  Otherwise just use this to get a list of all controls.\n\n        This function is needed within the CatalogInterface in order to determine if new controls have been added\n        to the dict and need to be inserted in the actual catalog during update.\n        \"\"\"\n        controls = CatalogInterface._get_all_controls_in_list(as_list(catalog.controls), True)\n        id_list = [control.id for control in controls]\n        for group in as_list(catalog.groups):\n            controls = CatalogInterface._get_all_controls_in_group(group, True)\n            id_list.extend([control.id for control in as_list(controls)])\n        return id_list\n\n    def get_control_by_param_id(self, param_id: str) -&gt; Optional[cat.Control]:\n\"\"\"Get control from catalog that has this param id using the dict.\"\"\"\n        if param_id in self._param_control_map:\n            return self.get_control(self._param_control_map[param_id])\n        return None\n\n    def get_control_id_and_status(self, control_name: str) -&gt; Tuple[str, str]:\n\"\"\"\n        Get the control id and status using the control name.\n\n        Returns empty string if status not found.\n        \"\"\"\n        for control in self.get_all_controls_from_dict():\n            if ControlInterface.get_label(control).strip().lower() == control_name.strip().lower():\n                status = ControlInterface.get_prop(control, 'status')\n                return control.id, status\n        return '', ''\n\n    def get_catalog_title(self) -&gt; str:\n\"\"\"Get the title of the catalog.\"\"\"\n        return self._catalog.metadata.title\n\n    def get_statement_part_id_map(self, label_as_key: bool) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"Create mapping of label to part_id for top level parts in statement of all controls.\"\"\"\n        id_map = {}\n        for control in self.get_all_controls_from_catalog(True):\n            statement_part = get_item_from_list(control.parts, const.STATEMENT, lambda p: p.name)\n            if statement_part:\n                id_dict: Dict[str, str] = {}\n                for sub_part in as_list(statement_part.parts):\n                    label = ControlInterface.get_label(sub_part)\n                    if label_as_key:\n                        id_dict[label] = sub_part.id\n                    else:\n                        id_dict[sub_part.id] = label\n                if id_dict:\n                    id_map[control.id] = id_dict\n        return id_map\n\n    @staticmethod\n    def _get_statement_sub_parts(part: common.Part, indent: int) -&gt; List[Dict[str, str]]:\n        items = []\n        # this may be '' if no label\n        label = ControlInterface.get_label(part)\n        prose = '' if part.prose is None else part.prose\n        items.append({'indent': indent, 'label': label, 'prose': prose})\n        for prt in as_filtered_list(part.parts, lambda p: p.name == 'item'):\n            items.extend(CatalogInterface._get_statement_sub_parts(prt, indent + 1))\n        return items\n\n    def get_statement_parts(self, control_id: str) -&gt; List[Dict[str, str]]:\n\"\"\"Get list of statement parts as dicts with indentation, label and prose.\"\"\"\n        items = []\n        control = self.get_control(control_id)\n\n        # control may have no statement or parts\n        # but if statement present it is first part\n        if control is None:\n            logger.warning(f'No control found for id {control_id}')\n        elif control.parts:\n            part = control.parts[0]\n            if part.name == 'statement':\n                items.extend(CatalogInterface._get_statement_sub_parts(part, 0))\n            else:\n                logger.warning(f'Control {control_id} has parts but first part name is {part.name} - not statement')\n        return items\n\n    def get_control_part_prose(self, control_id: str, part_name: str) -&gt; str:\n\"\"\"\n        Get the prose for a named part in the control.\n\n        Args:\n            control_id: id of the control\n            part_name: name of the part\n\n        Returns:\n            Single string concatenating prose from all parts and sub-parts in control with that name.\n        \"\"\"\n        control = self.get_control(control_id)\n        return ControlInterface.get_part_prose(control, part_name)\n\n    def get_all_controls_from_catalog(self, recurse: bool) -&gt; Iterator[cat.Control]:\n\"\"\"\n        Yield all controls from the actual catalog by group including optional sub controls.\n\n        Args:\n            recurse: Whether to recurse within controls, but groups are always recursed\n\n        Returns:\n            iterator of the controls in the catalog\n\n        Notes:\n            This follows the actual structure of the catalog and groups\n        \"\"\"\n        if self._catalog.groups:\n            for group in self._catalog.groups:\n                controls = self._get_all_controls_in_group(group, recurse)\n                for control in controls:\n                    yield control\n        if self._catalog.controls:\n            cat_controls = self._get_all_controls_in_list(self._catalog.controls, recurse)\n            for control in cat_controls:\n                yield control\n\n    def get_all_controls_from_dict(self) -&gt; List[cat.Control]:\n\"\"\"Yield individual controls from the dict.\"\"\"\n        return [handle.control for handle in self._control_dict.values()]\n\n    def get_count_of_controls_in_dict(self) -&gt; int:\n\"\"\"Find number of controls in the dict.\"\"\"\n        return len(self._control_dict.keys())\n\n    def get_count_of_controls_in_catalog(self, recurse: bool) -&gt; int:\n\"\"\"Get count of controls from the actual catalog including optional sub controls.\"\"\"\n        return len(list(self.get_all_controls_from_catalog(recurse)))\n\n    def get_group_ids(self) -&gt; List[str]:\n\"\"\"Get all the group id's as a list of sorted strings.\"\"\"\n        return sorted(filter(lambda id: id, list({control.group_id for control in self._control_dict.values()})))\n\n    def get_all_groups_from_catalog(self) -&gt; List[cat.Group]:\n\"\"\"\n        Retrieve all groups in the catalog sorted by group_id.\n\n        This ignores controls that are direct children of the catalog.\n        \"\"\"\n        groups: List[cat.Group] = []\n        if self._catalog.groups:\n            for my_group in self._catalog.groups:\n                for res in CatalogInterface._get_groups_from_group(my_group):\n                    groups.append(res)\n        return sorted(groups, key=lambda group: group.id)\n\n    def get_statement_label_if_exists(self, control_id: str,\n                                      statement_id: str) -&gt; Tuple[Optional[str], Optional[common.Part]]:\n\"\"\"Get statement label if available.\"\"\"\n\n        def does_part_exists(part: common.Part) -&gt; bool:\n            does_match = False\n            if part.name and part.name in {const.STATEMENT, 'item'} and part.id == statement_id:\n                does_match = True\n            return does_match\n\n        control = self.get_control(control_id)\n        if not control:\n            return '', None\n        label = None\n        found_part = None\n        if control.parts:\n            for part in as_list(control.parts):\n                # Performance OSCAL assumption, ids are nested so recurse only if prefix\n                if part.id and statement_id.startswith(part.id):\n                    part = self.find_part_with_condition(part, does_part_exists)\n                    if part:\n                        label = ControlInterface.get_label(part)\n                        found_part = part\n                        break\n\n        return label, found_part\n\n    def find_part_with_condition(self, part: common.Part, condition: Callable) -&gt; Optional[common.Part]:\n\"\"\"Traverse part and find subpart that satisfies given condition.\"\"\"\n        if condition(part):\n            # Part that satisfies the condition is found.\n            return part\n        else:\n            if part.parts:\n                for subpart in part.parts:\n                    found_part = self.find_part_with_condition(subpart, condition)\n                    if found_part:\n                        return found_part\n\n        return None\n\n    def delete_withdrawn_controls(self) -&gt; None:\n\"\"\"Delete all withdrawn controls from the catalog.\"\"\"\n        delete_list = []\n        for control in self.get_all_controls_from_dict():\n            if ControlInterface.is_withdrawn(control):\n                delete_list.append(control.id)\n        for id_ in delete_list:\n            self.delete_control(id_)\n\n    @staticmethod\n    def _get_groups_from_group(group: cat.Group) -&gt; Iterator[cat.Group]:\n        yield group\n        if group.groups:\n            for new_group in group.groups:\n                for res in CatalogInterface._get_groups_from_group(new_group):\n                    yield res\n\n    def get_group_info_by_control(self, control_id: str) -&gt; Tuple[str, str, str]:\n\"\"\"Get the group_id, title, class for this control from the dict.\"\"\"\n        return (\n            self._control_dict[control_id].group_id,\n            self._control_dict[control_id].group_title,\n            self._control_dict[control_id].group_class\n        )\n\n    def get_control_path(self, control_id: str) -&gt; List[str]:\n\"\"\"Return the path into the markdown directory for this control based only on the groups.\"\"\"\n        return self._control_dict[control_id].group_path\n\n    def get_control_file_path(self, md_root: pathlib.Path, control_id: str) -&gt; Optional[pathlib.Path]:\n\"\"\"Get the path to the control from the given root.\"\"\"\n        if control_id not in self._control_dict:\n            return None\n        path = md_root\n        for item in self.get_control_path(control_id):\n            path = path / item\n        return path / f'{control_id}.md'\n\n    def get_full_control_path(self, control_id: str) -&gt; List[str]:\n\"\"\"Return the path to the control including groups and sub-controls.\"\"\"\n        return self._control_dict[control_id].control_path\n\n    def replace_control(self, control: cat.Control) -&gt; None:\n\"\"\"\n        Replace the control in the control_dict.\n\n        This only replaces the parent control and not its children.\n        \"\"\"\n        self._control_dict[control.id].control = control\n\n    def delete_control(self, control_id: str) -&gt; None:\n\"\"\"\n        Delete the control from the control_dict based on id.\n\n        Delete all its dependent children also.\n        \"\"\"\n        control = self.get_control(control_id)\n        if control:\n            for sub_control_id in self.get_dependent_control_ids(control.id):\n                self._control_dict.pop(sub_control_id, None)\n            self._control_dict.pop(control_id, None)\n\n    def get_catalog(self, update=True) -&gt; cat.Catalog:\n\"\"\"Safe method to get catalog after forced update from catalog dict.\"\"\"\n        if update:\n            self.update_catalog_controls()\n        return self._catalog\n\n    def _update_all_controls_in_list(self, controls: List[cat.Control]) -&gt; List[cat.Control]:\n\"\"\"\n        Given a list of controls, create fresh list pulled from the control dict.\n\n        Args:\n            controls: a list of controls in the original catalog\n\n        Returns:\n            The new list of updated controls, possibly with some missing if they have been removed from the dict.\n            Children are inserted as needed into parent controls.\n        \"\"\"\n        new_list: List[cat.Control] = []\n        for control in controls:\n            # first update the control itself by getting it from the dict\n            new_control = self.get_control(control.id)\n            if new_control:\n                # this overrides any sub controls in the control itself\n                # any added sub-controls should add to the skipped list\n                new_control.controls = self._update_all_controls_in_list(as_list(control.controls))\n                new_control.controls = none_if_empty(new_control.controls)\n                new_list.append(new_control)\n        return new_list\n\n    def _update_all_controls_in_group(self, group: cat.Group) -&gt; None:\n\"\"\"Given a group of controls, create fresh version pulled from the control dict.\"\"\"\n        group.controls = self._update_all_controls_in_list(as_list(group.controls))\n        group.controls = none_if_empty(group.controls)\n        new_groups: List[cat.Group] = []\n        for sub_group in as_list(group.groups):\n            self._update_all_controls_in_group(sub_group)\n            new_groups.append(sub_group)\n        group.groups = none_if_empty(new_groups)\n\n    def _insert_control_in_catalog(self, control_handle: ControlHandle) -&gt; None:\n\"\"\"Insert the control into the catalog based on its path.\"\"\"\n        path = control_handle.group_path\n        node = self._catalog\n        if path[0] != '':\n            for group_id in path:\n                found_group = None\n                for group in as_list(node.groups):\n                    if group.id == group_id:\n                        found_group = group\n                        break\n                if found_group:\n                    node = found_group\n                else:\n                    raise TrestleError(f'No controls found in catalog for group {group.id}')\n            node.title = control_handle.group_title\n            node.class_ = control_handle.group_class\n        node.controls = delete_item_from_list(\n            as_list(node.controls), control_handle.control.id, lambda control: control.id\n        )\n        node.controls.append(control_handle.control)\n        node.controls = none_if_empty(sorted(node.controls, key=lambda control: ControlInterface.get_sort_id(control)))\n\n    def update_catalog_controls(self) -&gt; None:\n\"\"\"\n        Update the actual catalog by pulling fresh controls from the dict.\n\n        During assembly, controls may be added, but not children of controls.\n        New groups may not be added.\n        A control containing controls cannot be added.  Controls containing controls are only available if\n        the parent catalog was loaded from json.\n        \"\"\"\n        # first go through the catalog and pull existing controls from the dict\n        for group in as_list(self._catalog.groups):\n            self._update_all_controls_in_group(group)\n\n        new_list = []\n        for control in as_list(self._catalog.controls):\n            new_control = self.get_control(control.id)\n            new_control.controls = self._update_all_controls_in_list(as_list(control.controls))\n            new_control.controls = none_if_empty(new_control.controls)\n            new_list.append(new_control)\n        self._catalog.controls = none_if_empty(new_list)\n\n        # now add any new controls that are discovered in the dict\n        ids_in_catalog = CatalogInterface.get_control_ids_from_catalog(self._catalog)\n        for control_handle in self._control_dict.values():\n            if control_handle.control.id not in ids_in_catalog:\n                self._insert_control_in_catalog(control_handle)\n\n        self._catalog.params = none_if_empty(list(self.loose_param_dict.values()))\n\n    def _find_string_in_part(self, control_id: str, part: common.Part, seek_str: str) -&gt; List[str]:\n        hits: List[str] = []\n        if part.prose and part.prose.find(seek_str) &gt;= 0:\n            hits.append((control_id, part.prose))\n        if part.parts:\n            for sub_part in part.parts:\n                hits.extend(self._find_string_in_part(control_id, sub_part, seek_str))\n        return hits\n\n    def find_string_in_control(self, control: cat.Control, seek_str: str) -&gt; List[Tuple[str, str]]:\n\"\"\"Find all instances of this string in prose of control.\"\"\"\n        hits: List[Tuple[str, str]] = []\n        if control.parts:\n            for part in control.parts:\n                hits.extend(self._find_string_in_part(control.id, part, seek_str))\n        return hits\n\n    @staticmethod\n    def _get_full_profile_param_dict(profile: Optional[prof.Profile]) -&gt; Dict[str, common.Parameter]:\n\"\"\"Get the full mapping of param_id to modified value for this profiles set_params.\"\"\"\n        set_param_dict: Dict[str, common.Parameter] = {}\n        if profile and profile.modify:\n            for set_param in as_list(profile.modify.set_parameters):\n                param = ControlInterface.setparam_to_param(set_param.param_id, set_param)\n                set_param_dict[set_param.param_id] = param\n        return set_param_dict\n\n    @staticmethod\n    def _get_profile_param_dict(\n        control: cat.Control, profile_param_dict: Dict[str, common.Parameter], values_only: bool\n    ) -&gt; Dict[str, common.Parameter]:\n\"\"\"\n        Get the dict of params for this control including possible overrides made by the profile modifications.\n\n        Args:\n            control: The control being queried\n            profile_param_dict: The full dict of params and modified values made by the profile\n\n        Returns:\n            mapping of param ids to their final parameter states after possible modify by the profile setparameters\n        \"\"\"\n        # get the mapping of param_id's to params for this control, excluding those with no value set\n        param_dict = ControlInterface.get_control_param_dict(control, values_only)\n        for key in param_dict.keys():\n            if key in profile_param_dict:\n                param_dict[key] = profile_param_dict[key]\n        return param_dict\n\n    def _get_full_param_dict(self) -&gt; Dict[str, common.Parameter]:\n        param_dict: Dict[str, common.Parameter] = {}\n        # build the full mapping of params to values from the catalog interface\n        for control in self.get_all_controls_from_dict():\n            param_dict.update(ControlInterface.get_control_param_dict(control, False))\n        return param_dict\n\n    def _change_prose_with_param_values(\n        self,\n        param_format,\n        param_rep,\n        show_value_warnings: bool,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; None:\n\"\"\"Go through all controls and change prose based on param values.\"\"\"\n        param_dict = self._get_full_param_dict()\n        # insert param values into prose of all controls\n        for control in self.get_all_controls_from_dict():\n            ControlInterface.replace_control_prose(\n                control,\n                param_dict,\n                param_format,\n                param_rep,\n                show_value_warnings,\n                value_assigned_prefix,\n                value_not_assigned_prefix\n            )\n\n    @staticmethod\n    def _get_display_name_and_ns(param: common.Parameter) -&gt; Tuple[Optional[str], Optional[str]]:\n        for prop in as_list(param.props):\n            if prop.name == const.DISPLAY_NAME:\n                ns = str(prop.ns) if prop.ns else None\n                return prop.value, ns\n        return None, None\n\n    @staticmethod\n    def _prune_controls(md_path: pathlib.Path, written_controls: Set[str]) -&gt; List[str]:\n\"\"\"Search directory and remove any controls that were not written out.\"\"\"\n        deleted_controls = []\n        for control_file in md_path.rglob('*.md'):\n            if control_file.stem not in written_controls:\n                logger.debug(\n                    f'Existing control markdown {control_file} deleted since it was not written out during generate'\n                )  # noqa E501\n                control_file.unlink()\n                deleted_controls.append(control_file.stem)\n        return sorted(deleted_controls)\n\n    def _extend_rules_param_list(\n        self, control_id: str, header: Dict[str, Any], param_id_rule_name_map: Dict[str, str]\n    ) -&gt; None:\n\"\"\"Go through all set_params and put in rules param list if name matches.\"\"\"\n        control_comp_set_params = {}\n        rules_set_params = {}\n        all_set_params = self.get_control_comp_set_params(control_id)\n        for comp_name, param_list in all_set_params.items():\n            for param in param_list:\n                param_vals = none_if_empty(as_list(param.values))\n                rule_name = deep_get(param_id_rule_name_map, [comp_name, param.param_id], None)\n                if rule_name:\n                    param_dict = {'name': param.param_id}\n                    if param_vals:\n                        param_dict['values'] = param_vals\n                    deep_append(rules_set_params, [comp_name], param_dict)\n        set_or_pop(header, const.COMP_DEF_RULES_PARAM_VALS_TAG, rules_set_params)\n        set_or_pop(header, const.SET_PARAMS_TAG, control_comp_set_params)\n\n    def _get_control_memory_info(self, control_id: str, context: ControlContext) -&gt; Tuple[Dict[str, Any], CompDict]:\n\"\"\"Build the rule info for the control into the header.\"\"\"\n        header = {}\n        rule_names_list: List[str] = []\n        comp_dict = self.get_comp_info(control_id)\n        # find the rule names that are needed by the control\n        for _, value in comp_dict.items():\n            for comp_info in value.values():\n                rule_names_list.extend(as_list(comp_info.rules))\n        if rule_names_list:\n            header_rules_dict = {}\n            rule_ids = {}\n            param_id_rule_name_map = {}\n            rule_id_rule_name_map = {}\n            # only include rules needed by control in the header\n            for comp_name, rules_dict in context.rules_dict.items():\n                for rule_id, rule_dict in rules_dict.items():\n                    if rule_dict['name'] in rule_names_list:\n                        deep_append(rule_ids, [comp_name], rule_id)\n                        deep_append(header_rules_dict, [comp_name], rule_dict)\n                        deep_set(rule_id_rule_name_map, [comp_name, rule_id], rule_dict['name'])\n            set_or_pop(header, const.COMP_DEF_RULES_TAG, header_rules_dict)\n            rules_params = {}\n            rules_param_names = []\n            for comp_name, rules_params_dict in as_dict(context.rules_params_dict).items():\n                for rule_id, rules_param in rules_params_dict.items():\n                    if rule_id in rule_ids.get(comp_name, []):\n                        param_name = rules_param['name']\n                        rules_param_names.append(param_name)\n                        rules_param[const.HEADER_RULE_ID] = rule_id_rule_name_map[comp_name].get(rule_id, None)\n                        deep_append(rules_params, [comp_name], rules_param)\n                        deep_set(\n                            param_id_rule_name_map, [comp_name, rules_param['name']],\n                            rule_id_rule_name_map[comp_name][rule_id]\n                        )\n            set_or_pop(header, const.RULES_PARAMS_TAG, rules_params)\n\n            self._extend_rules_param_list(control_id, header, param_id_rule_name_map)\n\n        return header, comp_dict\n\n    @staticmethod\n    def _get_group_ids_and_dirs(md_path: pathlib.Path) -&gt; Dict[str, pathlib.Path]:\n\"\"\"\n        Create a sorted map of group id to group dir that is ordered by group id.\n\n        This includes '' as the root group id.\n        \"\"\"\n        # manually insert the top dir as group ''\n        id_map: Dict[str, pathlib.Path] = {'': md_path}\n        for gdir in md_path.rglob('*'):\n            if gdir.is_dir():\n                dir_name = gdir.parts[-1]\n                id_map[dir_name] = gdir\n        # rebuild the dict by inserting items in manner sorted by key\n        sorted_id_map: Dict[str, pathlib.Path] = {}\n        for key in sorted(id_map):\n            sorted_id_map[key] = id_map[key]\n        return sorted_id_map\n\n    def get_sections(self) -&gt; List[str]:\n\"\"\"Get the available sections by a full index of all controls.\"\"\"\n        return list(\n            {\n                part.name\n                for control_handle in self._control_dict.values()\n                for part in as_list(control_handle.control.parts)\n                if part.name != const.STATEMENT\n            }\n        )\n\n    def _find_control_in_group(self, group_id: str) -&gt; Tuple[str, ControlHandle]:\n\"\"\"\n        Find a representative control for this group and its control handle.\n\n        This is a simple way to get group info (title etc.) given only group id.\n        It is not intended for high performance loops.  Use only as needed.\n        \"\"\"\n        for control_id, control_handle in self._control_dict.items():\n            if control_handle.group_id == group_id:\n                return control_id, control_handle\n        raise TrestleError(f'No controls found for group {group_id}')\n\n    def _add_control_imp_comp_info(\n        self, context: ControlContext, part_id_map: Dict[str, Dict[str, str]], comp_rules_props: List[common.Property]\n    ) -&gt; None:\n\"\"\"Add component info to the impreqs of the control implementation based on applied rules.\"\"\"\n        control_imp_rules_dict, control_imp_rules_params_dict, ci_rules_props = ControlInterface.get_rules_and_params_dict_from_item(context.control_implementation)  # noqa E501\n        context.rules_dict[context.comp_name].update(control_imp_rules_dict)\n        comp_rules_params_dict = context.rules_params_dict.get(context.comp_name, {})\n        comp_rules_params_dict.update(control_imp_rules_params_dict)\n        context.rules_params_dict[context.comp_name] = comp_rules_params_dict\n        ci_set_params = ControlInterface.get_set_params_from_item(context.control_implementation)\n        catalog_control_ids = self.get_control_ids()\n        for imp_req in as_list(context.control_implementation.implemented_requirements):\n            if imp_req.control_id not in catalog_control_ids:\n                logger.warning(\n                    f'Component {context.component.title} references control {imp_req.control_id} not in profile.'\n                )\n            control_part_id_map = part_id_map.get(imp_req.control_id, {})\n            # find if any rules apply to this control, including in statements\n            control_rules, statement_rules, ir_props = ControlInterface.get_rule_list_for_imp_req(imp_req)\n            rule_props = comp_rules_props[:]\n            rule_props.extend(ci_rules_props)\n            rule_props.extend(ir_props)\n            rule_props = ControlInterface.clean_props(rule_props, remove_imp_status=False)\n            if control_rules:\n                status = ControlInterface.get_status_from_props(imp_req)\n                final_props = ControlInterface.cull_props_by_rules(rule_props, control_rules)\n                comp_info = ComponentImpInfo(imp_req.description, control_rules, final_props, status)\n                self.add_comp_info(imp_req.control_id, context.comp_name, '', comp_info)\n            set_params = copy.deepcopy(ci_set_params)\n            set_params.update(ControlInterface.get_set_params_from_item(imp_req))\n            for set_param in set_params.values():\n                # add to control_comp_set_params dict\n                self.add_comp_set_param(imp_req.control_id, context.comp_name, set_param)\n            for statement in as_list(imp_req.statements):\n                rule_list, stat_props = ControlInterface.get_rule_list_for_item(statement)\n                if rule_list:\n                    status = ControlInterface.get_status_from_props(statement)\n                    if statement.statement_id not in control_part_id_map:\n                        label = statement.statement_id\n                        logger.warning(\n                            f'No statement label found for statement id {label}.  Defaulting to {label}.'  # noqa E501\n                        )\n                    else:\n                        label = control_part_id_map[statement.statement_id]\n                    all_props = rule_props[:]\n                    all_props.extend(stat_props)\n                    final_props = ControlInterface.cull_props_by_rules(all_props, rule_list)\n                    comp_info = ComponentImpInfo(statement.description, rule_list, final_props, status)\n                    self.add_comp_info(imp_req.control_id, context.comp_name, label, comp_info)\n\n    def generate_control_rule_info(self, part_id_map: Dict[str, Dict[str, str]], context: ControlContext) -&gt; None:\n\"\"\"\n        Generate rule info for controls directly from the components.\n\n        Args:\n            part_id_map: Mapping of label to part in the control\n            context: Control context for the current operation\n\n        Returns:\n            Returns nothing but places the rules_dict and rules_params_dict in the context for each component\n        \"\"\"\n        context.rules_dict = {}\n        context.rules_params_dict = {}\n        for comp_def_name in context.comp_def_name_list:\n            context.comp_def, _ = ModelUtils.load_model_for_class(\n                context.trestle_root,\n                comp_def_name,\n                comp.ComponentDefinition\n            )\n            for component in as_list(context.comp_def.components):\n                context.component = component\n                context.comp_name = component.title\n                # get top level rule info applying to all controls from the component props\n                comp_rules_dict, comp_rules_params_dict, comp_rules_props = ControlInterface.get_rules_and_params_dict_from_item(component)  # noqa E501\n                context.rules_dict[context.comp_name] = comp_rules_dict\n                deep_update(context.rules_params_dict, [context.comp_name], comp_rules_params_dict)\n                for control_imp in as_list(component.control_implementations):\n                    context.control_implementation = control_imp\n                    self._add_control_imp_comp_info(context, part_id_map, comp_rules_props)\n                # add the rule_id to the param_dict\n                for param_comp_name, rule_param_dict in context.rules_params_dict.items():\n                    for rule_tag, param_dict in rule_param_dict.items():\n                        rule_dict = deep_get(context.rules_dict, [param_comp_name, rule_tag], {})\n                        param_dict[const.HEADER_RULE_ID] = rule_dict.get(const.NAME, 'unknown_rule')\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.ControlHandle","title":"<code> ControlHandle        </code>  <code>dataclass</code>","text":"<p>Convenience class for handling controls as members of a group.</p> <p>group_id: id of parent group or '' if not in a group group_title: title of the group group_class: class of the group path: path of parent groups leading to this control - without the final control_id, or [''] if in cat list important to remember that controls may not be in a group and are directly attached to cat control: the control itself</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>class ControlHandle:\n\"\"\"Convenience class for handling controls as members of a group.\n\n    group_id: id of parent group or '' if not in a group\n    group_title: title of the group\n    group_class: class of the group\n    path: path of parent groups leading to this control - without the final control_id, or [''] if in cat list\n    important to remember that controls may not be in a group and are directly attached to cat\n    control: the control itself\n    \"\"\"\n\n    group_id: str\n    group_title: Optional[str]\n    group_class: Optional[str]\n    group_path: List[str]\n    control_path: List[str]\n    control: cat.Control\n</code></pre> <code>control: Control</code> <code>dataclass-field</code> \u00a4 <code>control_path: List[str]</code> <code>dataclass-field</code> \u00a4 <code>group_class: Optional[str]</code> <code>dataclass-field</code> \u00a4 <code>group_id: str</code> <code>dataclass-field</code> \u00a4 <code>group_path: List[str]</code> <code>dataclass-field</code> \u00a4 <code>group_title: Optional[str]</code> <code>dataclass-field</code> \u00a4 <code>__eq__(self, other)</code> <code>special</code> \u00a4 <code>__init__(self, group_id, group_title, group_class, group_path, control_path, control)</code> <code>special</code> \u00a4 <code>__repr__(self)</code> <code>special</code> \u00a4"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.__init__","title":"<code>__init__(self, catalog=None)</code>  <code>special</code>","text":"<p>Initialize the interface with the catalog.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def __init__(self, catalog: Optional[cat.Catalog] = None) -&gt; None:\n\"\"\"Initialize the interface with the catalog.\"\"\"\n    self._catalog = catalog\n    self._param_control_map: Dict[str, str] = {}\n    self._generate_group_index: int = 0\n    self._control_dict = self._create_control_dict() if catalog else None\n    self.loose_param_dict: Dict[str, common.Parameter] = {param.id: param\n                                                          for param in as_list(catalog.params)} if catalog else {}\n    # map control id to CompDict\n    self._control_comp_dicts: Dict[str, CompDict] = {}\n    # map control id to dict containing set parameters by component\n    self._control_comp_set_params: Dict[str, Dict[str, comp.SetParameter]] = {}\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.add_comp_info","title":"<code>add_comp_info(self, control_id, comp_name, label, comp_info)</code>","text":"<p>Add comp_info for a control.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def add_comp_info(self, control_id: str, comp_name: str, label: str, comp_info: ComponentImpInfo) -&gt; None:\n\"\"\"Add comp_info for a control.\"\"\"\n    deep_set(self._control_comp_dicts, [control_id, comp_name, label], comp_info)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.add_comp_set_param","title":"<code>add_comp_set_param(self, control_id, comp_name, set_param)</code>","text":"<p>Add component setparam for control with overwrite.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def add_comp_set_param(self, control_id: str, comp_name: str, set_param: comp.SetParameter) -&gt; None:\n\"\"\"Add component setparam for control with overwrite.\"\"\"\n    deep_append(self._control_comp_set_params, [control_id, comp_name], set_param)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.clear_comp_dicts","title":"<code>clear_comp_dicts(self)</code>","text":"<p>Clear the control component dicts.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def clear_comp_dicts(self) -&gt; None:\n\"\"\"Clear the control component dicts.\"\"\"\n    self._control_comp_dicts = {}\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.clear_set_params","title":"<code>clear_set_params(self)</code>","text":"<p>Clear the control set params.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def clear_set_params(self) -&gt; None:\n\"\"\"Clear the control set params.\"\"\"\n    self._control_comp_set_params = {}\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.delete_control","title":"<code>delete_control(self, control_id)</code>","text":"<p>Delete the control from the control_dict based on id.</p> <p>Delete all its dependent children also.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def delete_control(self, control_id: str) -&gt; None:\n\"\"\"\n    Delete the control from the control_dict based on id.\n\n    Delete all its dependent children also.\n    \"\"\"\n    control = self.get_control(control_id)\n    if control:\n        for sub_control_id in self.get_dependent_control_ids(control.id):\n            self._control_dict.pop(sub_control_id, None)\n        self._control_dict.pop(control_id, None)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.delete_withdrawn_controls","title":"<code>delete_withdrawn_controls(self)</code>","text":"<p>Delete all withdrawn controls from the catalog.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def delete_withdrawn_controls(self) -&gt; None:\n\"\"\"Delete all withdrawn controls from the catalog.\"\"\"\n    delete_list = []\n    for control in self.get_all_controls_from_dict():\n        if ControlInterface.is_withdrawn(control):\n            delete_list.append(control.id)\n    for id_ in delete_list:\n        self.delete_control(id_)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.find_part_with_condition","title":"<code>find_part_with_condition(self, part, condition)</code>","text":"<p>Traverse part and find subpart that satisfies given condition.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def find_part_with_condition(self, part: common.Part, condition: Callable) -&gt; Optional[common.Part]:\n\"\"\"Traverse part and find subpart that satisfies given condition.\"\"\"\n    if condition(part):\n        # Part that satisfies the condition is found.\n        return part\n    else:\n        if part.parts:\n            for subpart in part.parts:\n                found_part = self.find_part_with_condition(subpart, condition)\n                if found_part:\n                    return found_part\n\n    return None\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.find_string_in_control","title":"<code>find_string_in_control(self, control, seek_str)</code>","text":"<p>Find all instances of this string in prose of control.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def find_string_in_control(self, control: cat.Control, seek_str: str) -&gt; List[Tuple[str, str]]:\n\"\"\"Find all instances of this string in prose of control.\"\"\"\n    hits: List[Tuple[str, str]] = []\n    if control.parts:\n        for part in control.parts:\n            hits.extend(self._find_string_in_part(control.id, part, seek_str))\n    return hits\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.generate_control_rule_info","title":"<code>generate_control_rule_info(self, part_id_map, context)</code>","text":"<p>Generate rule info for controls directly from the components.</p> <p>Parameters:</p> Name Type Description Default <code>part_id_map</code> <code>Dict[str, Dict[str, str]]</code> <p>Mapping of label to part in the control</p> required <code>context</code> <code>ControlContext</code> <p>Control context for the current operation</p> required <p>Returns:</p> Type Description <code>None</code> <p>Returns nothing but places the rules_dict and rules_params_dict in the context for each component</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def generate_control_rule_info(self, part_id_map: Dict[str, Dict[str, str]], context: ControlContext) -&gt; None:\n\"\"\"\n    Generate rule info for controls directly from the components.\n\n    Args:\n        part_id_map: Mapping of label to part in the control\n        context: Control context for the current operation\n\n    Returns:\n        Returns nothing but places the rules_dict and rules_params_dict in the context for each component\n    \"\"\"\n    context.rules_dict = {}\n    context.rules_params_dict = {}\n    for comp_def_name in context.comp_def_name_list:\n        context.comp_def, _ = ModelUtils.load_model_for_class(\n            context.trestle_root,\n            comp_def_name,\n            comp.ComponentDefinition\n        )\n        for component in as_list(context.comp_def.components):\n            context.component = component\n            context.comp_name = component.title\n            # get top level rule info applying to all controls from the component props\n            comp_rules_dict, comp_rules_params_dict, comp_rules_props = ControlInterface.get_rules_and_params_dict_from_item(component)  # noqa E501\n            context.rules_dict[context.comp_name] = comp_rules_dict\n            deep_update(context.rules_params_dict, [context.comp_name], comp_rules_params_dict)\n            for control_imp in as_list(component.control_implementations):\n                context.control_implementation = control_imp\n                self._add_control_imp_comp_info(context, part_id_map, comp_rules_props)\n            # add the rule_id to the param_dict\n            for param_comp_name, rule_param_dict in context.rules_params_dict.items():\n                for rule_tag, param_dict in rule_param_dict.items():\n                    rule_dict = deep_get(context.rules_dict, [param_comp_name, rule_tag], {})\n                    param_dict[const.HEADER_RULE_ID] = rule_dict.get(const.NAME, 'unknown_rule')\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_all_controls_from_catalog","title":"<code>get_all_controls_from_catalog(self, recurse)</code>","text":"<p>Yield all controls from the actual catalog by group including optional sub controls.</p> <p>Parameters:</p> Name Type Description Default <code>recurse</code> <code>bool</code> <p>Whether to recurse within controls, but groups are always recursed</p> required <p>Returns:</p> Type Description <code>Iterator[trestle.oscal.catalog.Control]</code> <p>iterator of the controls in the catalog</p> <p>Notes</p> <p>This follows the actual structure of the catalog and groups</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_all_controls_from_catalog(self, recurse: bool) -&gt; Iterator[cat.Control]:\n\"\"\"\n    Yield all controls from the actual catalog by group including optional sub controls.\n\n    Args:\n        recurse: Whether to recurse within controls, but groups are always recursed\n\n    Returns:\n        iterator of the controls in the catalog\n\n    Notes:\n        This follows the actual structure of the catalog and groups\n    \"\"\"\n    if self._catalog.groups:\n        for group in self._catalog.groups:\n            controls = self._get_all_controls_in_group(group, recurse)\n            for control in controls:\n                yield control\n    if self._catalog.controls:\n        cat_controls = self._get_all_controls_in_list(self._catalog.controls, recurse)\n        for control in cat_controls:\n            yield control\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_all_controls_from_dict","title":"<code>get_all_controls_from_dict(self)</code>","text":"<p>Yield individual controls from the dict.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_all_controls_from_dict(self) -&gt; List[cat.Control]:\n\"\"\"Yield individual controls from the dict.\"\"\"\n    return [handle.control for handle in self._control_dict.values()]\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_all_groups_from_catalog","title":"<code>get_all_groups_from_catalog(self)</code>","text":"<p>Retrieve all groups in the catalog sorted by group_id.</p> <p>This ignores controls that are direct children of the catalog.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_all_groups_from_catalog(self) -&gt; List[cat.Group]:\n\"\"\"\n    Retrieve all groups in the catalog sorted by group_id.\n\n    This ignores controls that are direct children of the catalog.\n    \"\"\"\n    groups: List[cat.Group] = []\n    if self._catalog.groups:\n        for my_group in self._catalog.groups:\n            for res in CatalogInterface._get_groups_from_group(my_group):\n                groups.append(res)\n    return sorted(groups, key=lambda group: group.id)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_catalog","title":"<code>get_catalog(self, update=True)</code>","text":"<p>Safe method to get catalog after forced update from catalog dict.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_catalog(self, update=True) -&gt; cat.Catalog:\n\"\"\"Safe method to get catalog after forced update from catalog dict.\"\"\"\n    if update:\n        self.update_catalog_controls()\n    return self._catalog\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_catalog_title","title":"<code>get_catalog_title(self)</code>","text":"<p>Get the title of the catalog.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_catalog_title(self) -&gt; str:\n\"\"\"Get the title of the catalog.\"\"\"\n    return self._catalog.metadata.title\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_comp_info","title":"<code>get_comp_info(self, control_id)</code>","text":"<p>Get comp_dict for this control.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_comp_info(self, control_id: str) -&gt; CompDict:\n\"\"\"Get comp_dict for this control.\"\"\"\n    return self._control_comp_dicts.get(control_id, {})\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_control","title":"<code>get_control(self, control_id)</code>","text":"<p>Get control from the control dict with this id.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_control(self, control_id: str) -&gt; Optional[cat.Control]:\n\"\"\"Get control from the control dict with this id.\"\"\"\n    return None if control_id not in self._control_dict else self._control_dict[control_id].control\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_control_by_param_id","title":"<code>get_control_by_param_id(self, param_id)</code>","text":"<p>Get control from catalog that has this param id using the dict.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_control_by_param_id(self, param_id: str) -&gt; Optional[cat.Control]:\n\"\"\"Get control from catalog that has this param id using the dict.\"\"\"\n    if param_id in self._param_control_map:\n        return self.get_control(self._param_control_map[param_id])\n    return None\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_control_comp_set_params","title":"<code>get_control_comp_set_params(self, control_id)</code>","text":"<p>Get dict of setparams list per component.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_control_comp_set_params(self, control_id: str) -&gt; Dict[str, List[comp.SetParameter]]:\n\"\"\"Get dict of setparams list per component.\"\"\"\n    return self._control_comp_set_params.get(control_id, {})\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_control_file_path","title":"<code>get_control_file_path(self, md_root, control_id)</code>","text":"<p>Get the path to the control from the given root.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_control_file_path(self, md_root: pathlib.Path, control_id: str) -&gt; Optional[pathlib.Path]:\n\"\"\"Get the path to the control from the given root.\"\"\"\n    if control_id not in self._control_dict:\n        return None\n    path = md_root\n    for item in self.get_control_path(control_id):\n        path = path / item\n    return path / f'{control_id}.md'\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_control_id_and_status","title":"<code>get_control_id_and_status(self, control_name)</code>","text":"<p>Get the control id and status using the control name.</p> <p>Returns empty string if status not found.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_control_id_and_status(self, control_name: str) -&gt; Tuple[str, str]:\n\"\"\"\n    Get the control id and status using the control name.\n\n    Returns empty string if status not found.\n    \"\"\"\n    for control in self.get_all_controls_from_dict():\n        if ControlInterface.get_label(control).strip().lower() == control_name.strip().lower():\n            status = ControlInterface.get_prop(control, 'status')\n            return control.id, status\n    return '', ''\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_control_ids","title":"<code>get_control_ids(self)</code>","text":"<p>Get all control ids from the control dict.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_control_ids(self) -&gt; List[str]:\n\"\"\"Get all control ids from the control dict.\"\"\"\n    return self._control_dict.keys()\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_control_ids_from_catalog","title":"<code>get_control_ids_from_catalog(catalog)</code>  <code>staticmethod</code>","text":"<p>Get all control ids from a catalog.</p> <p>This is intended to provide a quick list of all controls in a catalog without the expense of building the control dict.  So, if repeated queries are made into a catalog, it is worth instantiating a CatalogInterface and associated control dict.  Otherwise just use this to get a list of all controls.</p> <p>This function is needed within the CatalogInterface in order to determine if new controls have been added to the dict and need to be inserted in the actual catalog during update.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>@staticmethod\ndef get_control_ids_from_catalog(catalog: cat.Catalog) -&gt; List[str]:\n\"\"\"\n    Get all control ids from a catalog.\n\n    This is intended to provide a quick list of all controls in a catalog without the expense of building the\n    control dict.  So, if repeated queries are made into a catalog, it is worth instantiating a CatalogInterface\n    and associated control dict.  Otherwise just use this to get a list of all controls.\n\n    This function is needed within the CatalogInterface in order to determine if new controls have been added\n    to the dict and need to be inserted in the actual catalog during update.\n    \"\"\"\n    controls = CatalogInterface._get_all_controls_in_list(as_list(catalog.controls), True)\n    id_list = [control.id for control in controls]\n    for group in as_list(catalog.groups):\n        controls = CatalogInterface._get_all_controls_in_group(group, True)\n        id_list.extend([control.id for control in as_list(controls)])\n    return id_list\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_control_part_prose","title":"<code>get_control_part_prose(self, control_id, part_name)</code>","text":"<p>Get the prose for a named part in the control.</p> <p>Parameters:</p> Name Type Description Default <code>control_id</code> <code>str</code> <p>id of the control</p> required <code>part_name</code> <code>str</code> <p>name of the part</p> required <p>Returns:</p> Type Description <code>str</code> <p>Single string concatenating prose from all parts and sub-parts in control with that name.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_control_part_prose(self, control_id: str, part_name: str) -&gt; str:\n\"\"\"\n    Get the prose for a named part in the control.\n\n    Args:\n        control_id: id of the control\n        part_name: name of the part\n\n    Returns:\n        Single string concatenating prose from all parts and sub-parts in control with that name.\n    \"\"\"\n    control = self.get_control(control_id)\n    return ControlInterface.get_part_prose(control, part_name)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_control_path","title":"<code>get_control_path(self, control_id)</code>","text":"<p>Return the path into the markdown directory for this control based only on the groups.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_control_path(self, control_id: str) -&gt; List[str]:\n\"\"\"Return the path into the markdown directory for this control based only on the groups.\"\"\"\n    return self._control_dict[control_id].group_path\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_count_of_controls_in_catalog","title":"<code>get_count_of_controls_in_catalog(self, recurse)</code>","text":"<p>Get count of controls from the actual catalog including optional sub controls.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_count_of_controls_in_catalog(self, recurse: bool) -&gt; int:\n\"\"\"Get count of controls from the actual catalog including optional sub controls.\"\"\"\n    return len(list(self.get_all_controls_from_catalog(recurse)))\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_count_of_controls_in_dict","title":"<code>get_count_of_controls_in_dict(self)</code>","text":"<p>Find number of controls in the dict.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_count_of_controls_in_dict(self) -&gt; int:\n\"\"\"Find number of controls in the dict.\"\"\"\n    return len(self._control_dict.keys())\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_dependent_control_ids","title":"<code>get_dependent_control_ids(self, control_id)</code>","text":"<p>Find all child ids of this control from the dict with recursion.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_dependent_control_ids(self, control_id: str) -&gt; List[str]:\n\"\"\"Find all child ids of this control from the dict with recursion.\"\"\"\n    children: List[str] = []\n    control = self.get_control(control_id)\n    if control:\n        new_controls = self._get_all_controls_in_list(as_list(control.controls), True)\n        children.extend([con.id for con in new_controls])\n    return children\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_full_control_path","title":"<code>get_full_control_path(self, control_id)</code>","text":"<p>Return the path to the control including groups and sub-controls.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_full_control_path(self, control_id: str) -&gt; List[str]:\n\"\"\"Return the path to the control including groups and sub-controls.\"\"\"\n    return self._control_dict[control_id].control_path\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_group_ids","title":"<code>get_group_ids(self)</code>","text":"<p>Get all the group id's as a list of sorted strings.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_group_ids(self) -&gt; List[str]:\n\"\"\"Get all the group id's as a list of sorted strings.\"\"\"\n    return sorted(filter(lambda id: id, list({control.group_id for control in self._control_dict.values()})))\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_group_info_by_control","title":"<code>get_group_info_by_control(self, control_id)</code>","text":"<p>Get the group_id, title, class for this control from the dict.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_group_info_by_control(self, control_id: str) -&gt; Tuple[str, str, str]:\n\"\"\"Get the group_id, title, class for this control from the dict.\"\"\"\n    return (\n        self._control_dict[control_id].group_id,\n        self._control_dict[control_id].group_title,\n        self._control_dict[control_id].group_class\n    )\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_sections","title":"<code>get_sections(self)</code>","text":"<p>Get the available sections by a full index of all controls.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_sections(self) -&gt; List[str]:\n\"\"\"Get the available sections by a full index of all controls.\"\"\"\n    return list(\n        {\n            part.name\n            for control_handle in self._control_dict.values()\n            for part in as_list(control_handle.control.parts)\n            if part.name != const.STATEMENT\n        }\n    )\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_sorted_controls_in_group","title":"<code>get_sorted_controls_in_group(self, group_id)</code>","text":"<p>Get the list of controls in a group sorted by the control sort-id.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_sorted_controls_in_group(self, group_id: str) -&gt; List[cat.Control]:\n\"\"\"Get the list of controls in a group sorted by the control sort-id.\"\"\"\n    controls: List[cat.Control] = []\n    for control in self.get_all_controls_from_dict():\n        grp_id, _, _ = self.get_group_info_by_control(control.id)\n        if grp_id == group_id:\n            controls.append(control)\n    return sorted(controls, key=lambda control: ControlInterface.get_sort_id(control))\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_statement_label_if_exists","title":"<code>get_statement_label_if_exists(self, control_id, statement_id)</code>","text":"<p>Get statement label if available.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_statement_label_if_exists(self, control_id: str,\n                                  statement_id: str) -&gt; Tuple[Optional[str], Optional[common.Part]]:\n\"\"\"Get statement label if available.\"\"\"\n\n    def does_part_exists(part: common.Part) -&gt; bool:\n        does_match = False\n        if part.name and part.name in {const.STATEMENT, 'item'} and part.id == statement_id:\n            does_match = True\n        return does_match\n\n    control = self.get_control(control_id)\n    if not control:\n        return '', None\n    label = None\n    found_part = None\n    if control.parts:\n        for part in as_list(control.parts):\n            # Performance OSCAL assumption, ids are nested so recurse only if prefix\n            if part.id and statement_id.startswith(part.id):\n                part = self.find_part_with_condition(part, does_part_exists)\n                if part:\n                    label = ControlInterface.get_label(part)\n                    found_part = part\n                    break\n\n    return label, found_part\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_statement_part_id_map","title":"<code>get_statement_part_id_map(self, label_as_key)</code>","text":"<p>Create mapping of label to part_id for top level parts in statement of all controls.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_statement_part_id_map(self, label_as_key: bool) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"Create mapping of label to part_id for top level parts in statement of all controls.\"\"\"\n    id_map = {}\n    for control in self.get_all_controls_from_catalog(True):\n        statement_part = get_item_from_list(control.parts, const.STATEMENT, lambda p: p.name)\n        if statement_part:\n            id_dict: Dict[str, str] = {}\n            for sub_part in as_list(statement_part.parts):\n                label = ControlInterface.get_label(sub_part)\n                if label_as_key:\n                    id_dict[label] = sub_part.id\n                else:\n                    id_dict[sub_part.id] = label\n            if id_dict:\n                id_map[control.id] = id_dict\n    return id_map\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.get_statement_parts","title":"<code>get_statement_parts(self, control_id)</code>","text":"<p>Get list of statement parts as dicts with indentation, label and prose.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def get_statement_parts(self, control_id: str) -&gt; List[Dict[str, str]]:\n\"\"\"Get list of statement parts as dicts with indentation, label and prose.\"\"\"\n    items = []\n    control = self.get_control(control_id)\n\n    # control may have no statement or parts\n    # but if statement present it is first part\n    if control is None:\n        logger.warning(f'No control found for id {control_id}')\n    elif control.parts:\n        part = control.parts[0]\n        if part.name == 'statement':\n            items.extend(CatalogInterface._get_statement_sub_parts(part, 0))\n        else:\n            logger.warning(f'Control {control_id} has parts but first part name is {part.name} - not statement')\n    return items\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.replace_control","title":"<code>replace_control(self, control)</code>","text":"<p>Replace the control in the control_dict.</p> <p>This only replaces the parent control and not its children.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def replace_control(self, control: cat.Control) -&gt; None:\n\"\"\"\n    Replace the control in the control_dict.\n\n    This only replaces the parent control and not its children.\n    \"\"\"\n    self._control_dict[control.id].control = control\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_interface/#trestle.core.catalog.catalog_interface.CatalogInterface.update_catalog_controls","title":"<code>update_catalog_controls(self)</code>","text":"<p>Update the actual catalog by pulling fresh controls from the dict.</p> <p>During assembly, controls may be added, but not children of controls. New groups may not be added. A control containing controls cannot be added.  Controls containing controls are only available if the parent catalog was loaded from json.</p> Source code in <code>trestle/core/catalog/catalog_interface.py</code> <pre><code>def update_catalog_controls(self) -&gt; None:\n\"\"\"\n    Update the actual catalog by pulling fresh controls from the dict.\n\n    During assembly, controls may be added, but not children of controls.\n    New groups may not be added.\n    A control containing controls cannot be added.  Controls containing controls are only available if\n    the parent catalog was loaded from json.\n    \"\"\"\n    # first go through the catalog and pull existing controls from the dict\n    for group in as_list(self._catalog.groups):\n        self._update_all_controls_in_group(group)\n\n    new_list = []\n    for control in as_list(self._catalog.controls):\n        new_control = self.get_control(control.id)\n        new_control.controls = self._update_all_controls_in_list(as_list(control.controls))\n        new_control.controls = none_if_empty(new_control.controls)\n        new_list.append(new_control)\n    self._catalog.controls = none_if_empty(new_list)\n\n    # now add any new controls that are discovered in the dict\n    ids_in_catalog = CatalogInterface.get_control_ids_from_catalog(self._catalog)\n    for control_handle in self._control_dict.values():\n        if control_handle.control.id not in ids_in_catalog:\n            self._insert_control_in_catalog(control_handle)\n\n    self._catalog.params = none_if_empty(list(self.loose_param_dict.values()))\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_merger/","title":"catalog_merger","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.catalog.catalog_merger/#trestle.core.catalog.catalog_merger","title":"<code>trestle.core.catalog.catalog_merger</code>","text":"<p>Provide interface to merge one catalog to another.</p>"},{"location":"api_reference/trestle.core.catalog.catalog_merger/#trestle.core.catalog.catalog_merger.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.catalog.catalog_merger/#trestle.core.catalog.catalog_merger-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.catalog.catalog_merger/#trestle.core.catalog.catalog_merger.CatalogMerger","title":"<code> CatalogMerger        </code>","text":"<p>Catalog merger.</p> <p>Catalog merger handles all operations related to merging contents of one catalog to another.</p> Source code in <code>trestle/core/catalog/catalog_merger.py</code> <pre><code>class CatalogMerger():\n\"\"\"\n    Catalog merger.\n\n    Catalog merger handles all operations related to\n    merging contents of one catalog to another.\n    \"\"\"\n\n    def __init__(self, catalog_interface: CatalogInterface):\n\"\"\"Initialize catalog merger.\"\"\"\n        self._catalog_interface = catalog_interface\n\n    @staticmethod\n    def merge_controls(dest: cat.Control, src: cat.Control, replace_params: bool) -&gt; None:\n\"\"\"\n        Merge the src control into dest.\n\n        Args:\n            dest: destination control into which content will be added\n            src: source control with new content\n            replace_params: replace the control params with the new ones\n        \"\"\"\n        ControlInterface.merge_parts(dest, src)\n        if replace_params:\n            dest.params = src.params\n\n    def merge_catalog(self, catalog: cat.Catalog, replace_params: bool) -&gt; None:\n\"\"\"\n        Merge the provided new catalog controls into the original catalog in this catalog interface.\n\n        Args:\n            catalog: catalog containing controls that are merged into the current catalog of the interface\n            replace_params: replace all params in the control with the new ones\n\n        Notes:\n            This is mainly to support the reading of a catalog from markdown.  It allows retention of content such as\n            metadata and backmatter, along with labels and other parameter attributes that aren't in markdown.\n            The list of controls and group structure is specified by the markdown structure - but this doesn't allow\n            controls to contain controls.  Group lists are specified per directory.\n\n            Reading the markdown tells you groups and controls in them - and groups in groups.\n            Controls cannot change groups.  If the control was in the original json, its parts are replaced,\n            including its parameters.  Only values may be specified.  If no value specified, the value is unset in json.\n        \"\"\"\n        cat_interface = CatalogInterface(catalog)\n        for src in cat_interface.get_all_controls_from_dict():\n            group_id, _, _ = cat_interface.get_group_info_by_control(src.id)\n            dest = self._catalog_interface.get_control(src.id)\n            if dest:\n                dest_group, _, _ = self._catalog_interface.get_group_info_by_control(dest.id)\n                if dest_group != group_id:\n                    raise TrestleError(f'Markdown for control {src.id} has different group id.')\n                CatalogMerger.merge_controls(dest, src, replace_params)\n                self._catalog_interface.replace_control(dest)\n            else:\n                # this is a new control that isn't already in the merge destination\n                # need to add the control knowing its group must already exist\n                # get group info from an arbitrary control already present in group\n                _, control_handle = self._catalog_interface._find_control_in_group(group_id)\n                new_control_handle = copy.deepcopy(control_handle)\n                new_control_handle.control = src\n                # add the control and its handle to the param_dict\n                self._catalog_interface._control_dict[src.id] = new_control_handle\n\n        # now need to cull any controls that are not in the src catalog\n        handled_ids = set(cat_interface._control_dict.keys())\n        orig_ids = set(self._catalog_interface._control_dict.keys())\n        extra_ids = orig_ids.difference(handled_ids)\n        for extra_id in sorted(extra_ids):\n            self._catalog_interface._control_dict.pop(extra_id)\n\n        self._catalog_interface.update_catalog_controls()\n\n    def _merge_header_and_comp_dict(\n        self, control: cat.Control, control_file_path: pathlib.Path, context: ControlContext\n    ) -&gt; None:\n\"\"\"\n        Merge the header and the comp_dict.\n\n        Notes:\n            now have all rules in context.rules_dict and all rules_params in context.rules_params_dict\n            all set-params per component for each control are in the cat interface\n            all comp-infos by control and part are in the cat interface\n\n            can now write out catalog and pull from the markdown:\n            header for param values to set during assem\n            prose and status for This System\n            status for all parts that still have rules\n        \"\"\"\n        memory_header, memory_comp_dict = self._catalog_interface._get_control_memory_info(control.id, context)\n        ControlInterface.merge_dicts_deep(memory_header, context.merged_header, True)\n        md_header, md_comp_dict = CatalogReader._read_comp_info_from_md(control_file_path, context)\n        # md content replaces memory content but unless memory has no rules for it and the content is removed\n        # but This System doesn't require rules, so its content is always kept\n\n        # go through the just-read md_comp_dict and update the memory dict with contents in md\n        if const.SSP_MAIN_COMP_NAME in md_comp_dict:\n            memory_comp_dict[const.SSP_MAIN_COMP_NAME] = md_comp_dict[const.SSP_MAIN_COMP_NAME]\n        for comp_name, md_label_dict in md_comp_dict.items():\n            memory_label_dict = memory_comp_dict.get(comp_name, None)\n            if comp_name != const.SSP_MAIN_COMP_NAME:\n                if not memory_label_dict:\n                    continue\n                for label, comp_info in md_label_dict.items():\n                    if label in memory_label_dict:\n                        memory_label_dict[label] = comp_info\n\n        memory_rules_param_vals = memory_header.get(const.COMP_DEF_RULES_PARAM_VALS_TAG, {})\n        md_rules_param_vals = md_header.get(const.COMP_DEF_RULES_PARAM_VALS_TAG, {})\n        for comp_name, val_list in md_rules_param_vals.items():\n            val_dict = {val['name']: val for val in val_list}\n            if comp_name not in memory_rules_param_vals:\n                memory_rules_param_vals[comp_name] = val_list\n            else:\n                # merge the lists with priority to md\n                new_list = []\n                mem_list = memory_rules_param_vals[comp_name]\n                mem_names = [mem['name'] for mem in mem_list]\n                for val in mem_list:\n                    new_list.append(val_dict.get(val['name'], val))\n                for key, val in val_dict.items():\n                    if key not in mem_names:\n                        new_list.append(val)\n                memory_rules_param_vals[comp_name] = new_list\n\n        set_or_pop(memory_header, const.COMP_DEF_RULES_PARAM_VALS_TAG, memory_rules_param_vals)\n        context.merged_header = memory_header\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_merger/#trestle.core.catalog.catalog_merger.CatalogMerger-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.catalog.catalog_merger/#trestle.core.catalog.catalog_merger.CatalogMerger.__init__","title":"<code>__init__(self, catalog_interface)</code>  <code>special</code>","text":"<p>Initialize catalog merger.</p> Source code in <code>trestle/core/catalog/catalog_merger.py</code> <pre><code>def __init__(self, catalog_interface: CatalogInterface):\n\"\"\"Initialize catalog merger.\"\"\"\n    self._catalog_interface = catalog_interface\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_merger/#trestle.core.catalog.catalog_merger.CatalogMerger.merge_catalog","title":"<code>merge_catalog(self, catalog, replace_params)</code>","text":"<p>Merge the provided new catalog controls into the original catalog in this catalog interface.</p> <p>Parameters:</p> Name Type Description Default <code>catalog</code> <code>Catalog</code> <p>catalog containing controls that are merged into the current catalog of the interface</p> required <code>replace_params</code> <code>bool</code> <p>replace all params in the control with the new ones</p> required <p>Notes</p> <p>This is mainly to support the reading of a catalog from markdown.  It allows retention of content such as metadata and backmatter, along with labels and other parameter attributes that aren't in markdown. The list of controls and group structure is specified by the markdown structure - but this doesn't allow controls to contain controls.  Group lists are specified per directory.</p> <p>Reading the markdown tells you groups and controls in them - and groups in groups. Controls cannot change groups.  If the control was in the original json, its parts are replaced, including its parameters.  Only values may be specified.  If no value specified, the value is unset in json.</p> Source code in <code>trestle/core/catalog/catalog_merger.py</code> <pre><code>def merge_catalog(self, catalog: cat.Catalog, replace_params: bool) -&gt; None:\n\"\"\"\n    Merge the provided new catalog controls into the original catalog in this catalog interface.\n\n    Args:\n        catalog: catalog containing controls that are merged into the current catalog of the interface\n        replace_params: replace all params in the control with the new ones\n\n    Notes:\n        This is mainly to support the reading of a catalog from markdown.  It allows retention of content such as\n        metadata and backmatter, along with labels and other parameter attributes that aren't in markdown.\n        The list of controls and group structure is specified by the markdown structure - but this doesn't allow\n        controls to contain controls.  Group lists are specified per directory.\n\n        Reading the markdown tells you groups and controls in them - and groups in groups.\n        Controls cannot change groups.  If the control was in the original json, its parts are replaced,\n        including its parameters.  Only values may be specified.  If no value specified, the value is unset in json.\n    \"\"\"\n    cat_interface = CatalogInterface(catalog)\n    for src in cat_interface.get_all_controls_from_dict():\n        group_id, _, _ = cat_interface.get_group_info_by_control(src.id)\n        dest = self._catalog_interface.get_control(src.id)\n        if dest:\n            dest_group, _, _ = self._catalog_interface.get_group_info_by_control(dest.id)\n            if dest_group != group_id:\n                raise TrestleError(f'Markdown for control {src.id} has different group id.')\n            CatalogMerger.merge_controls(dest, src, replace_params)\n            self._catalog_interface.replace_control(dest)\n        else:\n            # this is a new control that isn't already in the merge destination\n            # need to add the control knowing its group must already exist\n            # get group info from an arbitrary control already present in group\n            _, control_handle = self._catalog_interface._find_control_in_group(group_id)\n            new_control_handle = copy.deepcopy(control_handle)\n            new_control_handle.control = src\n            # add the control and its handle to the param_dict\n            self._catalog_interface._control_dict[src.id] = new_control_handle\n\n    # now need to cull any controls that are not in the src catalog\n    handled_ids = set(cat_interface._control_dict.keys())\n    orig_ids = set(self._catalog_interface._control_dict.keys())\n    extra_ids = orig_ids.difference(handled_ids)\n    for extra_id in sorted(extra_ids):\n        self._catalog_interface._control_dict.pop(extra_id)\n\n    self._catalog_interface.update_catalog_controls()\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_merger/#trestle.core.catalog.catalog_merger.CatalogMerger.merge_controls","title":"<code>merge_controls(dest, src, replace_params)</code>  <code>staticmethod</code>","text":"<p>Merge the src control into dest.</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <code>Control</code> <p>destination control into which content will be added</p> required <code>src</code> <code>Control</code> <p>source control with new content</p> required <code>replace_params</code> <code>bool</code> <p>replace the control params with the new ones</p> required Source code in <code>trestle/core/catalog/catalog_merger.py</code> <pre><code>@staticmethod\ndef merge_controls(dest: cat.Control, src: cat.Control, replace_params: bool) -&gt; None:\n\"\"\"\n    Merge the src control into dest.\n\n    Args:\n        dest: destination control into which content will be added\n        src: source control with new content\n        replace_params: replace the control params with the new ones\n    \"\"\"\n    ControlInterface.merge_parts(dest, src)\n    if replace_params:\n        dest.params = src.params\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_reader/","title":"catalog_reader","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader","title":"<code>trestle.core.catalog.catalog_reader</code>","text":"<p>Provide interface to read catalog from markdown back to OSCAL.</p>"},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader.CatalogReader","title":"<code> CatalogReader        </code>","text":"<p>Catalog reader.</p> <p>Catalog reader handles all operations related to reading catalog from markdown.</p> Source code in <code>trestle/core/catalog/catalog_reader.py</code> <pre><code>class CatalogReader():\n\"\"\"\n    Catalog reader.\n\n    Catalog reader handles all operations related to\n    reading catalog from markdown.\n    \"\"\"\n\n    def __init__(self, catalog_interface: CatalogInterface):\n\"\"\"Initialize catalog reader.\"\"\"\n        self._catalog_interface = catalog_interface\n\n    def read_additional_content(\n        self,\n        md_path: pathlib.Path,\n        required_sections_list: List[str],\n        label_map: Dict[str, Dict[str, str]],\n        sections_dict: Dict[str, str],\n        write_mode: bool\n    ) -&gt; Tuple[List[prof.Alter], Dict[str, Any], Dict[str, str]]:\n\"\"\"Read all markdown controls and return list of alters plus control param dict and param sort map.\"\"\"\n        alters_map: Dict[str, prof.Alter] = {}\n        final_param_dict: Dict[str, Any] = {}\n        param_sort_map: Dict[str, str] = {}\n        for group_path in CatalogInterface._get_group_ids_and_dirs(md_path).values():\n            for control_file in group_path.glob('*.md'):\n                sort_id, control_alters, control_param_dict = ControlReader.read_editable_content(\n                    control_file,\n                    required_sections_list,\n                    label_map,\n                    sections_dict,\n                    write_mode\n                )\n                alters_map[sort_id] = control_alters\n                for param_id, param_dict in control_param_dict.items():\n                    # if profile_values are present, overwrite values with them\n                    if const.PROFILE_VALUES in param_dict:\n                        param_dict[const.VALUES] = param_dict.pop(const.PROFILE_VALUES)\n                        final_param_dict[param_id] = param_dict\n                        param_sort_map[param_id] = sort_id\n        new_alters: List[prof.Alter] = []\n        # fill the alters according to the control sorting order\n        for key in sorted(alters_map.keys()):\n            new_alters.extend(alters_map[key])\n        return new_alters, final_param_dict, param_sort_map\n\n    def read_catalog_from_markdown(self, md_path: pathlib.Path, set_parameters_flag: bool) -&gt; cat.Catalog:\n\"\"\"\n        Read the groups and catalog controls from the given directory.\n\n        This will overwrite the existing groups and controls in the catalog.\n        \"\"\"\n        id_map = CatalogInterface._get_group_ids_and_dirs(md_path)\n        groups: List[cat.Group] = []\n        # read each group dir\n        for group_id, group_dir in id_map.items():\n            control_list_raw = []\n            group_title = ''\n            # Need to get group title from at least one control in this directory\n            # All controls in dir should have same group title\n            # Set group title to the first one found and warn if different non-empty title appears\n            # Controls with empty group titles are tolerated but at least one title must be present or warning given\n            # The special group with no name that has the catalog as parent is just a list and has no title\n            for control_path in group_dir.glob('*.md'):\n                control, control_group_title = ControlReader.read_control(control_path, set_parameters_flag)\n                if control_group_title:\n                    if group_title:\n                        if control_group_title != group_title:\n                            logger.warning(\n                                f'Control {control.id} group title {control_group_title} differs from {group_title}'\n                            )\n                    else:\n                        group_title = control_group_title\n                control_list_raw.append(control)\n            control_list = sorted(control_list_raw, key=lambda control: ControlInterface.get_sort_id(control))\n            if group_id:\n                if not group_title:\n                    logger.warning(\n                        f'No group title found in controls for group {group_id}.  The title will be recovered if assembling into an existing catalog with the group title defined.'  # noqa E501\n                    )\n                new_group = cat.Group(id=group_id, title=group_title)\n                new_group.controls = none_if_empty(control_list)\n                groups.append(new_group)\n            else:\n                # if the list of controls has no group id it also has no title and is just the controls of the catalog\n                self._catalog_interface._catalog.controls = none_if_empty(control_list)\n        self._catalog_interface._catalog.groups = none_if_empty(groups)\n        self._catalog_interface._create_control_dict()\n        self._catalog_interface._catalog.params = none_if_empty(self._catalog_interface._catalog.params)\n        return self._catalog_interface._catalog\n\n    @staticmethod\n    def read_catalog_imp_reqs(md_path: pathlib.Path, context: ControlContext) -&gt; List[comp.ImplementedRequirement]:\n\"\"\"Read the full set of control implemented requirements from markdown.\n\n        Args:\n            md_path: Path to the markdown control files, with directories for each group\n            context: Context for the operation\n\n        Returns:\n            List of implemented requirements gathered from each control\n\n        Notes:\n            As the controls are read into the catalog the needed components are added if not already available.\n            avail_comps provides the mapping of component name to the actual component.\n            This is only used during component assemble and only for updating one component\n        \"\"\"\n        imp_req_map: Dict[str, comp.ImplementedRequirement] = {}\n        for group_path in CatalogInterface._get_group_ids_and_dirs(md_path).values():\n            for control_file in group_path.glob('*.md'):\n                sort_id, imp_req = ControlReader.read_implemented_requirement(control_file, context)\n                imp_req_map[sort_id] = imp_req\n        return [imp_req_map[key] for key in sorted(imp_req_map.keys())]\n\n    @staticmethod\n    def _get_imp_req_for_control(ssp: ossp.SystemSecurityPlan, control_id: str) -&gt; ossp.ImplementedRequirement:\n        for imp_req in as_list(ssp.control_implementation.implemented_requirements):\n            if imp_req.control_id == control_id:\n                return imp_req\n        imp_req = gens.generate_sample_model(ossp.ImplementedRequirement)\n        imp_req.control_id = control_id\n        ssp.control_implementation.implemented_requirements = as_list(\n            ssp.control_implementation.implemented_requirements\n        )\n        ssp.control_implementation.implemented_requirements.append(imp_req)\n        return imp_req\n\n    @staticmethod\n    def _get_imp_req_for_statement(\n        ssp: ossp.SystemSecurityPlan, control_id: str, statement_id: str\n    ) -&gt; ossp.ImplementedRequirement:\n        control_imp_req: Optional[ossp.ImplementedRequirement] = None\n        for imp_req in as_list(ssp.control_implementation.implemented_requirements):\n            if imp_req.control_id == control_id:\n                control_imp_req = imp_req\n                if statement_id in [stat.statement_id for stat in as_list(imp_req.statements)]:\n                    return imp_req\n        # we didn't find imp_req with statement so need to make statement and/or imp_req\n        if not control_imp_req:\n            control_imp_req = gens.generate_sample_model(ossp.ImplementedRequirement)\n            control_imp_req.control_id = control_id\n            control_imp_req.statements = None\n            ssp.control_implementation.implemented_requirements = as_list(\n                ssp.control_implementation.implemented_requirements\n            )\n            ssp.control_implementation.implemented_requirements.append(control_imp_req)\n        statement = gens.generate_sample_model(ossp.Statement)\n        statement.statement_id = statement_id\n        statement.by_components = None\n        control_imp_req.statements = as_list(control_imp_req.statements)\n        control_imp_req.statements.append(statement)\n        return control_imp_req\n\n    @staticmethod\n    def _get_by_comp_from_imp_req(\n        imp_req: ossp.ImplementedRequirement, statement_id: str, comp_uuid: str\n    ) -&gt; ossp.ByComponent:\n        if statement_id:\n            for statement in as_list(imp_req.statements):\n                if statement.statement_id == statement_id:\n                    for by_comp in as_list(statement.by_components):\n                        if by_comp.component_uuid == comp_uuid:\n                            return by_comp\n                    # didnt find bycomp so need to make one\n                    by_comp = gens.generate_sample_model(ossp.ByComponent)\n                    by_comp.component_uuid = comp_uuid\n                    by_comp.implementation_status = com.ImplementationStatus(state=const.STATUS_PLANNED)\n                    statement.by_components = as_list(statement.by_components)\n                    statement.by_components.append(by_comp)\n                    return by_comp\n        else:\n            for by_comp in as_list(imp_req.by_components):\n                if by_comp.component_uuid == comp_uuid:\n                    return by_comp\n            by_comp = gens.generate_sample_model(ossp.ByComponent)\n            by_comp.component_uuid = comp_uuid\n            by_comp.implementation_status = com.ImplementationStatus(state=const.STATUS_PLANNED)\n            imp_req.by_components = as_list(imp_req.by_components)\n            imp_req.by_components.append(by_comp)\n            return by_comp\n        raise TrestleError(f'Internal error seeking by_comp for component {comp_uuid} and statement {statement_id}')\n\n    @staticmethod\n    def _read_comp_info_from_md(control_file_path: pathlib.Path,\n                                context: ControlContext) -&gt; Tuple[Dict[str, Any], CompDict]:\n        md_header = {}\n        comp_dict = {}\n        if control_file_path.exists():\n            md_header, comp_dict = ControlReader.read_control_info_from_md(control_file_path, context)\n        return md_header, comp_dict\n\n    @staticmethod\n    def _update_ssp_with_comp_info(\n        ssp: ossp.SystemSecurityPlan,\n        control_id: str,\n        gen_comp: generic.GenericComponent,\n        comp_info_dict: Dict[str, ComponentImpInfo],\n        part_id_map_by_label: Dict[str, Dict[str, str]]\n    ) -&gt; None:\n        # get imp req for control and find one with by_comp, creating if needed\n        imp_req = CatalogReader._get_imp_req_for_control(ssp, control_id)\n        # if control has no parts it will not have part id map and bycomps will go at control level\n        control_part_id_map = part_id_map_by_label.get(control_id, {})\n        for label, comp_info in comp_info_dict.items():\n            part_id = control_part_id_map.get(label, '')\n            by_comp = CatalogReader._get_by_comp_from_imp_req(imp_req, part_id, gen_comp.uuid)\n            by_comp.description = comp_info.prose\n            by_comp.implementation_status = comp_info.status\n\n    @staticmethod\n    def _insert_set_param_into_by_comps(\n        item: Union[ossp.ImplementedRequirement, ossp.ByComponent],\n        rule_id: str,\n        param_name: str,\n        param_values: List[str],\n        comp_uuid: str\n    ) -&gt; None:\n        for by_comp in as_list(item.by_components):\n            if by_comp.component_uuid == comp_uuid:\n                for prop in as_list(by_comp.props):\n                    if prop.name == const.RULE_ID and prop.value == rule_id:\n                        found = False\n                        for sp in as_list(by_comp.set_parameters):\n                            if sp.param_id == param_name:\n                                sp.values = param_values\n                                found = True\n                                break\n                        if not found:\n                            sp = ossp.SetParameter(param_id=param_name, values=param_values)\n                            by_comp.set_parameters = as_list(by_comp.set_parameters)\n                            by_comp.set_parameters.append(sp)\n\n    @staticmethod\n    def _insert_param_dict_in_imp_req(\n        imp_req: ossp.ImplementedRequirement,\n        param_dict: Dict[str, str],\n        comp_name: str,\n        md_header: Dict[str, Dict[str, str]],\n        comp_uuid: str\n    ):\n\"\"\"Insert the param in the by_comps that are supported by the rule.\"\"\"\n        # given param name find rule_id in comp name header entry\n        # then find all statements with by_comp that have that rule id in props\n        rules_dict = md_header.get(const.RULES_PARAMS_TAG, {})\n        comp_rules_params = rules_dict.get(comp_name, [])\n        param_name = param_dict['name']\n        param_values = param_dict['values']\n        for comp_rule_param in comp_rules_params:\n            if comp_rule_param['name'] == param_name:\n                rule_id = comp_rule_param[const.HEADER_RULE_ID]\n                CatalogReader._insert_set_param_into_by_comps(imp_req, rule_id, param_name, param_values, comp_uuid)\n                for statement in as_list(imp_req.statements):\n                    CatalogReader._insert_set_param_into_by_comps(\n                        statement, rule_id, param_name, param_values, comp_uuid\n                    )\n\n    @staticmethod\n    def _add_set_params_to_item(param_dict: Dict[str, str], item: TypeWithSetParams, param_id: str) -&gt; None:\n        value_list = param_dict[const.SSP_VALUES]\n        param_values = value_list\n        new_sp_list = []\n        for sp in as_list(item.set_parameters):\n            if sp.param_id != param_id:\n                new_sp_list.append(sp)\n        item.set_parameters = new_sp_list\n        item.set_parameters.append(ossp.SetParameter(param_id=param_id, values=param_values))\n\n    @staticmethod\n    def _update_ssp_with_md_header(\n        ssp: ossp.SystemSecurityPlan,\n        control_id: str,\n        comp_dict: Dict[str, generic.GenericComponent],\n        md_header: Dict[str, Dict[str, str]]\n    ) -&gt; None:\n\"\"\"Update the ssp with info from the header of an ssp control markdown file.\"\"\"\n        # rules param vals go in bycomps of imp_req\n        # param vals go directly in imp_req\n        rules_param_vals_dict = md_header.get(const.COMP_DEF_RULES_PARAM_VALS_TAG, {})\n        imp_req = CatalogReader._get_imp_req_for_control(ssp, control_id)\n        for comp_name, param_dict_list in rules_param_vals_dict.items():\n            for param_dict in as_list(param_dict_list):\n                if const.SSP_VALUES in param_dict:\n                    param_dict['values'] = param_dict['ssp-values']\n                CatalogReader._insert_param_dict_in_imp_req(\n                    imp_req, param_dict, comp_name, md_header, comp_dict[comp_name].uuid\n                )\n        param_vals_dict = md_header.get(const.SET_PARAMS_TAG, {})\n        for param_id, param_dict in param_vals_dict.items():\n            if const.SSP_VALUES in param_dict:\n                CatalogReader._add_set_params_to_item(param_dict, imp_req, param_id)\n\n    @staticmethod\n    def read_ssp_md_content(\n        md_path: pathlib.Path,\n        ssp: ossp.SystemSecurityPlan,\n        comp_dict: Dict[str, generic.GenericComponent],\n        part_id_map_by_label: Dict[str, Dict[str, str]],\n        context: ControlContext\n    ) -&gt; None:\n\"\"\"\n        Read md content into the ssp.\n\n        Args:\n            md_path: path to the catalog markdown\n            ssp: ssp in which to insert the md content\n            comp_dict: map of component name to component\n            part_id_map_by_label: map label to part_id of control\n            context: control context for the procedure\n\n        Notes:\n            The ssp should already contain info from the comp defs and this fills in selected content from md.\n            The only content read from md is:\n                ssp values in the comp def rules param vals of the header\n                ssp values in the set-params of the header\n                all prose for implementaton responses\n                all status values\n            ssp has components but may not have all needed imp reqs and bycomps\n            know controlid and comp name in comp_dict\n        \"\"\"\n        for group_path in CatalogInterface._get_group_ids_and_dirs(md_path).values():\n            for control_file in group_path.glob('*.md'):\n                control_id = control_file.stem\n                md_header, control_comp_dict = CatalogReader._read_comp_info_from_md(control_file, context)\n                for comp_name, comp_info_dict in control_comp_dict.items():\n                    if comp_name not in comp_dict:\n                        err_msg = f'Control {control_id} references component {comp_name} not defined in a component-definition.'  # noqa E501\n                        # give added guidance if no comp defs were specified at command line\n                        if not context.comp_def_name_list:\n                            err_msg += '  Please specify the names of any component-definitions needed for assembly.'\n                        raise TrestleError(err_msg)\n                    CatalogReader._update_ssp_with_comp_info(\n                        ssp, control_id, comp_dict[comp_name], comp_info_dict, part_id_map_by_label\n                    )\n                CatalogReader._update_ssp_with_md_header(ssp, control_id, comp_dict, md_header)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader.CatalogReader-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader.CatalogReader.__init__","title":"<code>__init__(self, catalog_interface)</code>  <code>special</code>","text":"<p>Initialize catalog reader.</p> Source code in <code>trestle/core/catalog/catalog_reader.py</code> <pre><code>def __init__(self, catalog_interface: CatalogInterface):\n\"\"\"Initialize catalog reader.\"\"\"\n    self._catalog_interface = catalog_interface\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader.CatalogReader.read_additional_content","title":"<code>read_additional_content(self, md_path, required_sections_list, label_map, sections_dict, write_mode)</code>","text":"<p>Read all markdown controls and return list of alters plus control param dict and param sort map.</p> Source code in <code>trestle/core/catalog/catalog_reader.py</code> <pre><code>def read_additional_content(\n    self,\n    md_path: pathlib.Path,\n    required_sections_list: List[str],\n    label_map: Dict[str, Dict[str, str]],\n    sections_dict: Dict[str, str],\n    write_mode: bool\n) -&gt; Tuple[List[prof.Alter], Dict[str, Any], Dict[str, str]]:\n\"\"\"Read all markdown controls and return list of alters plus control param dict and param sort map.\"\"\"\n    alters_map: Dict[str, prof.Alter] = {}\n    final_param_dict: Dict[str, Any] = {}\n    param_sort_map: Dict[str, str] = {}\n    for group_path in CatalogInterface._get_group_ids_and_dirs(md_path).values():\n        for control_file in group_path.glob('*.md'):\n            sort_id, control_alters, control_param_dict = ControlReader.read_editable_content(\n                control_file,\n                required_sections_list,\n                label_map,\n                sections_dict,\n                write_mode\n            )\n            alters_map[sort_id] = control_alters\n            for param_id, param_dict in control_param_dict.items():\n                # if profile_values are present, overwrite values with them\n                if const.PROFILE_VALUES in param_dict:\n                    param_dict[const.VALUES] = param_dict.pop(const.PROFILE_VALUES)\n                    final_param_dict[param_id] = param_dict\n                    param_sort_map[param_id] = sort_id\n    new_alters: List[prof.Alter] = []\n    # fill the alters according to the control sorting order\n    for key in sorted(alters_map.keys()):\n        new_alters.extend(alters_map[key])\n    return new_alters, final_param_dict, param_sort_map\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader.CatalogReader.read_catalog_from_markdown","title":"<code>read_catalog_from_markdown(self, md_path, set_parameters_flag)</code>","text":"<p>Read the groups and catalog controls from the given directory.</p> <p>This will overwrite the existing groups and controls in the catalog.</p> Source code in <code>trestle/core/catalog/catalog_reader.py</code> <pre><code>def read_catalog_from_markdown(self, md_path: pathlib.Path, set_parameters_flag: bool) -&gt; cat.Catalog:\n\"\"\"\n    Read the groups and catalog controls from the given directory.\n\n    This will overwrite the existing groups and controls in the catalog.\n    \"\"\"\n    id_map = CatalogInterface._get_group_ids_and_dirs(md_path)\n    groups: List[cat.Group] = []\n    # read each group dir\n    for group_id, group_dir in id_map.items():\n        control_list_raw = []\n        group_title = ''\n        # Need to get group title from at least one control in this directory\n        # All controls in dir should have same group title\n        # Set group title to the first one found and warn if different non-empty title appears\n        # Controls with empty group titles are tolerated but at least one title must be present or warning given\n        # The special group with no name that has the catalog as parent is just a list and has no title\n        for control_path in group_dir.glob('*.md'):\n            control, control_group_title = ControlReader.read_control(control_path, set_parameters_flag)\n            if control_group_title:\n                if group_title:\n                    if control_group_title != group_title:\n                        logger.warning(\n                            f'Control {control.id} group title {control_group_title} differs from {group_title}'\n                        )\n                else:\n                    group_title = control_group_title\n            control_list_raw.append(control)\n        control_list = sorted(control_list_raw, key=lambda control: ControlInterface.get_sort_id(control))\n        if group_id:\n            if not group_title:\n                logger.warning(\n                    f'No group title found in controls for group {group_id}.  The title will be recovered if assembling into an existing catalog with the group title defined.'  # noqa E501\n                )\n            new_group = cat.Group(id=group_id, title=group_title)\n            new_group.controls = none_if_empty(control_list)\n            groups.append(new_group)\n        else:\n            # if the list of controls has no group id it also has no title and is just the controls of the catalog\n            self._catalog_interface._catalog.controls = none_if_empty(control_list)\n    self._catalog_interface._catalog.groups = none_if_empty(groups)\n    self._catalog_interface._create_control_dict()\n    self._catalog_interface._catalog.params = none_if_empty(self._catalog_interface._catalog.params)\n    return self._catalog_interface._catalog\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader.CatalogReader.read_catalog_imp_reqs","title":"<code>read_catalog_imp_reqs(md_path, context)</code>  <code>staticmethod</code>","text":"<p>Read the full set of control implemented requirements from markdown.</p> <p>Parameters:</p> Name Type Description Default <code>md_path</code> <code>Path</code> <p>Path to the markdown control files, with directories for each group</p> required <code>context</code> <code>ControlContext</code> <p>Context for the operation</p> required <p>Returns:</p> Type Description <code>List[trestle.oscal.component.ImplementedRequirement]</code> <p>List of implemented requirements gathered from each control</p> <p>Notes</p> <p>As the controls are read into the catalog the needed components are added if not already available. avail_comps provides the mapping of component name to the actual component. This is only used during component assemble and only for updating one component</p> Source code in <code>trestle/core/catalog/catalog_reader.py</code> <pre><code>@staticmethod\ndef read_catalog_imp_reqs(md_path: pathlib.Path, context: ControlContext) -&gt; List[comp.ImplementedRequirement]:\n\"\"\"Read the full set of control implemented requirements from markdown.\n\n    Args:\n        md_path: Path to the markdown control files, with directories for each group\n        context: Context for the operation\n\n    Returns:\n        List of implemented requirements gathered from each control\n\n    Notes:\n        As the controls are read into the catalog the needed components are added if not already available.\n        avail_comps provides the mapping of component name to the actual component.\n        This is only used during component assemble and only for updating one component\n    \"\"\"\n    imp_req_map: Dict[str, comp.ImplementedRequirement] = {}\n    for group_path in CatalogInterface._get_group_ids_and_dirs(md_path).values():\n        for control_file in group_path.glob('*.md'):\n            sort_id, imp_req = ControlReader.read_implemented_requirement(control_file, context)\n            imp_req_map[sort_id] = imp_req\n    return [imp_req_map[key] for key in sorted(imp_req_map.keys())]\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_reader/#trestle.core.catalog.catalog_reader.CatalogReader.read_ssp_md_content","title":"<code>read_ssp_md_content(md_path, ssp, comp_dict, part_id_map_by_label, context)</code>  <code>staticmethod</code>","text":"<p>Read md content into the ssp.</p> <p>Parameters:</p> Name Type Description Default <code>md_path</code> <code>Path</code> <p>path to the catalog markdown</p> required <code>ssp</code> <code>SystemSecurityPlan</code> <p>ssp in which to insert the md content</p> required <code>comp_dict</code> <code>Dict[str, trestle.core.generic_oscal.GenericComponent]</code> <p>map of component name to component</p> required <code>part_id_map_by_label</code> <code>Dict[str, Dict[str, str]]</code> <p>map label to part_id of control</p> required <code>context</code> <code>ControlContext</code> <p>control context for the procedure</p> required <p>Notes</p> <p>The ssp should already contain info from the comp defs and this fills in selected content from md. The only content read from md is:     ssp values in the comp def rules param vals of the header     ssp values in the set-params of the header     all prose for implementaton responses     all status values ssp has components but may not have all needed imp reqs and bycomps know controlid and comp name in comp_dict</p> Source code in <code>trestle/core/catalog/catalog_reader.py</code> <pre><code>@staticmethod\ndef read_ssp_md_content(\n    md_path: pathlib.Path,\n    ssp: ossp.SystemSecurityPlan,\n    comp_dict: Dict[str, generic.GenericComponent],\n    part_id_map_by_label: Dict[str, Dict[str, str]],\n    context: ControlContext\n) -&gt; None:\n\"\"\"\n    Read md content into the ssp.\n\n    Args:\n        md_path: path to the catalog markdown\n        ssp: ssp in which to insert the md content\n        comp_dict: map of component name to component\n        part_id_map_by_label: map label to part_id of control\n        context: control context for the procedure\n\n    Notes:\n        The ssp should already contain info from the comp defs and this fills in selected content from md.\n        The only content read from md is:\n            ssp values in the comp def rules param vals of the header\n            ssp values in the set-params of the header\n            all prose for implementaton responses\n            all status values\n        ssp has components but may not have all needed imp reqs and bycomps\n        know controlid and comp name in comp_dict\n    \"\"\"\n    for group_path in CatalogInterface._get_group_ids_and_dirs(md_path).values():\n        for control_file in group_path.glob('*.md'):\n            control_id = control_file.stem\n            md_header, control_comp_dict = CatalogReader._read_comp_info_from_md(control_file, context)\n            for comp_name, comp_info_dict in control_comp_dict.items():\n                if comp_name not in comp_dict:\n                    err_msg = f'Control {control_id} references component {comp_name} not defined in a component-definition.'  # noqa E501\n                    # give added guidance if no comp defs were specified at command line\n                    if not context.comp_def_name_list:\n                        err_msg += '  Please specify the names of any component-definitions needed for assembly.'\n                    raise TrestleError(err_msg)\n                CatalogReader._update_ssp_with_comp_info(\n                    ssp, control_id, comp_dict[comp_name], comp_info_dict, part_id_map_by_label\n                )\n            CatalogReader._update_ssp_with_md_header(ssp, control_id, comp_dict, md_header)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_writer/","title":"catalog_writer","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer","title":"<code>trestle.core.catalog.catalog_writer</code>","text":"<p>Provide interface to write OSCAL catalog to markdown.</p>"},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer.CatalogWriter","title":"<code> CatalogWriter        </code>","text":"<p>Catalog writer.</p> <p>Catalog writer handles all operation related to writing catalog to markdown.</p> Source code in <code>trestle/core/catalog/catalog_writer.py</code> <pre><code>class CatalogWriter():\n\"\"\"\n    Catalog writer.\n\n    Catalog writer handles all operation related to writing\n    catalog to markdown.\n    \"\"\"\n\n    def __init__(self, catalog_interface: CatalogInterface):\n\"\"\"Initialize catalog writer.\"\"\"\n        self._catalog_interface = catalog_interface\n\n    def write_catalog_as_profile_markdown(\n        self, context: ControlContext, part_id_map: Dict[str, Dict[str, str]], md_alters: List[prof.Alter]\n    ) -&gt; None:\n\"\"\"Write out the catalog as profile markdown.\"\"\"\n        # Get the list of params for this profile from its set_params\n        # this is just from the set_params\n        profile_set_param_dict = CatalogInterface._get_full_profile_param_dict(context.profile)\n\n        # write out the controls\n        for control in self._catalog_interface.get_all_controls_from_catalog(True):\n            # here we do special handling of how set-parameters merge with the yaml header\n            new_context = ControlContext.clone(context)\n            new_context.merged_header = {}\n\n            new_context = self._add_inherited_props_to_header(new_context, control.id)\n\n            # get all params and vals for this control from the resolved profile catalog with block adds in effect\n            control_param_dict = ControlInterface.get_control_param_dict(control, False)\n\n            set_param_dict = self._construct_set_parameters_dict(profile_set_param_dict, control_param_dict, context)\n\n            if set_param_dict:\n                self._add_set_params_from_cli_yaml_header_to_header(new_context, set_param_dict, control_param_dict)\n\n            elif const.SET_PARAMS_TAG in new_context.merged_header:\n                # need to cull any params that are not in control\n                pop_list: List[str] = []\n                for key in new_context.merged_header[const.SET_PARAMS_TAG].keys():\n                    if key not in control_param_dict:\n                        pop_list.append(key)\n                for pop in pop_list:\n                    new_context.merged_header[const.SET_PARAMS_TAG].pop(pop)\n\n            found_control_alters = [alter for alter in md_alters if alter.control_id == control.id]\n\n            self._write_control_into_dir(new_context, control, part_id_map, found_control_alters)\n\n    def _add_inherited_props_to_header(self, context: ControlContext, control_id: str) -&gt; ControlContext:\n\"\"\"Add inherited props to the merged header under inherited tag.\"\"\"\n        if context.inherited_props:\n            inherited_props = context.inherited_props.get(control_id, None)\n            if inherited_props:\n                # build set in order of list so that duplicates will have final value stick, then convert to list\n                unique_props = list({prop['name']: prop for prop in inherited_props}.values())\n                context.merged_header[const.TRESTLE_INHERITED_PROPS_TAG] = unique_props\n\n        return context\n\n    def _add_set_params_from_cli_yaml_header_to_header(\n        self, context: ControlContext, set_param_dict: Dict[str, str], control_param_dict: Dict[str, common.Parameter]\n    ):\n\"\"\"\n        Add set parameters from the provided cli yaml header to the merged header.\n\n        If overwrite-header-value flag is given\n            - Set-parameters in set_param_dict will be overwritten with those in cli yaml header\n            - No new params from the cli yaml header will be added &lt;- TODO: Is this correct?\n        If ohv flag is NOT given :\n            - Set-parameters from the cli yaml header will be added\n            - Will not overwrite params that are already in set_param_dict\n        \"\"\"\n        if const.SET_PARAMS_TAG not in context.cli_yaml_header:\n            context.cli_yaml_header[const.SET_PARAMS_TAG] = {}\n\n        if context.cli_yaml_header:\n            if context.overwrite_header_values:\n                # update the control params with new values\n                for key, value in context.cli_yaml_header[const.SET_PARAMS_TAG].items():\n                    if key in control_param_dict:\n                        set_param_dict[key] = value\n            else:\n                # update the control params with any values in yaml header not set in control\n                # need to maintain order in the set_param_dict\n                for key, value in context.cli_yaml_header[const.SET_PARAMS_TAG].items():\n                    if key in control_param_dict and key not in set_param_dict:\n                        set_param_dict[key] = value\n        context.merged_header[const.SET_PARAMS_TAG] = set_param_dict\n\n    def _construct_set_parameters_dict(\n        self,\n        profile_set_param_dict: Dict[str, common.Parameter],\n        control_param_dict: Dict[str, Dict[str, Any]],\n        context: ControlContext\n    ) -&gt; Dict[str, Dict[str, Any]]:\n\"\"\"\n        Build set-parameters dictionary from the given profile.modify.set-parameters and control.params.\n\n        Resulting dictionary will have:\n        - All parameters from the control where:\n            - If control_param in profile.modify.set_params:\n                - Display name (if exists) - from profile\n                - Profile-values - from profile\n                - Values - from control\n            - If control_param is not in profile.modify.set_params:\n                - Values - from control\n        \"\"\"\n        set_param_dict: Dict[str, Dict[str, Any]] = {}\n        for param_id, param_dict in control_param_dict.items():\n            # if the param is in the full_param_dict, load its contents first and mark as profile-values\n            display_name = ''\n            if param_id in profile_set_param_dict:\n                # get the param from the profile set_param\n                param = profile_set_param_dict[param_id]\n                display_name, _ = CatalogInterface._get_display_name_and_ns(param)\n                # assign its contents to the dict\n                new_dict = ModelUtils.parameter_to_dict(param, True)\n                if const.VALUES in new_dict:\n                    if context.purpose == ContextPurpose.PROFILE:\n                        new_dict[const.PROFILE_VALUES] = new_dict[const.VALUES]\n                        new_dict.pop(const.VALUES)\n                # then insert the original, incoming values as values\n                if param_id in control_param_dict:\n                    orig_param = control_param_dict[param_id]\n                    orig_dict = ModelUtils.parameter_to_dict(orig_param, True)\n                    # pull only the values from the actual control dict\n                    # all the other elements are from the profile set_param\n                    new_dict[const.VALUES] = orig_dict.get(const.VALUES, None)\n            else:\n                # if the profile doesnt change this param at all, show it in the header with values\n                tmp_dict = ModelUtils.parameter_to_dict(param_dict, True)\n                values = tmp_dict.get('values', None)\n                new_dict = {'id': param_id, 'values': values}\n            new_dict.pop('id', None)\n            if display_name:\n                new_dict[const.DISPLAY_NAME] = display_name\n            set_param_dict[param_id] = new_dict\n\n        return set_param_dict\n\n    @staticmethod\n    def _fixup_param_dicts(context: ControlContext) -&gt; None:\n\"\"\"Merge info in the rules params dict and the rules param vals dict.\"\"\"\n        for comp_name, comp_dict in context.rules_params_dict.items():\n            rules_dict = context.rules_dict.get(comp_name, {})\n            for rule_id, param_dict in comp_dict.items():\n                rule_name = deep_get(rules_dict, [rule_id, 'name'], 'unknown_rule_name')\n                param_dict[const.HEADER_RULE_ID] = rule_name\n\n    def write_catalog_as_ssp_markdown(self, context: ControlContext, part_id_map: Dict[str, Dict[str, str]]) -&gt; None:\n\"\"\"\n        Write out the catalog as component markdown.\n\n        Already have resolved profile catalog, but with no setparams from compdefs\n        Load all control level rules and param values based on compdefs and profile values\n\n        In memory:\n        for each compdef:\n            for each comp:\n                load top level rules\n                for each control_imp:\n                    load set-params\n                    for each imp_req (bound to 1 control):\n                        load set-params\n                        load control level rules and status\n                        load part level rules and status\n                        add as compinfo to control comp_dict\n\n        \"\"\"\n        # generate rule and param info from the components\n        self._catalog_interface.generate_control_rule_info(part_id_map, context)\n\n        # now have all rules in context.rules_dict and all rules_params in context.rules_params_dict\n        # all set-params per component for each control are in the cat interface\n        # all comp-infos by control and part are in the cat interface\n        #\n        # can now write out catalog and pull from the markdown:\n        # header for param values to set during assem\n        # prose and status for This System\n        # status for all parts that still have rules\n\n        CatalogWriter._fixup_param_dicts(context)\n\n        # remove items left after above loop\n        context.component = None\n        context.comp_name = None\n\n        # get param_dict of set_params in profile\n        profile_set_param_dict = CatalogInterface._get_full_profile_param_dict(context.profile)\n        catalog_merger = CatalogMerger(self._catalog_interface)\n        for control in self._catalog_interface.get_all_controls_from_dict():\n            control_id = control.id\n            context.comp_dict = self._catalog_interface._control_comp_dicts.get(control_id, {})\n            control_file_path = self._catalog_interface.get_control_file_path(context.md_root, control_id)\n            control_file_path.parent.mkdir(exist_ok=True, parents=True)\n            # the catalog interface is from the resolved profile catalog\n            control = self._catalog_interface.get_control(control_id)\n            _, group_title, _ = self._catalog_interface.get_group_info_by_control(control_id)\n            control_param_dict = ControlInterface.get_control_param_dict(control, False)\n            set_param_dict = self._construct_set_parameters_dict(profile_set_param_dict, control_param_dict, context)\n            new_context = ControlContext.clone(context)\n\n            if set_param_dict:\n                self._add_set_params_from_cli_yaml_header_to_header(new_context, set_param_dict, control_param_dict)\n\n            elif const.SET_PARAMS_TAG in new_context.merged_header:\n                # need to cull any params that are not in control\n                pop_list: List[str] = []\n                for key in new_context.merged_header[const.SET_PARAMS_TAG].keys():\n                    if key not in control_param_dict:\n                        pop_list.append(key)\n                for pop in pop_list:\n                    new_context.merged_header[const.SET_PARAMS_TAG].pop(pop)\n\n            # merge the md_header and md_comp_dict with info in cat_interface for this control in new_context\n            catalog_merger._merge_header_and_comp_dict(control, control_file_path, new_context)\n\n            if const.COMP_DEF_RULES_PARAM_VALS_TAG in new_context.merged_header:\n                for _, param_list in new_context.merged_header[const.COMP_DEF_RULES_PARAM_VALS_TAG].items():\n                    for param_dict in param_list:\n                        param_dict.pop(const.HEADER_RULE_ID, None)\n\n            control_writer = ControlWriter()\n            control_writer.write_control_for_editing(\n                new_context, control, control_file_path.parent, group_title, part_id_map, []\n            )\n\n    def write_catalog_as_component_markdown(\n        self, context: ControlContext, part_id_map: Dict[str, Dict[str, str]]\n    ) -&gt; None:\n\"\"\"Write out the catalog as component markdown.\"\"\"\n        context.rules_dict = {}\n        context.rules_params_dict = {}\n\n        def _update_values(set_param: comp.SetParameter, control_param_dict) -&gt; None:\n            # set the param values based on the control_param_dict if available\n            if set_param.param_id in control_param_dict:\n                control_param_dict[set_param.param_id] = set_param\n\n        control_ids_in_comp_imp = [\n            imp_req.control_id for imp_req in as_list(context.control_implementation.implemented_requirements)\n        ]\n\n        missing_controls = set(control_ids_in_comp_imp).difference(self._catalog_interface.get_control_ids())\n        if missing_controls:\n            logger.warning(f'Component {context.comp_name} references controls {missing_controls} not in profile.')\n\n        # get top level rule info applying to all controls\n        comp_rules_dict, comp_rules_params_dict, _ = ControlInterface.get_rules_and_params_dict_from_item(context.component)  # noqa E501\n        context.rules_dict[context.comp_name] = comp_rules_dict\n        context.rules_params_dict.update(comp_rules_params_dict)\n        for control_imp in as_list(context.component.control_implementations):\n            control_imp_rules_dict, control_imp_rules_params_dict, _ = ControlInterface.get_rules_and_params_dict_from_item(control_imp)  # noqa E501\n            context.rules_dict[context.comp_name].update(control_imp_rules_dict)\n            comp_rules_params_dict = context.rules_params_dict.get(context.comp_name, {})\n            comp_rules_params_dict.update(control_imp_rules_params_dict)\n            context.rules_params_dict[context.comp_name] = comp_rules_params_dict\n            ci_set_params = ControlInterface.get_set_params_from_item(control_imp)\n            for imp_req in as_list(control_imp.implemented_requirements):\n                control_part_id_map = part_id_map.get(imp_req.control_id, {})\n                control_rules, statement_rules, _ = ControlInterface.get_rule_list_for_imp_req(imp_req)\n                if control_rules or statement_rules:\n                    if control_rules:\n                        status = ControlInterface.get_status_from_props(imp_req)\n                        comp_info = ComponentImpInfo(imp_req.description, control_rules, [], status)\n                        self._catalog_interface.add_comp_info(imp_req.control_id, context.comp_name, '', comp_info)\n                    set_params = copy.deepcopy(ci_set_params)\n                    set_params.update(ControlInterface.get_set_params_from_item(imp_req))\n                    for set_param in set_params.values():\n                        self._catalog_interface.add_comp_set_param(imp_req.control_id, context.comp_name, set_param)\n                    for statement in as_list(imp_req.statements):\n                        rule_list, _ = ControlInterface.get_rule_list_for_item(statement)\n                        if rule_list:\n                            status = ControlInterface.get_status_from_props(statement)\n                            if statement.statement_id not in control_part_id_map:\n                                label = statement.statement_id\n                                logger.warning(\n                                    f'No statement label found for statement id {label}.  Defaulting to {label}.'\n                                )\n                            else:\n                                label = control_part_id_map[statement.statement_id]\n                            comp_info = ComponentImpInfo(statement.description, rule_list, [], status)\n                            self._catalog_interface.add_comp_info(\n                                imp_req.control_id, context.comp_name, label, comp_info\n                            )\n\n        catalog_merger = CatalogMerger(self._catalog_interface)\n\n        for control in self._catalog_interface.get_all_controls_from_catalog(True):\n            if control.id in control_ids_in_comp_imp:\n                context.comp_dict = self._catalog_interface.get_comp_info(control.id)\n                new_context = ControlContext.clone(context)\n                # get the resolved catalog values for the control params\n                control_param_dict = ControlInterface.get_control_param_dict(control, False)\n                # update them with values in the ci\n                for set_param in as_list(new_context.control_implementation.set_parameters):\n                    _update_values(set_param, control_param_dict)\n                # update them with values in the imp_req\n                for imp_req in as_list(new_context.control_implementation.implemented_requirements):\n                    if imp_req.control_id == control.id:\n                        for set_param in as_list(imp_req.set_parameters):\n                            _update_values(set_param, control_param_dict)\n\n                # insert the param values into the header\n                if control_param_dict:\n                    new_context.merged_header[const.PARAM_VALUES_TAG] = {}\n                    for key, param in control_param_dict.items():\n                        new_context.merged_header[const.PARAM_VALUES_TAG][key] = none_if_empty(\n                            ControlInterface._param_values_as_str_list(param)\n                        )\n                # merge the md_header and md_comp_dict with info in cat_interface for this control\n                control_file_path = self._catalog_interface.get_control_file_path(context.md_root, control.id)\n                catalog_merger._merge_header_and_comp_dict(control, control_file_path, new_context)\n\n                self._write_control_into_dir(new_context, control, part_id_map, [])\n\n    def write_catalog_as_catalog(self, context: ControlContext, part_id_map: Dict[str, Dict[str, str]]) -&gt; None:\n\"\"\"Write the catalog as a simple catalog.\"\"\"\n        # write out the controls\n        for control in self._catalog_interface.get_all_controls_from_catalog(True):\n            # here we do special handling of how set-parameters merge with the yaml header\n            new_context = ControlContext.clone(context)\n\n            control_param_dict = ControlInterface.get_control_param_dict(control, False)\n            set_param_dict: Dict[str, str] = {}\n            for param_id, param_dict in control_param_dict.items():\n                tmp_dict = ModelUtils.parameter_to_dict(param_dict, True)\n                values = tmp_dict.get('values', None)\n                new_dict = {'values': values}\n                set_param_dict[param_id] = new_dict\n            if set_param_dict:\n                if const.SET_PARAMS_TAG not in new_context.cli_yaml_header:\n                    new_context.cli_yaml_header[const.SET_PARAMS_TAG] = {}\n                if new_context.overwrite_header_values:\n                    # update the control params with new values\n                    for key, value in new_context.cli_yaml_header[const.SET_PARAMS_TAG].items():\n                        if key in control_param_dict:\n                            set_param_dict[key] = value\n                else:\n                    # update the control params with any values in yaml header not set in control\n                    # need to maintain order in the set_param_dict\n                    for key, value in new_context.cli_yaml_header[const.SET_PARAMS_TAG].items():\n                        if key in control_param_dict and key not in set_param_dict:\n                            set_param_dict[key] = value\n                new_context.cli_yaml_header[const.SET_PARAMS_TAG] = set_param_dict\n            elif const.SET_PARAMS_TAG in new_context.cli_yaml_header:\n                # need to cull any params that are not in control\n                pop_list: List[str] = []\n                for key in new_context.cli_yaml_header[const.SET_PARAMS_TAG].keys():\n                    if key not in control_param_dict:\n                        pop_list.append(key)\n                for pop in pop_list:\n                    new_context.cli_yaml_header[const.SET_PARAMS_TAG].pop(pop)\n\n            self._write_control_into_dir(new_context, control, part_id_map, [])\n\n    def _write_control_into_dir(\n        self,\n        context: ControlContext,\n        control: cat.Control,\n        part_id_map: Dict[str, Dict[str, str]],\n        found_control_alters: List[prof.Alter]\n    ):\n        # we need to create the dir structure on demand because we don't know a priori what groups are included\n        _, group_title, _ = self._catalog_interface.get_group_info_by_control(control.id)\n        group_dir = context.md_root\n        control_path = self._catalog_interface.get_control_path(control.id)\n        for sub_dir in control_path:\n            group_dir = group_dir / sub_dir\n            if not group_dir.exists():\n                group_dir.mkdir(parents=True, exist_ok=True)\n\n        writer = ControlWriter()\n        writer.write_control_for_editing(context, control, group_dir, group_title, part_id_map, found_control_alters)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer.CatalogWriter-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer.CatalogWriter.__init__","title":"<code>__init__(self, catalog_interface)</code>  <code>special</code>","text":"<p>Initialize catalog writer.</p> Source code in <code>trestle/core/catalog/catalog_writer.py</code> <pre><code>def __init__(self, catalog_interface: CatalogInterface):\n\"\"\"Initialize catalog writer.\"\"\"\n    self._catalog_interface = catalog_interface\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer.CatalogWriter.write_catalog_as_catalog","title":"<code>write_catalog_as_catalog(self, context, part_id_map)</code>","text":"<p>Write the catalog as a simple catalog.</p> Source code in <code>trestle/core/catalog/catalog_writer.py</code> <pre><code>def write_catalog_as_catalog(self, context: ControlContext, part_id_map: Dict[str, Dict[str, str]]) -&gt; None:\n\"\"\"Write the catalog as a simple catalog.\"\"\"\n    # write out the controls\n    for control in self._catalog_interface.get_all_controls_from_catalog(True):\n        # here we do special handling of how set-parameters merge with the yaml header\n        new_context = ControlContext.clone(context)\n\n        control_param_dict = ControlInterface.get_control_param_dict(control, False)\n        set_param_dict: Dict[str, str] = {}\n        for param_id, param_dict in control_param_dict.items():\n            tmp_dict = ModelUtils.parameter_to_dict(param_dict, True)\n            values = tmp_dict.get('values', None)\n            new_dict = {'values': values}\n            set_param_dict[param_id] = new_dict\n        if set_param_dict:\n            if const.SET_PARAMS_TAG not in new_context.cli_yaml_header:\n                new_context.cli_yaml_header[const.SET_PARAMS_TAG] = {}\n            if new_context.overwrite_header_values:\n                # update the control params with new values\n                for key, value in new_context.cli_yaml_header[const.SET_PARAMS_TAG].items():\n                    if key in control_param_dict:\n                        set_param_dict[key] = value\n            else:\n                # update the control params with any values in yaml header not set in control\n                # need to maintain order in the set_param_dict\n                for key, value in new_context.cli_yaml_header[const.SET_PARAMS_TAG].items():\n                    if key in control_param_dict and key not in set_param_dict:\n                        set_param_dict[key] = value\n            new_context.cli_yaml_header[const.SET_PARAMS_TAG] = set_param_dict\n        elif const.SET_PARAMS_TAG in new_context.cli_yaml_header:\n            # need to cull any params that are not in control\n            pop_list: List[str] = []\n            for key in new_context.cli_yaml_header[const.SET_PARAMS_TAG].keys():\n                if key not in control_param_dict:\n                    pop_list.append(key)\n            for pop in pop_list:\n                new_context.cli_yaml_header[const.SET_PARAMS_TAG].pop(pop)\n\n        self._write_control_into_dir(new_context, control, part_id_map, [])\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer.CatalogWriter.write_catalog_as_component_markdown","title":"<code>write_catalog_as_component_markdown(self, context, part_id_map)</code>","text":"<p>Write out the catalog as component markdown.</p> Source code in <code>trestle/core/catalog/catalog_writer.py</code> <pre><code>def write_catalog_as_component_markdown(\n    self, context: ControlContext, part_id_map: Dict[str, Dict[str, str]]\n) -&gt; None:\n\"\"\"Write out the catalog as component markdown.\"\"\"\n    context.rules_dict = {}\n    context.rules_params_dict = {}\n\n    def _update_values(set_param: comp.SetParameter, control_param_dict) -&gt; None:\n        # set the param values based on the control_param_dict if available\n        if set_param.param_id in control_param_dict:\n            control_param_dict[set_param.param_id] = set_param\n\n    control_ids_in_comp_imp = [\n        imp_req.control_id for imp_req in as_list(context.control_implementation.implemented_requirements)\n    ]\n\n    missing_controls = set(control_ids_in_comp_imp).difference(self._catalog_interface.get_control_ids())\n    if missing_controls:\n        logger.warning(f'Component {context.comp_name} references controls {missing_controls} not in profile.')\n\n    # get top level rule info applying to all controls\n    comp_rules_dict, comp_rules_params_dict, _ = ControlInterface.get_rules_and_params_dict_from_item(context.component)  # noqa E501\n    context.rules_dict[context.comp_name] = comp_rules_dict\n    context.rules_params_dict.update(comp_rules_params_dict)\n    for control_imp in as_list(context.component.control_implementations):\n        control_imp_rules_dict, control_imp_rules_params_dict, _ = ControlInterface.get_rules_and_params_dict_from_item(control_imp)  # noqa E501\n        context.rules_dict[context.comp_name].update(control_imp_rules_dict)\n        comp_rules_params_dict = context.rules_params_dict.get(context.comp_name, {})\n        comp_rules_params_dict.update(control_imp_rules_params_dict)\n        context.rules_params_dict[context.comp_name] = comp_rules_params_dict\n        ci_set_params = ControlInterface.get_set_params_from_item(control_imp)\n        for imp_req in as_list(control_imp.implemented_requirements):\n            control_part_id_map = part_id_map.get(imp_req.control_id, {})\n            control_rules, statement_rules, _ = ControlInterface.get_rule_list_for_imp_req(imp_req)\n            if control_rules or statement_rules:\n                if control_rules:\n                    status = ControlInterface.get_status_from_props(imp_req)\n                    comp_info = ComponentImpInfo(imp_req.description, control_rules, [], status)\n                    self._catalog_interface.add_comp_info(imp_req.control_id, context.comp_name, '', comp_info)\n                set_params = copy.deepcopy(ci_set_params)\n                set_params.update(ControlInterface.get_set_params_from_item(imp_req))\n                for set_param in set_params.values():\n                    self._catalog_interface.add_comp_set_param(imp_req.control_id, context.comp_name, set_param)\n                for statement in as_list(imp_req.statements):\n                    rule_list, _ = ControlInterface.get_rule_list_for_item(statement)\n                    if rule_list:\n                        status = ControlInterface.get_status_from_props(statement)\n                        if statement.statement_id not in control_part_id_map:\n                            label = statement.statement_id\n                            logger.warning(\n                                f'No statement label found for statement id {label}.  Defaulting to {label}.'\n                            )\n                        else:\n                            label = control_part_id_map[statement.statement_id]\n                        comp_info = ComponentImpInfo(statement.description, rule_list, [], status)\n                        self._catalog_interface.add_comp_info(\n                            imp_req.control_id, context.comp_name, label, comp_info\n                        )\n\n    catalog_merger = CatalogMerger(self._catalog_interface)\n\n    for control in self._catalog_interface.get_all_controls_from_catalog(True):\n        if control.id in control_ids_in_comp_imp:\n            context.comp_dict = self._catalog_interface.get_comp_info(control.id)\n            new_context = ControlContext.clone(context)\n            # get the resolved catalog values for the control params\n            control_param_dict = ControlInterface.get_control_param_dict(control, False)\n            # update them with values in the ci\n            for set_param in as_list(new_context.control_implementation.set_parameters):\n                _update_values(set_param, control_param_dict)\n            # update them with values in the imp_req\n            for imp_req in as_list(new_context.control_implementation.implemented_requirements):\n                if imp_req.control_id == control.id:\n                    for set_param in as_list(imp_req.set_parameters):\n                        _update_values(set_param, control_param_dict)\n\n            # insert the param values into the header\n            if control_param_dict:\n                new_context.merged_header[const.PARAM_VALUES_TAG] = {}\n                for key, param in control_param_dict.items():\n                    new_context.merged_header[const.PARAM_VALUES_TAG][key] = none_if_empty(\n                        ControlInterface._param_values_as_str_list(param)\n                    )\n            # merge the md_header and md_comp_dict with info in cat_interface for this control\n            control_file_path = self._catalog_interface.get_control_file_path(context.md_root, control.id)\n            catalog_merger._merge_header_and_comp_dict(control, control_file_path, new_context)\n\n            self._write_control_into_dir(new_context, control, part_id_map, [])\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer.CatalogWriter.write_catalog_as_profile_markdown","title":"<code>write_catalog_as_profile_markdown(self, context, part_id_map, md_alters)</code>","text":"<p>Write out the catalog as profile markdown.</p> Source code in <code>trestle/core/catalog/catalog_writer.py</code> <pre><code>def write_catalog_as_profile_markdown(\n    self, context: ControlContext, part_id_map: Dict[str, Dict[str, str]], md_alters: List[prof.Alter]\n) -&gt; None:\n\"\"\"Write out the catalog as profile markdown.\"\"\"\n    # Get the list of params for this profile from its set_params\n    # this is just from the set_params\n    profile_set_param_dict = CatalogInterface._get_full_profile_param_dict(context.profile)\n\n    # write out the controls\n    for control in self._catalog_interface.get_all_controls_from_catalog(True):\n        # here we do special handling of how set-parameters merge with the yaml header\n        new_context = ControlContext.clone(context)\n        new_context.merged_header = {}\n\n        new_context = self._add_inherited_props_to_header(new_context, control.id)\n\n        # get all params and vals for this control from the resolved profile catalog with block adds in effect\n        control_param_dict = ControlInterface.get_control_param_dict(control, False)\n\n        set_param_dict = self._construct_set_parameters_dict(profile_set_param_dict, control_param_dict, context)\n\n        if set_param_dict:\n            self._add_set_params_from_cli_yaml_header_to_header(new_context, set_param_dict, control_param_dict)\n\n        elif const.SET_PARAMS_TAG in new_context.merged_header:\n            # need to cull any params that are not in control\n            pop_list: List[str] = []\n            for key in new_context.merged_header[const.SET_PARAMS_TAG].keys():\n                if key not in control_param_dict:\n                    pop_list.append(key)\n            for pop in pop_list:\n                new_context.merged_header[const.SET_PARAMS_TAG].pop(pop)\n\n        found_control_alters = [alter for alter in md_alters if alter.control_id == control.id]\n\n        self._write_control_into_dir(new_context, control, part_id_map, found_control_alters)\n</code></pre>"},{"location":"api_reference/trestle.core.catalog.catalog_writer/#trestle.core.catalog.catalog_writer.CatalogWriter.write_catalog_as_ssp_markdown","title":"<code>write_catalog_as_ssp_markdown(self, context, part_id_map)</code>","text":"<p>Write out the catalog as component markdown.</p> <p>Already have resolved profile catalog, but with no setparams from compdefs Load all control level rules and param values based on compdefs and profile values</p> <p>In memory: for each compdef:     for each comp:         load top level rules         for each control_imp:             load set-params             for each imp_req (bound to 1 control):                 load set-params                 load control level rules and status                 load part level rules and status                 add as compinfo to control comp_dict</p> Source code in <code>trestle/core/catalog/catalog_writer.py</code> <pre><code>def write_catalog_as_ssp_markdown(self, context: ControlContext, part_id_map: Dict[str, Dict[str, str]]) -&gt; None:\n\"\"\"\n    Write out the catalog as component markdown.\n\n    Already have resolved profile catalog, but with no setparams from compdefs\n    Load all control level rules and param values based on compdefs and profile values\n\n    In memory:\n    for each compdef:\n        for each comp:\n            load top level rules\n            for each control_imp:\n                load set-params\n                for each imp_req (bound to 1 control):\n                    load set-params\n                    load control level rules and status\n                    load part level rules and status\n                    add as compinfo to control comp_dict\n\n    \"\"\"\n    # generate rule and param info from the components\n    self._catalog_interface.generate_control_rule_info(part_id_map, context)\n\n    # now have all rules in context.rules_dict and all rules_params in context.rules_params_dict\n    # all set-params per component for each control are in the cat interface\n    # all comp-infos by control and part are in the cat interface\n    #\n    # can now write out catalog and pull from the markdown:\n    # header for param values to set during assem\n    # prose and status for This System\n    # status for all parts that still have rules\n\n    CatalogWriter._fixup_param_dicts(context)\n\n    # remove items left after above loop\n    context.component = None\n    context.comp_name = None\n\n    # get param_dict of set_params in profile\n    profile_set_param_dict = CatalogInterface._get_full_profile_param_dict(context.profile)\n    catalog_merger = CatalogMerger(self._catalog_interface)\n    for control in self._catalog_interface.get_all_controls_from_dict():\n        control_id = control.id\n        context.comp_dict = self._catalog_interface._control_comp_dicts.get(control_id, {})\n        control_file_path = self._catalog_interface.get_control_file_path(context.md_root, control_id)\n        control_file_path.parent.mkdir(exist_ok=True, parents=True)\n        # the catalog interface is from the resolved profile catalog\n        control = self._catalog_interface.get_control(control_id)\n        _, group_title, _ = self._catalog_interface.get_group_info_by_control(control_id)\n        control_param_dict = ControlInterface.get_control_param_dict(control, False)\n        set_param_dict = self._construct_set_parameters_dict(profile_set_param_dict, control_param_dict, context)\n        new_context = ControlContext.clone(context)\n\n        if set_param_dict:\n            self._add_set_params_from_cli_yaml_header_to_header(new_context, set_param_dict, control_param_dict)\n\n        elif const.SET_PARAMS_TAG in new_context.merged_header:\n            # need to cull any params that are not in control\n            pop_list: List[str] = []\n            for key in new_context.merged_header[const.SET_PARAMS_TAG].keys():\n                if key not in control_param_dict:\n                    pop_list.append(key)\n            for pop in pop_list:\n                new_context.merged_header[const.SET_PARAMS_TAG].pop(pop)\n\n        # merge the md_header and md_comp_dict with info in cat_interface for this control in new_context\n        catalog_merger._merge_header_and_comp_dict(control, control_file_path, new_context)\n\n        if const.COMP_DEF_RULES_PARAM_VALS_TAG in new_context.merged_header:\n            for _, param_list in new_context.merged_header[const.COMP_DEF_RULES_PARAM_VALS_TAG].items():\n                for param_dict in param_list:\n                    param_dict.pop(const.HEADER_RULE_ID, None)\n\n        control_writer = ControlWriter()\n        control_writer.write_control_for_editing(\n            new_context, control, control_file_path.parent, group_title, part_id_map, []\n        )\n</code></pre>"},{"location":"api_reference/trestle.core.catalog_validator/","title":"catalog_validator","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.catalog_validator/#trestle.core.catalog_validator","title":"<code>trestle.core.catalog_validator</code>","text":"<p>Validate catalog by confirming no duplicate param ids.</p>"},{"location":"api_reference/trestle.core.catalog_validator/#trestle.core.catalog_validator.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.catalog_validator/#trestle.core.catalog_validator-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.catalog_validator/#trestle.core.catalog_validator.CatalogValidator","title":"<code> CatalogValidator            (Validator)         </code>","text":"<p>Validator to confirm all param ids in catalog are unique.</p> Source code in <code>trestle/core/catalog_validator.py</code> <pre><code>class CatalogValidator(Validator):\n\"\"\"Validator to confirm all param ids in catalog are unique.\"\"\"\n\n    def model_is_valid(\n        self, model: TopLevelOscalModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None\n    ) -&gt; bool:\n\"\"\"\n        Test if the model is valid.\n\n        args:\n            model: A top level OSCAL model.\n            quiet: Don't report msgs unless invalid.\n\n        returns:\n            True (valid) if it is not a catalog, or it is a catalog and its links are 1:1 with resources.\n        \"\"\"\n        if not isinstance(model, Catalog):\n            return True\n        catalog: Catalog = model\n        cat_interface = CatalogInterface(catalog)\n        param_ids = set()\n        for control in cat_interface.get_all_controls_from_dict():\n            for param in as_list(control.params):\n                if param.id in param_ids:\n                    logger.warning(f'Catalog has duplicated parameter id: {param.id} in control {control.id}')\n                    return False\n                param_ids.add(param.id)\n        for param_id in cat_interface.loose_param_dict.keys():\n            if param_id in param_ids:\n                logger.warning(f'Catalog has duplicated parameter id: {param.id} in control {control.id}')\n                return False\n        return True\n</code></pre>"},{"location":"api_reference/trestle.core.catalog_validator/#trestle.core.catalog_validator.CatalogValidator-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.catalog_validator/#trestle.core.catalog_validator.CatalogValidator.model_is_valid","title":"<code>model_is_valid(self, model, quiet, trestle_root=None)</code>","text":"<p>Test if the model is valid.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>~TopLevelOscalModel</code> <p>A top level OSCAL model.</p> required <code>quiet</code> <code>bool</code> <p>Don't report msgs unless invalid.</p> required <p>Returns:</p> Type Description <code>True (valid) if it is not a catalog, or it is a catalog and its links are 1</code> <p>1 with resources.</p> Source code in <code>trestle/core/catalog_validator.py</code> <pre><code>def model_is_valid(\n    self, model: TopLevelOscalModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None\n) -&gt; bool:\n\"\"\"\n    Test if the model is valid.\n\n    args:\n        model: A top level OSCAL model.\n        quiet: Don't report msgs unless invalid.\n\n    returns:\n        True (valid) if it is not a catalog, or it is a catalog and its links are 1:1 with resources.\n    \"\"\"\n    if not isinstance(model, Catalog):\n        return True\n    catalog: Catalog = model\n    cat_interface = CatalogInterface(catalog)\n    param_ids = set()\n    for control in cat_interface.get_all_controls_from_dict():\n        for param in as_list(control.params):\n            if param.id in param_ids:\n                logger.warning(f'Catalog has duplicated parameter id: {param.id} in control {control.id}')\n                return False\n            param_ids.add(param.id)\n    for param_id in cat_interface.loose_param_dict.keys():\n        if param_id in param_ids:\n            logger.warning(f'Catalog has duplicated parameter id: {param.id} in control {control.id}')\n            return False\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.commands.add/","title":"add","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.add/#trestle.core.commands.add","title":"<code>trestle.core.commands.add</code>","text":"<p>Trestle Add Command.</p>"},{"location":"api_reference/trestle.core.commands.add/#trestle.core.commands.add.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.add/#trestle.core.commands.add-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.add/#trestle.core.commands.add.Add","title":"<code> Add        </code>","text":"<p>Class supporting Add of an OSCAL object to a provided file based on element path.</p> <p>Examples of element paths:     catalog.metadata     catalog.controls.control     assessment-results.results.</p> <p>The method first finds the parent model from the file and loads the file into the model. Then the method executes 'add' for each of the element paths specified. Add was originally its own command but has been incorporated into the Create command.</p> Source code in <code>trestle/core/commands/add.py</code> <pre><code>class Add():\n\"\"\"\n    Class supporting Add of an OSCAL object to a provided file based on element path.\n\n    Examples of element paths:\n        catalog.metadata\n        catalog.controls.control\n        assessment-results.results.\n\n    The method first finds the parent model from the file and loads the file into the model.\n    Then the method executes 'add' for each of the element paths specified.\n    Add was originally its own command but has been incorporated into the Create command.\n    \"\"\"\n\n    def add_from_args(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Parse args for add element to file.\"\"\"\n        file_path = pathlib.Path(args.file).resolve()\n\n        # Get parent model and then load json into parent model\n        parent_model, _ = ModelUtils.get_stripped_model_type(file_path, args.trestle_root)\n        parent_object = parent_model.oscal_read(file_path)\n        parent_element = Element(parent_object, classname_to_alias(parent_model.__name__, AliasMode.JSON))\n\n        add_plan = Plan()\n        # Do _add for each element_path specified in args\n        element_paths: List[str] = args.element.split(',')\n        for elm_path_str in element_paths:\n            element_path = ElementPath(elm_path_str)\n            update_action, parent_element = self.add(element_path, parent_element, args.include_optional_fields)\n            add_plan.add_action(update_action)\n\n        create_action = CreatePathAction(file_path, True)\n        # this will output json or yaml based on type of input file\n        write_action = WriteFileAction(file_path, parent_element, FileContentType.to_content_type(file_path.suffix))\n\n        add_plan.add_action(create_action)\n        add_plan.add_action(write_action)\n\n        add_plan.execute()\n        return CmdReturnCodes.SUCCESS.value\n\n    @staticmethod\n    def add(element_path: ElementPath, parent_element: Element, include_optional: bool) -&gt; None:\n\"\"\"For a element_path, add a child model to the parent_element of a given parent_model.\n\n        Args:\n            element_path: element path of the item to create within the model\n            parent_element: the parent element that will host the created element\n            include_optional: whether to create optional attributes in the created element\n\n        Notes:\n            First we find the child model at the specified element path and instantiate it with default values.\n            Then we check if there's already existing element at that path, in which case we append the child model\n            to the existing list of dict.\n            Then we set up an action plan to update the model (specified by file_path) in memory, create a file\n            at the same location and write the file.\n            We update the parent_element to prepare for next adds in the chain\n        \"\"\"\n        if '*' in element_path.get_full_path_parts():\n            raise err.TrestleError('trestle add does not support Wildcard element path.')\n        # Get child model\n        try:\n            child_model = element_path.get_type(type(parent_element.get()))\n\n            # Create child element with sample values\n            child_object = gens.generate_sample_model(child_model, include_optional=include_optional)\n\n            if parent_element.get_at(element_path) is not None:\n                # The element already exists\n                if type(parent_element.get_at(element_path)) is list:\n                    child_object = parent_element.get_at(element_path) + child_object\n                elif type(parent_element.get_at(element_path)) is dict:\n                    child_object = {**parent_element.get_at(element_path), **child_object}\n                else:\n                    raise err.TrestleError('Already exists and is not a list or dictionary.')\n\n        except Exception as e:\n            raise err.TrestleError(f'Bad element path. {str(e)}')\n\n        update_action = UpdateAction(\n            sub_element=child_object, dest_element=parent_element, sub_element_path=element_path\n        )\n        parent_element = parent_element.set_at(element_path, child_object)\n\n        return update_action, parent_element\n</code></pre>"},{"location":"api_reference/trestle.core.commands.add/#trestle.core.commands.add.Add-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.add/#trestle.core.commands.add.Add.add","title":"<code>add(element_path, parent_element, include_optional)</code>  <code>staticmethod</code>","text":"<p>For a element_path, add a child model to the parent_element of a given parent_model.</p> <p>Parameters:</p> Name Type Description Default <code>element_path</code> <code>ElementPath</code> <p>element path of the item to create within the model</p> required <code>parent_element</code> <code>Element</code> <p>the parent element that will host the created element</p> required <code>include_optional</code> <code>bool</code> <p>whether to create optional attributes in the created element</p> required <p>Notes</p> <p>First we find the child model at the specified element path and instantiate it with default values. Then we check if there's already existing element at that path, in which case we append the child model to the existing list of dict. Then we set up an action plan to update the model (specified by file_path) in memory, create a file at the same location and write the file. We update the parent_element to prepare for next adds in the chain</p> Source code in <code>trestle/core/commands/add.py</code> <pre><code>@staticmethod\ndef add(element_path: ElementPath, parent_element: Element, include_optional: bool) -&gt; None:\n\"\"\"For a element_path, add a child model to the parent_element of a given parent_model.\n\n    Args:\n        element_path: element path of the item to create within the model\n        parent_element: the parent element that will host the created element\n        include_optional: whether to create optional attributes in the created element\n\n    Notes:\n        First we find the child model at the specified element path and instantiate it with default values.\n        Then we check if there's already existing element at that path, in which case we append the child model\n        to the existing list of dict.\n        Then we set up an action plan to update the model (specified by file_path) in memory, create a file\n        at the same location and write the file.\n        We update the parent_element to prepare for next adds in the chain\n    \"\"\"\n    if '*' in element_path.get_full_path_parts():\n        raise err.TrestleError('trestle add does not support Wildcard element path.')\n    # Get child model\n    try:\n        child_model = element_path.get_type(type(parent_element.get()))\n\n        # Create child element with sample values\n        child_object = gens.generate_sample_model(child_model, include_optional=include_optional)\n\n        if parent_element.get_at(element_path) is not None:\n            # The element already exists\n            if type(parent_element.get_at(element_path)) is list:\n                child_object = parent_element.get_at(element_path) + child_object\n            elif type(parent_element.get_at(element_path)) is dict:\n                child_object = {**parent_element.get_at(element_path), **child_object}\n            else:\n                raise err.TrestleError('Already exists and is not a list or dictionary.')\n\n    except Exception as e:\n        raise err.TrestleError(f'Bad element path. {str(e)}')\n\n    update_action = UpdateAction(\n        sub_element=child_object, dest_element=parent_element, sub_element_path=element_path\n    )\n    parent_element = parent_element.set_at(element_path, child_object)\n\n    return update_action, parent_element\n</code></pre>"},{"location":"api_reference/trestle.core.commands.add/#trestle.core.commands.add.Add.add_from_args","title":"<code>add_from_args(self, args)</code>","text":"<p>Parse args for add element to file.</p> Source code in <code>trestle/core/commands/add.py</code> <pre><code>def add_from_args(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Parse args for add element to file.\"\"\"\n    file_path = pathlib.Path(args.file).resolve()\n\n    # Get parent model and then load json into parent model\n    parent_model, _ = ModelUtils.get_stripped_model_type(file_path, args.trestle_root)\n    parent_object = parent_model.oscal_read(file_path)\n    parent_element = Element(parent_object, classname_to_alias(parent_model.__name__, AliasMode.JSON))\n\n    add_plan = Plan()\n    # Do _add for each element_path specified in args\n    element_paths: List[str] = args.element.split(',')\n    for elm_path_str in element_paths:\n        element_path = ElementPath(elm_path_str)\n        update_action, parent_element = self.add(element_path, parent_element, args.include_optional_fields)\n        add_plan.add_action(update_action)\n\n    create_action = CreatePathAction(file_path, True)\n    # this will output json or yaml based on type of input file\n    write_action = WriteFileAction(file_path, parent_element, FileContentType.to_content_type(file_path.suffix))\n\n    add_plan.add_action(create_action)\n    add_plan.add_action(write_action)\n\n    add_plan.execute()\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.assemble/","title":"assemble","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.assemble/#trestle.core.commands.assemble","title":"<code>trestle.core.commands.assemble</code>","text":"<p>Trestle Assemble Command.</p>"},{"location":"api_reference/trestle.core.commands.assemble/#trestle.core.commands.assemble.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.assemble/#trestle.core.commands.assemble-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.assemble/#trestle.core.commands.assemble.AssembleCmd","title":"<code> AssembleCmd            (CommandPlusDocs)         </code>","text":"<p>Assemble all subcomponents from a specified trestle model into a single JSON/YAML file under dist.</p> Source code in <code>trestle/core/commands/assemble.py</code> <pre><code>class AssembleCmd(CommandPlusDocs):\n\"\"\"Assemble all subcomponents from a specified trestle model into a single JSON/YAML file under dist.\"\"\"\n\n    name = 'assemble'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument('model', help='', choices=const.MODEL_TYPE_LIST)\n        self.add_argument('-n', '--name', help='Name of a single model to assemble.')\n        self.add_argument('-t', '--type', action='store_true', help='Assemble all models of the given type.')\n        self.add_argument(\n            '-x', '--extension', help='Type of file output.', choices=['json', 'yaml', 'yml'], default='json'\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            return self.assemble_model(args.model, args)\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while assembling OSCAL model')\n\n    @classmethod\n    def assemble_model(cls, model_alias: str, args: argparse.Namespace) -&gt; int:\n\"\"\"Assemble a top level OSCAL model within the trestle dist directory.\"\"\"\n        log.set_log_level_from_args(args)\n        logger.info(f'Assembling models of type {model_alias}.')\n\n        trestle_root = args.trestle_root  # trestle root is set via command line in args. Default is cwd.\n        if not trestle_root or not file_utils.is_valid_project_root(args.trestle_root):\n            raise TrestleRootError(f'Given directory {trestle_root} is not a trestle project.')\n\n        model_names = []\n        if args.name:\n            model_names = [args.name]\n            logger.info(f'Assembling single model of type {model_alias}: {args.name}.')\n        else:\n            model_names = ModelUtils.get_models_of_type(model_alias, trestle_root)\n            nmodels = len(model_names)\n            logger.info(f'Assembling {nmodels} found models of type {model_alias}.')\n        if len(model_names) == 0:\n            logger.info(f'No models found to assemble of type {model_alias}.')\n            return CmdReturnCodes.SUCCESS.value\n\n        for model_name in model_names:\n            # contruct path to the model file name\n            root_model_dir = trestle_root / ModelUtils.model_type_to_model_dir(model_alias)\n\n            model_file_type = file_utils.get_contextual_file_type(root_model_dir / model_name)\n\n            model_file_name = f'{model_alias}{FileContentType.to_file_extension(model_file_type)}'\n            root_model_filepath = root_model_dir / model_name / model_file_name\n\n            if not root_model_filepath.exists():\n                raise TrestleError(f'No top level model file at {root_model_dir}')\n\n            assembled_model = load_validate_model_path(args.trestle_root, root_model_filepath)\n            plural_alias = ModelUtils.model_type_to_model_dir(model_alias)\n\n            assembled_model_dir = trestle_root / const.TRESTLE_DIST_DIR / plural_alias\n\n            assembled_model_filepath = assembled_model_dir / f'{model_name}.{args.extension}'\n\n            plan = Plan()\n            plan.add_action(CreatePathAction(assembled_model_filepath, True))\n            plan.add_action(\n                WriteFileAction(\n                    assembled_model_filepath,\n                    Element(assembled_model),\n                    FileContentType.to_content_type(f'.{args.extension}')\n                )\n            )\n\n            plan.execute()\n\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.assemble/#trestle.core.commands.assemble.AssembleCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.assemble/#trestle.core.commands.assemble.AssembleCmd-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.assemble/#trestle.core.commands.assemble.AssembleCmd.assemble_model","title":"<code>assemble_model(model_alias, args)</code>  <code>classmethod</code>","text":"<p>Assemble a top level OSCAL model within the trestle dist directory.</p> Source code in <code>trestle/core/commands/assemble.py</code> <pre><code>@classmethod\ndef assemble_model(cls, model_alias: str, args: argparse.Namespace) -&gt; int:\n\"\"\"Assemble a top level OSCAL model within the trestle dist directory.\"\"\"\n    log.set_log_level_from_args(args)\n    logger.info(f'Assembling models of type {model_alias}.')\n\n    trestle_root = args.trestle_root  # trestle root is set via command line in args. Default is cwd.\n    if not trestle_root or not file_utils.is_valid_project_root(args.trestle_root):\n        raise TrestleRootError(f'Given directory {trestle_root} is not a trestle project.')\n\n    model_names = []\n    if args.name:\n        model_names = [args.name]\n        logger.info(f'Assembling single model of type {model_alias}: {args.name}.')\n    else:\n        model_names = ModelUtils.get_models_of_type(model_alias, trestle_root)\n        nmodels = len(model_names)\n        logger.info(f'Assembling {nmodels} found models of type {model_alias}.')\n    if len(model_names) == 0:\n        logger.info(f'No models found to assemble of type {model_alias}.')\n        return CmdReturnCodes.SUCCESS.value\n\n    for model_name in model_names:\n        # contruct path to the model file name\n        root_model_dir = trestle_root / ModelUtils.model_type_to_model_dir(model_alias)\n\n        model_file_type = file_utils.get_contextual_file_type(root_model_dir / model_name)\n\n        model_file_name = f'{model_alias}{FileContentType.to_file_extension(model_file_type)}'\n        root_model_filepath = root_model_dir / model_name / model_file_name\n\n        if not root_model_filepath.exists():\n            raise TrestleError(f'No top level model file at {root_model_dir}')\n\n        assembled_model = load_validate_model_path(args.trestle_root, root_model_filepath)\n        plural_alias = ModelUtils.model_type_to_model_dir(model_alias)\n\n        assembled_model_dir = trestle_root / const.TRESTLE_DIST_DIR / plural_alias\n\n        assembled_model_filepath = assembled_model_dir / f'{model_name}.{args.extension}'\n\n        plan = Plan()\n        plan.add_action(CreatePathAction(assembled_model_filepath, True))\n        plan.add_action(\n            WriteFileAction(\n                assembled_model_filepath,\n                Element(assembled_model),\n                FileContentType.to_content_type(f'.{args.extension}')\n            )\n        )\n\n        plan.execute()\n\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.catalog/","title":"catalog","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog","title":"<code>trestle.core.commands.author.catalog</code>","text":"<p>Author commands to generate catalog controls as markdown and assemble them back to json.</p>"},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog.CatalogAssemble","title":"<code> CatalogAssemble            (AuthorCommonCommand)         </code>","text":"<p>Assemble markdown files of controls into a Catalog json file.</p> Source code in <code>trestle/core/commands/author/catalog.py</code> <pre><code>class CatalogAssemble(AuthorCommonCommand):\n\"\"\"Assemble markdown files of controls into a Catalog json file.\"\"\"\n\n    name = 'catalog-assemble'\n\n    def _init_arguments(self) -&gt; None:\n        name_help_str = (\n            'Optional name of the catalog model in the trestle workspace that is being modified.  '\n            'If not provided the output name is used.'\n        )\n        self.add_argument('-n', '--name', help=name_help_str, required=False, type=str)\n        file_help_str = 'Name of the input markdown file directory'\n        self.add_argument('-m', '--markdown', help=file_help_str, required=True, type=str)\n        output_help_str = 'Name of the output generated json Catalog'\n        self.add_argument('-o', '--output', help=output_help_str, required=True, type=str)\n        self.add_argument('-sp', '--set-parameters', action='store_true', help=const.HELP_SET_PARAMS)\n        self.add_argument('-r', '--regenerate', action='store_true', help=const.HELP_REGENERATE)\n        self.add_argument('-vn', '--version', help=const.HELP_VERSION, required=False, type=str)\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            trestle_root = pathlib.Path(args.trestle_root)\n            return CatalogAssemble.assemble_catalog(\n                trestle_root=trestle_root,\n                md_name=args.markdown,\n                assem_cat_name=args.output,\n                parent_cat_name=args.name,\n                set_parameters_flag=args.set_parameters,\n                regenerate=args.regenerate,\n                version=args.version\n            )\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error occurred while assembling catalog')\n\n    @staticmethod\n    def assemble_catalog(\n        trestle_root: pathlib.Path,\n        md_name: str,\n        assem_cat_name: str,\n        parent_cat_name: Optional[str],\n        set_parameters_flag: bool,\n        regenerate: bool,\n        version: Optional[str]\n    ) -&gt; int:\n\"\"\"\n        Assemble the markdown directory into a json catalog model file.\n\n        Args:\n            trestle_root: The trestle root directory\n            md_name: The name of the directory containing the markdown control files for the ssp\n            assem_cat_name: The output name of the catalog model to be created from the assembly\n            parent_cat_name: Optional name of the parent catalog that the markdown controls will replace\n            set_parameters_flag: set the parameters and props in the control to the values in the markdown yaml header\n            regenerate: whether to regenerate the uuid's in the catalog\n            version: version for the assembled catalog\n\n        Returns:\n            0 on success, 1 otherwise\n\n        Notes:\n            If the destination catalog_name model already exists in the trestle workspace, it is overwritten.\n            If a parent catalog is not specified, the assembled catalog will be used as the parent if it exists.\n            If no parent catalog name is available, the catalog is created anew using only the markdown content.\n        \"\"\"\n        md_dir = trestle_root / md_name\n        if not md_dir.exists():\n            raise TrestleError(f'Markdown directory {md_name} does not exist.')\n\n        # assemble the markdown controls into fresh md_catalog\n        catalog_api_from_md = CatalogAPI(catalog=None)\n        try:\n            md_catalog = catalog_api_from_md.read_catalog_from_markdown(md_dir, set_parameters_flag)\n        except Exception as e:\n            raise TrestleError(f'Error reading catalog from markdown {md_dir}: {e}')\n\n        # this is None if it doesn't exist yet\n        assem_cat_path = ModelUtils.get_model_path_for_name_and_class(trestle_root, assem_cat_name, Catalog)\n        logger.debug(f'assem_cat_path is {assem_cat_path}')\n\n        # if original cat is not specified, use the assembled cat but only if it already exists\n        if not parent_cat_name and assem_cat_path:\n            parent_cat_name = assem_cat_name\n\n        # default to JSON but allow override later if other file type found\n        new_content_type = FileContentType.JSON\n\n        # if we have parent catalog then merge the markdown controls into it\n        # the parent can be a separate catalog or the destination assembled catalog if it exists\n        # but this is the catalog that the markdown is merged into in memory\n        logger.debug(f'parent_cat_name is {parent_cat_name}')\n        if parent_cat_name:\n            parent_cat, parent_cat_path = load_validate_model_name(trestle_root, parent_cat_name, Catalog)\n            parent_cat_api = CatalogAPI(catalog=parent_cat)\n            # merge the just-read md catalog into the original json\n            parent_cat_api.merge_catalog(md_catalog, set_parameters_flag)\n            md_catalog = parent_cat_api._catalog_interface.get_catalog()\n            new_content_type = FileContentType.path_to_content_type(parent_cat_path)\n\n        if version:\n            md_catalog.metadata.version = version\n\n        # now check the destination catalog to see if the in-memory catalog matches it\n        if assem_cat_path:\n            new_content_type = FileContentType.path_to_content_type(assem_cat_path)\n            existing_cat = load_validate_model_path(trestle_root, assem_cat_path)\n            if ModelUtils.models_are_equivalent(existing_cat, md_catalog):\n                logger.info('Assembled catalog is not different from existing version, so no update.')\n                return CmdReturnCodes.SUCCESS.value\n            else:\n                logger.debug('new assembled catalog is different from existing one')\n\n        if regenerate:\n            md_catalog, _, _ = ModelUtils.regenerate_uuids(md_catalog)\n            logger.debug('regenerating uuids in catalog')\n        ModelUtils.update_last_modified(md_catalog)\n\n        md_catalog.metadata.oscal_version = OSCAL_VERSION\n\n        # we still may not know the assem_cat_path but can now create it with file content type\n        assem_cat_path = ModelUtils.get_model_path_for_name_and_class(\n            trestle_root, assem_cat_name, Catalog, new_content_type\n        )\n\n        if assem_cat_path.parent.exists():\n            logger.info('Creating catalog from markdown and destination catalog exists, so updating.')\n            shutil.rmtree(str(assem_cat_path.parent))\n\n        assem_cat_path.parent.mkdir(parents=True, exist_ok=True)\n        md_catalog.oscal_write(assem_cat_path.parent / 'catalog.json')\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog.CatalogAssemble.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog.CatalogAssemble-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog.CatalogAssemble.assemble_catalog","title":"<code>assemble_catalog(trestle_root, md_name, assem_cat_name, parent_cat_name, set_parameters_flag, regenerate, version)</code>  <code>staticmethod</code>","text":"<p>Assemble the markdown directory into a json catalog model file.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>The trestle root directory</p> required <code>md_name</code> <code>str</code> <p>The name of the directory containing the markdown control files for the ssp</p> required <code>assem_cat_name</code> <code>str</code> <p>The output name of the catalog model to be created from the assembly</p> required <code>parent_cat_name</code> <code>Optional[str]</code> <p>Optional name of the parent catalog that the markdown controls will replace</p> required <code>set_parameters_flag</code> <code>bool</code> <p>set the parameters and props in the control to the values in the markdown yaml header</p> required <code>regenerate</code> <code>bool</code> <p>whether to regenerate the uuid's in the catalog</p> required <code>version</code> <code>Optional[str]</code> <p>version for the assembled catalog</p> required <p>Returns:</p> Type Description <code>int</code> <p>0 on success, 1 otherwise</p> <p>Notes</p> <p>If the destination catalog_name model already exists in the trestle workspace, it is overwritten. If a parent catalog is not specified, the assembled catalog will be used as the parent if it exists. If no parent catalog name is available, the catalog is created anew using only the markdown content.</p> Source code in <code>trestle/core/commands/author/catalog.py</code> <pre><code>@staticmethod\ndef assemble_catalog(\n    trestle_root: pathlib.Path,\n    md_name: str,\n    assem_cat_name: str,\n    parent_cat_name: Optional[str],\n    set_parameters_flag: bool,\n    regenerate: bool,\n    version: Optional[str]\n) -&gt; int:\n\"\"\"\n    Assemble the markdown directory into a json catalog model file.\n\n    Args:\n        trestle_root: The trestle root directory\n        md_name: The name of the directory containing the markdown control files for the ssp\n        assem_cat_name: The output name of the catalog model to be created from the assembly\n        parent_cat_name: Optional name of the parent catalog that the markdown controls will replace\n        set_parameters_flag: set the parameters and props in the control to the values in the markdown yaml header\n        regenerate: whether to regenerate the uuid's in the catalog\n        version: version for the assembled catalog\n\n    Returns:\n        0 on success, 1 otherwise\n\n    Notes:\n        If the destination catalog_name model already exists in the trestle workspace, it is overwritten.\n        If a parent catalog is not specified, the assembled catalog will be used as the parent if it exists.\n        If no parent catalog name is available, the catalog is created anew using only the markdown content.\n    \"\"\"\n    md_dir = trestle_root / md_name\n    if not md_dir.exists():\n        raise TrestleError(f'Markdown directory {md_name} does not exist.')\n\n    # assemble the markdown controls into fresh md_catalog\n    catalog_api_from_md = CatalogAPI(catalog=None)\n    try:\n        md_catalog = catalog_api_from_md.read_catalog_from_markdown(md_dir, set_parameters_flag)\n    except Exception as e:\n        raise TrestleError(f'Error reading catalog from markdown {md_dir}: {e}')\n\n    # this is None if it doesn't exist yet\n    assem_cat_path = ModelUtils.get_model_path_for_name_and_class(trestle_root, assem_cat_name, Catalog)\n    logger.debug(f'assem_cat_path is {assem_cat_path}')\n\n    # if original cat is not specified, use the assembled cat but only if it already exists\n    if not parent_cat_name and assem_cat_path:\n        parent_cat_name = assem_cat_name\n\n    # default to JSON but allow override later if other file type found\n    new_content_type = FileContentType.JSON\n\n    # if we have parent catalog then merge the markdown controls into it\n    # the parent can be a separate catalog or the destination assembled catalog if it exists\n    # but this is the catalog that the markdown is merged into in memory\n    logger.debug(f'parent_cat_name is {parent_cat_name}')\n    if parent_cat_name:\n        parent_cat, parent_cat_path = load_validate_model_name(trestle_root, parent_cat_name, Catalog)\n        parent_cat_api = CatalogAPI(catalog=parent_cat)\n        # merge the just-read md catalog into the original json\n        parent_cat_api.merge_catalog(md_catalog, set_parameters_flag)\n        md_catalog = parent_cat_api._catalog_interface.get_catalog()\n        new_content_type = FileContentType.path_to_content_type(parent_cat_path)\n\n    if version:\n        md_catalog.metadata.version = version\n\n    # now check the destination catalog to see if the in-memory catalog matches it\n    if assem_cat_path:\n        new_content_type = FileContentType.path_to_content_type(assem_cat_path)\n        existing_cat = load_validate_model_path(trestle_root, assem_cat_path)\n        if ModelUtils.models_are_equivalent(existing_cat, md_catalog):\n            logger.info('Assembled catalog is not different from existing version, so no update.')\n            return CmdReturnCodes.SUCCESS.value\n        else:\n            logger.debug('new assembled catalog is different from existing one')\n\n    if regenerate:\n        md_catalog, _, _ = ModelUtils.regenerate_uuids(md_catalog)\n        logger.debug('regenerating uuids in catalog')\n    ModelUtils.update_last_modified(md_catalog)\n\n    md_catalog.metadata.oscal_version = OSCAL_VERSION\n\n    # we still may not know the assem_cat_path but can now create it with file content type\n    assem_cat_path = ModelUtils.get_model_path_for_name_and_class(\n        trestle_root, assem_cat_name, Catalog, new_content_type\n    )\n\n    if assem_cat_path.parent.exists():\n        logger.info('Creating catalog from markdown and destination catalog exists, so updating.')\n        shutil.rmtree(str(assem_cat_path.parent))\n\n    assem_cat_path.parent.mkdir(parents=True, exist_ok=True)\n    md_catalog.oscal_write(assem_cat_path.parent / 'catalog.json')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog.CatalogGenerate","title":"<code> CatalogGenerate            (AuthorCommonCommand)         </code>","text":"<p>Generate Catalog controls in markdown form from a catalog in the trestle workspace.</p> Source code in <code>trestle/core/commands/author/catalog.py</code> <pre><code>class CatalogGenerate(AuthorCommonCommand):\n\"\"\"Generate Catalog controls in markdown form from a catalog in the trestle workspace.\"\"\"\n\n    name = 'catalog-generate'\n\n    def _init_arguments(self) -&gt; None:\n        name_help_str = 'Name of the catalog model in the trestle workspace'\n        self.add_argument('-n', '--name', help=name_help_str, required=True, type=str)\n        self.add_argument(\n            '-o', '--output', help='Name of the output generated catalog markdown folder', required=True, type=str\n        )  # noqa E501\n        self.add_argument('-fo', '--force-overwrite', help=const.HELP_FO_OUTPUT, required=False, action='store_true')\n        self.add_argument('-y', '--yaml-header', help=const.HELP_YAML_PATH, required=False, type=str)\n        self.add_argument(\n            '-ohv',\n            '--overwrite-header-values',\n            help=const.HELP_OVERWRITE_HEADER_VALUES,\n            required=False,\n            action='store_true',\n            default=False\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            trestle_root = args.trestle_root\n            if not file_utils.is_directory_name_allowed(args.output):\n                raise TrestleError(f'{args.output} is not an allowed directory name')\n\n            if args.force_overwrite:\n                try:\n                    logger.info(f'Overwriting the content in {args.output} folder.')\n                    clear_folder(pathlib.Path(args.output))\n                except TrestleError as e:  # pragma: no cover\n                    raise TrestleError(f'Unable to overwrite contents in {args.output} folder: {e}')\n\n            yaml_header: dict = {}\n            if args.yaml_header:\n                try:\n                    logging.debug(f'Loading yaml header file {args.yaml_header}')\n                    yaml = YAML(typ='safe')\n                    yaml_header = yaml.load(pathlib.Path(args.yaml_header).open('r'))\n                except YAMLError as e:\n                    raise TrestleError(f'YAML error loading yaml header {args.yaml_header} for ssp generation: {e}')\n\n            catalog_path = trestle_root / f'catalogs/{args.name}/catalog.json'\n\n            markdown_path = trestle_root / args.output\n\n            return self.generate_markdown(\n                trestle_root, catalog_path, markdown_path, yaml_header, args.overwrite_header_values\n            )\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error occurred when generating markdown for catalog')\n\n    def generate_markdown(\n        self,\n        trestle_root: pathlib.Path,\n        catalog_path: pathlib.Path,\n        markdown_path: pathlib.Path,\n        yaml_header: dict,\n        overwrite_header_values: bool\n    ) -&gt; int:\n\"\"\"Generate markdown for the controls in the catalog.\"\"\"\n        try:\n            catalog = load_validate_model_path(trestle_root, catalog_path)\n            context = ControlContext.generate(\n                ContextPurpose.CATALOG,\n                True,\n                trestle_root,\n                markdown_path,\n                cli_yaml_header=yaml_header,\n                overwrite_header_values=overwrite_header_values,\n                set_parameters_flag=True\n            )\n            catalog_api = CatalogAPI(catalog=catalog, context=context)\n            catalog_api.write_catalog_as_markdown()\n\n        except TrestleNotFoundError as e:\n            raise TrestleError(f'Catalog {catalog_path} not found for load: {e}')\n        except Exception as e:\n            raise TrestleError(f'Error generating markdown for controls in {catalog_path}: {e}')\n\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog.CatalogGenerate.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog.CatalogGenerate-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.catalog/#trestle.core.commands.author.catalog.CatalogGenerate.generate_markdown","title":"<code>generate_markdown(self, trestle_root, catalog_path, markdown_path, yaml_header, overwrite_header_values)</code>","text":"<p>Generate markdown for the controls in the catalog.</p> Source code in <code>trestle/core/commands/author/catalog.py</code> <pre><code>def generate_markdown(\n    self,\n    trestle_root: pathlib.Path,\n    catalog_path: pathlib.Path,\n    markdown_path: pathlib.Path,\n    yaml_header: dict,\n    overwrite_header_values: bool\n) -&gt; int:\n\"\"\"Generate markdown for the controls in the catalog.\"\"\"\n    try:\n        catalog = load_validate_model_path(trestle_root, catalog_path)\n        context = ControlContext.generate(\n            ContextPurpose.CATALOG,\n            True,\n            trestle_root,\n            markdown_path,\n            cli_yaml_header=yaml_header,\n            overwrite_header_values=overwrite_header_values,\n            set_parameters_flag=True\n        )\n        catalog_api = CatalogAPI(catalog=catalog, context=context)\n        catalog_api.write_catalog_as_markdown()\n\n    except TrestleNotFoundError as e:\n        raise TrestleError(f'Catalog {catalog_path} not found for load: {e}')\n    except Exception as e:\n        raise TrestleError(f'Error generating markdown for controls in {catalog_path}: {e}')\n\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.command/","title":"command","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.command/#trestle.core.commands.author.command","title":"<code>trestle.core.commands.author.command</code>","text":"<p>Trestle author command.</p> <p>Umbrella command for all markdown related transformations</p>"},{"location":"api_reference/trestle.core.commands.author.command/#trestle.core.commands.author.command.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.command/#trestle.core.commands.author.command-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.command/#trestle.core.commands.author.command.AuthorCmd","title":"<code> AuthorCmd            (CommandPlusDocs)         </code>","text":"<p>trestle author, a collection of commands for authoring compliance content outside of OSCAL.</p> Source code in <code>trestle/core/commands/author/command.py</code> <pre><code>class AuthorCmd(CommandPlusDocs):\n\"\"\"trestle author, a collection of commands for authoring compliance content outside of OSCAL.\"\"\"\n\n    name = 'author'\n\n    subcommands = [\n        CatalogAssemble,\n        CatalogGenerate,\n        ComponentAssemble,\n        ComponentGenerate,\n        Docs,\n        Folders,\n        Headers,\n        JinjaCmd,\n        ProfileAssemble,\n        ProfileGenerate,\n        ProfileResolve,\n        SSPAssemble,\n        SSPFilter,\n        SSPGenerate\n    ]\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.command/#trestle.core.commands.author.command.AuthorCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.command/#trestle.core.commands.author.command.AuthorCmd.subcommands","title":"<code>subcommands</code>","text":""},{"location":"api_reference/trestle.core.commands.author.common/","title":"common","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.common/#trestle.core.commands.author.common","title":"<code>trestle.core.commands.author.common</code>","text":"<p>AuthorCommonCommands - reusable utilities to increase code base abstraction for author command.</p>"},{"location":"api_reference/trestle.core.commands.author.common/#trestle.core.commands.author.common.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.common/#trestle.core.commands.author.common-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.common/#trestle.core.commands.author.common.AuthorCommonCommand","title":"<code> AuthorCommonCommand            (CommandPlusDocs)         </code>","text":"<p>Extension for the subset of commands that operate using the common mode structure.</p> Source code in <code>trestle/core/commands/author/common.py</code> <pre><code>class AuthorCommonCommand(CommandPlusDocs):\n\"\"\"Extension for the subset of commands that operate using the common mode structure.\"\"\"\n\n    trestle_root: pathlib.Path\n\n    task_name: str\n\n    def _initialize(self, args: argparse.Namespace) -&gt; int:\n        log.set_log_level_from_args(args)\n        # Externalize\n        self.trestle_root = args.trestle_root\n        self.task_name = args.task_name\n\n        try:\n            self.global_ = args.__getattribute__('global')\n        except AttributeError:\n            self.global_ = None\n\n        if self.task_name:\n            self.task_path = self.trestle_root / self.task_name\n            if not file_utils.is_directory_name_allowed(self.task_name):\n                logger.error(\n                    f'Task name {self.task_name} is invalid as it interferes with OSCAL and trestle reserved names.'\n                )\n                return CmdReturnCodes.COMMAND_ERROR.value\n\n        rc = self._setup_template_dir(args)\n\n        return rc\n\n    def rel_dir(self, path: pathlib.Path) -&gt; str:\n\"\"\"Stringify a directory relative to trestle root.\"\"\"\n        return str(path.relative_to(self.trestle_root))\n\n    def _setup_template_dir(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Set template directory and update to new format.\"\"\"\n        if not self.global_ and self.task_name is None:\n            logger.error('At least a global flag or a task name should be provided.')\n            return CmdReturnCodes.INCORRECT_ARGS.value\n        if self.global_:\n            old_template_dir = self.trestle_root / TRESTLE_CONFIG_DIR / 'author' / '__global__'\n            self._set_template_version_to_latest(args, old_template_dir)\n            self.template_dir = old_template_dir / args.template_version\n        elif self.task_name and not self.global_:\n            old_template_dir = self.trestle_root / TRESTLE_CONFIG_DIR / 'author' / self.task_name\n            self._set_template_version_to_latest(args, old_template_dir)\n            self.template_dir = old_template_dir / args.template_version\n\n        if old_template_dir.exists():\n            TemplateVersioning.update_template_folder_structure(old_template_dir)\n\n        return CmdReturnCodes.SUCCESS.value\n\n    def _set_template_version_to_latest(self, args: argparse.Namespace, template_dir: pathlib.Path):\n\"\"\"Set template version argument to the latest version if none was given.\"\"\"\n        if not TemplateVersioning.is_valid_version(args.template_version):\n            raise TrestleError(f'Version {args.template_version} is invalid, version format should be: 0.0.1')\n        if args.template_version is None and args.mode == ARG_VALIDATE:\n            # in validate mode no version will validate instances based on header version\n            args.template_version = ''\n        if args.template_version is None:\n            args.template_version = START_TEMPLATE_VERSION\n            if template_dir.exists():\n                all_versions = TemplateVersioning.get_all_versions_for_task(template_dir)\n                if all_versions:\n                    args.template_version = max(all_versions)\n        if args.template_version == '':\n            logger.info('Instances will be validated against template version specified in their headers.')\n        else:\n            logger.info(f'Set template version to {args.template_version}.')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.common/#trestle.core.commands.author.common.AuthorCommonCommand-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.common/#trestle.core.commands.author.common.AuthorCommonCommand.rel_dir","title":"<code>rel_dir(self, path)</code>","text":"<p>Stringify a directory relative to trestle root.</p> Source code in <code>trestle/core/commands/author/common.py</code> <pre><code>def rel_dir(self, path: pathlib.Path) -&gt; str:\n\"\"\"Stringify a directory relative to trestle root.\"\"\"\n    return str(path.relative_to(self.trestle_root))\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.component/","title":"component","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component","title":"<code>trestle.core.commands.author.component</code>","text":"<p>Author commands to generate component definition as markdown and assemble to json after edit.</p>"},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentAssemble","title":"<code> ComponentAssemble            (AuthorCommonCommand)         </code>","text":"<p>Assemble markdown files of controls into a Component json file.</p> Source code in <code>trestle/core/commands/author/component.py</code> <pre><code>class ComponentAssemble(AuthorCommonCommand):\n\"\"\"Assemble markdown files of controls into a Component json file.\"\"\"\n\n    name = 'component-assemble'\n\n    def _init_arguments(self) -&gt; None:\n        name_help_str = (\n            'Optional name of the component-definition model in the trestle workspace that is being modified.  '\n            'If not provided the output name is used.'\n        )\n        self.add_argument('-n', '--name', help=name_help_str, required=False, type=str)\n        file_help_str = 'Name of the source markdown directory'\n        self.add_argument('-m', '--markdown', help=file_help_str, required=True, type=str)\n        output_help_str = 'Name of the output generated json component-definition (ok to overwrite original)'\n        self.add_argument('-o', '--output', help=output_help_str, required=True, type=str)\n        self.add_argument('-r', '--regenerate', action='store_true', help=const.HELP_REGENERATE)\n        self.add_argument('-vn', '--version', help=const.HELP_VERSION, required=False, type=str)\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            return self.assemble_component(\n                trestle_root=args.trestle_root,\n                parent_comp_name=args.name,\n                md_name=args.markdown,\n                assem_comp_name=args.output,\n                regenerate=args.regenerate,\n                version=args.version,\n            )\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Assembly of markdown to component-definition failed')\n\n    @staticmethod\n    def assemble_component(\n        trestle_root: pathlib.Path,\n        parent_comp_name: Optional[str],\n        md_name: str,\n        assem_comp_name: str,\n        regenerate: bool,\n        version: Optional[str],\n    ) -&gt; int:\n\"\"\"\n        Assemble the markdown directory into a json component-definition model file.\n\n        Args:\n            trestle_root: The trestle root directory\n            parent_comp_name: Optional name of component-definition used to generate markdown, default = assem_comp_name\n            md_name: The name of the directory containing the markdown control files for the component\n            assem_comp_name: The name of the assembled component-definiton.  Can be same as the parent to overwrite\n            regenerate: Whether to regenerate the uuid's in the component\n            version: Optional version for the assembled component\n\n        Returns:\n            0 on success, 1 otherwise\n\n        Notes:\n            There must already be a component model and it will either be updated or a new json component created.\n            The generated markdown has the current values for parameters of controls being imported, as set by\n            the original catalog and any intermediate components.  It also shows the current SetParameters being applied\n            by this component.  That list of SetParameters can be edited by changing the assigned values and adding or\n            removing SetParameters from that list.  During assembly that list will be used to create the SetParameters\n            in the assembled component if the --set-parameters option is specified.\n        \"\"\"\n        md_dir = trestle_root / md_name\n        if not md_dir.exists():\n            raise TrestleError(f'Markdown directory {md_name} does not exist.')\n\n        if not parent_comp_name:\n            parent_comp_name = assem_comp_name\n\n        # load the comp-def that will be updated\n        parent_comp, parent_comp_path = ModelUtils.load_model_for_class(\n            trestle_root,\n            parent_comp_name,\n            comp.ComponentDefinition\n        )\n        new_content_type = FileContentType.path_to_content_type(parent_comp_path)\n\n        context = ControlContext.generate(ContextPurpose.COMPONENT, False, trestle_root, md_dir)\n\n        ComponentAssemble.assemble_comp_def_into_parent(parent_comp, md_dir, context)\n\n        if version:\n            parent_comp.metadata.version = version\n\n        assem_comp_path = ModelUtils.get_model_path_for_name_and_class(\n            trestle_root, assem_comp_name, comp.ComponentDefinition, new_content_type\n        )\n\n        if not version and assem_comp_path.exists():\n            _, _, existing_comp = ModelUtils.load_distributed(assem_comp_path, trestle_root)\n            # comp def will change statement uuids so need to ignore them in comparison\n            if ModelUtils.models_are_equivalent(existing_comp, parent_comp, True):\n                logger.info('Assembled component definition is no different from existing version, so no update.')\n                return CmdReturnCodes.SUCCESS.value\n\n        if regenerate:\n            parent_comp, _, _ = ModelUtils.regenerate_uuids(parent_comp)\n        ModelUtils.update_last_modified(parent_comp)\n\n        if assem_comp_path.parent.exists():\n            logger.info(\n                'Creating component definition from markdown and destination component definition exists, so updating.'\n            )  # noqa E501\n            shutil.rmtree(str(assem_comp_path.parent))\n\n        assem_comp_path.parent.mkdir(parents=True, exist_ok=True)\n        parent_comp.oscal_write(assem_comp_path)\n        return CmdReturnCodes.SUCCESS.value\n\n    @staticmethod\n    def assemble_comp_def_into_parent(\n        parent_comp: comp.ComponentDefinition, md_dir: pathlib.Path, context: ControlContext\n    ) -&gt; None:\n\"\"\"Assemble markdown content into provided component-definition model.\"\"\"\n        # find the needed list of comps\n        sub_dirs = file_utils.iterdir_without_hidden_files(md_dir)\n        comp_names = [sub_dir.name for sub_dir in sub_dirs if sub_dir.is_dir()]\n\n        # make sure parent has list of comps to work with - possibly empty\n        if not parent_comp.components:\n            parent_comp.components = []\n\n        parent_comp.components[:] = [comp for comp in parent_comp.components if comp.title in comp_names]\n\n        # create new comps if needed\n        existing_comp_names = [component.title for component in parent_comp.components]\n        for comp_name in comp_names:\n            if comp_name not in existing_comp_names:\n                parent_comp.components.append(\n                    comp.DefinedComponent(\n                        uuid=str(uuid4()), title=comp_name, type=const.REPLACE_ME, description=const.REPLACE_ME\n                    )\n                )\n\n        for component in parent_comp.components:\n            context.comp_name = component.title\n            context.comp_def = parent_comp\n            context.component = component\n            logger.info(f'Assembling markdown for component {component.title}')\n            ComponentAssemble._update_component_with_markdown(md_dir, component, context)\n\n    @staticmethod\n    def _get_profile_title_and_href_from_dir(md_dir: pathlib.Path) -&gt; Tuple[str, str]:\n\"\"\"Get profile title and href from yaml header of first md file found in dir that has info.\"\"\"\n        md_files = md_dir.rglob('*.md')\n        markdown_api = MarkdownAPI()\n        for md_file in md_files:\n            header, _ = markdown_api.processor.read_markdown_wo_processing(md_file)\n            prof_title = deep_get(header, [const.TRESTLE_GLOBAL_TAG, const.PROFILE, const.TITLE])\n            profile_href = deep_get(header, [const.TRESTLE_GLOBAL_TAG, const.PROFILE, const.HREF], 'unknown_href')\n            # return first one found\n            if prof_title:\n                return prof_title, profile_href\n        logger.warning(f'Cannot find profile title and href in markdown headers of directory {md_dir}')\n        return 'unknown_title', 'unknown_href'\n\n    @staticmethod\n    def _update_component_with_markdown(\n        md_dir: pathlib.Path, component: comp.DefinedComponent, context: ControlContext\n    ) -&gt; None:\n        md_path = md_dir / component.title\n        sub_dirs = file_utils.iterdir_without_hidden_files(md_path)\n        source_dirs = [sub_dir.name for sub_dir in sub_dirs if sub_dir.is_dir()]\n        for source_dir in source_dirs:\n            profile_title, _ = ComponentAssemble._get_profile_title_and_href_from_dir(md_path / source_dir)\n            # context has defined component and comp_name\n            imp_reqs = CatalogReader.read_catalog_imp_reqs(md_path / source_dir, context)\n            # the imp_reqs need to be inserted into the correct control_implementation\n            for imp_req in imp_reqs:\n                ControlInterface.insert_imp_req_into_component(component, imp_req, profile_title, context.trestle_root)\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentAssemble.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentAssemble-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentAssemble.assemble_comp_def_into_parent","title":"<code>assemble_comp_def_into_parent(parent_comp, md_dir, context)</code>  <code>staticmethod</code>","text":"<p>Assemble markdown content into provided component-definition model.</p> Source code in <code>trestle/core/commands/author/component.py</code> <pre><code>@staticmethod\ndef assemble_comp_def_into_parent(\n    parent_comp: comp.ComponentDefinition, md_dir: pathlib.Path, context: ControlContext\n) -&gt; None:\n\"\"\"Assemble markdown content into provided component-definition model.\"\"\"\n    # find the needed list of comps\n    sub_dirs = file_utils.iterdir_without_hidden_files(md_dir)\n    comp_names = [sub_dir.name for sub_dir in sub_dirs if sub_dir.is_dir()]\n\n    # make sure parent has list of comps to work with - possibly empty\n    if not parent_comp.components:\n        parent_comp.components = []\n\n    parent_comp.components[:] = [comp for comp in parent_comp.components if comp.title in comp_names]\n\n    # create new comps if needed\n    existing_comp_names = [component.title for component in parent_comp.components]\n    for comp_name in comp_names:\n        if comp_name not in existing_comp_names:\n            parent_comp.components.append(\n                comp.DefinedComponent(\n                    uuid=str(uuid4()), title=comp_name, type=const.REPLACE_ME, description=const.REPLACE_ME\n                )\n            )\n\n    for component in parent_comp.components:\n        context.comp_name = component.title\n        context.comp_def = parent_comp\n        context.component = component\n        logger.info(f'Assembling markdown for component {component.title}')\n        ComponentAssemble._update_component_with_markdown(md_dir, component, context)\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentAssemble.assemble_component","title":"<code>assemble_component(trestle_root, parent_comp_name, md_name, assem_comp_name, regenerate, version)</code>  <code>staticmethod</code>","text":"<p>Assemble the markdown directory into a json component-definition model file.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>The trestle root directory</p> required <code>parent_comp_name</code> <code>Optional[str]</code> <p>Optional name of component-definition used to generate markdown, default = assem_comp_name</p> required <code>md_name</code> <code>str</code> <p>The name of the directory containing the markdown control files for the component</p> required <code>assem_comp_name</code> <code>str</code> <p>The name of the assembled component-definiton.  Can be same as the parent to overwrite</p> required <code>regenerate</code> <code>bool</code> <p>Whether to regenerate the uuid's in the component</p> required <code>version</code> <code>Optional[str]</code> <p>Optional version for the assembled component</p> required <p>Returns:</p> Type Description <code>int</code> <p>0 on success, 1 otherwise</p> <p>Notes</p> <p>There must already be a component model and it will either be updated or a new json component created. The generated markdown has the current values for parameters of controls being imported, as set by the original catalog and any intermediate components.  It also shows the current SetParameters being applied by this component.  That list of SetParameters can be edited by changing the assigned values and adding or removing SetParameters from that list.  During assembly that list will be used to create the SetParameters in the assembled component if the --set-parameters option is specified.</p> Source code in <code>trestle/core/commands/author/component.py</code> <pre><code>@staticmethod\ndef assemble_component(\n    trestle_root: pathlib.Path,\n    parent_comp_name: Optional[str],\n    md_name: str,\n    assem_comp_name: str,\n    regenerate: bool,\n    version: Optional[str],\n) -&gt; int:\n\"\"\"\n    Assemble the markdown directory into a json component-definition model file.\n\n    Args:\n        trestle_root: The trestle root directory\n        parent_comp_name: Optional name of component-definition used to generate markdown, default = assem_comp_name\n        md_name: The name of the directory containing the markdown control files for the component\n        assem_comp_name: The name of the assembled component-definiton.  Can be same as the parent to overwrite\n        regenerate: Whether to regenerate the uuid's in the component\n        version: Optional version for the assembled component\n\n    Returns:\n        0 on success, 1 otherwise\n\n    Notes:\n        There must already be a component model and it will either be updated or a new json component created.\n        The generated markdown has the current values for parameters of controls being imported, as set by\n        the original catalog and any intermediate components.  It also shows the current SetParameters being applied\n        by this component.  That list of SetParameters can be edited by changing the assigned values and adding or\n        removing SetParameters from that list.  During assembly that list will be used to create the SetParameters\n        in the assembled component if the --set-parameters option is specified.\n    \"\"\"\n    md_dir = trestle_root / md_name\n    if not md_dir.exists():\n        raise TrestleError(f'Markdown directory {md_name} does not exist.')\n\n    if not parent_comp_name:\n        parent_comp_name = assem_comp_name\n\n    # load the comp-def that will be updated\n    parent_comp, parent_comp_path = ModelUtils.load_model_for_class(\n        trestle_root,\n        parent_comp_name,\n        comp.ComponentDefinition\n    )\n    new_content_type = FileContentType.path_to_content_type(parent_comp_path)\n\n    context = ControlContext.generate(ContextPurpose.COMPONENT, False, trestle_root, md_dir)\n\n    ComponentAssemble.assemble_comp_def_into_parent(parent_comp, md_dir, context)\n\n    if version:\n        parent_comp.metadata.version = version\n\n    assem_comp_path = ModelUtils.get_model_path_for_name_and_class(\n        trestle_root, assem_comp_name, comp.ComponentDefinition, new_content_type\n    )\n\n    if not version and assem_comp_path.exists():\n        _, _, existing_comp = ModelUtils.load_distributed(assem_comp_path, trestle_root)\n        # comp def will change statement uuids so need to ignore them in comparison\n        if ModelUtils.models_are_equivalent(existing_comp, parent_comp, True):\n            logger.info('Assembled component definition is no different from existing version, so no update.')\n            return CmdReturnCodes.SUCCESS.value\n\n    if regenerate:\n        parent_comp, _, _ = ModelUtils.regenerate_uuids(parent_comp)\n    ModelUtils.update_last_modified(parent_comp)\n\n    if assem_comp_path.parent.exists():\n        logger.info(\n            'Creating component definition from markdown and destination component definition exists, so updating.'\n        )  # noqa E501\n        shutil.rmtree(str(assem_comp_path.parent))\n\n    assem_comp_path.parent.mkdir(parents=True, exist_ok=True)\n    parent_comp.oscal_write(assem_comp_path)\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentGenerate","title":"<code> ComponentGenerate            (AuthorCommonCommand)         </code>","text":"<p>Generate component in markdown form from a component in the trestle workspace.</p> Source code in <code>trestle/core/commands/author/component.py</code> <pre><code>class ComponentGenerate(AuthorCommonCommand):\n\"\"\"Generate component in markdown form from a component in the trestle workspace.\"\"\"\n\n    name = 'component-generate'\n\n    def _init_arguments(self) -&gt; None:\n        name_help_str = 'Name of the source component model in the trestle workspace'\n        self.add_argument('-n', '--name', help=name_help_str, required=True, type=str)\n        self.add_argument(\n            '-o', '--output', help='Name of the output generated component markdown folder', required=True, type=str\n        )  # noqa E501\n        self.add_argument('-fo', '--force-overwrite', help=const.HELP_FO_OUTPUT, required=False, action='store_true')\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n\n            if args.force_overwrite:\n                try:\n                    logger.info(f'Overwriting the content in {args.output} folder.')\n                    clear_folder(pathlib.Path(args.output))\n                except TrestleError as e:  # pragma: no cover\n                    raise TrestleError(f'Unable to overwrite contents in {args.output} folder: {e}')\n\n            return self.component_generate_all(args.trestle_root, args.name, args.output)\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Generation of the component markdown failed')\n\n    def component_generate_all(self, trestle_root: pathlib.Path, comp_def_name: str, markdown_dir_name: str) -&gt; int:\n\"\"\"Generate markdown for all components in comp def.\"\"\"\n        if not file_utils.is_directory_name_allowed(markdown_dir_name):\n            raise TrestleError(f'{markdown_dir_name} is not an allowed directory name')\n        md_path = trestle_root / markdown_dir_name\n        md_path.mkdir(parents=True, exist_ok=True)\n        component_def, _ = load_validate_model_name(trestle_root, comp_def_name, comp.ComponentDefinition)\n\n        context = ControlContext.generate(ContextPurpose.COMPONENT, True, trestle_root, md_path)\n        context.prompt_responses = True\n        context.comp_def = component_def\n\n        rc = CmdReturnCodes.SUCCESS.value\n        for component in as_list(component_def.components):\n            rc = self.component_generate_by_name(context, component, md_path / component.title)\n            if rc != CmdReturnCodes.SUCCESS.value:\n                break\n        return rc\n\n    @staticmethod\n    def _get_name_from_uri(source_uri: str) -&gt; str:\n\"\"\"Get the name from a source profile or catalog source uri.\"\"\"\n        uri_type = FetcherFactory.get_uri_type(source_uri)\n        if uri_type == FetcherFactory.UriType.TRESTLE:\n            return source_uri.split('/')[-2]\n        return ''\n\n    def component_generate_by_name(\n        self, context: ControlContext, component: comp.DefinedComponent, markdown_dir_path: pathlib.Path\n    ) -&gt; int:\n\"\"\"Create markdown for the component using its source profiles.\"\"\"\n        logger.info(f'Generating markdown for component {component.title}')\n        context.comp_name = component.title\n        context.component = component\n        context.uri_name_map = {}\n        cat_api_dict: Dict[str, CatalogAPI] = {}\n        name_index = 1\n        for control_imp in as_list(component.control_implementations):\n            context.control_implementation = control_imp\n            source_profile_uri = control_imp.source\n            # get the resolved profile catalog for this source, generating it if not already created\n            if source_profile_uri not in cat_api_dict:\n                name = ComponentGenerate._get_name_from_uri(source_profile_uri)\n                if not name:\n                    name = f'source_{name_index:03d}'\n                    name_index += 1\n                context.uri_name_map[source_profile_uri] = name\n                resolved_catalog = ProfileResolver.get_resolved_profile_catalog(\n                    context.trestle_root, source_profile_uri\n                )\n                local_catalog_api = CatalogAPI(resolved_catalog)\n                cat_api_dict[source_profile_uri] = local_catalog_api\n            else:\n                local_catalog_api = cat_api_dict[source_profile_uri]\n            # insert the profile title (from title of resolved catalog) into the yaml header so it appears in md\n            # different controls in the final catalog may have different profile titles if from different control_imps\n            context.cli_yaml_header = {}\n            context.cli_yaml_header[const.TRESTLE_GLOBAL_TAG] = {}\n\n            profile_title = local_catalog_api._catalog_interface.get_catalog_title()\n            profile_header = {'title': profile_title, 'href': source_profile_uri}\n            context.cli_yaml_header[const.TRESTLE_GLOBAL_TAG][const.PROFILE] = profile_header\n\n            sub_dir_name = context.uri_name_map[source_profile_uri]\n            context.md_root = markdown_dir_path / sub_dir_name\n            # write controls corresponding to this source catalog\n            # if two controlimps load the same control, the second one will merge into the first\n            # otherwise the full catalog will be written in subsets by control_imp\n            # if an imp_req has a set param also in the control_imp. the imp_req value is used for the control\n            cat_api_dict[source_profile_uri].update_context(context)\n            cat_api_dict[source_profile_uri].write_catalog_as_markdown()\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentGenerate.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentGenerate-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentGenerate.component_generate_all","title":"<code>component_generate_all(self, trestle_root, comp_def_name, markdown_dir_name)</code>","text":"<p>Generate markdown for all components in comp def.</p> Source code in <code>trestle/core/commands/author/component.py</code> <pre><code>def component_generate_all(self, trestle_root: pathlib.Path, comp_def_name: str, markdown_dir_name: str) -&gt; int:\n\"\"\"Generate markdown for all components in comp def.\"\"\"\n    if not file_utils.is_directory_name_allowed(markdown_dir_name):\n        raise TrestleError(f'{markdown_dir_name} is not an allowed directory name')\n    md_path = trestle_root / markdown_dir_name\n    md_path.mkdir(parents=True, exist_ok=True)\n    component_def, _ = load_validate_model_name(trestle_root, comp_def_name, comp.ComponentDefinition)\n\n    context = ControlContext.generate(ContextPurpose.COMPONENT, True, trestle_root, md_path)\n    context.prompt_responses = True\n    context.comp_def = component_def\n\n    rc = CmdReturnCodes.SUCCESS.value\n    for component in as_list(component_def.components):\n        rc = self.component_generate_by_name(context, component, md_path / component.title)\n        if rc != CmdReturnCodes.SUCCESS.value:\n            break\n    return rc\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.component/#trestle.core.commands.author.component.ComponentGenerate.component_generate_by_name","title":"<code>component_generate_by_name(self, context, component, markdown_dir_path)</code>","text":"<p>Create markdown for the component using its source profiles.</p> Source code in <code>trestle/core/commands/author/component.py</code> <pre><code>def component_generate_by_name(\n    self, context: ControlContext, component: comp.DefinedComponent, markdown_dir_path: pathlib.Path\n) -&gt; int:\n\"\"\"Create markdown for the component using its source profiles.\"\"\"\n    logger.info(f'Generating markdown for component {component.title}')\n    context.comp_name = component.title\n    context.component = component\n    context.uri_name_map = {}\n    cat_api_dict: Dict[str, CatalogAPI] = {}\n    name_index = 1\n    for control_imp in as_list(component.control_implementations):\n        context.control_implementation = control_imp\n        source_profile_uri = control_imp.source\n        # get the resolved profile catalog for this source, generating it if not already created\n        if source_profile_uri not in cat_api_dict:\n            name = ComponentGenerate._get_name_from_uri(source_profile_uri)\n            if not name:\n                name = f'source_{name_index:03d}'\n                name_index += 1\n            context.uri_name_map[source_profile_uri] = name\n            resolved_catalog = ProfileResolver.get_resolved_profile_catalog(\n                context.trestle_root, source_profile_uri\n            )\n            local_catalog_api = CatalogAPI(resolved_catalog)\n            cat_api_dict[source_profile_uri] = local_catalog_api\n        else:\n            local_catalog_api = cat_api_dict[source_profile_uri]\n        # insert the profile title (from title of resolved catalog) into the yaml header so it appears in md\n        # different controls in the final catalog may have different profile titles if from different control_imps\n        context.cli_yaml_header = {}\n        context.cli_yaml_header[const.TRESTLE_GLOBAL_TAG] = {}\n\n        profile_title = local_catalog_api._catalog_interface.get_catalog_title()\n        profile_header = {'title': profile_title, 'href': source_profile_uri}\n        context.cli_yaml_header[const.TRESTLE_GLOBAL_TAG][const.PROFILE] = profile_header\n\n        sub_dir_name = context.uri_name_map[source_profile_uri]\n        context.md_root = markdown_dir_path / sub_dir_name\n        # write controls corresponding to this source catalog\n        # if two controlimps load the same control, the second one will merge into the first\n        # otherwise the full catalog will be written in subsets by control_imp\n        # if an imp_req has a set param also in the control_imp. the imp_req value is used for the control\n        cat_api_dict[source_profile_uri].update_context(context)\n        cat_api_dict[source_profile_uri].write_catalog_as_markdown()\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.consts/","title":"consts","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts","title":"<code>trestle.core.commands.author.consts</code>","text":"<p>Constants associated with trestle author commands to decrease duplication.</p>"},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.EXCLUDE_HELP","title":"<code>EXCLUDE_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.EXCLUDE_LONG","title":"<code>EXCLUDE_LONG</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.EXCLUDE_SHORT","title":"<code>EXCLUDE_SHORT</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.GH_HELP","title":"<code>GH_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.GH_LONG","title":"<code>GH_LONG</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.GH_SHORT","title":"<code>GH_SHORT</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.GLOBAL_HELP","title":"<code>GLOBAL_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.GLOBAL_LONG","title":"<code>GLOBAL_LONG</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.GLOBAL_SHORT","title":"<code>GLOBAL_SHORT</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.HEADER_VALIDATE_HELP","title":"<code>HEADER_VALIDATE_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.HOV_HELP","title":"<code>HOV_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.HOV_LONG","title":"<code>HOV_LONG</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.HOV_SHORT","title":"<code>HOV_SHORT</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.IGNORE_HELP","title":"<code>IGNORE_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.LONG_HEADER_VALIDATE","title":"<code>LONG_HEADER_VALIDATE</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.LONG_IGNORE","title":"<code>LONG_IGNORE</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.LONG_README_VALIDATE","title":"<code>LONG_README_VALIDATE</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.LONG_TEMPLATE_VERSION","title":"<code>LONG_TEMPLATE_VERSION</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.MODE_ARG_NAME","title":"<code>MODE_ARG_NAME</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.MODE_CHOICES","title":"<code>MODE_CHOICES</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.README_VALIDATE_FOLDERS_HELP","title":"<code>README_VALIDATE_FOLDERS_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.README_VALIDATE_HELP","title":"<code>README_VALIDATE_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.RECURSE_HELP","title":"<code>RECURSE_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.RECURSE_LONG","title":"<code>RECURSE_LONG</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.RECURSE_SHORT","title":"<code>RECURSE_SHORT</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.REFERENCE_TEMPLATES","title":"<code>REFERENCE_TEMPLATES</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.SHORT_HEADER_VALIDATE","title":"<code>SHORT_HEADER_VALIDATE</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.SHORT_IGNORE","title":"<code>SHORT_IGNORE</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.SHORT_README_VALIDATE","title":"<code>SHORT_README_VALIDATE</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.SHORT_TEMPLATE_VERSION","title":"<code>SHORT_TEMPLATE_VERSION</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.START_TEMPLATE_VERSION","title":"<code>START_TEMPLATE_VERSION</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.TASK_NAME_LONG","title":"<code>TASK_NAME_LONG</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.TASK_NAME_SHORT","title":"<code>TASK_NAME_SHORT</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.TEMPLATE_VERSION_HEADER","title":"<code>TEMPLATE_VERSION_HEADER</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.TEMPLATE_VERSION_HELP","title":"<code>TEMPLATE_VERSION_HELP</code>","text":""},{"location":"api_reference/trestle.core.commands.author.consts/#trestle.core.commands.author.consts.TRESTLE_RESOURCES","title":"<code>TRESTLE_RESOURCES</code>","text":""},{"location":"api_reference/trestle.core.commands.author.docs/","title":"docs","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs","title":"<code>trestle.core.commands.author.docs</code>","text":"<p>Trestle author docs sub-command.</p>"},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs.Docs","title":"<code> Docs            (AuthorCommonCommand)         </code>","text":"<p>Markdown governed documents - enforcing consistent markdown across a set of files.</p> Source code in <code>trestle/core/commands/author/docs.py</code> <pre><code>class Docs(AuthorCommonCommand):\n\"\"\"Markdown governed documents - enforcing consistent markdown across a set of files.\"\"\"\n\n    name = 'docs'\n\n    template_name = 'template.md'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument(\n            author_const.GH_SHORT, author_const.GH_LONG, help=author_const.GH_HELP, default=None, type=str\n        )\n        self.add_argument(\n            author_const.SHORT_HEADER_VALIDATE,\n            author_const.LONG_HEADER_VALIDATE,\n            help=author_const.HEADER_VALIDATE_HELP,\n            action='store_true'\n        )\n        self.add_argument(\n            author_const.SHORT_TEMPLATE_VERSION,\n            author_const.LONG_TEMPLATE_VERSION,\n            help=author_const.TEMPLATE_VERSION_HELP,\n            action='store'\n        )\n        self.add_argument(\n            author_const.HOV_SHORT, author_const.HOV_LONG, help=author_const.HOV_HELP, action='store_true'\n        )\n        self.add_argument(\n            author_const.SHORT_IGNORE, author_const.LONG_IGNORE, help=author_const.IGNORE_HELP, default=None, type=str\n        )\n        self.add_argument(\n            author_const.RECURSE_SHORT, author_const.RECURSE_LONG, help=author_const.RECURSE_HELP, action='store_true'\n        )\n        self.add_argument(author_const.MODE_ARG_NAME, choices=author_const.MODE_CHOICES)\n        tn_help_str = '\\n'.join(\n            [\n                'The name of the the task to be governed.',\n                ''\n                'The template file is at .trestle/author/[task-name]/template.md',\n                'Note that by default this will automatically enforce the task.'\n            ]\n        )\n\n        self.add_argument(\n            author_const.TASK_NAME_SHORT, author_const.TASK_NAME_LONG, help=tn_help_str, required=True, type=str\n        )\n        self.add_argument(\n            author_const.SHORT_README_VALIDATE,\n            author_const.LONG_README_VALIDATE,\n            help=author_const.README_VALIDATE_HELP,\n            action='store_true'\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            status = 1\n            if self._initialize(args):\n                return status\n\n            if args.mode == 'create-sample':\n                status = self.create_sample()\n\n            elif args.mode == 'template-validate':\n                status = self.template_validate(\n                    args.governed_heading,\n                    args.header_validate,\n                    args.header_only_validate,\n                )\n            elif args.mode == 'setup':\n                status = self.setup_template_governed_docs(args.template_version)\n            elif args.mode == 'validate':\n                # mode is validate\n                status = self.validate(\n                    args.governed_heading,\n                    args.header_validate,\n                    args.header_only_validate,\n                    args.recurse,\n                    args.readme_validate,\n                    args.template_version,\n                    args.ignore\n                )\n\n            return status\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error occurred when running trestle author docs')\n\n    def setup_template_governed_docs(self, template_version: str) -&gt; int:\n\"\"\"Create structure to allow markdown template enforcement.\n\n        Returns:\n            Unix return code.\n        \"\"\"\n        if not self.task_path.exists():\n            self.task_path.mkdir(exist_ok=True, parents=True)\n        elif self.task_path.is_file():\n            raise TrestleError(f'Task path: {self.rel_dir(self.task_path)} is a file not a directory.')\n        if not self.template_dir.exists():\n            self.template_dir.mkdir(exist_ok=True, parents=True)\n        elif self.template_dir.is_file():\n            raise TrestleError(f'Template path: {self.rel_dir(self.template_dir)} is a file not a directory.')\n        logger.debug(self.template_dir)\n        if not self._validate_template_dir():\n            raise TrestleError('Aborting setup')\n        template_file = self.template_dir / self.template_name\n        if template_file.is_file():\n            return CmdReturnCodes.SUCCESS.value\n        TemplateVersioning.write_versioned_template('template.md', self.template_dir, template_file, template_version)\n        logger.info(f'Template file setup for task {self.task_name} at {self.rel_dir(template_file)}')\n        logger.info(f'Task directory is {self.rel_dir(self.task_path)}')\n        return CmdReturnCodes.SUCCESS.value\n\n    def create_sample(self) -&gt; int:\n\"\"\"Presuming the template exists, copy into a sample markdown file with an index.\"\"\"\n        template_file = self.template_dir / self.template_name\n\n        if not self._validate_template_dir():\n            raise TrestleError('Aborting setup')\n        if not template_file.is_file():\n            raise TrestleError('No template file ... exiting.')\n\n        index = 0\n        while True:\n            candidate_task = self.task_path / f'{self.task_name}_{index:03d}.md'\n            if candidate_task.is_file():\n                index = index + 1\n            else:\n                shutil.copy(str(template_file), str(candidate_task))\n                break\n        return CmdReturnCodes.SUCCESS.value\n\n    def template_validate(self, heading: Optional[str], validate_header: bool, validate_only_header: bool) -&gt; int:\n\"\"\"Validate that the template is acceptable markdown.\"\"\"\n        template_file = self.template_dir / self.template_name\n        if not self._validate_template_dir():\n            raise TrestleError(f'Aborting setup, template directory {self.template_dir} is invalid.')\n        if not template_file.is_file():\n            raise TrestleError(f'Required template file: {self.rel_dir(template_file)} does not exist. Exiting.')\n        try:\n            md_api = MarkdownAPI()\n            validate_body = False if validate_only_header else True\n            md_api.load_validator_with_template(\n                template_file, validate_header or validate_only_header, validate_body, heading, True\n            )\n        except Exception as ex:\n            raise TrestleError(f'Template for task {self.task_name} failed to validate due to {ex}')\n\n        logger.info(f'TEMPLATES VALID: {self.task_name}')\n        return CmdReturnCodes.SUCCESS.value\n\n    def _validate_template_dir(self) -&gt; bool:\n\"\"\"Template directory should only have template file.\"\"\"\n        for child in file_utils.iterdir_without_hidden_files(self.template_dir):\n            # Only allowable template file in the directory is the template directory.\n            if child.name != self.template_name and child.name.lower() != 'readme.md':\n                logger.warning(f'Unknown file: {child.name} in template directory {self.rel_dir(self.template_dir)}')\n                return False\n        return True\n\n    def _validate_dir(\n        self,\n        governed_heading: str,\n        md_dir: pathlib.Path,\n        validate_header: bool,\n        validate_only_header: bool,\n        recurse: bool,\n        readme_validate: bool,\n        template_version: Optional[str] = None,\n        ignore: Optional[str] = None\n    ) -&gt; int:\n\"\"\"\n        Validate md files in a directory with option to recurse.\n\n        Template version will be fetched from the instance header.\n        \"\"\"\n        # status is a linux returncode\n        status = 0\n        for item_path in md_dir.iterdir():\n            if file_utils.is_local_and_visible(item_path):\n                if item_path.is_file():\n                    if not item_path.suffix == const.MARKDOWN_FILE_EXT:\n                        logger.info(\n                            f'Unexpected file {self.rel_dir(item_path)} in folder {self.rel_dir(md_dir)}, skipping.'\n                        )\n                        continue\n                    if not readme_validate and item_path.name.lower() == 'readme.md':\n                        continue\n\n                    if ignore:\n                        p = re.compile(ignore)\n                        matched = p.match(item_path.parts[-1])\n                        if matched is not None:\n                            logger.info(f'Ignoring file {item_path} from validation.')\n                            continue\n\n                    md_api = MarkdownAPI()\n                    if template_version != '':\n                        template_file = self.template_dir / self.template_name\n                    else:\n                        instance_version = md_api.processor.fetch_value_from_header(\n                            item_path, author_const.TEMPLATE_VERSION_HEADER\n                        )\n                        if instance_version is None:\n                            instance_version = '0.0.1'\n                        versione_template_dir = TemplateVersioning.get_versioned_template_dir(\n                            self.template_dir, instance_version\n                        )\n                        template_file = versione_template_dir / self.template_name\n                    if not template_file.is_file():\n                        raise TrestleError(\n                            f'Required template file: {self.rel_dir(template_file)} does not exist. Exiting.'\n                        )\n                    md_api.load_validator_with_template(\n                        template_file, validate_header, not validate_only_header, governed_heading\n                    )\n                    if not md_api.validate_instance(item_path):\n                        logger.info(f'INVALID: {self.rel_dir(item_path)}')\n                        status = 1\n                    else:\n                        logger.info(f'VALID: {self.rel_dir(item_path)}')\n                elif recurse:\n                    if ignore:\n                        p = re.compile(ignore)\n                        if len(list(filter(p.match, str(item_path.relative_to(md_dir)).split('/')))) &gt; 0:\n                            logger.info(f'Ignoring directory {item_path} from validation.')\n                            continue\n                    rc = self._validate_dir(\n                        governed_heading,\n                        item_path,\n                        validate_header,\n                        validate_only_header,\n                        recurse,\n                        readme_validate,\n                        template_version,\n                        ignore\n                    )\n                    if rc != 0:\n                        status = rc\n\n        return status\n\n    def validate(\n        self,\n        governed_heading: str,\n        validate_header: bool,\n        validate_only_header: bool,\n        recurse: bool,\n        readme_validate: bool,\n        template_version: str,\n        ignore: str\n    ) -&gt; int:\n\"\"\"\n        Validate task.\n\n        Args:\n            governed_heading: A heading for which structural enforcement (see online docs).\n            validate_header: Whether or not to validate the key structure of the yaml header to the markdown document.\n            validate_only_header: Whether to validate just the yaml header.\n            recurse: Whether to allow validated files to be in a directory tree.\n            readme_validate: Whether to validate readme files, otherwise they will be ignored.\n\n        Returns:\n            Return code to be used for the command.\n        \"\"\"\n        if not self.task_path.is_dir():\n            raise TrestleError(f'Task directory {self.rel_dir(self.task_path)} does not exist. Exiting validate.')\n\n        return self._validate_dir(\n            governed_heading,\n            self.task_path,\n            validate_header,\n            validate_only_header,\n            recurse,\n            readme_validate,\n            template_version,\n            ignore\n        )\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs.Docs.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs.Docs.template_name","title":"<code>template_name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs.Docs-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs.Docs.create_sample","title":"<code>create_sample(self)</code>","text":"<p>Presuming the template exists, copy into a sample markdown file with an index.</p> Source code in <code>trestle/core/commands/author/docs.py</code> <pre><code>def create_sample(self) -&gt; int:\n\"\"\"Presuming the template exists, copy into a sample markdown file with an index.\"\"\"\n    template_file = self.template_dir / self.template_name\n\n    if not self._validate_template_dir():\n        raise TrestleError('Aborting setup')\n    if not template_file.is_file():\n        raise TrestleError('No template file ... exiting.')\n\n    index = 0\n    while True:\n        candidate_task = self.task_path / f'{self.task_name}_{index:03d}.md'\n        if candidate_task.is_file():\n            index = index + 1\n        else:\n            shutil.copy(str(template_file), str(candidate_task))\n            break\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs.Docs.setup_template_governed_docs","title":"<code>setup_template_governed_docs(self, template_version)</code>","text":"<p>Create structure to allow markdown template enforcement.</p> <p>Returns:</p> Type Description <code>int</code> <p>Unix return code.</p> Source code in <code>trestle/core/commands/author/docs.py</code> <pre><code>def setup_template_governed_docs(self, template_version: str) -&gt; int:\n\"\"\"Create structure to allow markdown template enforcement.\n\n    Returns:\n        Unix return code.\n    \"\"\"\n    if not self.task_path.exists():\n        self.task_path.mkdir(exist_ok=True, parents=True)\n    elif self.task_path.is_file():\n        raise TrestleError(f'Task path: {self.rel_dir(self.task_path)} is a file not a directory.')\n    if not self.template_dir.exists():\n        self.template_dir.mkdir(exist_ok=True, parents=True)\n    elif self.template_dir.is_file():\n        raise TrestleError(f'Template path: {self.rel_dir(self.template_dir)} is a file not a directory.')\n    logger.debug(self.template_dir)\n    if not self._validate_template_dir():\n        raise TrestleError('Aborting setup')\n    template_file = self.template_dir / self.template_name\n    if template_file.is_file():\n        return CmdReturnCodes.SUCCESS.value\n    TemplateVersioning.write_versioned_template('template.md', self.template_dir, template_file, template_version)\n    logger.info(f'Template file setup for task {self.task_name} at {self.rel_dir(template_file)}')\n    logger.info(f'Task directory is {self.rel_dir(self.task_path)}')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs.Docs.template_validate","title":"<code>template_validate(self, heading, validate_header, validate_only_header)</code>","text":"<p>Validate that the template is acceptable markdown.</p> Source code in <code>trestle/core/commands/author/docs.py</code> <pre><code>def template_validate(self, heading: Optional[str], validate_header: bool, validate_only_header: bool) -&gt; int:\n\"\"\"Validate that the template is acceptable markdown.\"\"\"\n    template_file = self.template_dir / self.template_name\n    if not self._validate_template_dir():\n        raise TrestleError(f'Aborting setup, template directory {self.template_dir} is invalid.')\n    if not template_file.is_file():\n        raise TrestleError(f'Required template file: {self.rel_dir(template_file)} does not exist. Exiting.')\n    try:\n        md_api = MarkdownAPI()\n        validate_body = False if validate_only_header else True\n        md_api.load_validator_with_template(\n            template_file, validate_header or validate_only_header, validate_body, heading, True\n        )\n    except Exception as ex:\n        raise TrestleError(f'Template for task {self.task_name} failed to validate due to {ex}')\n\n    logger.info(f'TEMPLATES VALID: {self.task_name}')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.docs/#trestle.core.commands.author.docs.Docs.validate","title":"<code>validate(self, governed_heading, validate_header, validate_only_header, recurse, readme_validate, template_version, ignore)</code>","text":"<p>Validate task.</p> <p>Parameters:</p> Name Type Description Default <code>governed_heading</code> <code>str</code> <p>A heading for which structural enforcement (see online docs).</p> required <code>validate_header</code> <code>bool</code> <p>Whether or not to validate the key structure of the yaml header to the markdown document.</p> required <code>validate_only_header</code> <code>bool</code> <p>Whether to validate just the yaml header.</p> required <code>recurse</code> <code>bool</code> <p>Whether to allow validated files to be in a directory tree.</p> required <code>readme_validate</code> <code>bool</code> <p>Whether to validate readme files, otherwise they will be ignored.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Return code to be used for the command.</p> Source code in <code>trestle/core/commands/author/docs.py</code> <pre><code>def validate(\n    self,\n    governed_heading: str,\n    validate_header: bool,\n    validate_only_header: bool,\n    recurse: bool,\n    readme_validate: bool,\n    template_version: str,\n    ignore: str\n) -&gt; int:\n\"\"\"\n    Validate task.\n\n    Args:\n        governed_heading: A heading for which structural enforcement (see online docs).\n        validate_header: Whether or not to validate the key structure of the yaml header to the markdown document.\n        validate_only_header: Whether to validate just the yaml header.\n        recurse: Whether to allow validated files to be in a directory tree.\n        readme_validate: Whether to validate readme files, otherwise they will be ignored.\n\n    Returns:\n        Return code to be used for the command.\n    \"\"\"\n    if not self.task_path.is_dir():\n        raise TrestleError(f'Task directory {self.rel_dir(self.task_path)} does not exist. Exiting validate.')\n\n    return self._validate_dir(\n        governed_heading,\n        self.task_path,\n        validate_header,\n        validate_only_header,\n        recurse,\n        readme_validate,\n        template_version,\n        ignore\n    )\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.folders/","title":"folders","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders","title":"<code>trestle.core.commands.author.folders</code>","text":"<p>Trestle author docs sub-command.</p>"},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders.Folders","title":"<code> Folders            (AuthorCommonCommand)         </code>","text":"<p>Markdown governed folders - enforcing consistent files and templates across directories.</p> Source code in <code>trestle/core/commands/author/folders.py</code> <pre><code>class Folders(AuthorCommonCommand):\n\"\"\"Markdown governed folders - enforcing consistent files and templates across directories.\"\"\"\n\n    name = 'folders'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument(\n            author_const.GH_SHORT, author_const.GH_LONG, help=author_const.GH_HELP, default=None, type=str\n        )\n        self.add_argument(\n            author_const.SHORT_HEADER_VALIDATE,\n            author_const.LONG_HEADER_VALIDATE,\n            help=author_const.HEADER_VALIDATE_HELP,\n            action='store_true'\n        )\n        self.add_argument(\n            author_const.HOV_SHORT, author_const.HOV_LONG, help=author_const.HOV_HELP, action='store_true'\n        )\n        self.add_argument(\n            author_const.SHORT_TEMPLATE_VERSION,\n            author_const.LONG_TEMPLATE_VERSION,\n            help=author_const.TEMPLATE_VERSION_HELP,\n            action='store'\n        )\n        self.add_argument(\n            author_const.SHORT_IGNORE, author_const.LONG_IGNORE, help=author_const.IGNORE_HELP, default=None, type=str\n        )\n        self.add_argument(author_const.MODE_ARG_NAME, choices=author_const.MODE_CHOICES)\n        tn_help_str = '\\n'.join(\n            [\n                'The name of the the task to be governed.',\n                '',\n                'The template files are at .trestle/author/[task-name],',\n                'where the directory tree established and the markdown files within that directory'\n                + 'tree are enforced.'\n            ]\n        )\n\n        self.add_argument(\n            author_const.TASK_NAME_SHORT, author_const.TASK_NAME_LONG, help=tn_help_str, required=True, type=str\n        )\n        self.add_argument(\n            author_const.SHORT_README_VALIDATE,\n            author_const.LONG_README_VALIDATE,\n            help=author_const.README_VALIDATE_FOLDERS_HELP,\n            action='store_true'\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            if self._initialize(args):\n                raise TrestleError(f'Error when initializing trestle folders command with args: {args}')\n            if args.mode == 'create-sample':\n                status = self.create_sample()\n\n            elif args.mode == 'template-validate':\n                status = self.template_validate(\n                    args.header_validate, args.header_only_validate, args.governed_heading, args.readme_validate\n                )\n            elif args.mode == 'setup':\n                status = self.setup_template(args.template_version)\n            elif args.mode == 'validate':\n                # mode is validate\n                status = self.validate(\n                    args.header_validate,\n                    args.header_only_validate,\n                    args.governed_heading,\n                    args.readme_validate,\n                    args.template_version,\n                    args.ignore\n                )\n            else:\n                raise TrestleIncorrectArgsError(f'Unsupported mode: {args.mode} for folders command.')\n\n            return status\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error occurred when running trestle author folders')\n\n    def setup_template(self, template_version: str) -&gt; int:\n\"\"\"Create structure to allow markdown template enforcement.\"\"\"\n        if not self.task_path.exists():\n            self.task_path.mkdir(exist_ok=True, parents=True)\n        elif self.task_path.is_file():\n            raise TrestleError(f'Task path: {self.rel_dir(self.task_path)} is a file not a directory.')\n        if not self.template_dir.exists():\n            self.template_dir.mkdir(exist_ok=True, parents=True)\n        elif self.template_dir.is_file():\n            raise TrestleError(f'Template path: {self.rel_dir(self.template_dir)} is a file not a directory.')\n\n        template_file_a_md = self.template_dir / 'a_template.md'\n        template_file_another_md = self.template_dir / 'another_template.md'\n        template_file_drawio = self.template_dir / 'architecture.drawio'\n        TemplateVersioning.write_versioned_template(\n            'template.md', self.template_dir, template_file_a_md, template_version\n        )\n        TemplateVersioning.write_versioned_template(\n            'template.md', self.template_dir, template_file_another_md, template_version\n        )\n        TemplateVersioning.write_versioned_template(\n            'template.drawio', self.template_dir, template_file_drawio, template_version\n        )\n\n        return CmdReturnCodes.SUCCESS.value\n\n    def template_validate(\n        self, validate_header: bool, validate_only_header: bool, heading: str, readme_validate: bool\n    ) -&gt; int:\n\"\"\"Validate that the template is acceptable markdown.\"\"\"\n        if not self.template_dir.is_dir():\n            raise TrestleError(\n                f'Template directory {self.rel_dir(self.template_dir)} for task {self.task_name} does not exist.'\n            )\n        # get list of files:\n        template_files = self.template_dir.rglob('*')\n\n        for template_file in template_files:\n            try:\n                if not file_utils.is_local_and_visible(template_file):\n                    continue\n                elif template_file.is_dir():\n                    continue\n                elif template_file.suffix.lower() == const.MARKDOWN_FILE_EXT:\n                    if not readme_validate and template_file.name == 'readme.md':\n                        raise TrestleError('Template directory contains a readme.md file and readme validation is off.')\n\n                    md_api = MarkdownAPI()\n                    md_api.load_validator_with_template(\n                        template_file, validate_header, not validate_only_header, heading\n                    )\n                elif template_file.suffix.lower().lstrip('.') == 'drawio':\n                    _ = draw_io.DrawIOMetadataValidator(template_file)\n                else:\n                    logger.info(\n                        f'File: {self.rel_dir(template_file)} within the template directory was ignored'\n                        + ' as it is not markdown.'\n                    )\n            except Exception as ex:\n                raise TrestleError(\n                    f'Template file {self.rel_dir(template_file)} for task {self.task_name}'\n                    + f' failed to validate due to {ex}'\n                )\n        logger.info(f'TEMPLATES VALID: {self.task_name}.')\n        return CmdReturnCodes.SUCCESS.value\n\n    def _measure_template_folder(\n        self,\n        instance_dir: pathlib.Path,\n        validate_header: bool,\n        validate_only_header: bool,\n        governed_heading: str,\n        readme_validate: bool,\n        template_version: str,\n        ignore: str\n    ) -&gt; bool:\n\"\"\"\n        Validate instances against templates.\n\n        Validation will succeed iff:\n            1. All template files from the specified version are present in the task\n            2. All of the instances are valid\n        \"\"\"\n        all_versioned_templates = {}\n        instance_version = template_version\n        instance_file_names: List[pathlib.Path] = []\n        # Fetch all instances versions and build dictionary of required template files\n        for instance_file in instance_dir.iterdir():\n            if not file_utils.is_local_and_visible(instance_file):\n                continue\n            if not instance_file.is_file():\n                continue\n            if instance_file.name.lower() == 'readme.md' and not readme_validate:\n                continue\n            if ignore:\n                p = re.compile(ignore)\n                matched = p.match(instance_file.parts[-1])\n                if matched is not None:\n                    logger.info(f'Ignoring file {instance_file} from validation.')\n                    continue\n            instance_file_name = instance_file.relative_to(instance_dir)\n            instance_file_names.append(instance_file_name)\n            if instance_file.suffix == const.MARKDOWN_FILE_EXT:\n                md_api = MarkdownAPI()\n                versioned_template_dir = None\n                if template_version != '':\n                    template_file = self.template_dir / instance_file_name\n                    versioned_template_dir = self.template_dir\n                else:\n                    instance_version = md_api.processor.fetch_value_from_header(\n                        instance_file, author_const.TEMPLATE_VERSION_HEADER\n                    )\n                    if instance_version is None:\n                        instance_version = '0.0.1'  # backward compatibility\n                    versioned_template_dir = TemplateVersioning.get_versioned_template_dir(\n                        self.template_dir, instance_version\n                    )\n                    template_file = versioned_template_dir / instance_file_name\n\n                # Check if instance is in the available templates,\n                # additional files are allowed but should not be validated.\n                templates = self._get_templates(versioned_template_dir, readme_validate)\n                is_template_present = False\n                for template in templates:\n                    if template.name == str(instance_file_name):\n                        is_template_present = True\n                        break\n\n                if not is_template_present:\n                    logger.info(\n                        f'INFO: File{instance_file} will not be validated '\n                        f'as its name does not match any template file.'\n                    )\n                    continue\n\n                if instance_version not in all_versioned_templates.keys():\n                    all_versioned_templates[instance_version] = dict.fromkeys(\n                        [t.relative_to(versioned_template_dir) for t in templates], False\n                    )\n\n                if instance_file_name in all_versioned_templates[instance_version]:\n                    # validate\n                    md_api.load_validator_with_template(\n                        template_file, validate_header, not validate_only_header, governed_heading\n                    )\n                    status = md_api.validate_instance(instance_file)\n                    if not status:\n                        logger.warning(\n                            f'INVALID: Markdown file {instance_file} failed validation against' + f' {template_file}'\n                        )\n                        return False\n                    else:\n                        logger.info(f'VALID: {instance_file}')\n                    # mark template as present\n                    all_versioned_templates[instance_version][instance_file_name] = True\n\n            elif instance_file.suffix == const.DRAWIO_FILE_EXT:\n                drawio = draw_io.DrawIO(instance_file)\n                metadata = drawio.get_metadata()[0]\n                versioned_template_dir = None\n                if template_version != '':\n                    template_file = self.template_dir / instance_file_name\n                    versioned_template_dir = self.template_dir\n                else:\n                    if author_const.TEMPLATE_VERSION_HEADER in metadata.keys():\n                        instance_version = metadata[author_const.TEMPLATE_VERSION_HEADER]\n                    else:\n                        instance_version = '0.0.1'  # backward compatibility\n\n                    versioned_template_dir = TemplateVersioning.get_versioned_template_dir(\n                        self.template_dir, instance_version\n                    )\n                    template_file = versioned_template_dir / instance_file_name\n\n                if instance_version not in all_versioned_templates.keys():\n                    templates = self._get_templates(versioned_template_dir, readme_validate)\n\n                    all_versioned_templates[instance_version] = dict.fromkeys(\n                        [t.relative_to(versioned_template_dir) for t in templates], False\n                    )\n\n                if instance_file_name in all_versioned_templates[instance_version]:\n                    # validate\n                    drawio_validator = draw_io.DrawIOMetadataValidator(template_file)\n                    status = drawio_validator.validate(instance_file)\n                    if not status:\n                        logger.warning(\n                            f'INVALID: Drawio file {instance_file} failed validation against' + f' {template_file}'\n                        )\n                        return False\n                    else:\n                        logger.info(f'VALID: {instance_file}')\n                    # mark template as present\n                    all_versioned_templates[instance_version][instance_file_name] = True\n\n            else:\n                logger.debug(f'Unsupported extension of the instance file: {instance_file}, will not be validated.')\n\n        # Check that all template files are present\n        for version in all_versioned_templates.keys():\n            for template in all_versioned_templates[version]:\n                if not all_versioned_templates[version][template]:\n                    logger.warning(\n                        f'Required template file {template} does not exist in measured instance' + f'{instance_dir}'\n                    )\n                    return False\n\n        return True\n\n    def _get_templates(self, versioned_template_dir: pathlib.Path, readme_validate: bool) -&gt; List[pathlib.Path]:\n\"\"\"Get templates for the given version.\"\"\"\n        templates = list(\n            filter(\n                lambda p: file_utils.is_local_and_visible(p) and p.is_file()\n                and  # noqa: W504 - conflicting lint and formatting\n                (p.suffix == const.MARKDOWN_FILE_EXT or p.suffix == const.DRAWIO_FILE_EXT),\n                versioned_template_dir.iterdir()\n            )\n        )\n        if not readme_validate:\n            templates = list(filter(lambda p: p.name.lower() != 'readme.md', templates))\n\n        return templates\n\n    def create_sample(self) -&gt; int:\n\"\"\"\n        Create a sample folder within the task and populate with template content.\n\n        Returns:\n            Unix return code for running sample as a command.\n        \"\"\"\n        ii = 0\n        while True:\n            sample_path = self.task_path / f'sample_folder_{ii}'\n            if sample_path.exists():\n                ii = ii + 1\n                continue\n            shutil.copytree(str(self.template_dir), str(sample_path))\n            return CmdReturnCodes.SUCCESS.value\n\n    def validate(\n        self,\n        validate_header: bool,\n        validate_only_header: bool,\n        governed_heading: str,\n        readme_validate: bool,\n        template_version: str,\n        ignore: str\n    ) -&gt; int:\n\"\"\"Validate task.\"\"\"\n        if not self.task_path.is_dir():\n            raise TrestleError(f'Task directory {self.task_path} does not exist. Exiting validate.')\n\n        for task_instance in self.task_path.iterdir():\n            if task_instance.is_dir():\n                if file_utils.is_symlink(task_instance):\n                    continue\n                result = self._measure_template_folder(\n                    task_instance,\n                    validate_header,\n                    validate_only_header,\n                    governed_heading,\n                    readme_validate,\n                    template_version,\n                    ignore\n                )\n                if not result:\n                    raise TrestleError(\n                        'Governed-folder validation failed for task'\n                        + f'{self.task_name} on directory {self.rel_dir(task_instance)}'\n                    )\n            else:\n                logger.info(\n                    f'Unexpected file {self.rel_dir(task_instance)} identified in {self.task_name}'\n                    + ' directory, ignoring.'\n                )\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders.Folders.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders.Folders-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders.Folders.create_sample","title":"<code>create_sample(self)</code>","text":"<p>Create a sample folder within the task and populate with template content.</p> <p>Returns:</p> Type Description <code>int</code> <p>Unix return code for running sample as a command.</p> Source code in <code>trestle/core/commands/author/folders.py</code> <pre><code>def create_sample(self) -&gt; int:\n\"\"\"\n    Create a sample folder within the task and populate with template content.\n\n    Returns:\n        Unix return code for running sample as a command.\n    \"\"\"\n    ii = 0\n    while True:\n        sample_path = self.task_path / f'sample_folder_{ii}'\n        if sample_path.exists():\n            ii = ii + 1\n            continue\n        shutil.copytree(str(self.template_dir), str(sample_path))\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders.Folders.setup_template","title":"<code>setup_template(self, template_version)</code>","text":"<p>Create structure to allow markdown template enforcement.</p> Source code in <code>trestle/core/commands/author/folders.py</code> <pre><code>def setup_template(self, template_version: str) -&gt; int:\n\"\"\"Create structure to allow markdown template enforcement.\"\"\"\n    if not self.task_path.exists():\n        self.task_path.mkdir(exist_ok=True, parents=True)\n    elif self.task_path.is_file():\n        raise TrestleError(f'Task path: {self.rel_dir(self.task_path)} is a file not a directory.')\n    if not self.template_dir.exists():\n        self.template_dir.mkdir(exist_ok=True, parents=True)\n    elif self.template_dir.is_file():\n        raise TrestleError(f'Template path: {self.rel_dir(self.template_dir)} is a file not a directory.')\n\n    template_file_a_md = self.template_dir / 'a_template.md'\n    template_file_another_md = self.template_dir / 'another_template.md'\n    template_file_drawio = self.template_dir / 'architecture.drawio'\n    TemplateVersioning.write_versioned_template(\n        'template.md', self.template_dir, template_file_a_md, template_version\n    )\n    TemplateVersioning.write_versioned_template(\n        'template.md', self.template_dir, template_file_another_md, template_version\n    )\n    TemplateVersioning.write_versioned_template(\n        'template.drawio', self.template_dir, template_file_drawio, template_version\n    )\n\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders.Folders.template_validate","title":"<code>template_validate(self, validate_header, validate_only_header, heading, readme_validate)</code>","text":"<p>Validate that the template is acceptable markdown.</p> Source code in <code>trestle/core/commands/author/folders.py</code> <pre><code>def template_validate(\n    self, validate_header: bool, validate_only_header: bool, heading: str, readme_validate: bool\n) -&gt; int:\n\"\"\"Validate that the template is acceptable markdown.\"\"\"\n    if not self.template_dir.is_dir():\n        raise TrestleError(\n            f'Template directory {self.rel_dir(self.template_dir)} for task {self.task_name} does not exist.'\n        )\n    # get list of files:\n    template_files = self.template_dir.rglob('*')\n\n    for template_file in template_files:\n        try:\n            if not file_utils.is_local_and_visible(template_file):\n                continue\n            elif template_file.is_dir():\n                continue\n            elif template_file.suffix.lower() == const.MARKDOWN_FILE_EXT:\n                if not readme_validate and template_file.name == 'readme.md':\n                    raise TrestleError('Template directory contains a readme.md file and readme validation is off.')\n\n                md_api = MarkdownAPI()\n                md_api.load_validator_with_template(\n                    template_file, validate_header, not validate_only_header, heading\n                )\n            elif template_file.suffix.lower().lstrip('.') == 'drawio':\n                _ = draw_io.DrawIOMetadataValidator(template_file)\n            else:\n                logger.info(\n                    f'File: {self.rel_dir(template_file)} within the template directory was ignored'\n                    + ' as it is not markdown.'\n                )\n        except Exception as ex:\n            raise TrestleError(\n                f'Template file {self.rel_dir(template_file)} for task {self.task_name}'\n                + f' failed to validate due to {ex}'\n            )\n    logger.info(f'TEMPLATES VALID: {self.task_name}.')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.folders/#trestle.core.commands.author.folders.Folders.validate","title":"<code>validate(self, validate_header, validate_only_header, governed_heading, readme_validate, template_version, ignore)</code>","text":"<p>Validate task.</p> Source code in <code>trestle/core/commands/author/folders.py</code> <pre><code>def validate(\n    self,\n    validate_header: bool,\n    validate_only_header: bool,\n    governed_heading: str,\n    readme_validate: bool,\n    template_version: str,\n    ignore: str\n) -&gt; int:\n\"\"\"Validate task.\"\"\"\n    if not self.task_path.is_dir():\n        raise TrestleError(f'Task directory {self.task_path} does not exist. Exiting validate.')\n\n    for task_instance in self.task_path.iterdir():\n        if task_instance.is_dir():\n            if file_utils.is_symlink(task_instance):\n                continue\n            result = self._measure_template_folder(\n                task_instance,\n                validate_header,\n                validate_only_header,\n                governed_heading,\n                readme_validate,\n                template_version,\n                ignore\n            )\n            if not result:\n                raise TrestleError(\n                    'Governed-folder validation failed for task'\n                    + f'{self.task_name} on directory {self.rel_dir(task_instance)}'\n                )\n        else:\n            logger.info(\n                f'Unexpected file {self.rel_dir(task_instance)} identified in {self.task_name}'\n                + ' directory, ignoring.'\n            )\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.headers/","title":"headers","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers","title":"<code>trestle.core.commands.author.headers</code>","text":"<p>Trestle author headers command.</p>"},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers.Headers","title":"<code> Headers            (AuthorCommonCommand)         </code>","text":"<p>Enforce header / metadata across file types supported by author (markdown and drawio).</p> Source code in <code>trestle/core/commands/author/headers.py</code> <pre><code>class Headers(AuthorCommonCommand):\n\"\"\"Enforce header / metadata across file types supported by author (markdown and drawio).\"\"\"\n\n    name = 'headers'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument(\n            author_const.RECURSE_SHORT, author_const.RECURSE_LONG, help=author_const.RECURSE_HELP, action='store_true'\n        )\n        self.add_argument(author_const.MODE_ARG_NAME, choices=author_const.MODE_CHOICES)\n        tn_help_str = '\\n'.join(\n            [\n                'The name of the the task to be governed.',\n                '',\n                'The template files for header metadata governance are located at .trestle/author/[task name]',\n                'Currently supported types are:',\n                'Markdown: .trestle/author/[task name]/template.md',\n                'Drawio: .trestle/author/[task name]/template.drawio',\n                '',\n                'Note that by default this will automatically enforce the task.'\n            ]\n        )\n        self.add_argument(\n            author_const.TASK_NAME_SHORT, author_const.TASK_NAME_LONG, help=tn_help_str, type=str, default=None\n        )\n        self.add_argument(\n            author_const.SHORT_README_VALIDATE,\n            author_const.LONG_README_VALIDATE,\n            help=author_const.README_VALIDATE_HELP,\n            action='store_true'\n        )\n        self.add_argument(\n            author_const.SHORT_TEMPLATE_VERSION,\n            author_const.LONG_TEMPLATE_VERSION,\n            help=author_const.TEMPLATE_VERSION_HELP,\n            action='store'\n        )\n        self.add_argument(\n            author_const.SHORT_IGNORE, author_const.LONG_IGNORE, help=author_const.IGNORE_HELP, default=None, type=str\n        )\n        self.add_argument(\n            author_const.GLOBAL_SHORT, author_const.GLOBAL_LONG, help=author_const.GLOBAL_HELP, action='store_true'\n        )\n        self.add_argument(\n            author_const.EXCLUDE_SHORT,\n            author_const.EXCLUDE_LONG,\n            help=author_const.EXCLUDE_HELP,\n            type=pathlib.Path,\n            nargs='*',\n            default=None\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            status = 1\n            if self._initialize(args):\n                return status\n            # Handle conditional requirement of args.task_name\n            # global is special so we need to use get attribute.\n            if not self.global_ and not self.task_name:\n                logger.warning('Task name (-tn) argument is required when global is not specified')\n                return status\n\n            if args.exclude:\n                logger.warning('--exclude or -e is deprecated, use --ignore instead.')\n\n            if args.mode == 'create-sample':\n                status = self.create_sample()\n\n            elif args.mode == 'template-validate':\n                status = self.template_validate()\n            elif args.mode == 'setup':\n                status = self.setup(args.template_version)\n            elif args.mode == 'validate':\n                exclusions = []\n                if args.exclude:\n                    exclusions = args.exclude\n                # mode is validate\n                status = self.validate(\n                    args.recurse, args.readme_validate, exclusions, args.template_version, args.ignore\n                )\n            return status\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error occurred when running trestle author headers')\n\n    def create_sample(self) -&gt; int:\n\"\"\"Create sample object, this always defaults to markdown.\"\"\"\n        logger.info('Header only validation does not support sample creation.')\n        logger.info('Exiting')\n        return CmdReturnCodes.SUCCESS.value\n\n    def setup(self, template_version: str) -&gt; int:\n\"\"\"Create template directory and templates.\"\"\"\n        # Step 1 - validation\n\n        if self.task_name and not self.task_path.exists():\n            self.task_path.mkdir(exist_ok=True, parents=True)\n        elif self.task_name and self.task_path.is_file():\n            raise TrestleError(f'Task path: {self.rel_dir(self.task_path)} is a file not a directory.')\n\n        if not self.template_dir.exists():\n            self.template_dir.mkdir(exist_ok=True, parents=True)\n        logger.info(f'Populating template files to {self.rel_dir(self.template_dir)}')\n        for template in author_const.REFERENCE_TEMPLATES.values():\n            destination_path = self.template_dir / template\n            TemplateVersioning.write_versioned_template(template, self.template_dir, destination_path, template_version)\n\n            logger.info(f'Template directory populated {self.rel_dir(destination_path)}')\n        return CmdReturnCodes.SUCCESS.value\n\n    def template_validate(self) -&gt; int:\n\"\"\"Validate the integrity of the template files.\"\"\"\n        logger.info('Checking template file integrity')\n        for template_file in self.template_dir.iterdir():\n            if (template_file.name not in author_const.REFERENCE_TEMPLATES.values()\n                    and template_file.name.lower() != 'readme.md'):\n                raise TrestleError(f'Unexpected template file {self.rel_dir(template_file)}')\n\n            if template_file.suffix == const.MARKDOWN_FILE_EXT:\n                try:\n                    md_api = MarkdownAPI()\n                    md_api.load_validator_with_template(template_file, True, False)\n                except Exception as ex:\n                    raise TrestleError(f'Template for task {self.task_name} failed to validate due to {ex}')\n\n            elif template_file.suffix == const.DRAWIO_FILE_EXT:\n                try:\n                    _ = DrawIOMetadataValidator(template_file)\n                except Exception as ex:\n                    raise TrestleError(f'Template for task {self.task_name} failed to validate due to {ex}')\n\n        logger.info('Templates validated')\n        return CmdReturnCodes.SUCCESS.value\n\n    def _validate_dir(\n        self,\n        candidate_dir: pathlib.Path,\n        recurse: bool,\n        readme_validate: bool,\n        relative_exclusions: List[pathlib.Path],\n        template_version: str,\n        ignore: str\n    ) -&gt; bool:\n\"\"\"Validate a directory within the trestle workspace.\"\"\"\n        all_versioned_templates = {}\n        instance_version = template_version\n        instance_file_names: List[pathlib.Path] = []\n        # Fetch all instances versions and build dictionary of required template files\n        instances = list(candidate_dir.iterdir())\n        if recurse:\n            instances = candidate_dir.rglob('*')\n            if ignore:\n                p = re.compile(ignore)\n                instances = list(\n                    filter(\n                        lambda f: len(list(filter(p.match, str(f.relative_to(candidate_dir)).split('/')))) == 0,\n                        instances\n                    )\n                )\n        for instance_file in instances:\n            if not file_utils.is_local_and_visible(instance_file):\n                continue\n            if instance_file.name.lower() == 'readme.md' and not readme_validate:\n                continue\n            if instance_file.is_dir() and not recurse:\n                continue\n            if any(str(ex) in str(instance_file) for ex in relative_exclusions):\n                continue\n            if ignore:\n                p = re.compile(ignore)\n                matched = p.match(instance_file.parts[-1])\n                if matched is not None:\n                    logger.info(f'Ignoring file {instance_file} from validation.')\n                    continue\n            instance_file_name = instance_file.relative_to(candidate_dir)\n            instance_file_names.append(instance_file_name)\n            if instance_file.suffix == const.MARKDOWN_FILE_EXT:\n                md_api = MarkdownAPI()\n                versioned_template_dir = None\n                if template_version != '':\n                    versioned_template_dir = self.template_dir\n                else:\n                    instance_version = md_api.processor.fetch_value_from_header(\n                        instance_file, author_const.TEMPLATE_VERSION_HEADER\n                    )\n                    if instance_version is None:\n                        instance_version = '0.0.1'  # backward compatibility\n                    versioned_template_dir = TemplateVersioning.get_versioned_template_dir(\n                        self.template_dir, instance_version\n                    )\n\n                if instance_version not in all_versioned_templates.keys():\n                    templates = list(\n                        filter(lambda p: file_utils.is_local_and_visible(p), versioned_template_dir.iterdir())\n                    )\n                    if not readme_validate:\n                        templates = list(filter(lambda p: p.name.lower() != 'readme.md', templates))\n                    self._update_templates(all_versioned_templates, templates, instance_version)\n\n                # validate\n                md_api.load_validator_with_template(all_versioned_templates[instance_version]['md'], True, False)\n                status = md_api.validate_instance(instance_file)\n                if not status:\n                    logger.info(f'INVALID: {self.rel_dir(instance_file)}')\n                    return False\n                else:\n                    logger.info(f'VALID: {self.rel_dir(instance_file)}')\n\n            elif instance_file.suffix == const.DRAWIO_FILE_EXT:\n                drawio = DrawIO(instance_file)\n                metadata = drawio.get_metadata()[0]\n\n                versioned_template_dir = None\n                if template_version != '':\n                    versioned_template_dir = self.template_dir\n                else:\n                    if author_const.TEMPLATE_VERSION_HEADER in metadata.keys():\n                        instance_version = metadata[author_const.TEMPLATE_VERSION_HEADER]\n                    else:\n                        instance_version = '0.0.1'  # backward compatibility\n\n                    versioned_template_dir = TemplateVersioning.get_versioned_template_dir(\n                        self.template_dir, instance_version\n                    )\n\n                if instance_version not in all_versioned_templates.keys():\n                    templates = list(\n                        filter(lambda p: file_utils.is_local_and_visible(p), versioned_template_dir.iterdir())\n                    )\n                    if not readme_validate:\n                        templates = list(filter(lambda p: p.name.lower() != 'readme.md', templates))\n                    self._update_templates(all_versioned_templates, templates, instance_version)\n\n                # validate\n                drawio_validator = DrawIOMetadataValidator(all_versioned_templates[instance_version]['drawio'])\n                status = drawio_validator.validate(instance_file)\n                if not status:\n                    logger.info(f'INVALID: {self.rel_dir(instance_file)}')\n                    return False\n                else:\n                    logger.info(f'VALID: {self.rel_dir(instance_file)}')\n\n            else:\n                logger.debug(f'Unsupported extension of the instance file: {instance_file}, will not be validated.')\n\n        return True\n\n    def _update_templates(\n        self, all_versioned_templates: Dict[str, Dict[str, str]], templates: List[str], instance_version: str\n    ):\n        all_versioned_templates[instance_version] = {}\n        all_drawio_templates = list(filter(lambda p: p.suffix == const.DRAWIO_FILE_EXT, templates))\n        all_md_templates = list(filter(lambda p: p.suffix == const.MARKDOWN_FILE_EXT, templates))\n        if all_drawio_templates:\n            all_versioned_templates[instance_version]['drawio'] = all_drawio_templates[0]\n        if all_md_templates:\n            all_versioned_templates[instance_version]['md'] = all_md_templates[0]\n\n    def validate(\n        self,\n        recurse: bool,\n        readme_validate: bool,\n        relative_excludes: List[pathlib.Path],\n        template_version: str,\n        ignore: str\n    ) -&gt; int:\n\"\"\"Run validation based on available templates.\"\"\"\n        paths = []\n        if self.task_name:\n            if not self.task_path.is_dir():\n                raise TrestleError(f'Task directory {self.rel_dir(self.task_path)} does not exist. Exiting validate.')\n\n            paths = [self.task_path]\n        else:\n            for path in self.trestle_root.iterdir():\n                relative_path = path.relative_to(self.trestle_root)\n                # Files in the root directory must be exclused\n                if path.is_file():\n                    continue\n                if not file_utils.is_directory_name_allowed(path):\n                    continue\n                if str(relative_path).rstrip('/') in const.MODEL_DIR_LIST:\n                    continue\n                if (relative_path in relative_excludes):\n                    continue\n                if not file_utils.is_hidden(path):\n                    paths.append(path)\n\n        for path in paths:\n            try:\n                valid = self._validate_dir(path, recurse, readme_validate, relative_excludes, template_version, ignore)\n                if not valid:\n                    logger.info(f'validation failed on {path}')\n                    return CmdReturnCodes.DOCUMENTS_VALIDATION_ERROR.value\n            except Exception as e:\n                raise TrestleError(f'Error during header validation on {path} {e}')\n\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers.Headers.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers.Headers-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers.Headers.create_sample","title":"<code>create_sample(self)</code>","text":"<p>Create sample object, this always defaults to markdown.</p> Source code in <code>trestle/core/commands/author/headers.py</code> <pre><code>def create_sample(self) -&gt; int:\n\"\"\"Create sample object, this always defaults to markdown.\"\"\"\n    logger.info('Header only validation does not support sample creation.')\n    logger.info('Exiting')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers.Headers.setup","title":"<code>setup(self, template_version)</code>","text":"<p>Create template directory and templates.</p> Source code in <code>trestle/core/commands/author/headers.py</code> <pre><code>def setup(self, template_version: str) -&gt; int:\n\"\"\"Create template directory and templates.\"\"\"\n    # Step 1 - validation\n\n    if self.task_name and not self.task_path.exists():\n        self.task_path.mkdir(exist_ok=True, parents=True)\n    elif self.task_name and self.task_path.is_file():\n        raise TrestleError(f'Task path: {self.rel_dir(self.task_path)} is a file not a directory.')\n\n    if not self.template_dir.exists():\n        self.template_dir.mkdir(exist_ok=True, parents=True)\n    logger.info(f'Populating template files to {self.rel_dir(self.template_dir)}')\n    for template in author_const.REFERENCE_TEMPLATES.values():\n        destination_path = self.template_dir / template\n        TemplateVersioning.write_versioned_template(template, self.template_dir, destination_path, template_version)\n\n        logger.info(f'Template directory populated {self.rel_dir(destination_path)}')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers.Headers.template_validate","title":"<code>template_validate(self)</code>","text":"<p>Validate the integrity of the template files.</p> Source code in <code>trestle/core/commands/author/headers.py</code> <pre><code>def template_validate(self) -&gt; int:\n\"\"\"Validate the integrity of the template files.\"\"\"\n    logger.info('Checking template file integrity')\n    for template_file in self.template_dir.iterdir():\n        if (template_file.name not in author_const.REFERENCE_TEMPLATES.values()\n                and template_file.name.lower() != 'readme.md'):\n            raise TrestleError(f'Unexpected template file {self.rel_dir(template_file)}')\n\n        if template_file.suffix == const.MARKDOWN_FILE_EXT:\n            try:\n                md_api = MarkdownAPI()\n                md_api.load_validator_with_template(template_file, True, False)\n            except Exception as ex:\n                raise TrestleError(f'Template for task {self.task_name} failed to validate due to {ex}')\n\n        elif template_file.suffix == const.DRAWIO_FILE_EXT:\n            try:\n                _ = DrawIOMetadataValidator(template_file)\n            except Exception as ex:\n                raise TrestleError(f'Template for task {self.task_name} failed to validate due to {ex}')\n\n    logger.info('Templates validated')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.headers/#trestle.core.commands.author.headers.Headers.validate","title":"<code>validate(self, recurse, readme_validate, relative_excludes, template_version, ignore)</code>","text":"<p>Run validation based on available templates.</p> Source code in <code>trestle/core/commands/author/headers.py</code> <pre><code>def validate(\n    self,\n    recurse: bool,\n    readme_validate: bool,\n    relative_excludes: List[pathlib.Path],\n    template_version: str,\n    ignore: str\n) -&gt; int:\n\"\"\"Run validation based on available templates.\"\"\"\n    paths = []\n    if self.task_name:\n        if not self.task_path.is_dir():\n            raise TrestleError(f'Task directory {self.rel_dir(self.task_path)} does not exist. Exiting validate.')\n\n        paths = [self.task_path]\n    else:\n        for path in self.trestle_root.iterdir():\n            relative_path = path.relative_to(self.trestle_root)\n            # Files in the root directory must be exclused\n            if path.is_file():\n                continue\n            if not file_utils.is_directory_name_allowed(path):\n                continue\n            if str(relative_path).rstrip('/') in const.MODEL_DIR_LIST:\n                continue\n            if (relative_path in relative_excludes):\n                continue\n            if not file_utils.is_hidden(path):\n                paths.append(path)\n\n    for path in paths:\n        try:\n            valid = self._validate_dir(path, recurse, readme_validate, relative_excludes, template_version, ignore)\n            if not valid:\n                logger.info(f'validation failed on {path}')\n                return CmdReturnCodes.DOCUMENTS_VALIDATION_ERROR.value\n        except Exception as e:\n            raise TrestleError(f'Error during header validation on {path} {e}')\n\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.jinja/","title":"jinja","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja","title":"<code>trestle.core.commands.author.jinja</code>","text":"<p>Trestle Commands.</p>"},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja.JinjaCmd","title":"<code> JinjaCmd            (CommandPlusDocs)         </code>","text":"<p>Transform an input template to an output document using jinja templating.</p> Source code in <code>trestle/core/commands/author/jinja.py</code> <pre><code>class JinjaCmd(CommandPlusDocs):\n\"\"\"Transform an input template to an output document using jinja templating.\"\"\"\n\n    max_recursion_depth = 2\n\n    name = 'jinja'\n\n    def _init_arguments(self):\n        self.add_argument('-i', '--input', help='Input jinja template, relative to trestle root', required=True)\n        self.add_argument('-o', '--output', help='Output template, relative to trestle root.', required=True)\n        self.add_argument(\n            '-lut',\n            '--look-up-table',\n            help='Key-value pair table, stored as yaml, to be passed to jinja as variables',\n            required=False\n        )\n        self.add_argument(\n            '-elp',\n            '--external-lut-prefix',\n            help='Prefix paths for LUT, to maintain compatibility with other templating systems',\n            required=False\n        )\n        self.add_argument(\n            '-nc',\n            '--number-captions',\n            help='Add incremental numbering to table and image captions, in the form Table n - ... and Figure n - ...',\n            action='store_true'\n        )\n        self.add_argument(\n            '-bf',\n            '--bracket-format',\n            help='With -sv, allows brackets around value, e.g. [.] or ((.)), with the dot representing the value.',\n            required=False\n        )\n        self.add_argument(\n            '-vap',\n            '--value-assigned-prefix',\n            help='Places a prefix in front of the parameter string if a value has been assigned.',\n            required=False,\n            type=str,\n            default=''\n        )\n        self.add_argument(\n            '-vnap',\n            '--value-not-assigned-prefix',\n            help='Places a prefix in front of the parameter string if a value has *not* been assigned.',\n            required=False,\n            type=str,\n            default=''\n        )\n        self.add_argument(\n            '-ssp', '--system-security-plan', help='An optional SSP to be passed', default=None, required=False\n        )\n        self.add_argument('-p', '--profile', help='An optional profile to be passed', default=None, required=False)\n        self.add_argument(\n            '-dp',\n            '--docs-profile',\n            help='Output profile controls to separate markdown files',\n            action='store_true',\n            required=False\n        )\n\n    def _run(self, args: argparse.Namespace):\n        try:\n            log.set_log_level_from_args(args)\n            logger.debug(f'Starting {self.name} command')\n            input_path = pathlib.Path(args.input)\n            output_path = pathlib.Path(args.output)\n            if args.system_security_plan and args.docs_profile:\n                raise TrestleIncorrectArgsError('Output to multiple files is possible with profile only.')\n\n            if args.docs_profile and not args.profile:\n                raise TrestleIncorrectArgsError('Profile must be provided to output to multiple files.')\n\n            lut = {}\n            if args.look_up_table:\n                lut_table = pathlib.Path(args.look_up_table)\n                lookup_table_path = pathlib.Path.cwd() / lut_table\n                lut = JinjaCmd.load_LUT(lookup_table_path, args.external_lut_prefix)\n\n            if args.system_security_plan:\n                return JinjaCmd.jinja_ify(\n                    pathlib.Path(args.trestle_root),\n                    input_path,\n                    output_path,\n                    args.system_security_plan,\n                    args.profile,\n                    lut,\n                    number_captions=args.number_captions,\n                    parameters_formatting=args.bracket_format,\n                    value_assigned_prefix=args.value_assigned_prefix,\n                    value_not_assigned_prefix=args.value_not_assigned_prefix\n                )\n            elif args.profile and args.docs_profile:\n                return JinjaCmd.jinja_multiple_md(\n                    pathlib.Path(args.trestle_root),\n                    input_path,\n                    output_path,\n                    args.profile,\n                    lut,\n                    parameters_formatting=args.bracket_format,\n                    value_assigned_prefix=args.value_assigned_prefix,\n                    value_not_assigned_prefix=args.value_not_assigned_prefix\n                )\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while generating markdown via Jinja template')\n\n    @staticmethod\n    def load_LUT(path: pathlib.Path, prefix: Optional[str]) -&gt; Dict[str, Any]:  # noqa: N802\n\"\"\"Load a Yaml lookup table from file.\"\"\"\n        yaml = YAML()\n        lut = yaml.load(path.open('r', encoding=const.FILE_ENCODING))\n        if prefix:\n            prefixes = prefix.split('.')\n            while prefixes:\n                old_lut = lut\n                lut[prefixes.pop(-1)] = old_lut\n\n        return lut\n\n    @staticmethod\n    def jinja_ify(\n        trestle_root: pathlib.Path,\n        r_input_file: pathlib.Path,\n        r_output_file: pathlib.Path,\n        ssp: Optional[str],\n        profile: Optional[str],\n        lut: Dict[str, Any],\n        number_captions: Optional[bool] = False,\n        parameters_formatting: Optional[str] = None,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; int:\n\"\"\"Run jinja over an input file with additional booleans.\"\"\"\n        template_folder = pathlib.Path.cwd()\n        jinja_env = Environment(\n            loader=FileSystemLoader(template_folder),\n            extensions=[MDSectionInclude, MDCleanInclude, MDDatestamp],\n            trim_blocks=True,\n            autoescape=True\n        )\n        template = jinja_env.get_template(str(r_input_file))\n        # create boolean dict\n        if operator.xor(bool(ssp), bool(profile)):\n            raise TrestleIncorrectArgsError('Both SSP and profile should be provided or not at all')\n\n        if ssp:\n            # name lookup\n            ssp_data, _ = load_validate_model_name(trestle_root, ssp, SystemSecurityPlan)\n            lut['ssp'] = ssp_data\n            profile_path = ModelUtils.get_model_path_for_name_and_class(trestle_root, profile, Profile)\n            profile_resolver = ProfileResolver()\n            resolved_catalog = profile_resolver.get_resolved_profile_catalog(\n                trestle_root,\n                profile_path,\n                False,\n                False,\n                parameters_formatting,\n                ParameterRep.ASSIGNMENT_FORM,\n                False,\n                value_assigned_prefix,\n                value_not_assigned_prefix\n            )\n\n            ssp_writer = SSPMarkdownWriter(trestle_root)\n            ssp_writer.set_ssp(ssp_data)\n            ssp_writer.set_catalog(resolved_catalog)\n            lut['catalog'] = resolved_catalog\n            lut['catalog_interface'] = CatalogInterface(resolved_catalog)\n            lut['control_interface'] = ControlInterface()\n            lut['control_writer'] = DocsControlWriter()\n            lut['ssp_md_writer'] = ssp_writer\n\n            output = JinjaCmd.render_template(template, lut, template_folder)\n\n            output_file = trestle_root / r_output_file\n            if number_captions:\n                output_file.open('w', encoding=const.FILE_ENCODING).write(_number_captions(output))\n            else:\n                output_file.open('w', encoding=const.FILE_ENCODING).write(output)\n\n            return CmdReturnCodes.SUCCESS.value\n\n    @staticmethod\n    def jinja_multiple_md(\n        trestle_root: pathlib.Path,\n        r_input_file: pathlib.Path,\n        r_output_file: pathlib.Path,\n        profile_name: Optional[str],\n        lut: Dict[str, Any],\n        parameters_formatting: Optional[str] = None,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; int:\n\"\"\"Output profile as multiple markdown files using Jinja.\"\"\"\n        template_folder = pathlib.Path.cwd()\n\n        # Output to multiple markdown files\n        profile, profile_path = ModelUtils.load_model_for_class(trestle_root, profile_name, Profile)\n        profile_resolver = ProfileResolver()\n        resolved_catalog = profile_resolver.get_resolved_profile_catalog(\n            trestle_root,\n            profile_path,\n            False,\n            False,\n            parameters_formatting,\n            ParameterRep.ASSIGNMENT_FORM,\n            False,\n            value_assigned_prefix,\n            value_not_assigned_prefix\n        )\n        catalog_interface = CatalogInterface(resolved_catalog)\n\n        # Generate a single markdown page for each control per each group\n        for group in catalog_interface.get_all_groups_from_catalog():\n            for control in catalog_interface.get_sorted_controls_in_group(group.id):\n                _, group_title, _ = catalog_interface.get_group_info_by_control(control.id)\n                group_dir = r_output_file\n                control_path = catalog_interface.get_control_path(control.id)\n                for sub_dir in control_path:\n                    group_dir = group_dir / sub_dir\n                    if not group_dir.exists():\n                        group_dir.mkdir(parents=True, exist_ok=True)\n\n                control_writer = DocsControlWriter()\n\n                jinja_env = Environment(\n                    loader=FileSystemLoader(template_folder),\n                    extensions=[MDSectionInclude, MDCleanInclude, MDDatestamp],\n                    trim_blocks=True,\n                    autoescape=True\n                )\n                template = jinja_env.get_template(str(r_input_file))\n                lut['catalog_interface'] = catalog_interface\n                lut['control_interface'] = ControlInterface()\n                lut['control_writer'] = control_writer\n                lut['control'] = control\n                lut['profile'] = profile\n                lut['group_title'] = group_title\n                output = JinjaCmd.render_template(template, lut, template_folder)\n\n                output_file = trestle_root / group_dir / pathlib.Path(control.id + const.MARKDOWN_FILE_EXT)\n                output_file.open('w', encoding=const.FILE_ENCODING).write(output)\n\n        return CmdReturnCodes.SUCCESS.value\n\n    @staticmethod\n    def render_template(template: Template, lut: Dict[str, Any], template_folder: pathlib.Path) -&gt; str:\n\"\"\"Render template.\"\"\"\n        new_output = template.render(**lut)\n        output = ''\n        # This recursion allows nesting within expressions (e.g. an expression can contain jinja templates).\n        error_countdown = JinjaCmd.max_recursion_depth\n        while new_output != output and error_countdown &gt; 0:\n            error_countdown = error_countdown - 1\n            output = new_output\n            random_name = uuid.uuid4()  # Should be random and not used.\n            dict_loader = DictLoader({str(random_name): new_output})\n            jinja_env = Environment(\n                loader=ChoiceLoader([dict_loader, FileSystemLoader(template_folder)]),\n                extensions=[MDCleanInclude, MDSectionInclude, MDDatestamp],\n                autoescape=True,\n                trim_blocks=True\n            )\n            template = jinja_env.get_template(str(random_name))\n            new_output = template.render(**lut)\n\n        return output\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja.JinjaCmd.max_recursion_depth","title":"<code>max_recursion_depth</code>","text":""},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja.JinjaCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja.JinjaCmd-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja.JinjaCmd.jinja_ify","title":"<code>jinja_ify(trestle_root, r_input_file, r_output_file, ssp, profile, lut, number_captions=False, parameters_formatting=None, value_assigned_prefix=None, value_not_assigned_prefix=None)</code>  <code>staticmethod</code>","text":"<p>Run jinja over an input file with additional booleans.</p> Source code in <code>trestle/core/commands/author/jinja.py</code> <pre><code>@staticmethod\ndef jinja_ify(\n    trestle_root: pathlib.Path,\n    r_input_file: pathlib.Path,\n    r_output_file: pathlib.Path,\n    ssp: Optional[str],\n    profile: Optional[str],\n    lut: Dict[str, Any],\n    number_captions: Optional[bool] = False,\n    parameters_formatting: Optional[str] = None,\n    value_assigned_prefix: Optional[str] = None,\n    value_not_assigned_prefix: Optional[str] = None\n) -&gt; int:\n\"\"\"Run jinja over an input file with additional booleans.\"\"\"\n    template_folder = pathlib.Path.cwd()\n    jinja_env = Environment(\n        loader=FileSystemLoader(template_folder),\n        extensions=[MDSectionInclude, MDCleanInclude, MDDatestamp],\n        trim_blocks=True,\n        autoescape=True\n    )\n    template = jinja_env.get_template(str(r_input_file))\n    # create boolean dict\n    if operator.xor(bool(ssp), bool(profile)):\n        raise TrestleIncorrectArgsError('Both SSP and profile should be provided or not at all')\n\n    if ssp:\n        # name lookup\n        ssp_data, _ = load_validate_model_name(trestle_root, ssp, SystemSecurityPlan)\n        lut['ssp'] = ssp_data\n        profile_path = ModelUtils.get_model_path_for_name_and_class(trestle_root, profile, Profile)\n        profile_resolver = ProfileResolver()\n        resolved_catalog = profile_resolver.get_resolved_profile_catalog(\n            trestle_root,\n            profile_path,\n            False,\n            False,\n            parameters_formatting,\n            ParameterRep.ASSIGNMENT_FORM,\n            False,\n            value_assigned_prefix,\n            value_not_assigned_prefix\n        )\n\n        ssp_writer = SSPMarkdownWriter(trestle_root)\n        ssp_writer.set_ssp(ssp_data)\n        ssp_writer.set_catalog(resolved_catalog)\n        lut['catalog'] = resolved_catalog\n        lut['catalog_interface'] = CatalogInterface(resolved_catalog)\n        lut['control_interface'] = ControlInterface()\n        lut['control_writer'] = DocsControlWriter()\n        lut['ssp_md_writer'] = ssp_writer\n\n        output = JinjaCmd.render_template(template, lut, template_folder)\n\n        output_file = trestle_root / r_output_file\n        if number_captions:\n            output_file.open('w', encoding=const.FILE_ENCODING).write(_number_captions(output))\n        else:\n            output_file.open('w', encoding=const.FILE_ENCODING).write(output)\n\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja.JinjaCmd.jinja_multiple_md","title":"<code>jinja_multiple_md(trestle_root, r_input_file, r_output_file, profile_name, lut, parameters_formatting=None, value_assigned_prefix=None, value_not_assigned_prefix=None)</code>  <code>staticmethod</code>","text":"<p>Output profile as multiple markdown files using Jinja.</p> Source code in <code>trestle/core/commands/author/jinja.py</code> <pre><code>@staticmethod\ndef jinja_multiple_md(\n    trestle_root: pathlib.Path,\n    r_input_file: pathlib.Path,\n    r_output_file: pathlib.Path,\n    profile_name: Optional[str],\n    lut: Dict[str, Any],\n    parameters_formatting: Optional[str] = None,\n    value_assigned_prefix: Optional[str] = None,\n    value_not_assigned_prefix: Optional[str] = None\n) -&gt; int:\n\"\"\"Output profile as multiple markdown files using Jinja.\"\"\"\n    template_folder = pathlib.Path.cwd()\n\n    # Output to multiple markdown files\n    profile, profile_path = ModelUtils.load_model_for_class(trestle_root, profile_name, Profile)\n    profile_resolver = ProfileResolver()\n    resolved_catalog = profile_resolver.get_resolved_profile_catalog(\n        trestle_root,\n        profile_path,\n        False,\n        False,\n        parameters_formatting,\n        ParameterRep.ASSIGNMENT_FORM,\n        False,\n        value_assigned_prefix,\n        value_not_assigned_prefix\n    )\n    catalog_interface = CatalogInterface(resolved_catalog)\n\n    # Generate a single markdown page for each control per each group\n    for group in catalog_interface.get_all_groups_from_catalog():\n        for control in catalog_interface.get_sorted_controls_in_group(group.id):\n            _, group_title, _ = catalog_interface.get_group_info_by_control(control.id)\n            group_dir = r_output_file\n            control_path = catalog_interface.get_control_path(control.id)\n            for sub_dir in control_path:\n                group_dir = group_dir / sub_dir\n                if not group_dir.exists():\n                    group_dir.mkdir(parents=True, exist_ok=True)\n\n            control_writer = DocsControlWriter()\n\n            jinja_env = Environment(\n                loader=FileSystemLoader(template_folder),\n                extensions=[MDSectionInclude, MDCleanInclude, MDDatestamp],\n                trim_blocks=True,\n                autoescape=True\n            )\n            template = jinja_env.get_template(str(r_input_file))\n            lut['catalog_interface'] = catalog_interface\n            lut['control_interface'] = ControlInterface()\n            lut['control_writer'] = control_writer\n            lut['control'] = control\n            lut['profile'] = profile\n            lut['group_title'] = group_title\n            output = JinjaCmd.render_template(template, lut, template_folder)\n\n            output_file = trestle_root / group_dir / pathlib.Path(control.id + const.MARKDOWN_FILE_EXT)\n            output_file.open('w', encoding=const.FILE_ENCODING).write(output)\n\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja.JinjaCmd.load_LUT","title":"<code>load_LUT(path, prefix)</code>  <code>staticmethod</code>","text":"<p>Load a Yaml lookup table from file.</p> Source code in <code>trestle/core/commands/author/jinja.py</code> <pre><code>@staticmethod\ndef load_LUT(path: pathlib.Path, prefix: Optional[str]) -&gt; Dict[str, Any]:  # noqa: N802\n\"\"\"Load a Yaml lookup table from file.\"\"\"\n    yaml = YAML()\n    lut = yaml.load(path.open('r', encoding=const.FILE_ENCODING))\n    if prefix:\n        prefixes = prefix.split('.')\n        while prefixes:\n            old_lut = lut\n            lut[prefixes.pop(-1)] = old_lut\n\n    return lut\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.jinja/#trestle.core.commands.author.jinja.JinjaCmd.render_template","title":"<code>render_template(template, lut, template_folder)</code>  <code>staticmethod</code>","text":"<p>Render template.</p> Source code in <code>trestle/core/commands/author/jinja.py</code> <pre><code>@staticmethod\ndef render_template(template: Template, lut: Dict[str, Any], template_folder: pathlib.Path) -&gt; str:\n\"\"\"Render template.\"\"\"\n    new_output = template.render(**lut)\n    output = ''\n    # This recursion allows nesting within expressions (e.g. an expression can contain jinja templates).\n    error_countdown = JinjaCmd.max_recursion_depth\n    while new_output != output and error_countdown &gt; 0:\n        error_countdown = error_countdown - 1\n        output = new_output\n        random_name = uuid.uuid4()  # Should be random and not used.\n        dict_loader = DictLoader({str(random_name): new_output})\n        jinja_env = Environment(\n            loader=ChoiceLoader([dict_loader, FileSystemLoader(template_folder)]),\n            extensions=[MDCleanInclude, MDSectionInclude, MDDatestamp],\n            autoescape=True,\n            trim_blocks=True\n        )\n        template = jinja_env.get_template(str(random_name))\n        new_output = template.render(**lut)\n\n    return output\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.profile/","title":"profile","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile","title":"<code>trestle.core.commands.author.profile</code>","text":"<p>Author commands to generate profile as markdown and assemble to json after edit.</p>"},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileAssemble","title":"<code> ProfileAssemble            (AuthorCommonCommand)         </code>","text":"<p>Assemble markdown files of controls into a Profile json file.</p> Source code in <code>trestle/core/commands/author/profile.py</code> <pre><code>class ProfileAssemble(AuthorCommonCommand):\n\"\"\"Assemble markdown files of controls into a Profile json file.\"\"\"\n\n    name = 'profile-assemble'\n\n    def _init_arguments(self) -&gt; None:\n        name_help_str = (\n            'Optional name of the profile model in the trestle workspace that is being modified.  '\n            'If not provided the output name is used.'\n        )\n        self.add_argument('-n', '--name', help=name_help_str, required=False, type=str)\n        file_help_str = 'Name of the source markdown file directory'\n        self.add_argument('-m', '--markdown', help=file_help_str, required=True, type=str)\n        output_help_str = 'Name of the output generated json Profile (ok to overwrite original)'\n        self.add_argument('-o', '--output', help=output_help_str, required=True, type=str)\n        self.add_argument('-sp', '--set-parameters', action='store_true', help=const.HELP_SET_PARAMS, required=False)\n        self.add_argument('-r', '--regenerate', action='store_true', help=const.HELP_REGENERATE)\n        self.add_argument('-vn', '--version', help=const.HELP_VERSION, required=False, type=str)\n        self.add_argument('-s', '--sections', help=const.HELP_SECTIONS, required=False, type=str)\n        self.add_argument('-rs', '--required-sections', help=const.HELP_REQUIRED_SECTIONS, required=False, type=str)\n        self.add_argument('-as', '--allowed-sections', help=const.HELP_ALLOWED_SECTIONS, required=False, type=str)\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            trestle_root = pathlib.Path(args.trestle_root)\n            return self.assemble_profile(\n                trestle_root=trestle_root,\n                parent_prof_name=args.name,\n                md_name=args.markdown,\n                assem_prof_name=args.output,\n                set_parameters_flag=args.set_parameters,\n                regenerate=args.regenerate,\n                version=args.version,\n                sections_dict=comma_colon_sep_to_dict(args.sections),\n                required_sections=comma_sep_to_list(args.required_sections),\n                allowed_sections=args.allowed_sections\n            )\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Assembly of markdown to profile failed')\n\n    @staticmethod\n    def _replace_alter_adds(profile: prof.Profile, alters: List[prof.Alter]) -&gt; bool:\n\"\"\"Replace the alter adds in the orig_profile with the new ones and return True if changed.\"\"\"\n        changed = False\n        if not profile.modify:\n            profile.modify = prof.Modify(alters=alters)\n            if alters:\n                changed = True\n        elif not profile.modify.alters:\n            profile.modify.alters = alters\n            if alters:\n                changed = True\n        else:\n            alter_dict = {}\n            # if an alter has adds - remove them up front and build dict of alters by control id\n            for alter in profile.modify.alters:\n                alter.adds = None\n                alter_dict[alter.control_id] = alter\n            # now go through new alters and add them to each control in dict by control id\n            for new_alter in alters:\n                alter = alter_dict.get(new_alter.control_id, None)\n                if not alter:\n                    # the control did not have alters, so add\n                    alter = prof.Alter(control_id=new_alter.control_id)\n\n                # even though we removed adds at start, we may have added one already\n                if alter.adds:\n                    alter.adds.extend(new_alter.adds)\n                else:\n                    alter.adds = new_alter.adds\n                # update the dict with the new alter with its added adds\n                alter_dict[new_alter.control_id] = alter\n            # get the new list of alters from the dict and update profile\n            new_alters = list(alter_dict.values())\n            # special case, if all adds were deleted remove such alters completely\n            new_alters = list(filter(lambda alt: alt.adds or alt.removes, new_alters))\n            if profile.modify.alters != new_alters:\n                changed = True\n            profile.modify.alters = none_if_empty(new_alters)\n        return changed\n\n    @staticmethod\n    def _replace_modify_set_params(\n        profile: prof.Profile, param_dict: Dict[str, Any], param_map: Dict[str, str]\n    ) -&gt; bool:\n\"\"\"\n        Replace the set_params in the profile with list and values from markdown.\n\n        Notes:\n            Returns whether or not change was made.\n        \"\"\"\n        changed = False\n        if param_dict:\n            if not profile.modify:\n                profile.modify = prof.Modify()\n            new_set_params: List[prof.SetParameter] = []\n            for key, sub_param_dict in param_dict.items():\n                if sub_param_dict:\n                    sub_param_dict['id'] = key\n                    param = ModelUtils.dict_to_parameter(sub_param_dict)\n                    new_set_params.append(\n                        prof.SetParameter(\n                            param_id=key,\n                            label=param.label,\n                            values=param.values,\n                            select=param.select,\n                            props=param.props\n                        )\n                    )\n            if profile.modify.set_parameters != new_set_params:\n                changed = True\n            # sort the params first by control sorting then by param_id\n            profile.modify.set_parameters = sorted(\n                new_set_params, key=lambda param: (param_map[param.param_id], param.param_id)\n            )\n        if profile.modify:\n            profile.modify.set_parameters = none_if_empty(profile.modify.set_parameters)\n        return changed\n\n    @staticmethod\n    def assemble_profile(\n        trestle_root: pathlib.Path,\n        parent_prof_name: str,\n        md_name: str,\n        assem_prof_name: str,\n        set_parameters_flag: bool,\n        regenerate: bool,\n        version: Optional[str],\n        sections_dict: Dict[str, str],\n        required_sections: List[str],\n        allowed_sections: Optional[List[str]]\n    ) -&gt; int:\n\"\"\"\n        Assemble the markdown directory into a json profile model file.\n\n        Args:\n            trestle_root: The trestle root directory\n            parent_prof_name: Optional name of profile used to generate the markdown (default is assem_prof_name)\n            md_name: The name of the directory containing the markdown control files for the profile\n            assem_prof_name: The name of the assembled profile.  It can be the same as the parent to overwrite\n            set_parameters_flag: Use the params and props in yaml header to add or alter setparameters in the profile\n            regenerate: Whether to regenerate the uuid's in the profile\n            version: Optional version for the assembled profile\n            sections_dict: Optional map of short name to long name for sections\n            required_sections: List of required sections in assembled profile, as comma-separated short names\n            allowed_sections: Optional list of section short names that are allowed, as comma-separated short names\n\n        Returns:\n            0 on success, 1 otherwise\n\n        Notes:\n            There must already be a profile model and it will either be updated or a new json profile created.\n            The generated markdown has the current values for parameters of controls being imported, as set by\n            the original catalog and any intermediate profiles.  It also shows the current SetParameters being applied\n            by this profile.  That list of SetParameters can be edited by changing the assigned values and adding or\n            removing SetParameters from that list.  During assembly that list will be used to create the SetParameters\n            in the assembled profile if the --set-parameters option is specified.\n        \"\"\"\n        md_dir = trestle_root / md_name\n        if not md_dir.exists():\n            raise TrestleError(f'Markdown directory {md_name} does not exist.')\n\n        if not parent_prof_name:\n            parent_prof_name = assem_prof_name\n\n        parent_prof_path = ModelUtils.get_model_path_for_name_and_class(trestle_root, parent_prof_name, prof.Profile)\n        if parent_prof_path is None:\n            raise TrestleError(f'Profile {parent_prof_name} does not exist.  An existing profile must be provided.')\n\n        parent_prof, parent_prof_path = load_validate_model_name(trestle_root, parent_prof_name, prof.Profile)\n        new_content_type = FileContentType.path_to_content_type(parent_prof_path)\n\n        catalog = ProfileResolver.get_resolved_profile_catalog(trestle_root, parent_prof_path)\n\n        context = ControlContext.generate(\n            ContextPurpose.PROFILE, to_markdown=False, trestle_root=trestle_root, md_root=md_dir\n        )\n        context.sections_dict = sections_dict\n        context.required_sections = required_sections\n\n        # load the editable sections of the markdown and create Adds for them\n        # then overwrite the Adds in the existing profile with the new ones\n        # keep track if any changes were made\n        catalog_api = CatalogAPI(catalog=catalog, context=context)\n        found_alters, param_dict, param_map = catalog_api.read_additional_content_from_md(label_as_key=True)\n\n        # technically if allowed sections is [] it means no sections are allowed\n        if allowed_sections is not None:\n            for bad_part in [part for alter in found_alters for add in as_list(alter.adds)\n                             for part in as_filtered_list(add.parts, lambda a: a.name not in allowed_sections)]:\n                raise TrestleError(f'Profile has alter with name {bad_part.name} not in allowed sections.')\n\n        ProfileAssemble._replace_alter_adds(parent_prof, found_alters)\n        if set_parameters_flag:\n            ProfileAssemble._replace_modify_set_params(parent_prof, param_dict, param_map)\n\n        if version:\n            parent_prof.metadata.version = version\n\n        parent_prof.metadata.oscal_version = OSCAL_VERSION\n\n        assem_prof_path = ModelUtils.get_model_path_for_name_and_class(\n            trestle_root, assem_prof_name, prof.Profile, new_content_type\n        )\n\n        if assem_prof_path.exists():\n            _, _, existing_prof = ModelUtils.load_distributed(assem_prof_path, trestle_root)\n            if ModelUtils.models_are_equivalent(existing_prof, parent_prof):\n                logger.info('Assembled profile is no different from existing version, so no update.')\n                return CmdReturnCodes.SUCCESS.value\n\n        if regenerate:\n            parent_prof, _, _ = ModelUtils.regenerate_uuids(parent_prof)\n        ModelUtils.update_last_modified(parent_prof)\n\n        if assem_prof_path.parent.exists():\n            logger.info('Creating profile from markdown and destination profile exists, so updating.')\n            shutil.rmtree(str(assem_prof_path.parent))\n\n        assem_prof_path.parent.mkdir(parents=True, exist_ok=True)\n        parent_prof.oscal_write(assem_prof_path)\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileAssemble.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileAssemble-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileAssemble.assemble_profile","title":"<code>assemble_profile(trestle_root, parent_prof_name, md_name, assem_prof_name, set_parameters_flag, regenerate, version, sections_dict, required_sections, allowed_sections)</code>  <code>staticmethod</code>","text":"<p>Assemble the markdown directory into a json profile model file.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>The trestle root directory</p> required <code>parent_prof_name</code> <code>str</code> <p>Optional name of profile used to generate the markdown (default is assem_prof_name)</p> required <code>md_name</code> <code>str</code> <p>The name of the directory containing the markdown control files for the profile</p> required <code>assem_prof_name</code> <code>str</code> <p>The name of the assembled profile.  It can be the same as the parent to overwrite</p> required <code>set_parameters_flag</code> <code>bool</code> <p>Use the params and props in yaml header to add or alter setparameters in the profile</p> required <code>regenerate</code> <code>bool</code> <p>Whether to regenerate the uuid's in the profile</p> required <code>version</code> <code>Optional[str]</code> <p>Optional version for the assembled profile</p> required <code>sections_dict</code> <code>Dict[str, str]</code> <p>Optional map of short name to long name for sections</p> required <code>required_sections</code> <code>List[str]</code> <p>List of required sections in assembled profile, as comma-separated short names</p> required <code>allowed_sections</code> <code>Optional[List[str]]</code> <p>Optional list of section short names that are allowed, as comma-separated short names</p> required <p>Returns:</p> Type Description <code>int</code> <p>0 on success, 1 otherwise</p> <p>Notes</p> <p>There must already be a profile model and it will either be updated or a new json profile created. The generated markdown has the current values for parameters of controls being imported, as set by the original catalog and any intermediate profiles.  It also shows the current SetParameters being applied by this profile.  That list of SetParameters can be edited by changing the assigned values and adding or removing SetParameters from that list.  During assembly that list will be used to create the SetParameters in the assembled profile if the --set-parameters option is specified.</p> Source code in <code>trestle/core/commands/author/profile.py</code> <pre><code>@staticmethod\ndef assemble_profile(\n    trestle_root: pathlib.Path,\n    parent_prof_name: str,\n    md_name: str,\n    assem_prof_name: str,\n    set_parameters_flag: bool,\n    regenerate: bool,\n    version: Optional[str],\n    sections_dict: Dict[str, str],\n    required_sections: List[str],\n    allowed_sections: Optional[List[str]]\n) -&gt; int:\n\"\"\"\n    Assemble the markdown directory into a json profile model file.\n\n    Args:\n        trestle_root: The trestle root directory\n        parent_prof_name: Optional name of profile used to generate the markdown (default is assem_prof_name)\n        md_name: The name of the directory containing the markdown control files for the profile\n        assem_prof_name: The name of the assembled profile.  It can be the same as the parent to overwrite\n        set_parameters_flag: Use the params and props in yaml header to add or alter setparameters in the profile\n        regenerate: Whether to regenerate the uuid's in the profile\n        version: Optional version for the assembled profile\n        sections_dict: Optional map of short name to long name for sections\n        required_sections: List of required sections in assembled profile, as comma-separated short names\n        allowed_sections: Optional list of section short names that are allowed, as comma-separated short names\n\n    Returns:\n        0 on success, 1 otherwise\n\n    Notes:\n        There must already be a profile model and it will either be updated or a new json profile created.\n        The generated markdown has the current values for parameters of controls being imported, as set by\n        the original catalog and any intermediate profiles.  It also shows the current SetParameters being applied\n        by this profile.  That list of SetParameters can be edited by changing the assigned values and adding or\n        removing SetParameters from that list.  During assembly that list will be used to create the SetParameters\n        in the assembled profile if the --set-parameters option is specified.\n    \"\"\"\n    md_dir = trestle_root / md_name\n    if not md_dir.exists():\n        raise TrestleError(f'Markdown directory {md_name} does not exist.')\n\n    if not parent_prof_name:\n        parent_prof_name = assem_prof_name\n\n    parent_prof_path = ModelUtils.get_model_path_for_name_and_class(trestle_root, parent_prof_name, prof.Profile)\n    if parent_prof_path is None:\n        raise TrestleError(f'Profile {parent_prof_name} does not exist.  An existing profile must be provided.')\n\n    parent_prof, parent_prof_path = load_validate_model_name(trestle_root, parent_prof_name, prof.Profile)\n    new_content_type = FileContentType.path_to_content_type(parent_prof_path)\n\n    catalog = ProfileResolver.get_resolved_profile_catalog(trestle_root, parent_prof_path)\n\n    context = ControlContext.generate(\n        ContextPurpose.PROFILE, to_markdown=False, trestle_root=trestle_root, md_root=md_dir\n    )\n    context.sections_dict = sections_dict\n    context.required_sections = required_sections\n\n    # load the editable sections of the markdown and create Adds for them\n    # then overwrite the Adds in the existing profile with the new ones\n    # keep track if any changes were made\n    catalog_api = CatalogAPI(catalog=catalog, context=context)\n    found_alters, param_dict, param_map = catalog_api.read_additional_content_from_md(label_as_key=True)\n\n    # technically if allowed sections is [] it means no sections are allowed\n    if allowed_sections is not None:\n        for bad_part in [part for alter in found_alters for add in as_list(alter.adds)\n                         for part in as_filtered_list(add.parts, lambda a: a.name not in allowed_sections)]:\n            raise TrestleError(f'Profile has alter with name {bad_part.name} not in allowed sections.')\n\n    ProfileAssemble._replace_alter_adds(parent_prof, found_alters)\n    if set_parameters_flag:\n        ProfileAssemble._replace_modify_set_params(parent_prof, param_dict, param_map)\n\n    if version:\n        parent_prof.metadata.version = version\n\n    parent_prof.metadata.oscal_version = OSCAL_VERSION\n\n    assem_prof_path = ModelUtils.get_model_path_for_name_and_class(\n        trestle_root, assem_prof_name, prof.Profile, new_content_type\n    )\n\n    if assem_prof_path.exists():\n        _, _, existing_prof = ModelUtils.load_distributed(assem_prof_path, trestle_root)\n        if ModelUtils.models_are_equivalent(existing_prof, parent_prof):\n            logger.info('Assembled profile is no different from existing version, so no update.')\n            return CmdReturnCodes.SUCCESS.value\n\n    if regenerate:\n        parent_prof, _, _ = ModelUtils.regenerate_uuids(parent_prof)\n    ModelUtils.update_last_modified(parent_prof)\n\n    if assem_prof_path.parent.exists():\n        logger.info('Creating profile from markdown and destination profile exists, so updating.')\n        shutil.rmtree(str(assem_prof_path.parent))\n\n    assem_prof_path.parent.mkdir(parents=True, exist_ok=True)\n    parent_prof.oscal_write(assem_prof_path)\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileGenerate","title":"<code> ProfileGenerate            (AuthorCommonCommand)         </code>","text":"<p>Generate profile in markdown form from a profile in the trestle workspace.</p> Source code in <code>trestle/core/commands/author/profile.py</code> <pre><code>class ProfileGenerate(AuthorCommonCommand):\n\"\"\"Generate profile in markdown form from a profile in the trestle workspace.\"\"\"\n\n    name = 'profile-generate'\n\n    def _init_arguments(self) -&gt; None:\n        name_help_str = 'Name of the source profile model in the trestle workspace'\n        self.add_argument('-n', '--name', help=name_help_str, required=True, type=str)\n        self.add_argument('-o', '--output', help=const.HELP_MARKDOWN_NAME, required=True, type=str)\n        self.add_argument('-y', '--yaml-header', help=const.HELP_YAML_PATH, required=False, type=str)\n        self.add_argument(\n            '-fo', '--force-overwrite', help=const.HELP_FO_OUTPUT, required=False, action='store_true', default=False\n        )\n        self.add_argument(\n            '-ohv',\n            '--overwrite-header-values',\n            help=const.HELP_OVERWRITE_HEADER_VALUES,\n            required=False,\n            action='store_true',\n            default=False\n        )\n        self.add_argument('-s', '--sections', help=const.HELP_SECTIONS, required=False, type=str)\n        self.add_argument('-rs', '--required-sections', help=const.HELP_REQUIRED_SECTIONS, required=False, type=str)\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            trestle_root: pathlib.Path = args.trestle_root\n            if not file_utils.is_directory_name_allowed(args.output):\n                raise TrestleError(f'{args.output} is not an allowed directory name')\n\n            yaml_header: dict = {}\n            if args.yaml_header:\n                try:\n                    logging.debug(f'Loading yaml header file {args.yaml_header}')\n                    yaml = YAML()\n                    yaml_header = yaml.load(pathlib.Path(args.yaml_header).open('r'))\n                except YAMLError as e:\n                    raise TrestleError(f'YAML error loading yaml header for ssp generation: {e}')\n\n            if args.force_overwrite:\n                try:\n                    logger.info(f'Overwriting the content in {args.output}.')\n                    clear_folder(pathlib.Path(args.output))\n                except TrestleError as e:  # pragma: no cover\n                    raise TrestleError(f'Unable to overwrite contents of {args.output}: {e}')\n\n            # combine command line sections with any in the yaml header, with priority to command line\n            sections_dict = comma_colon_sep_to_dict(args.sections)\n\n            profile_path = trestle_root / f'profiles/{args.name}/profile.json'\n\n            markdown_path = trestle_root / args.output\n\n            return self.generate_markdown(\n                trestle_root,\n                profile_path,\n                markdown_path,\n                yaml_header,\n                args.overwrite_header_values,\n                sections_dict,\n                comma_sep_to_list(args.required_sections)\n            )\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Generation of the profile markdown failed')\n\n    def generate_markdown(\n        self,\n        trestle_root: pathlib.Path,\n        profile_path: pathlib.Path,\n        markdown_path: pathlib.Path,\n        yaml_header: dict,\n        overwrite_header_values: bool,\n        sections_dict: Optional[Dict[str, str]],\n        required_sections: Optional[List[str]]\n    ) -&gt; int:\n\"\"\"Generate markdown for the controls in the profile.\n\n        Args:\n            trestle_root: Root directory of the trestle workspace\n            profile_path: Path of the profile json file\n            markdown_path: Path to the directory into which the markdown will be written\n            yaml_header: Dict to merge into the yaml header of the control markdown\n            overwrite_header_values: Overwrite values in the markdown header but allow new items to be added\n            sections_dict: Optional dict mapping section short names to long\n            required_sections: Optional list of sections that get prompted for prose if not in the profile\n\n        Returns:\n            0 on success, 1 on error\n        \"\"\"\n        try:\n            if sections_dict and const.STATEMENT in sections_dict:\n                logger.warning('statement is not allowed as a section name.')\n                return CmdReturnCodes.COMMAND_ERROR.value\n            _, _, profile = ModelUtils.load_distributed(profile_path, trestle_root)\n            catalog, inherited_props = ProfileResolver().get_resolved_profile_catalog_and_inherited_props(\n                trestle_root, profile_path, True, True, None, ParameterRep.LEAVE_MOUSTACHE\n            )\n            deep_set(yaml_header, [const.TRESTLE_GLOBAL_TAG, const.PROFILE, const.TITLE], profile.metadata.title)\n\n            context = ControlContext.generate(ContextPurpose.PROFILE, True, trestle_root, markdown_path)\n            context.cli_yaml_header = yaml_header\n            context.sections_dict = sections_dict\n            context.profile = profile\n            context.overwrite_header_values = overwrite_header_values\n            context.set_parameters_flag = True\n            context.required_sections = required_sections\n            context.inherited_props = inherited_props\n            catalog_api = CatalogAPI(catalog=catalog, context=context)\n            catalog_api.write_catalog_as_markdown()\n\n        except TrestleNotFoundError as e:\n            raise TrestleError(f'Profile {profile_path} not found, error {e}')\n        except TrestleError as e:\n            raise TrestleError(f'Error generating the catalog as markdown: {e}')\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileGenerate.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileGenerate-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileGenerate.generate_markdown","title":"<code>generate_markdown(self, trestle_root, profile_path, markdown_path, yaml_header, overwrite_header_values, sections_dict, required_sections)</code>","text":"<p>Generate markdown for the controls in the profile.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>Root directory of the trestle workspace</p> required <code>profile_path</code> <code>Path</code> <p>Path of the profile json file</p> required <code>markdown_path</code> <code>Path</code> <p>Path to the directory into which the markdown will be written</p> required <code>yaml_header</code> <code>dict</code> <p>Dict to merge into the yaml header of the control markdown</p> required <code>overwrite_header_values</code> <code>bool</code> <p>Overwrite values in the markdown header but allow new items to be added</p> required <code>sections_dict</code> <code>Optional[Dict[str, str]]</code> <p>Optional dict mapping section short names to long</p> required <code>required_sections</code> <code>Optional[List[str]]</code> <p>Optional list of sections that get prompted for prose if not in the profile</p> required <p>Returns:</p> Type Description <code>int</code> <p>0 on success, 1 on error</p> Source code in <code>trestle/core/commands/author/profile.py</code> <pre><code>def generate_markdown(\n    self,\n    trestle_root: pathlib.Path,\n    profile_path: pathlib.Path,\n    markdown_path: pathlib.Path,\n    yaml_header: dict,\n    overwrite_header_values: bool,\n    sections_dict: Optional[Dict[str, str]],\n    required_sections: Optional[List[str]]\n) -&gt; int:\n\"\"\"Generate markdown for the controls in the profile.\n\n    Args:\n        trestle_root: Root directory of the trestle workspace\n        profile_path: Path of the profile json file\n        markdown_path: Path to the directory into which the markdown will be written\n        yaml_header: Dict to merge into the yaml header of the control markdown\n        overwrite_header_values: Overwrite values in the markdown header but allow new items to be added\n        sections_dict: Optional dict mapping section short names to long\n        required_sections: Optional list of sections that get prompted for prose if not in the profile\n\n    Returns:\n        0 on success, 1 on error\n    \"\"\"\n    try:\n        if sections_dict and const.STATEMENT in sections_dict:\n            logger.warning('statement is not allowed as a section name.')\n            return CmdReturnCodes.COMMAND_ERROR.value\n        _, _, profile = ModelUtils.load_distributed(profile_path, trestle_root)\n        catalog, inherited_props = ProfileResolver().get_resolved_profile_catalog_and_inherited_props(\n            trestle_root, profile_path, True, True, None, ParameterRep.LEAVE_MOUSTACHE\n        )\n        deep_set(yaml_header, [const.TRESTLE_GLOBAL_TAG, const.PROFILE, const.TITLE], profile.metadata.title)\n\n        context = ControlContext.generate(ContextPurpose.PROFILE, True, trestle_root, markdown_path)\n        context.cli_yaml_header = yaml_header\n        context.sections_dict = sections_dict\n        context.profile = profile\n        context.overwrite_header_values = overwrite_header_values\n        context.set_parameters_flag = True\n        context.required_sections = required_sections\n        context.inherited_props = inherited_props\n        catalog_api = CatalogAPI(catalog=catalog, context=context)\n        catalog_api.write_catalog_as_markdown()\n\n    except TrestleNotFoundError as e:\n        raise TrestleError(f'Profile {profile_path} not found, error {e}')\n    except TrestleError as e:\n        raise TrestleError(f'Error generating the catalog as markdown: {e}')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileResolve","title":"<code> ProfileResolve            (AuthorCommonCommand)         </code>","text":"<p>Resolve profile to resolved profile catalog.</p> Source code in <code>trestle/core/commands/author/profile.py</code> <pre><code>class ProfileResolve(AuthorCommonCommand):\n\"\"\"Resolve profile to resolved profile catalog.\"\"\"\n\n    name = 'profile-resolve'\n\n    def _init_arguments(self) -&gt; None:\n        name_help_str = 'Name of the source profile model in the trestle workspace'\n        self.add_argument('-n', '--name', help=name_help_str, required=True, type=str)\n        self.add_argument('-o', '--output', help='Name of the output resolved profile catalog', required=True, type=str)\n        self.add_argument(\n            '-sv',\n            '--show-values',\n            help='Show values for parameters in prose',\n            required=False,\n            action='store_true',\n            default=False\n        )\n        self.add_argument(\n            '-sl',\n            '--show-labels',\n            help='Show labels for parameters in prose instead of values',\n            required=False,\n            action='store_true',\n            default=False\n        )\n        self.add_argument(\n            '-bf',\n            '--bracket-format',\n            help='With -sv, allows brackets around value, e.g. [.] or ((.)), with the dot representing the value.',\n            required=False,\n            type=str,\n            default=''\n        )\n        self.add_argument(\n            '-vap',\n            '--value-assigned-prefix',\n            help='With -sv, places a prefix in front of the parameter string if a value has been assigned.',\n            required=False,\n            type=str,\n            default=''\n        )\n        self.add_argument(\n            '-vnap',\n            '--value-not-assigned-prefix',\n            help='With -sv, places a prefix in front of the parameter string if a value has *not* been assigned.',\n            required=False,\n            type=str,\n            default=''\n        )\n        self.add_argument(\n            '-lp',\n            '--label-prefix',\n            help='With -sl, places a prefix in front of the parameter label.',\n            required=False,\n            type=str,\n            default=''\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            trestle_root: pathlib.Path = args.trestle_root\n            profile_path = trestle_root / f'profiles/{args.name}/profile.json'\n            catalog_name = args.output\n            show_values = args.show_values\n            param_format = args.bracket_format\n            value_assigned_prefix = args.value_assigned_prefix\n            value_not_assigned_prefix = args.value_not_assigned_prefix\n            label_prefix = args.label_prefix\n            show_labels = args.show_labels\n\n            return self.resolve_profile(\n                trestle_root,\n                profile_path,\n                catalog_name,\n                show_values,\n                param_format,\n                value_assigned_prefix,\n                value_not_assigned_prefix,\n                show_labels,\n                label_prefix\n            )\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Generation of the resolved profile catalog failed')\n\n    def resolve_profile(\n        self,\n        trestle_root: pathlib.Path,\n        profile_path: pathlib.Path,\n        catalog_name: str,\n        show_values: bool,\n        bracket_format: str,\n        value_assigned_prefix: Optional[str],\n        value_not_assigned_prefix: Optional[str],\n        show_labels: bool,\n        label_prefix: Optional[str]\n    ) -&gt; int:\n\"\"\"Create resolved profile catalog from given profile.\n\n        Args:\n            trestle_root: Root directory of the trestle workspace\n            profile_path: Path of the profile json file\n            catalog_name: Name of the resolved profile catalog\n            show_values: If true, show values of parameters in prose rather than original {{}} form\n            bracket_format: String representing brackets around value, e.g. [.] or ((.))\n            value_assigned_prefix: Prefix placed in front of param string if a value was assigned\n            value_not_assigned_prefix: Prefix placed in front of param string if a value was *not* assigned\n            show_labels: Show labels for parameters and not values\n            label_prefix: Prefix placed in front of param label\n\n        Returns:\n            0 on success and raises exception on error\n        \"\"\"\n        if not profile_path.exists():\n            raise TrestleNotFoundError(f'Cannot resolve profile catalog: profile {profile_path} does not exist.')\n\n        param_rep = ParameterRep.LEAVE_MOUSTACHE\n        if show_values:\n            param_rep = ParameterRep.ASSIGNMENT_FORM\n            if label_prefix or show_labels:\n                raise TrestleError('Use of show-values is not compatible with show-labels or label-prefix')\n        elif value_assigned_prefix or value_not_assigned_prefix:\n            raise TrestleError('Use of value-assigned-prefix or value-not-assigned-prefix requires show-values')\n        if show_labels:\n            param_rep = ParameterRep.LABEL_FORM\n            # overload value_not_assigned_prefix to use the label_prefix value\n            value_not_assigned_prefix = label_prefix\n        elif label_prefix:\n            raise TrestleError('Use of label-prefix requires show-labels')\n\n        bracket_format = none_if_empty(bracket_format)\n        catalog = ProfileResolver().get_resolved_profile_catalog(\n            trestle_root,\n            profile_path,\n            False,\n            False,\n            bracket_format,\n            param_rep,\n            False,\n            value_assigned_prefix,\n            value_not_assigned_prefix\n        )\n        ModelUtils.save_top_level_model(catalog, trestle_root, catalog_name, FileContentType.JSON)\n\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileResolve.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileResolve-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.profile/#trestle.core.commands.author.profile.ProfileResolve.resolve_profile","title":"<code>resolve_profile(self, trestle_root, profile_path, catalog_name, show_values, bracket_format, value_assigned_prefix, value_not_assigned_prefix, show_labels, label_prefix)</code>","text":"<p>Create resolved profile catalog from given profile.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>Root directory of the trestle workspace</p> required <code>profile_path</code> <code>Path</code> <p>Path of the profile json file</p> required <code>catalog_name</code> <code>str</code> <p>Name of the resolved profile catalog</p> required <code>show_values</code> <code>bool</code> <p>If true, show values of parameters in prose rather than original {{}} form</p> required <code>bracket_format</code> <code>str</code> <p>String representing brackets around value, e.g. [.] or ((.))</p> required <code>value_assigned_prefix</code> <code>Optional[str]</code> <p>Prefix placed in front of param string if a value was assigned</p> required <code>value_not_assigned_prefix</code> <code>Optional[str]</code> <p>Prefix placed in front of param string if a value was not assigned</p> required <code>show_labels</code> <code>bool</code> <p>Show labels for parameters and not values</p> required <code>label_prefix</code> <code>Optional[str]</code> <p>Prefix placed in front of param label</p> required <p>Returns:</p> Type Description <code>int</code> <p>0 on success and raises exception on error</p> Source code in <code>trestle/core/commands/author/profile.py</code> <pre><code>def resolve_profile(\n    self,\n    trestle_root: pathlib.Path,\n    profile_path: pathlib.Path,\n    catalog_name: str,\n    show_values: bool,\n    bracket_format: str,\n    value_assigned_prefix: Optional[str],\n    value_not_assigned_prefix: Optional[str],\n    show_labels: bool,\n    label_prefix: Optional[str]\n) -&gt; int:\n\"\"\"Create resolved profile catalog from given profile.\n\n    Args:\n        trestle_root: Root directory of the trestle workspace\n        profile_path: Path of the profile json file\n        catalog_name: Name of the resolved profile catalog\n        show_values: If true, show values of parameters in prose rather than original {{}} form\n        bracket_format: String representing brackets around value, e.g. [.] or ((.))\n        value_assigned_prefix: Prefix placed in front of param string if a value was assigned\n        value_not_assigned_prefix: Prefix placed in front of param string if a value was *not* assigned\n        show_labels: Show labels for parameters and not values\n        label_prefix: Prefix placed in front of param label\n\n    Returns:\n        0 on success and raises exception on error\n    \"\"\"\n    if not profile_path.exists():\n        raise TrestleNotFoundError(f'Cannot resolve profile catalog: profile {profile_path} does not exist.')\n\n    param_rep = ParameterRep.LEAVE_MOUSTACHE\n    if show_values:\n        param_rep = ParameterRep.ASSIGNMENT_FORM\n        if label_prefix or show_labels:\n            raise TrestleError('Use of show-values is not compatible with show-labels or label-prefix')\n    elif value_assigned_prefix or value_not_assigned_prefix:\n        raise TrestleError('Use of value-assigned-prefix or value-not-assigned-prefix requires show-values')\n    if show_labels:\n        param_rep = ParameterRep.LABEL_FORM\n        # overload value_not_assigned_prefix to use the label_prefix value\n        value_not_assigned_prefix = label_prefix\n    elif label_prefix:\n        raise TrestleError('Use of label-prefix requires show-labels')\n\n    bracket_format = none_if_empty(bracket_format)\n    catalog = ProfileResolver().get_resolved_profile_catalog(\n        trestle_root,\n        profile_path,\n        False,\n        False,\n        bracket_format,\n        param_rep,\n        False,\n        value_assigned_prefix,\n        value_not_assigned_prefix\n    )\n    ModelUtils.save_top_level_model(catalog, trestle_root, catalog_name, FileContentType.JSON)\n\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.ssp/","title":"ssp","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp","title":"<code>trestle.core.commands.author.ssp</code>","text":"<p>Create ssp from catalog and profile.</p>"},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp.SSPAssemble","title":"<code> SSPAssemble            (AuthorCommonCommand)         </code>","text":"<p>Assemble markdown files of controls into an SSP json file.</p> Source code in <code>trestle/core/commands/author/ssp.py</code> <pre><code>class SSPAssemble(AuthorCommonCommand):\n\"\"\"Assemble markdown files of controls into an SSP json file.\"\"\"\n\n    name = 'ssp-assemble'\n\n    def _init_arguments(self) -&gt; None:\n        name_help_str = (\n            'Optional name of the ssp model in the trestle workspace that is being modified.  '\n            'If not provided the output name is used.'\n        )\n        self.add_argument('-n', '--name', help=name_help_str, required=False, type=str)\n        file_help_str = 'Name of the input markdown file directory'\n        self.add_argument('-m', '--markdown', help=file_help_str, required=True, type=str)\n        output_help_str = 'Name of the output generated json SSP'\n        self.add_argument('-cd', '--compdefs', help=const.HELP_COMPDEFS, required=False, type=str)\n        self.add_argument('-o', '--output', help=output_help_str, required=True, type=str)\n        self.add_argument('-r', '--regenerate', action='store_true', help=const.HELP_REGENERATE)\n        self.add_argument('-vn', '--version', help=const.HELP_VERSION, required=False, type=str)\n\n    @staticmethod\n    def _get_ssp_component(ssp: ossp.SystemSecurityPlan, gen_comp: generic.GenericComponent) -&gt; ossp.SystemComponent:\n        for component in as_list(ssp.system_implementation.components):\n            if component.title == gen_comp.title:\n                return component\n        new_component = gen_comp.as_system_component()\n        return new_component\n\n    @staticmethod\n    def _merge_by_comps(stat: ossp.Statement, statement: ossp.Statement, set_params: List[ossp.SetParameter]):\n        for by_comp in as_list(statement.by_components):\n            found = False\n            for dest_by_comp in as_list(stat.by_components):\n                if dest_by_comp.component_uuid == by_comp.component_uuid:\n                    dest_by_comp.description = by_comp.description\n                    dest_by_comp.props = as_list(dest_by_comp.props)\n                    dest_by_comp.props.extend(as_list(statement.props))\n                    dest_by_comp.props = none_if_empty(ControlInterface.clean_props(by_comp.props))\n                    dest_by_comp.implementation_status = by_comp.implementation_status\n                    dest_by_comp.set_parameters = none_if_empty(set_params)\n                    found = True\n                    break\n            if not found:\n                stat.by_components = as_list(stat.by_components)\n                by_comp.set_parameters = none_if_empty(set_params)\n                stat.by_components.append(by_comp)\n\n    @staticmethod\n    def _merge_statement(\n        imp_req: ossp.ImplementedRequirement,\n        statement: generic.GenericStatement,\n        set_params: List[ossp.SetParameter],\n    ):\n\"\"\"Merge the generic statement into the statements of the imp_req.\"\"\"\n        # if the statement id is already in the imp_req, merge its by_comps into the existing statement\n        for stat in as_list(imp_req.statements):\n            if stat.statement_id == statement.statement_id:\n                SSPAssemble._merge_by_comps(stat, statement, set_params)\n                return\n        # otherwise just ad the statement - but only if it has by_comps\n        if statement.by_components:\n            imp_req.statements = as_list(imp_req.statements)\n            imp_req.statements.append(statement)\n\n    @staticmethod\n    def _merge_imp_req_into_imp_req(\n        imp_req: ossp.ImplementedRequirement,\n        gen_imp_req: generic.GenericImplementedRequirement,\n        set_params: List[ossp.SetParameter]\n    ) -&gt; None:\n\"\"\"Merge comp def imp req into existing imp req.\"\"\"\n        # convert generic imp req from comp defs into ssp form\n        src_imp_req = gen_imp_req.as_ssp()\n        imp_req.props = none_if_empty(\n            ControlInterface.clean_props(gen_imp_req.props, remove_imp_status=True, remove_all_rule_info=True)\n        )\n        for statement in as_list(src_imp_req.statements):\n            SSPAssemble._merge_statement(imp_req, statement, set_params)\n\n    @staticmethod\n    def _get_params_for_rules(context: ControlContext, rules_list: List[str],\n                              set_params: List[ossp.SetParameter]) -&gt; List[ossp.SetParameter]:\n\"\"\"Get all set_params needed by the rules along with non-rule set_params.\"\"\"\n        needed_param_ids: Set[str] = set()\n        rule_dict = context.rules_params_dict.get(context.comp_name, {})\n        # find param_ids needed by rules\n        for rule_id in rules_list:\n            # get list of param_ids associated with this rule_id\n            param_ids = [param['name'] for param in rule_dict.values() if param['rule-id'] == rule_id]\n            needed_param_ids.update(param_ids)\n        all_rule_param_ids = [param['name'] for param in rule_dict.values()]\n        # any set_param that isn't associated with a rule should be included as a normal control set param with no rule\n        for set_param in set_params:\n            if set_param.param_id not in all_rule_param_ids:\n                needed_param_ids.add(set_param.param_id)\n        param_ids_list = sorted(needed_param_ids)\n        needed_set_params: List[ossp.SetParameter] = []\n        for param_id in param_ids_list:\n            set_param = None\n            for sp in set_params:\n                if sp.param_id == param_id:\n                    set_param = sp\n                    break\n            if set_param:\n                needed_set_params.append(set_param)\n            else:\n                logger.warning(f'No set param found for param {param_id}')\n        return needed_set_params\n\n    @staticmethod\n    def _add_imp_req_to_ssp(\n        ssp: ossp.SystemSecurityPlan,\n        gen_comp: generic.GenericComponent,\n        gen_imp_req: generic.GenericImplementedRequirement,\n        set_params: List[ossp.SetParameter],\n        context: ControlContext\n    ) -&gt; None:\n\"\"\"Add imp req from control implementation into new ssp being assembled.\"\"\"\n        # the incoming gen_imp_req comes directly from the comp def\n        # but the imp_req here is pulled from the ssp and created if not already there\n        imp_req = CatalogReader._get_imp_req_for_control(ssp, gen_imp_req.control_id)\n        local_set_params = as_list(set_params)[:]\n        local_set_params.extend(as_list(imp_req.set_parameters))\n        local_set_params = ControlInterface.uniquify_set_params(local_set_params)\n        # get any rules set at control level, if present\n        rules_list, _ = ControlInterface.get_rule_list_for_item(gen_imp_req)\n        # There should be no rule content at top level of imp_req in ssp so strip them out\n        imp_req.props = none_if_empty(\n            ControlInterface.clean_props(gen_imp_req.props, remove_imp_status=True, remove_all_rule_info=True)\n        )\n        # if we have rules applying or need to make set_params, we need to make a by_comp\n        control_set_params = SSPAssemble._get_params_for_rules(context, rules_list, local_set_params)\n        if rules_list or control_set_params:\n            by_comp = gens.generate_sample_model(ossp.ByComponent)\n            by_comp.component_uuid = gen_comp.uuid\n            by_comp.description = gen_imp_req.description\n            by_comp.set_parameters = none_if_empty(control_set_params)\n            by_comp.implementation_status = ControlInterface.get_status_from_props(gen_imp_req)\n            by_comp.props = none_if_empty(ControlInterface.clean_props(gen_imp_req.props))\n            imp_req.by_components = as_list(imp_req.by_components)\n            imp_req.by_components.append(by_comp)\n        # each statement in ci corresponds to by_comp in an ssp imp req\n        # so insert the new by_comp directly into the ssp, generating parts as needed\n        imp_req.statements = as_list(imp_req.statements)\n        for statement in as_list(gen_imp_req.statements):\n            if ControlInterface.item_has_rules(statement):\n                imp_req = CatalogReader._get_imp_req_for_statement(ssp, gen_imp_req.control_id, statement.statement_id)\n                by_comp = CatalogReader._get_by_comp_from_imp_req(imp_req, statement.statement_id, gen_comp.uuid)\n                by_comp.description = statement.description\n                by_comp.props = none_if_empty(ControlInterface.clean_props(statement.props))\n                rules_list, _ = ControlInterface.get_rule_list_for_item(statement)\n                by_comp.set_parameters = none_if_empty(\n                    SSPAssemble._get_params_for_rules(context, rules_list, local_set_params)\n                )\n        imp_req.statements = none_if_empty(imp_req.statements)\n        ssp.control_implementation.implemented_requirements = as_list(\n            ssp.control_implementation.implemented_requirements\n        )\n\n    @staticmethod\n    def _merge_imp_req_into_ssp(\n        ssp: ossp.SystemSecurityPlan,\n        gen_imp_req: generic.GenericImplementedRequirement,\n        set_params: List[ossp.SetParameter],\n    ) -&gt; None:\n\"\"\"Merge the new imp_reqs into the ssp.\"\"\"\n        for imp_req in as_list(ssp.control_implementation.implemented_requirements):\n            if imp_req.control_id == gen_imp_req.control_id:\n                SSPAssemble._merge_imp_req_into_imp_req(imp_req, gen_imp_req, set_params)\n                return\n        new_imp_req = gen_imp_req.as_ssp()\n        imp_req.props = none_if_empty(\n            ControlInterface.clean_props(gen_imp_req.props, remove_imp_status=True, remove_all_rule_info=True)\n        )\n        ssp.control_implementation.implemented_requirements.append(new_imp_req)\n\n    def _merge_comp_defs(\n        self,\n        ssp: ossp.SystemSecurityPlan,\n        comp_dict: Dict[str, generic.GenericComponent],\n        context: ControlContext,\n        catalog_interface: CatalogInterface\n    ) -&gt; None:\n\"\"\"Merge the original generic comp defs into the ssp.\"\"\"\n        all_comps: List[ossp.SystemComponent] = []\n        # determine if this is a new and empty ssp\n        new_ssp = not ssp.control_implementation.implemented_requirements\n        for _, gen_comp in comp_dict.items():\n            context.comp_name = gen_comp.title\n            all_ci_props: List[com.Property] = []\n            ssp_comp = SSPAssemble._get_ssp_component(ssp, gen_comp)\n            set_params: List[ossp.SetParameter] = []\n            for ci in as_list(gen_comp.control_implementations):\n                all_ci_props.extend(as_list(ci.props))\n                # get the list of set_params in the control implementation - for this component\n                for sp in as_list(ci.set_parameters):\n                    set_params.append(sp.to_ssp())\n                for imp_req in as_list(ci.implemented_requirements):\n                    # ignore any controls not in the ssp profile (resolved catalog)\n                    if not catalog_interface.get_control(imp_req.control_id):\n                        logger.debug(f'Ignoring imp_req for control {imp_req.control_id} not in ssp profile')\n                        continue\n                    if new_ssp:\n                        SSPAssemble._add_imp_req_to_ssp(ssp, gen_comp, imp_req, set_params, context)\n                    else:\n                        # compile all new uuids for new component definitions\n                        comp_uuids = [x.uuid for x in comp_dict.values()]\n                        for imp_requirement in as_list(ssp.control_implementation.implemented_requirements):\n                            to_delete = []\n                            for i, by_comp in enumerate(imp_requirement.by_components):\n                                if by_comp.component_uuid not in comp_uuids:\n                                    logger.warning(\n                                        f'By_component {by_comp.component_uuid} removed from implemented requirement '\n                                        f'{imp_requirement.control_id} because the corresponding component is not in '\n                                        'the specified compdefs '\n                                    )\n                                    to_delete.append(i)\n                            if to_delete:\n                                delete_list_from_list(imp_requirement.by_components, to_delete)\n                        SSPAssemble._merge_imp_req_into_ssp(ssp, imp_req, set_params)\n            ssp_comp.props = as_list(gen_comp.props)\n            ssp_comp.props.extend(all_ci_props)\n            ssp_comp.props = none_if_empty(ControlInterface.clean_props(ssp_comp.props))\n            all_comps.append(ssp_comp)\n\n        ssp.system_implementation.components = none_if_empty(all_comps)\n\n    def _generate_roles_in_metadata(self, ssp: ossp.SystemSecurityPlan) -&gt; bool:\n\"\"\"Find all roles referenced by imp reqs and create role in metadata as needed.\"\"\"\n        metadata = ssp.metadata\n        metadata.roles = as_list(metadata.roles)\n        known_role_ids = [role.id for role in metadata.roles]\n        changed = False\n        for imp_req in ssp.control_implementation.implemented_requirements:\n            role_ids = [resp_role.role_id for resp_role in as_list(imp_req.responsible_roles)]\n            for role_id in role_ids:\n                if role_id not in known_role_ids:\n                    role = com.Role(id=role_id, title=role_id)\n                    metadata.roles.append(role)\n                    known_role_ids.append(role_id)\n                    changed = True\n        metadata.roles = none_if_empty(metadata.roles)\n        return changed\n\n    @staticmethod\n    def _build_comp_dict_from_comp_defs(\n        trestle_root: pathlib.Path, comp_def_name_list: List[str], create_sys_comp: bool\n    ) -&gt; Dict[str, generic.GenericComponent]:\n        comp_dict: Dict[str, generic.GenericComponent] = {}\n        for comp_name in comp_def_name_list:\n            comp_def, _ = ModelUtils.load_model_for_class(trestle_root, comp_name, comp.ComponentDefinition)\n            for def_comp in as_list(comp_def.components):\n                gen_def_comp = generic.GenericComponent.from_defined_component(def_comp)\n                comp_dict[def_comp.title] = gen_def_comp\n        if create_sys_comp:\n            sys_comp = generic.GenericComponent.generate()\n            sys_comp.type = const.THIS_SYSTEM_AS_KEY\n            sys_comp.title = const.SSP_MAIN_COMP_NAME\n            comp_dict[sys_comp.title] = sys_comp\n        return comp_dict\n\n    @staticmethod\n    def _get_this_system_as_gen_comp(ssp: ossp.SystemSecurityPlan) -&gt; Optional[generic.GenericComponent]:\n        for component in as_list(ssp.system_implementation.components):\n            if component.title == const.SSP_MAIN_COMP_NAME:\n                return generic.GenericComponent.from_defined_component(component)\n        return None\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            trestle_root = pathlib.Path(args.trestle_root)\n\n            md_path = trestle_root / args.markdown\n\n            # the original, reference ssp name defaults to same as output if name not specified\n            # thus in cyclic editing you are reading and writing same json ssp\n            orig_ssp_name = args.output\n            if args.name:\n                orig_ssp_name = args.name\n            new_ssp_name = args.output\n\n            _, profile_href = ComponentAssemble._get_profile_title_and_href_from_dir(md_path)\n            res_cat = ProfileResolver.get_resolved_profile_catalog(trestle_root, profile_href)\n            catalog_interface = CatalogInterface(res_cat)\n\n            new_file_content_type = FileContentType.JSON\n\n            # if output ssp already exists, load it to see if new one is different\n            existing_ssp: Optional[ossp.SystemSecurityPlan] = None\n            new_ssp_path = ModelUtils.get_model_path_for_name_and_class(\n                trestle_root, new_ssp_name, ossp.SystemSecurityPlan\n            )\n            if new_ssp_path:\n                _, _, existing_ssp = ModelUtils.load_distributed(new_ssp_path, trestle_root)\n                new_file_content_type = FileContentType.path_to_content_type(new_ssp_path)\n\n            ssp: ossp.SystemSecurityPlan\n\n            # if orig ssp exists - need to load it rather than instantiate new one\n            orig_ssp_path = ModelUtils.get_model_path_for_name_and_class(\n                trestle_root, orig_ssp_name, ossp.SystemSecurityPlan\n            )\n\n            context = ControlContext.generate(ContextPurpose.SSP, True, trestle_root, md_path)\n            context.comp_def_name_list = comma_sep_to_list(args.compdefs)\n            part_id_map_by_id = catalog_interface.get_statement_part_id_map(False)\n            catalog_interface.generate_control_rule_info(part_id_map_by_id, context)\n\n            # load all original comp defs\n            # only additions from markdown will be imp_req prose and status\n            # and param vals\n            # if this is a new ssp then create system component in the comp_dict\n            comp_dict = SSPAssemble._build_comp_dict_from_comp_defs(\n                trestle_root, context.comp_def_name_list, not orig_ssp_path\n            )\n\n            part_id_map_by_label = catalog_interface.get_statement_part_id_map(True)\n\n            # if ssp already exists use it as container for new content\n            if orig_ssp_path:\n                # load the existing json ssp\n                _, _, ssp = ModelUtils.load_distributed(orig_ssp_path, trestle_root)\n                # add the This System comp to the comp dict so its uuid is known\n                sys_comp = SSPAssemble._get_this_system_as_gen_comp(ssp)\n                if not sys_comp:\n                    raise TrestleError('Original ssp has no system component.')\n                comp_dict[const.SSP_MAIN_COMP_NAME] = sys_comp\n\n                # Verifies older compdefs in an ssp no longer exist in newly provided ones\n                comp_titles = [x.title for x in comp_dict.values()]\n                ssp_sys_imp_comps = ssp.system_implementation.components\n                diffs = [x for x in ssp_sys_imp_comps if x.title not in comp_titles]\n                if diffs:\n                    for diff in diffs:\n                        logger.warning(\n                            f'Component named: {diff.title} was removed from system components from ssp '\n                            'because the corresponding component is not in '\n                            'the specified compdefs '\n                        )\n                    index_list = [ssp_sys_imp_comps.index(value) for value in diffs if value in ssp_sys_imp_comps]\n                    delete_list_from_list(ssp.system_implementation.components, index_list)\n\n                self._merge_comp_defs(ssp, comp_dict, context, catalog_interface)\n                CatalogReader.read_ssp_md_content(md_path, ssp, comp_dict, part_id_map_by_label, context)\n\n                new_file_content_type = FileContentType.path_to_content_type(orig_ssp_path)\n            else:\n                # create a sample ssp to hold all the parts\n                ssp = gens.generate_sample_model(ossp.SystemSecurityPlan)\n                ssp.control_implementation.implemented_requirements = []\n                ssp.control_implementation.description = const.SSP_SYSTEM_CONTROL_IMPLEMENTATION_TEXT\n                ssp.system_implementation.components = []\n                self._merge_comp_defs(ssp, comp_dict, context, catalog_interface)\n                CatalogReader.read_ssp_md_content(md_path, ssp, comp_dict, part_id_map_by_label, context)\n\n                import_profile: ossp.ImportProfile = gens.generate_sample_model(ossp.ImportProfile)\n                import_profile.href = const.REPLACE_ME\n                ssp.import_profile = import_profile\n\n            # now that we know the complete list of needed components, add them to the sys_imp\n            # TODO if the ssp already existed then components may need to be removed if not ref'd by imp_reqs\n            self._generate_roles_in_metadata(ssp)\n\n            ssp.import_profile.href = profile_href\n\n            if args.version:\n                ssp.metadata.version = args.version\n\n            if ModelUtils.models_are_equivalent(existing_ssp, ssp):\n                logger.info('No changes to assembled ssp so ssp not written out.')\n                return CmdReturnCodes.SUCCESS.value\n\n            if args.regenerate:\n                ssp, _, _ = ModelUtils.regenerate_uuids(ssp)\n            ModelUtils.update_last_modified(ssp)\n            # validate model rules before saving\n            args_validate = argparse.Namespace(mode=const.VAL_MODE_RULES)\n            validator: Validator = validator_factory.get(args_validate)\n            if not validator.model_is_valid(ssp, True, trestle_root):\n                logger.error(\n                    'Validation of file to be imported did not pass. Rule parameter values validation failed, '\n                    'please check values are correct for shared parameters in current model'\n                )\n                return CmdReturnCodes.COMMAND_ERROR.value\n            # write out the ssp as json\n            ModelUtils.save_top_level_model(ssp, trestle_root, new_ssp_name, new_file_content_type)\n\n            return CmdReturnCodes.SUCCESS.value\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while assembling SSP')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp.SSPAssemble.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp.SSPFilter","title":"<code> SSPFilter            (AuthorCommonCommand)         </code>","text":"<p>Filter the controls in an ssp.</p> <p>The filtered ssp is based on controls included by the following: profile, components, and/or implementation status.</p> Source code in <code>trestle/core/commands/author/ssp.py</code> <pre><code>class SSPFilter(AuthorCommonCommand):\n\"\"\"\n    Filter the controls in an ssp.\n\n    The filtered ssp is based on controls included by the following:\n    profile, components, and/or implementation status.\n    \"\"\"\n\n    name = 'ssp-filter'\n\n    def _init_arguments(self) -&gt; None:\n        file_help_str = 'Name of the input ssp'\n        self.add_argument('-n', '--name', help=file_help_str, required=True, type=str)\n        file_help_str = 'Name of the optional input profile that defines set of controls in filtered ssp'\n        self.add_argument('-p', '--profile', help=file_help_str, required=False, type=str)\n        output_help_str = 'Name of the output generated SSP'\n        self.add_argument('-o', '--output', help=output_help_str, required=True, type=str)\n        self.add_argument('-r', '--regenerate', action='store_true', help=const.HELP_REGENERATE)\n        self.add_argument('-vn', '--version', help=const.HELP_VERSION, required=False, type=str)\n        comp_help_str = 'Colon-delimited list of component names to include in filtered ssp.'\n        self.add_argument('-c', '--components', help=comp_help_str, required=False, type=str)\n        is_help_str = 'Comma-delimited list of control implementation statuses to include in filtered ssp.'\n        self.add_argument('-is', '--implementation-status', help=is_help_str, required=False, type=str)\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            trestle_root = pathlib.Path(args.trestle_root)\n            comp_names: Optional[List[str]] = None\n            impl_status_values: Optional[List[str]] = None\n\n            if not (args.components or args.implementation_status or args.profile):\n                logger.warning(\n                    'You must specify at least one, or a combination of: profile, list of component names'\n                    ', or list of implementation statuses for ssp-filter.'\n                )\n                return CmdReturnCodes.COMMAND_ERROR.value\n\n            if args.components:\n                comp_names = args.components.split(':')\n\n            if args.implementation_status:\n                impl_status_values = args.implementation_status.split(',')\n                allowed_is_values = {\n                    const.STATUS_PLANNED,\n                    const.STATUS_PARTIAL,\n                    const.STATUS_IMPLEMENTED,\n                    const.STATUS_ALTERNATIVE,\n                    const.STATUS_NOT_APPLICABLE\n                }\n                allowed_is_string = ', '.join(str(item) for item in allowed_is_values)\n                for impl_status in impl_status_values:\n                    if impl_status not in allowed_is_values:\n                        logger.warning(\n                            f'Provided implementation status \"{impl_status}\" is invalid.\\n'\n                            f'Please use the following for ssp-filter: {allowed_is_string}'\n                        )\n                        return CmdReturnCodes.COMMAND_ERROR.value\n\n            return self.filter_ssp(\n                trestle_root,\n                args.name,\n                args.profile,\n                args.output,\n                args.regenerate,\n                args.version,\n                comp_names,\n                impl_status_values\n            )\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error generating the filtered ssp')\n\n    def filter_ssp(\n        self,\n        trestle_root: pathlib.Path,\n        ssp_name: str,\n        profile_name: str,\n        out_name: str,\n        regenerate: bool,\n        version: Optional[str],\n        components: Optional[List[str]] = None,\n        implementation_status: Optional[List[str]] = None\n    ) -&gt; int:\n\"\"\"\n        Filter the ssp and output new ssp.\n\n        The filtered ssp is based on controls included by the following:\n        profile, components, and/or implementation status.\n\n        Args:\n            trestle_root: root directory of the trestle workspace\n            ssp_name: name of the ssp model\n            profile_name: name of the optional profile model used for filtering\n            out_name: name of the output ssp model with filtered controls\n            regenerate: whether to regenerate the uuid's in the ssp\n            version: new version for the model\n            components: optional list of component names used for filtering\n            implementation_status: optional list of implementation statuses for filtering\n\n        Returns:\n            0 on success, 1 otherwise\n        \"\"\"\n        # load the ssp\n        ssp: ossp.SystemSecurityPlan\n        ssp, _ = load_validate_model_name(trestle_root, ssp_name, ossp.SystemSecurityPlan, FileContentType.JSON)\n        profile_path = ModelUtils.get_model_path_for_name_and_class(\n            trestle_root, profile_name, prof.Profile, FileContentType.JSON\n        )\n\n        if components:\n            raw_comp_names = [ControlReader.simplify_name(name) for name in components]\n            comp_uuids: List[str] = []\n            for component in ssp.system_implementation.components:\n                if ControlReader.simplify_name(component.title) in raw_comp_names:\n                    comp_uuids.append(component.uuid)\n\n            if len(comp_uuids) != len(components):\n                raise TrestleError(\n                    f'Unable to filter the ssp because one of the components {components} is not in the ssp.'\n                )\n\n            # imp_reqs can be by comp\n            # and imp_reqs can have statements that are by comp\n            if comp_uuids:\n                new_imp_reqs: List[ossp.ImplementedRequirement] = []\n                # these are all required to be present\n                for imp_req in ssp.control_implementation.implemented_requirements:\n                    new_by_comps: List[ossp.ByComponent] = []\n                    # by_comps is optional\n                    for by_comp in as_list(imp_req.by_components):\n                        if by_comp.component_uuid in comp_uuids:\n                            new_by_comps.append(by_comp)\n                    imp_req.by_components = none_if_empty(new_by_comps)\n                    new_imp_reqs.append(imp_req)\n                    new_statements: List[ossp.Statement] = []\n                    for statement in as_list(imp_req.statements):\n                        new_by_comps: List[ossp.ByComponent] = []\n                        for by_comp in as_list(statement.by_components):\n                            if by_comp.component_uuid in comp_uuids:\n                                new_by_comps.append(by_comp)\n                        statement.by_components = none_if_empty(new_by_comps)\n                        new_statements.append(statement)\n                    imp_req.statements = none_if_empty(new_statements)\n                ssp.control_implementation.implemented_requirements = new_imp_reqs\n                # now remove any unused components from the ssp\n                new_comp_list: List[ossp.SystemComponent] = []\n                for comp_ in ssp.system_implementation.components:\n                    if comp_.uuid in comp_uuids:\n                        new_comp_list.append(comp_)\n                ssp.system_implementation.components = new_comp_list\n\n        # filter by controls in profile\n        if profile_name:\n            prof_resolver = ProfileResolver()\n            catalog = prof_resolver.get_resolved_profile_catalog(trestle_root, profile_path, show_value_warnings=True)\n            catalog_api = CatalogAPI(catalog=catalog)\n\n            # The input ssp should reference a superset of the controls referenced by the profile\n            # Need to cull references in the ssp to controls not in the profile\n            # Also make sure the output ssp contains imp reqs for all controls in the profile\n            control_imp = ssp.control_implementation\n            ssp_control_ids: Set[str] = set()\n\n            new_set_params: List[ossp.SetParameter] = []\n            for set_param in as_list(control_imp.set_parameters):\n                control = catalog_api._catalog_interface.get_control_by_param_id(set_param.param_id)\n                if control is not None:\n                    new_set_params.append(set_param)\n                    ssp_control_ids.add(control.id)\n            control_imp.set_parameters = none_if_empty(new_set_params)\n\n            new_imp_requirements: List[ossp.ImplementedRequirement] = []\n            for imp_requirement in as_list(control_imp.implemented_requirements):\n                control = catalog_api._catalog_interface.get_control(imp_requirement.control_id)\n                if control is not None:\n                    new_imp_requirements.append(imp_requirement)\n                    ssp_control_ids.add(control.id)\n            control_imp.implemented_requirements = new_imp_requirements\n\n            # make sure all controls in the profile have implemented reqs in the final ssp\n            if not ssp_control_ids.issuperset(catalog_api._catalog_interface.get_control_ids()):\n                raise TrestleError('Unable to filter the ssp because the profile references controls not in it.')\n\n            ssp.control_implementation = control_imp\n\n        # filter implemented requirements and statements by component implementation status\n        # this will remove any implemented requirements without statements or by_component fields set\n        if implementation_status:\n            new_imp_reqs: List[ossp.ImplementedRequirement] = []\n            # these are all required to be present\n            for imp_req in ssp.control_implementation.implemented_requirements:\n                new_by_comps: List[ossp.ByComponent] = []\n                # by_comps is optional\n                for by_comp in as_list(imp_req.by_components):\n                    if by_comp.implementation_status.state in implementation_status:\n                        new_by_comps.append(by_comp)\n                imp_req.by_components = none_if_empty(new_by_comps)\n\n                new_statements: List[ossp.Statement] = []\n                for statement in as_list(imp_req.statements):\n                    new_by_comps: List[ossp.ByComponent] = []\n                    for by_comp in as_list(statement.by_components):\n                        if by_comp.implementation_status.state in implementation_status:\n                            new_by_comps.append(by_comp)\n                    statement.by_components = none_if_empty(new_by_comps)\n                    if statement.by_components is not None:\n                        new_statements.append(statement)\n                imp_req.statements = none_if_empty(new_statements)\n\n                if imp_req.by_components is not None or imp_req.statements is not None:\n                    new_imp_reqs.append(imp_req)\n\n            ssp.control_implementation.implemented_requirements = new_imp_reqs\n\n        if version:\n            ssp.metadata.version = version\n\n        existing_ssp_path = ModelUtils.get_model_path_for_name_and_class(\n            trestle_root, out_name, ossp.SystemSecurityPlan\n        )\n        if existing_ssp_path is not None:\n            existing_ssp, _ = load_validate_model_name(trestle_root, out_name, ossp.SystemSecurityPlan)\n            if ModelUtils.models_are_equivalent(existing_ssp, ssp):\n                logger.info('No changes to filtered ssp so ssp not written out.')\n                return CmdReturnCodes.SUCCESS.value\n\n        if regenerate:\n            ssp, _, _ = ModelUtils.regenerate_uuids(ssp)\n\n        ModelUtils.update_last_modified(ssp)\n\n        ModelUtils.save_top_level_model(ssp, trestle_root, out_name, FileContentType.JSON)\n\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp.SSPFilter.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp.SSPFilter-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp.SSPFilter.filter_ssp","title":"<code>filter_ssp(self, trestle_root, ssp_name, profile_name, out_name, regenerate, version, components=None, implementation_status=None)</code>","text":"<p>Filter the ssp and output new ssp.</p> <p>The filtered ssp is based on controls included by the following: profile, components, and/or implementation status.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>root directory of the trestle workspace</p> required <code>ssp_name</code> <code>str</code> <p>name of the ssp model</p> required <code>profile_name</code> <code>str</code> <p>name of the optional profile model used for filtering</p> required <code>out_name</code> <code>str</code> <p>name of the output ssp model with filtered controls</p> required <code>regenerate</code> <code>bool</code> <p>whether to regenerate the uuid's in the ssp</p> required <code>version</code> <code>Optional[str]</code> <p>new version for the model</p> required <code>components</code> <code>Optional[List[str]]</code> <p>optional list of component names used for filtering</p> <code>None</code> <code>implementation_status</code> <code>Optional[List[str]]</code> <p>optional list of implementation statuses for filtering</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>0 on success, 1 otherwise</p> Source code in <code>trestle/core/commands/author/ssp.py</code> <pre><code>def filter_ssp(\n    self,\n    trestle_root: pathlib.Path,\n    ssp_name: str,\n    profile_name: str,\n    out_name: str,\n    regenerate: bool,\n    version: Optional[str],\n    components: Optional[List[str]] = None,\n    implementation_status: Optional[List[str]] = None\n) -&gt; int:\n\"\"\"\n    Filter the ssp and output new ssp.\n\n    The filtered ssp is based on controls included by the following:\n    profile, components, and/or implementation status.\n\n    Args:\n        trestle_root: root directory of the trestle workspace\n        ssp_name: name of the ssp model\n        profile_name: name of the optional profile model used for filtering\n        out_name: name of the output ssp model with filtered controls\n        regenerate: whether to regenerate the uuid's in the ssp\n        version: new version for the model\n        components: optional list of component names used for filtering\n        implementation_status: optional list of implementation statuses for filtering\n\n    Returns:\n        0 on success, 1 otherwise\n    \"\"\"\n    # load the ssp\n    ssp: ossp.SystemSecurityPlan\n    ssp, _ = load_validate_model_name(trestle_root, ssp_name, ossp.SystemSecurityPlan, FileContentType.JSON)\n    profile_path = ModelUtils.get_model_path_for_name_and_class(\n        trestle_root, profile_name, prof.Profile, FileContentType.JSON\n    )\n\n    if components:\n        raw_comp_names = [ControlReader.simplify_name(name) for name in components]\n        comp_uuids: List[str] = []\n        for component in ssp.system_implementation.components:\n            if ControlReader.simplify_name(component.title) in raw_comp_names:\n                comp_uuids.append(component.uuid)\n\n        if len(comp_uuids) != len(components):\n            raise TrestleError(\n                f'Unable to filter the ssp because one of the components {components} is not in the ssp.'\n            )\n\n        # imp_reqs can be by comp\n        # and imp_reqs can have statements that are by comp\n        if comp_uuids:\n            new_imp_reqs: List[ossp.ImplementedRequirement] = []\n            # these are all required to be present\n            for imp_req in ssp.control_implementation.implemented_requirements:\n                new_by_comps: List[ossp.ByComponent] = []\n                # by_comps is optional\n                for by_comp in as_list(imp_req.by_components):\n                    if by_comp.component_uuid in comp_uuids:\n                        new_by_comps.append(by_comp)\n                imp_req.by_components = none_if_empty(new_by_comps)\n                new_imp_reqs.append(imp_req)\n                new_statements: List[ossp.Statement] = []\n                for statement in as_list(imp_req.statements):\n                    new_by_comps: List[ossp.ByComponent] = []\n                    for by_comp in as_list(statement.by_components):\n                        if by_comp.component_uuid in comp_uuids:\n                            new_by_comps.append(by_comp)\n                    statement.by_components = none_if_empty(new_by_comps)\n                    new_statements.append(statement)\n                imp_req.statements = none_if_empty(new_statements)\n            ssp.control_implementation.implemented_requirements = new_imp_reqs\n            # now remove any unused components from the ssp\n            new_comp_list: List[ossp.SystemComponent] = []\n            for comp_ in ssp.system_implementation.components:\n                if comp_.uuid in comp_uuids:\n                    new_comp_list.append(comp_)\n            ssp.system_implementation.components = new_comp_list\n\n    # filter by controls in profile\n    if profile_name:\n        prof_resolver = ProfileResolver()\n        catalog = prof_resolver.get_resolved_profile_catalog(trestle_root, profile_path, show_value_warnings=True)\n        catalog_api = CatalogAPI(catalog=catalog)\n\n        # The input ssp should reference a superset of the controls referenced by the profile\n        # Need to cull references in the ssp to controls not in the profile\n        # Also make sure the output ssp contains imp reqs for all controls in the profile\n        control_imp = ssp.control_implementation\n        ssp_control_ids: Set[str] = set()\n\n        new_set_params: List[ossp.SetParameter] = []\n        for set_param in as_list(control_imp.set_parameters):\n            control = catalog_api._catalog_interface.get_control_by_param_id(set_param.param_id)\n            if control is not None:\n                new_set_params.append(set_param)\n                ssp_control_ids.add(control.id)\n        control_imp.set_parameters = none_if_empty(new_set_params)\n\n        new_imp_requirements: List[ossp.ImplementedRequirement] = []\n        for imp_requirement in as_list(control_imp.implemented_requirements):\n            control = catalog_api._catalog_interface.get_control(imp_requirement.control_id)\n            if control is not None:\n                new_imp_requirements.append(imp_requirement)\n                ssp_control_ids.add(control.id)\n        control_imp.implemented_requirements = new_imp_requirements\n\n        # make sure all controls in the profile have implemented reqs in the final ssp\n        if not ssp_control_ids.issuperset(catalog_api._catalog_interface.get_control_ids()):\n            raise TrestleError('Unable to filter the ssp because the profile references controls not in it.')\n\n        ssp.control_implementation = control_imp\n\n    # filter implemented requirements and statements by component implementation status\n    # this will remove any implemented requirements without statements or by_component fields set\n    if implementation_status:\n        new_imp_reqs: List[ossp.ImplementedRequirement] = []\n        # these are all required to be present\n        for imp_req in ssp.control_implementation.implemented_requirements:\n            new_by_comps: List[ossp.ByComponent] = []\n            # by_comps is optional\n            for by_comp in as_list(imp_req.by_components):\n                if by_comp.implementation_status.state in implementation_status:\n                    new_by_comps.append(by_comp)\n            imp_req.by_components = none_if_empty(new_by_comps)\n\n            new_statements: List[ossp.Statement] = []\n            for statement in as_list(imp_req.statements):\n                new_by_comps: List[ossp.ByComponent] = []\n                for by_comp in as_list(statement.by_components):\n                    if by_comp.implementation_status.state in implementation_status:\n                        new_by_comps.append(by_comp)\n                statement.by_components = none_if_empty(new_by_comps)\n                if statement.by_components is not None:\n                    new_statements.append(statement)\n            imp_req.statements = none_if_empty(new_statements)\n\n            if imp_req.by_components is not None or imp_req.statements is not None:\n                new_imp_reqs.append(imp_req)\n\n        ssp.control_implementation.implemented_requirements = new_imp_reqs\n\n    if version:\n        ssp.metadata.version = version\n\n    existing_ssp_path = ModelUtils.get_model_path_for_name_and_class(\n        trestle_root, out_name, ossp.SystemSecurityPlan\n    )\n    if existing_ssp_path is not None:\n        existing_ssp, _ = load_validate_model_name(trestle_root, out_name, ossp.SystemSecurityPlan)\n        if ModelUtils.models_are_equivalent(existing_ssp, ssp):\n            logger.info('No changes to filtered ssp so ssp not written out.')\n            return CmdReturnCodes.SUCCESS.value\n\n    if regenerate:\n        ssp, _, _ = ModelUtils.regenerate_uuids(ssp)\n\n    ModelUtils.update_last_modified(ssp)\n\n    ModelUtils.save_top_level_model(ssp, trestle_root, out_name, FileContentType.JSON)\n\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp.SSPGenerate","title":"<code> SSPGenerate            (AuthorCommonCommand)         </code>","text":"<p>Generate SSP in markdown form from a Profile.</p> Source code in <code>trestle/core/commands/author/ssp.py</code> <pre><code>class SSPGenerate(AuthorCommonCommand):\n\"\"\"Generate SSP in markdown form from a Profile.\"\"\"\n\n    name = 'ssp-generate'\n\n    def _init_arguments(self) -&gt; None:\n        file_help_str = 'Main profile href, or name of the profile model in the trestle workspace'\n        self.add_argument('-p', '--profile', help=file_help_str, required=True, type=str)\n        self.add_argument(\n            '-o', '--output', help='Name of the output generated ssp markdown folder', required=True, type=str\n        )  # noqa E501\n        self.add_argument('-cd', '--compdefs', help=const.HELP_COMPDEFS, required=False, type=str)\n        self.add_argument('-y', '--yaml-header', help=const.HELP_YAML_PATH, required=False, type=str)\n        self.add_argument(\n            '-fo', '--force-overwrite', help=const.HELP_FO_OUTPUT, required=False, action='store_true', default=False\n        )\n        self.add_argument(\n            '-ohv',\n            '--overwrite-header-values',\n            help=const.HELP_OVERWRITE_HEADER_VALUES,\n            required=False,\n            action='store_true',\n            default=False\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            trestle_root = args.trestle_root\n            if not file_utils.is_directory_name_allowed(args.output):\n                raise TrestleError(f'{args.output} is not an allowed directory name')\n\n            yaml_header: dict = {}\n            if args.yaml_header:\n                try:\n                    logging.debug(f'Loading yaml header file {args.yaml_header}')\n                    yaml = YAML()\n                    yaml_header = yaml.load(pathlib.Path(args.yaml_header).open('r'))\n                except YAMLError as e:\n                    raise TrestleError(f'YAML error loading yaml header {args.yaml_header} for ssp generation: {e}')\n\n            compdef_name_list = comma_sep_to_list(args.compdefs)\n\n            md_path = trestle_root / args.output\n\n            return self._generate_ssp_markdown(\n                trestle_root,\n                args.profile,\n                compdef_name_list,\n                md_path,\n                yaml_header,\n                args.overwrite_header_values,\n                args.force_overwrite\n            )\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while writing markdown from catalog')\n\n    def _generate_ssp_markdown(\n        self,\n        trestle_root: pathlib.Path,\n        profile_name_or_href: str,\n        compdef_name_list: List[str],\n        md_path: pathlib.Path,\n        yaml_header: Dict[str, Any],\n        overwrite_header_values: bool,\n        force_overwrite: bool\n    ) -&gt; int:\n\"\"\"\n        Generate the ssp markdown from the profile and compdefs.\n\n        Notes:\n        Get RPC from profile.\n        For each compdef:\n            For each comp:\n                Load top level rules\n                for each control_imp:\n                    Load rules params values\n                    For each imp_req (bound to 1 control):\n                        Load control level rules and status\n                        Load part level rules\n                        If rules apply then write out control and add to list written out\n                        If control exists, read it and insert content\n        \"\"\"\n        if force_overwrite:\n            try:\n                logger.info(f'Overwriting the content in {md_path}.')\n                clear_folder(pathlib.Path(md_path))\n            except TrestleError as e:  # pragma: no cover\n                raise TrestleError(f'Unable to overwrite contents of {md_path}: {e}')\n\n        context = ControlContext.generate(ContextPurpose.SSP, True, trestle_root, md_path)\n        context.cli_yaml_header = yaml_header\n        context.sections_dict = None\n        context.prompt_responses = True\n        context.overwrite_header_values = overwrite_header_values\n        context.allowed_sections = None\n        context.comp_def_name_list = compdef_name_list\n\n        # if file not recognized as URI form, assume it represents name of file in trestle directory\n        profile_in_trestle_dir = '://' not in profile_name_or_href\n        profile_href = profile_name_or_href\n        if profile_in_trestle_dir:\n            local_path = f'profiles/{profile_name_or_href}/profile.json'\n            profile_href = const.TRESTLE_HREF_HEADING + local_path\n            profile_path = trestle_root / local_path\n            _, _, context.profile = ModelUtils.load_distributed(profile_path, trestle_root)\n        else:\n            fetcher = FetcherFactory.get_fetcher(trestle_root, profile_href)\n            context.profile: prof.Profile = fetcher.get_oscal()\n            profile_path = profile_href\n\n        profile_resolver = ProfileResolver()\n        # in ssp context we want to see missing value warnings\n        resolved_catalog = profile_resolver.get_resolved_profile_catalog(\n            trestle_root, profile_path, block_params=False, params_format='[.]', show_value_warnings=True\n        )\n\n        catalog_api = CatalogAPI(catalog=resolved_catalog, context=context)\n\n        context.cli_yaml_header[const.TRESTLE_GLOBAL_TAG] = {}\n        profile_header = {'title': context.profile.metadata.title, 'href': profile_href}\n\n        context.cli_yaml_header[const.TRESTLE_GLOBAL_TAG][const.PROFILE] = profile_header\n\n        catalog_api.write_catalog_as_markdown()\n\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.ssp/#trestle.core.commands.author.ssp.SSPGenerate.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/","title":"template_versioning","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning","title":"<code>trestle.core.commands.author.versioning.template_versioning</code>","text":"<p>A Template Versioning.</p>"},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning.TemplateVersioning","title":"<code> TemplateVersioning        </code>","text":"<p>Template versioning solution.</p> <ol> <li>Load template with a specified version.<ol> <li>Template version can be specified via -tv flag</li> <li>If no version specified the latest version will be used by default.</li> <li>Otherwise use the templates from the specified version.</li> </ol> </li> <li>Backward compatibility.<ol> <li>Version 0.0.1 will be reserved for the template versions prior to this change.</li> <li>If the old template path is detected (i.e. without the template version).     then the filesystem will be updated to the new path with the version.</li> <li>Upon first run, old template versions prior to this change will be placed to the folder 0.0.1.</li> <li>If templates have no headers then 0.0.1 version will be used.</li> </ol> </li> <li>Versioning organization.<ol> <li>Template and instance version is added both: in the file system (via path) and in the headers or metadata.</li> </ol> </li> <li>Instance version validation.<ol> <li>Markdown:<ol> <li>When validating the instance the header will be used to validate the version.</li> </ol> </li> <li>Drawio:<ol> <li>When validating the instance the metadata will be used to validate the version.</li> </ol> </li> </ol> </li> </ol> Source code in <code>trestle/core/commands/author/versioning/template_versioning.py</code> <pre><code>class TemplateVersioning:\n\"\"\"\n    Template versioning solution.\n\n    1. Load template with a specified version.\n        1. Template version can be specified via -tv flag\n        2. If no version specified the latest version will be used by default.\n        3. Otherwise use the templates from the specified version.\n    2. Backward compatibility.\n        1. Version 0.0.1 will be reserved for the template versions prior to this change.\n        2. If the old template path is detected (i.e. without the template version).\n            then the filesystem will be updated to the new path with the version.\n        3. Upon first run, old template versions prior to this change will be placed to the folder 0.0.1.\n        4. If templates have no headers then 0.0.1 version will be used.\n    3. Versioning organization.\n        1. Template and instance version is added both: in the file system (via path) and in the headers or metadata.\n    4. Instance version validation.\n        1. Markdown:\n            1. When validating the instance the header will be used to validate the version.\n        2. Drawio:\n            1. When validating the instance the metadata will be used to validate the version.\n    \"\"\"\n\n    @staticmethod\n    def update_template_folder_structure(task_path: Path) -&gt; None:\n\"\"\"\n        Automatically detect whether the path is an old style and update it.\n\n        An old-style path is a path of the form:\n         root_folder/.trestle/author/{template_name}/{template_objects}\n        The new version path is a path of the form:\n         root_folder/.trestle/author/{template_name}/{version}/{template_objects}\n        By default all old-style templates will be updated to version 0.0.1\n        \"\"\"\n        TemplateVersioning._check_if_exists_and_dir(task_path)\n\n        try:\n            all_files_wo_version = list(\n                filter(lambda p: p.is_file(), file_utils.iterdir_without_hidden_files(task_path))\n            )\n\n            pattern = re.compile(TEMPLATE_VERSION_REGEX)\n            all_non_template_directories = list(\n                filter(\n                    lambda p: p.is_dir() and pattern.search(p.parts[-1]) is None,\n                    file_utils.iterdir_without_hidden_files(task_path)\n                )\n            )\n\n            new_dir = Path(f'{task_path}/{START_TEMPLATE_VERSION}')\n            new_dir.mkdir(parents=True, exist_ok=True)\n\n            if len(all_files_wo_version) == 0:\n                logger.debug('No templates outside of the version folders.')\n                # if the base template folder is empty, delete it\n                if len(list(new_dir.iterdir())) == 0:\n                    new_dir.rmdir()\n\n            for f in all_files_wo_version + all_non_template_directories:\n                if f.is_file():\n                    shutil.copy(f, new_dir)\n                elif f.is_dir():\n                    shutil.copytree(f, new_dir / f.name)\n\n            for p in all_files_wo_version + all_non_template_directories:\n                if p.is_dir():\n                    shutil.rmtree(p)\n                else:\n                    p.unlink()\n\n        except OSError as e:\n            raise TrestleError(f'Error while updating template folder: {e}')\n        except Exception as e:\n            raise TrestleError(f'Unexpected error while updating template folder: {e}')\n\n    @staticmethod\n    def get_versioned_template_dir(task_path: Path, version: Optional[str] = None) -&gt; Path:\n\"\"\"\n        Get a template folder of the specified version.\n\n        If no version is given, the latest version of template will be returned\n        \"\"\"\n        TemplateVersioning._check_if_exists_and_dir(task_path)\n        latest_path = None\n        if version is None:\n            latest_path, _ = TemplateVersioning.get_latest_version_for_task(task_path)\n        else:\n            latest_path = Path(f'{task_path}/{version}/')\n\n        if not latest_path.exists():\n            raise TrestleError(f'The task: {task_path} with version: {version} does not exists.')\n\n        return latest_path\n\n    @staticmethod\n    def get_latest_version_for_task(task_path: Path) -&gt; Tuple[Path, str]:\n\"\"\"Get latest version of the template for the given task.\"\"\"\n        TemplateVersioning._check_if_exists_and_dir(task_path)\n\n        all_versions = TemplateVersioning.get_all_versions_for_task(task_path)\n        max_version = START_TEMPLATE_VERSION\n\n        if len(all_versions) == 0:\n            logger.debug(f'No template versions were found for task: {task_path}, defaulting to 0.0.1')\n            max_version = START_TEMPLATE_VERSION\n        else:\n            max_version = max(all_versions)\n\n        latest_path = Path(f'{task_path}/{max_version}')\n\n        return latest_path, max_version\n\n    @staticmethod\n    def get_all_versions_for_task(task_path: Path) -&gt; List[str]:\n\"\"\"Get all versions for the task.\"\"\"\n        pattern = re.compile(TEMPLATE_VERSION_REGEX)\n        all_versions = []\n        max_version = START_TEMPLATE_VERSION\n        for p in task_path.iterdir():\n            if p.is_dir() and pattern.search(p.parts[-1]) is not None:\n                match = pattern.search(p.parts[-1]).string\n                all_versions.append(match)\n                if match &gt; max_version:\n                    max_version = match\n\n        return all_versions\n\n    @staticmethod\n    def write_versioned_template(\n        resource_name: str, task_path: Path, target_file: Path, version: Optional[str] = None\n    ) -&gt; None:\n\"\"\"\n        Write a template with the header or metadata of a specified version.\n\n        If no version was given the latest version for the task will be used.\n\n        Args:\n            resource_name:  Template resource name\n            task_path: Task path\n            target_file: File path where template will be written\n            version: return a resource of a specific version\n\n        Returns:\n            A dotted path of a versioned template, list of all available versions\n        \"\"\"\n        TemplateVersioning._check_if_exists_and_dir(task_path)\n        try:\n            templates_resource_path = TRESTLE_RESOURCES + '.templates'\n\n            generic_template = Path(resource_filename(templates_resource_path, resource_name)).resolve()\n            if version is None:\n                _, version = TemplateVersioning.get_latest_version_for_task(task_path)\n\n            # modify header/metadata in the template\n            if generic_template.suffix == MARKDOWN_FILE_EXT:\n                md_api = MarkdownAPI()\n                header, md_body = md_api.processor.read_markdown_wo_processing(generic_template)\n                header[TEMPLATE_VERSION_HEADER] = version\n                md_api.write_markdown_with_header(target_file, header, md_body)\n                logger.debug(f'Successfully written template markdown to {target_file}')\n            elif generic_template.suffix == DRAWIO_FILE_EXT:\n                drawio = DrawIO(generic_template)\n                metadata = drawio.get_metadata()[0]\n                metadata[TEMPLATE_VERSION_HEADER] = version\n\n                drawio.write_drawio_with_metadata(generic_template, metadata, 0, target_file)\n                logger.debug(f'Successfully written template drawio to {target_file}')\n            else:\n                raise TrestleError(f'Unsupported template file extension {generic_template.suffix}')\n        except OSError as e:\n            raise TrestleError(f'Error while updating template folder: {e}')\n\n    @staticmethod\n    def is_valid_version(template_version: str) -&gt; bool:\n\"\"\"Check if the version format is correct.\"\"\"\n        if template_version is None:\n            return True  # we can have empty version\n        if template_version == '0.0.0':\n            return False\n        version_regex = r'^[0-9]+.[0-9]+.[0-9]+$'\n        pattern = re.compile(version_regex)\n        if pattern.search(template_version):\n            return True\n        else:\n            return False\n\n    @staticmethod\n    def _check_if_exists_and_dir(task_path: Path) -&gt; None:\n        if not task_path.exists():\n            raise TrestleError(f'Path: {task_path} does not exists.')\n\n        if not task_path.is_dir():\n            raise TrestleError(f'File {task_path} passed, however template directory is expected.')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning.TemplateVersioning-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning.TemplateVersioning.get_all_versions_for_task","title":"<code>get_all_versions_for_task(task_path)</code>  <code>staticmethod</code>","text":"<p>Get all versions for the task.</p> Source code in <code>trestle/core/commands/author/versioning/template_versioning.py</code> <pre><code>@staticmethod\ndef get_all_versions_for_task(task_path: Path) -&gt; List[str]:\n\"\"\"Get all versions for the task.\"\"\"\n    pattern = re.compile(TEMPLATE_VERSION_REGEX)\n    all_versions = []\n    max_version = START_TEMPLATE_VERSION\n    for p in task_path.iterdir():\n        if p.is_dir() and pattern.search(p.parts[-1]) is not None:\n            match = pattern.search(p.parts[-1]).string\n            all_versions.append(match)\n            if match &gt; max_version:\n                max_version = match\n\n    return all_versions\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning.TemplateVersioning.get_latest_version_for_task","title":"<code>get_latest_version_for_task(task_path)</code>  <code>staticmethod</code>","text":"<p>Get latest version of the template for the given task.</p> Source code in <code>trestle/core/commands/author/versioning/template_versioning.py</code> <pre><code>@staticmethod\ndef get_latest_version_for_task(task_path: Path) -&gt; Tuple[Path, str]:\n\"\"\"Get latest version of the template for the given task.\"\"\"\n    TemplateVersioning._check_if_exists_and_dir(task_path)\n\n    all_versions = TemplateVersioning.get_all_versions_for_task(task_path)\n    max_version = START_TEMPLATE_VERSION\n\n    if len(all_versions) == 0:\n        logger.debug(f'No template versions were found for task: {task_path}, defaulting to 0.0.1')\n        max_version = START_TEMPLATE_VERSION\n    else:\n        max_version = max(all_versions)\n\n    latest_path = Path(f'{task_path}/{max_version}')\n\n    return latest_path, max_version\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning.TemplateVersioning.get_versioned_template_dir","title":"<code>get_versioned_template_dir(task_path, version=None)</code>  <code>staticmethod</code>","text":"<p>Get a template folder of the specified version.</p> <p>If no version is given, the latest version of template will be returned</p> Source code in <code>trestle/core/commands/author/versioning/template_versioning.py</code> <pre><code>@staticmethod\ndef get_versioned_template_dir(task_path: Path, version: Optional[str] = None) -&gt; Path:\n\"\"\"\n    Get a template folder of the specified version.\n\n    If no version is given, the latest version of template will be returned\n    \"\"\"\n    TemplateVersioning._check_if_exists_and_dir(task_path)\n    latest_path = None\n    if version is None:\n        latest_path, _ = TemplateVersioning.get_latest_version_for_task(task_path)\n    else:\n        latest_path = Path(f'{task_path}/{version}/')\n\n    if not latest_path.exists():\n        raise TrestleError(f'The task: {task_path} with version: {version} does not exists.')\n\n    return latest_path\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning.TemplateVersioning.is_valid_version","title":"<code>is_valid_version(template_version)</code>  <code>staticmethod</code>","text":"<p>Check if the version format is correct.</p> Source code in <code>trestle/core/commands/author/versioning/template_versioning.py</code> <pre><code>@staticmethod\ndef is_valid_version(template_version: str) -&gt; bool:\n\"\"\"Check if the version format is correct.\"\"\"\n    if template_version is None:\n        return True  # we can have empty version\n    if template_version == '0.0.0':\n        return False\n    version_regex = r'^[0-9]+.[0-9]+.[0-9]+$'\n    pattern = re.compile(version_regex)\n    if pattern.search(template_version):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning.TemplateVersioning.update_template_folder_structure","title":"<code>update_template_folder_structure(task_path)</code>  <code>staticmethod</code>","text":"<p>Automatically detect whether the path is an old style and update it.</p> <p>An old-style path is a path of the form:  root_folder/.trestle/author/{template_name}/{template_objects} The new version path is a path of the form:  root_folder/.trestle/author/{template_name}/{version}/{template_objects} By default all old-style templates will be updated to version 0.0.1</p> Source code in <code>trestle/core/commands/author/versioning/template_versioning.py</code> <pre><code>@staticmethod\ndef update_template_folder_structure(task_path: Path) -&gt; None:\n\"\"\"\n    Automatically detect whether the path is an old style and update it.\n\n    An old-style path is a path of the form:\n     root_folder/.trestle/author/{template_name}/{template_objects}\n    The new version path is a path of the form:\n     root_folder/.trestle/author/{template_name}/{version}/{template_objects}\n    By default all old-style templates will be updated to version 0.0.1\n    \"\"\"\n    TemplateVersioning._check_if_exists_and_dir(task_path)\n\n    try:\n        all_files_wo_version = list(\n            filter(lambda p: p.is_file(), file_utils.iterdir_without_hidden_files(task_path))\n        )\n\n        pattern = re.compile(TEMPLATE_VERSION_REGEX)\n        all_non_template_directories = list(\n            filter(\n                lambda p: p.is_dir() and pattern.search(p.parts[-1]) is None,\n                file_utils.iterdir_without_hidden_files(task_path)\n            )\n        )\n\n        new_dir = Path(f'{task_path}/{START_TEMPLATE_VERSION}')\n        new_dir.mkdir(parents=True, exist_ok=True)\n\n        if len(all_files_wo_version) == 0:\n            logger.debug('No templates outside of the version folders.')\n            # if the base template folder is empty, delete it\n            if len(list(new_dir.iterdir())) == 0:\n                new_dir.rmdir()\n\n        for f in all_files_wo_version + all_non_template_directories:\n            if f.is_file():\n                shutil.copy(f, new_dir)\n            elif f.is_dir():\n                shutil.copytree(f, new_dir / f.name)\n\n        for p in all_files_wo_version + all_non_template_directories:\n            if p.is_dir():\n                shutil.rmtree(p)\n            else:\n                p.unlink()\n\n    except OSError as e:\n        raise TrestleError(f'Error while updating template folder: {e}')\n    except Exception as e:\n        raise TrestleError(f'Unexpected error while updating template folder: {e}')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.author.versioning.template_versioning/#trestle.core.commands.author.versioning.template_versioning.TemplateVersioning.write_versioned_template","title":"<code>write_versioned_template(resource_name, task_path, target_file, version=None)</code>  <code>staticmethod</code>","text":"<p>Write a template with the header or metadata of a specified version.</p> <p>If no version was given the latest version for the task will be used.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Template resource name</p> required <code>task_path</code> <code>Path</code> <p>Task path</p> required <code>target_file</code> <code>Path</code> <p>File path where template will be written</p> required <code>version</code> <code>Optional[str]</code> <p>return a resource of a specific version</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A dotted path of a versioned template, list of all available versions</p> Source code in <code>trestle/core/commands/author/versioning/template_versioning.py</code> <pre><code>@staticmethod\ndef write_versioned_template(\n    resource_name: str, task_path: Path, target_file: Path, version: Optional[str] = None\n) -&gt; None:\n\"\"\"\n    Write a template with the header or metadata of a specified version.\n\n    If no version was given the latest version for the task will be used.\n\n    Args:\n        resource_name:  Template resource name\n        task_path: Task path\n        target_file: File path where template will be written\n        version: return a resource of a specific version\n\n    Returns:\n        A dotted path of a versioned template, list of all available versions\n    \"\"\"\n    TemplateVersioning._check_if_exists_and_dir(task_path)\n    try:\n        templates_resource_path = TRESTLE_RESOURCES + '.templates'\n\n        generic_template = Path(resource_filename(templates_resource_path, resource_name)).resolve()\n        if version is None:\n            _, version = TemplateVersioning.get_latest_version_for_task(task_path)\n\n        # modify header/metadata in the template\n        if generic_template.suffix == MARKDOWN_FILE_EXT:\n            md_api = MarkdownAPI()\n            header, md_body = md_api.processor.read_markdown_wo_processing(generic_template)\n            header[TEMPLATE_VERSION_HEADER] = version\n            md_api.write_markdown_with_header(target_file, header, md_body)\n            logger.debug(f'Successfully written template markdown to {target_file}')\n        elif generic_template.suffix == DRAWIO_FILE_EXT:\n            drawio = DrawIO(generic_template)\n            metadata = drawio.get_metadata()[0]\n            metadata[TEMPLATE_VERSION_HEADER] = version\n\n            drawio.write_drawio_with_metadata(generic_template, metadata, 0, target_file)\n            logger.debug(f'Successfully written template drawio to {target_file}')\n        else:\n            raise TrestleError(f'Unsupported template file extension {generic_template.suffix}')\n    except OSError as e:\n        raise TrestleError(f'Error while updating template folder: {e}')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.command_docs/","title":"command_docs","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.command_docs/#trestle.core.commands.command_docs","title":"<code>trestle.core.commands.command_docs</code>","text":"<p>Trestle command abstraction.</p> <p>Improves parsing until such a point as ILCLI is fixed.</p>"},{"location":"api_reference/trestle.core.commands.command_docs/#trestle.core.commands.command_docs.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.command_docs/#trestle.core.commands.command_docs-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.command_docs/#trestle.core.commands.command_docs.CommandBase","title":"<code> CommandBase            (Command)         </code>","text":"<p>Linear extension to the ILCLI interface to use documentation string more.</p> <p>Trestle commands not requiring trestle-root should extend from this class.</p> Source code in <code>trestle/core/commands/command_docs.py</code> <pre><code>class CommandBase(Command):\n\"\"\"Linear extension to the ILCLI interface to use documentation string more.\n\n    Trestle commands not requiring trestle-root should extend from this class.\n    \"\"\"\n\n    # Example commands extedning from this class - init', 'trestle', 'version', 'partial-object-validate'\n    def __init__(self, parser=None, parent=None, name=None, out=None, err=None) -&gt; None:\n\"\"\"Override default ILCLI behaviour to include class documentation in command help description.\"\"\"\n        super(CommandBase, self).__init__(parser, parent, name, out, err)\n        self.parser.description = self.__doc__\n</code></pre>"},{"location":"api_reference/trestle.core.commands.command_docs/#trestle.core.commands.command_docs.CommandBase-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.command_docs/#trestle.core.commands.command_docs.CommandBase.__init__","title":"<code>__init__(self, parser=None, parent=None, name=None, out=None, err=None)</code>  <code>special</code>","text":"<p>Override default ILCLI behaviour to include class documentation in command help description.</p> Source code in <code>trestle/core/commands/command_docs.py</code> <pre><code>def __init__(self, parser=None, parent=None, name=None, out=None, err=None) -&gt; None:\n\"\"\"Override default ILCLI behaviour to include class documentation in command help description.\"\"\"\n    super(CommandBase, self).__init__(parser, parent, name, out, err)\n    self.parser.description = self.__doc__\n</code></pre>"},{"location":"api_reference/trestle.core.commands.command_docs/#trestle.core.commands.command_docs.CommandPlusDocs","title":"<code> CommandPlusDocs            (CommandBase)         </code>","text":"<p>This class validates trestle-root argument.</p> <p>Trestle commands requiring trestle-root should extend from this class. All commands that extend this class will validate the state of trestle workspace.</p> Source code in <code>trestle/core/commands/command_docs.py</code> <pre><code>class CommandPlusDocs(CommandBase):\n\"\"\"This class validates trestle-root argument.\n\n    Trestle commands requiring trestle-root should extend from this class.\n    All commands that extend this class will validate the state of trestle workspace.\n    \"\"\"\n\n    def _validate_arguments(self, args):\n\"\"\"Check trestle-root argument is a valid trestle root directory.\"\"\"\n        root = file_utils.extract_trestle_project_root(args.trestle_root)\n        if root is None:\n            logger.error(f'Given directory {args.trestle_root} is not in a valid trestle root directory')\n            return CmdReturnCodes.TRESTLE_ROOT_ERROR.value\n        is_oscal_dir_valid = file_utils.check_oscal_directories(args.trestle_root)\n        if not is_oscal_dir_valid:\n            return CmdReturnCodes.TRESTLE_ROOT_ERROR.value\n        args.trestle_root = root\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.common.cmd_utils/","title":"cmd_utils","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.common.cmd_utils/#trestle.core.commands.common.cmd_utils","title":"<code>trestle.core.commands.common.cmd_utils</code>","text":"<p>Trestle command related utilities.</p>"},{"location":"api_reference/trestle.core.commands.common.cmd_utils/#trestle.core.commands.common.cmd_utils-functions","title":"Functions","text":""},{"location":"api_reference/trestle.core.commands.common.cmd_utils/#trestle.core.commands.common.cmd_utils.clear_folder","title":"<code>clear_folder(folder_path)</code>","text":"<p>Clear all contents of the specified folder.</p> Source code in <code>trestle/core/commands/common/cmd_utils.py</code> <pre><code>def clear_folder(folder_path: pathlib.Path) -&gt; None:\n\"\"\"Clear all contents of the specified folder.\"\"\"\n    if not folder_path.exists() or not folder_path.is_dir():\n        return\n    try:\n        shutil.rmtree(folder_path)\n    except OSError as e:  # pragma: no cover\n        raise TrestleError(f'Error deleting contents of {folder_path}: {e}')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.common.cmd_utils/#trestle.core.commands.common.cmd_utils.model_type_is_too_granular","title":"<code>model_type_is_too_granular(model_type)</code>","text":"<p>Is an model_type too fine to split.</p> Source code in <code>trestle/core/commands/common/cmd_utils.py</code> <pre><code>def model_type_is_too_granular(model_type: Type[Any]) -&gt; bool:\n\"\"\"Is an model_type too fine to split.\"\"\"\n    if type_utils.is_collection_field_type(model_type):\n        return False\n    if hasattr(model_type, '__fields__') and '__root__' in model_type.__fields__:\n        return True\n    if model_type.__name__ in ['str', 'ConstrainedStrValue', 'int', 'float', 'datetime']:\n        return True\n    return False\n</code></pre>"},{"location":"api_reference/trestle.core.commands.common.cmd_utils/#trestle.core.commands.common.cmd_utils.parse_chain","title":"<code>parse_chain(model_obj, path_parts, relative_path=None)</code>","text":"<p>Parse the model chain starting from the beginning.</p> <p>Parameters:</p> Name Type Description Default <code>model_obj</code> <code>Optional[trestle.core.base_model.OscalBaseModel]</code> <p>Model to use for inspecting available elements, if available or none</p> required <code>path_parts</code> <code>List[str]</code> <p>list of string paths to parse including wildcards</p> required <code>relative_path</code> <code>Optional[pathlib.Path]</code> <p>Optional relative path (w.r.t trestle workspace root directory)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[trestle.core.models.elements.ElementPath]</code> <p>List of ElementPath</p> Source code in <code>trestle/core/commands/common/cmd_utils.py</code> <pre><code>def parse_chain(\n    model_obj: Union[OscalBaseModel, None],\n    path_parts: List[str],\n    relative_path: Optional[pathlib.Path] = None\n) -&gt; List[ElementPath]:\n\"\"\"Parse the model chain starting from the beginning.\n\n    Args:\n        model_obj: Model to use for inspecting available elements, if available or none\n        path_parts: list of string paths to parse including wildcards\n        relative_path: Optional relative path (w.r.t trestle workspace root directory)\n\n    Returns:\n        List of ElementPath\n    \"\"\"\n    element_paths: List[ElementPath] = []\n    sub_model = model_obj\n    have_model_to_parse = model_obj is not None\n\n    prev_element_path = None\n    latest_path = None\n    parent_model = path_parts[0]\n    i = 1\n    while i &lt; len(path_parts):\n        p = path_parts[i]\n\n        # if hit wildcard create element path up to this point\n        if p == ElementPath.WILDCARD and len(element_paths) &gt; 0:\n            # append wildcard to the latest element path\n            latest_path = element_paths.pop()\n            if latest_path.get_last() == ElementPath.WILDCARD:\n                raise TrestleError(f'Invalid element path with consecutive {ElementPath.WILDCARD}')\n\n            latest_path_str = ElementPath.PATH_SEPARATOR.join([latest_path.to_string(), p])\n            element_path = ElementPath(latest_path_str, latest_path.get_parent())\n        else:\n            # create and append element_path\n            # at this point sub_model may be a list of items\n            # new element path is needed only if any of the items contains the desired part\n            if p != ElementPath.WILDCARD:\n                new_attrib = str_utils.dash_to_underscore(p)\n                if isinstance(sub_model, list):\n                    for item in sub_model:\n                        # go into the list and find one with requested part\n                        sub_item = getattr(item, new_attrib, None)\n                        if sub_item is not None:\n                            sub_model = sub_item\n                            break\n                else:\n                    sub_model = getattr(sub_model, new_attrib, None)\n            if have_model_to_parse and sub_model is None:\n                return element_paths\n            p = ElementPath.PATH_SEPARATOR.join([parent_model, p])\n            element_path = ElementPath(p, parent_path=prev_element_path)\n\n        # If the path has wildcard and there are more parts later,\n        # get the parent model for the alias path\n        # If path has wildcard and it does not refer to a list, then there can be nothing after *\n        if element_path.get_last() == ElementPath.WILDCARD:\n            full_path_str = ElementPath.PATH_SEPARATOR.join(element_path.get_full_path_parts()[:-1])\n            parent_model = ModelUtils.get_singular_alias(full_path_str, relative_path)\n            # Does wildcard mean we need to inspect the sub_model to determine what can be split off from it?\n            # If it has __root__ it may mean it contains a list of objects and should be split as a list\n            if isinstance(sub_model, OscalBaseModel):\n                root = getattr(sub_model, '__root__', None)\n                if root is None or not isinstance(root, list):\n                    # Cannot have parts beyond * if it isn't a list\n                    if i &lt; len(path_parts) - 1:\n                        raise TrestleError(\n                            f'Cannot split beyond * when the wildcard does not refer to a list.  Path: {path_parts}'\n                        )\n                    for key in sub_model.__fields__.keys():\n                        # only create element path is item is present in the sub_model\n                        if getattr(sub_model, key, None) is None:\n                            continue\n                        new_alias = str_utils.underscore_to_dash(key)\n                        new_path = full_path_str + '.' + new_alias\n                        if not split_is_too_fine(new_path, model_obj):\n                            # to add parts of an element, need to add two links\n                            # prev_element_path may be None, for example catalog.*\n                            if prev_element_path is not None:\n                                element_paths.append(prev_element_path)\n                            element_paths.append(ElementPath(parent_model + '.' + new_alias, latest_path))\n                    # Since wildcard is last in the chain when splitting an oscal model we are done\n                    return element_paths\n        else:\n            parent_model = element_path.get_element_name()\n\n        # store values for next cycle\n        prev_element_path = element_path\n        element_paths.append(element_path)\n        i += 1\n    return element_paths\n</code></pre>"},{"location":"api_reference/trestle.core.commands.common.cmd_utils/#trestle.core.commands.common.cmd_utils.parse_element_arg","title":"<code>parse_element_arg(model_obj, element_arg, relative_path=None)</code>","text":"<p>Parse an element arg string into a list of ElementPath.</p> <p>Parameters:</p> Name Type Description Default <code>model_obj</code> <code>Optional[trestle.core.base_model.OscalBaseModel]</code> <p>The OscalBaseModel being inspected to determine available elements that can be split</p> required <code>element_arg</code> <code>str</code> <p>Single element path, as a string.</p> required <code>relative_path</code> <code>Optional[pathlib.Path]</code> <p>Optional relative path (from trestle root) used to validate element args are valid.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[trestle.core.models.elements.ElementPath]</code> <p>The requested parsed list of ElementPath for use in split</p> Source code in <code>trestle/core/commands/common/cmd_utils.py</code> <pre><code>def parse_element_arg(\n    model_obj: Union[OscalBaseModel, None],\n    element_arg: str,\n    relative_path: Optional[pathlib.Path] = None\n) -&gt; List[ElementPath]:\n\"\"\"Parse an element arg string into a list of ElementPath.\n\n    Args:\n        model_obj: The OscalBaseModel being inspected to determine available elements that can be split\n        element_arg: Single element path, as a string.\n        relative_path: Optional relative path (from trestle root) used to validate element args are valid.\n    Returns:\n        The requested parsed list of ElementPath for use in split\n    \"\"\"\n    element_arg = element_arg.strip()\n\n    if element_arg == '*':\n        raise TrestleError('Invalid element path containing only a single wildcard.')\n\n    if element_arg == '':\n        raise TrestleError('Invalid element path is empty string.')\n\n    # search for wildcards and create paths with its parent path\n    path_parts = element_arg.split(ElementPath.PATH_SEPARATOR)\n    if len(path_parts) &lt;= 1:\n        raise TrestleError(f'Invalid element path \"{element_arg}\" with only one element and no wildcard')\n\n    element_paths = parse_chain(model_obj, path_parts, relative_path)\n\n    if len(element_paths) &lt;= 0:\n        # don't complain if nothing to split\n        pass\n\n    return element_paths\n</code></pre>"},{"location":"api_reference/trestle.core.commands.common.cmd_utils/#trestle.core.commands.common.cmd_utils.parse_element_args","title":"<code>parse_element_args(model, element_args, relative_path=None)</code>","text":"<p>Parse element args into a list of ElementPath.</p> <p>The element paths are either simple links of two elements, or two elements followed by *. The * represents either a list of the items in that element, or a splitting of that element into its parts. The only parts split off are the non-trivial ones determined by the granularity check.</p> <p>contextual_mode specifies if the path is a valid project model path or not. For example, if we are processing a metadata.parties.*, we need to know which metadata we are processing. If we pass contextual_mode=true, we can infer the root model by inspecting the file directory</p> <p>If contextual_mode=False, then the path must include the full path, e.g. catalog.metadata.parties. instead of just metadata.parties.</p> <p>When the * represents splitting a model rather than a list, the model is inspected for what parts are available, and for each new part two element paths are created, one for the parent to the current element, and another from the current element to the child.</p> <p>A path may have multiple *'s, but only the final one can represent splitting a model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Optional[trestle.core.base_model.OscalBaseModel]</code> <p>The OscalBaseModel being inspected to determine available elements that can be split</p> required <code>element_args</code> <code>List[str]</code> <p>List of str representing links in the chain of element paths to be parsed</p> required <code>relative_path</code> <code>Optional[pathlib.Path]</code> <p>Optional relative path (from trestle root) used to validate element args are valid.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[trestle.core.models.elements.ElementPath]</code> <p>The requested parsed list of ElementPath for use in split</p> Source code in <code>trestle/core/commands/common/cmd_utils.py</code> <pre><code>def parse_element_args(\n    model: Union[OscalBaseModel, None],\n    element_args: List[str],\n    relative_path: Optional[pathlib.Path] = None\n) -&gt; List[ElementPath]:\n\"\"\"Parse element args into a list of ElementPath.\n\n    The element paths are either simple links of two elements, or two elements followed by *.\n    The * represents either a list of the items in that element, or a splitting of that element into its parts.\n    The only parts split off are the non-trivial ones determined by the granularity check.\n\n    contextual_mode specifies if the path is a valid project model path or not. For example,\n    if we are processing a metadata.parties.*, we need to know which metadata we are processing. If we pass\n    contextual_mode=true, we can infer the root model by inspecting the file directory\n\n    If contextual_mode=False, then the path must include the full path, e.g. catalog.metadata.parties.* instead of just\n    metadata.parties.*\n\n    When the * represents splitting a model rather than a list, the model is inspected for what parts are available,\n    and for each new part two element paths are created, one for the parent to the current element, and another from\n    the current element to the child.\n\n    A path may have multiple *'s, but only the final one can represent splitting a model.\n\n    Args:\n        model: The OscalBaseModel being inspected to determine available elements that can be split\n        element_args: List of str representing links in the chain of element paths to be parsed\n        relative_path: Optional relative path (from trestle root) used to validate element args are valid.\n    Returns:\n        The requested parsed list of ElementPath for use in split\n    \"\"\"\n    # collect all paths\n    element_paths: List[ElementPath] = []\n    for element_arg in element_args:\n        paths = parse_element_arg(model, element_arg, relative_path)\n        element_paths.extend(paths)\n\n    return element_paths\n</code></pre>"},{"location":"api_reference/trestle.core.commands.common.cmd_utils/#trestle.core.commands.common.cmd_utils.split_is_too_fine","title":"<code>split_is_too_fine(split_paths, model_obj)</code>","text":"<p>Determine if the element path list goes too fine, e.g. individual strings.</p> Source code in <code>trestle/core/commands/common/cmd_utils.py</code> <pre><code>def split_is_too_fine(split_paths: str, model_obj: OscalBaseModel) -&gt; bool:\n\"\"\"Determine if the element path list goes too fine, e.g. individual strings.\"\"\"\n    for split_path in split_paths.split(','):\n        # find model type one level above if finishing with '.*'\n        model_type = ElementPath(split_path.rstrip('.*')).get_type(type(model_obj))\n        if model_type_is_too_granular(model_type):\n            return True\n    return False\n</code></pre>"},{"location":"api_reference/trestle.core.commands.common.cmd_utils/#trestle.core.commands.common.cmd_utils.to_model_file_name","title":"<code>to_model_file_name(model_obj, file_prefix, content_type)</code>","text":"<p>Return the file name for the item.</p> Source code in <code>trestle/core/commands/common/cmd_utils.py</code> <pre><code>def to_model_file_name(model_obj: OscalBaseModel, file_prefix: str, content_type: FileContentType) -&gt; str:\n\"\"\"Return the file name for the item.\"\"\"\n    file_ext = FileContentType.to_file_extension(content_type)\n    model_type = classname_to_alias(type(model_obj).__name__, AliasMode.JSON)\n    file_name = f'{file_prefix}{const.IDX_SEP}{model_type}{file_ext}'\n    return file_name\n</code></pre>"},{"location":"api_reference/trestle.core.commands.common.return_codes/","title":"return_codes","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes","title":"<code>trestle.core.commands.common.return_codes</code>","text":"<p>Trestle command return codes.</p>"},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes","title":"<code> CmdReturnCodes            (Enum)         </code>","text":"<p>Trestle CLI return codes.</p> <p>SUCCESS - Operation/validation completed successfully COMMAND_ERROR - Generic expected error while executing command (handled by command) INCORRECT_ARGS - Provided arguments were incorrect/incomplete DOCUMENTS_VALIDATION_ERROR - Validation of the markdown or drawio files failed MODEL_VALIDATION_ERROR - Validation of OSCAL model failed TRESTLE_ROOT_ERROR - Workspace setup has failed, the root is not trestle directory IO_ERROR - IO related errors, i.e. permission issue, non-existing file, etc AUTH_ERROR - Authenication error while accessing/storing cache UNKNOWN_ERROR - Unexpected error (unhandled by command) INVALID_MODEL - Loaded model is invalid</p> Source code in <code>trestle/core/commands/common/return_codes.py</code> <pre><code>class CmdReturnCodes(enum.Enum):\n\"\"\"\n    Trestle CLI return codes.\n\n    SUCCESS - Operation/validation completed successfully\n    COMMAND_ERROR - Generic expected error while executing command (handled by command)\n    INCORRECT_ARGS - Provided arguments were incorrect/incomplete\n    DOCUMENTS_VALIDATION_ERROR - Validation of the markdown or drawio files failed\n    MODEL_VALIDATION_ERROR - Validation of OSCAL model failed\n    TRESTLE_ROOT_ERROR - Workspace setup has failed, the root is not trestle directory\n    IO_ERROR - IO related errors, i.e. permission issue, non-existing file, etc\n    AUTH_ERROR - Authenication error while accessing/storing cache\n    UNKNOWN_ERROR - Unexpected error (unhandled by command)\n    INVALID_MODEL - Loaded model is invalid\n    \"\"\"\n\n    SUCCESS = 0\n    COMMAND_ERROR = 1\n    INCORRECT_ARGS = 2\n    DOCUMENTS_VALIDATION_ERROR = 3\n    OSCAL_VALIDATION_ERROR = 4\n    TRESTLE_ROOT_ERROR = 5\n    IO_ERROR = 6\n    AUTH_ERROR = 7\n    UNKNOWN_ERROR = 8\n</code></pre>"},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes.AUTH_ERROR","title":"<code>AUTH_ERROR</code>","text":""},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes.COMMAND_ERROR","title":"<code>COMMAND_ERROR</code>","text":""},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes.DOCUMENTS_VALIDATION_ERROR","title":"<code>DOCUMENTS_VALIDATION_ERROR</code>","text":""},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes.INCORRECT_ARGS","title":"<code>INCORRECT_ARGS</code>","text":""},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes.IO_ERROR","title":"<code>IO_ERROR</code>","text":""},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes.OSCAL_VALIDATION_ERROR","title":"<code>OSCAL_VALIDATION_ERROR</code>","text":""},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes.SUCCESS","title":"<code>SUCCESS</code>","text":""},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes.TRESTLE_ROOT_ERROR","title":"<code>TRESTLE_ROOT_ERROR</code>","text":""},{"location":"api_reference/trestle.core.commands.common.return_codes/#trestle.core.commands.common.return_codes.CmdReturnCodes.UNKNOWN_ERROR","title":"<code>UNKNOWN_ERROR</code>","text":""},{"location":"api_reference/trestle.core.commands.create/","title":"create","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.create/#trestle.core.commands.create","title":"<code>trestle.core.commands.create</code>","text":"<p>Trestle Create CommandPlusDocs.</p>"},{"location":"api_reference/trestle.core.commands.create/#trestle.core.commands.create.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.create/#trestle.core.commands.create-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.create/#trestle.core.commands.create.CreateCmd","title":"<code> CreateCmd            (CommandPlusDocs)         </code>","text":"<p>Create a sample OSCAL model in trestle workspace or create new elements within a given model.</p> Source code in <code>trestle/core/commands/create.py</code> <pre><code>class CreateCmd(CommandPlusDocs):\n\"\"\"Create a sample OSCAL model in trestle workspace or create new elements within a given model.\"\"\"\n\n    name = 'create'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument('-t', '--type', help='Type of model if created anew.', choices=const.MODEL_TYPE_LIST)\n        self.add_argument('-o', '--output', help='Name of the output created model.')\n        self.add_argument(const.IOF_SHORT, const.IOF_LONG, help=const.IOF_HELP, action='store_true')\n        self.add_argument(\n            '-x', '--extension', help='Type of file output.', choices=['json', 'yaml', 'yml'], default='json'\n        )\n        self.add_argument(\n            '-f', '--file', help='Optional existing OSCAL file that will have elements created within it.', type=str\n        )\n        self.add_argument(\n            '-e', '--element', help='Optional path of element to be created whithin the specified file.', type=str\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n\"\"\"\n        Execute the create command.\n\n        Notes\n            Either a new model will be created of the specified type,\n            or an existing file will have new elements added within it.\n        \"\"\"\n        try:\n            # Normal create path\n            if args.type and args.output:\n                object_type = ElementPath(args.type).get_type()\n                return self.create_object(args.type, object_type, args)\n            # Add path\n            elif args.file and args.element:\n                add = Add()\n                return add.add_from_args(args)\n\n            raise err.TrestleIncorrectArgsError(\n                'Create requires either a model type and output name, or a file and element path.'\n            )\n\n        except Exception as e:  # pragma: no cover\n            return err.handle_generic_command_exception(e, logger, 'Error while creating a sample OSCAL model')\n\n    @classmethod\n    def create_object(cls, model_alias: str, object_type: Type[TopLevelOscalModel], args: argparse.Namespace) -&gt; int:\n\"\"\"Create a top level OSCAL object within the trestle directory, leveraging functionality in add.\"\"\"\n        log.set_log_level_from_args(args)\n        trestle_root = args.trestle_root  # trestle root is set via command line in args. Default is cwd.\n        if not trestle_root or not file_utils.is_valid_project_root(args.trestle_root):\n            raise err.TrestleRootError(f'Given directory {trestle_root} is not a trestle project.')\n\n        plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n\n        desired_model_dir = trestle_root / plural_path / args.output\n\n        desired_model_path = desired_model_dir / (model_alias + '.' + args.extension)\n\n        if desired_model_path.exists():\n            raise err.TrestleError(f'OSCAL file to be created here: {desired_model_path} exists.')\n\n        # Create sample model.\n        sample_model = generators.generate_sample_model(object_type, include_optional=args.include_optional_fields)\n        # Presuming top level level model not sure how to do the typing for this.\n        sample_model.metadata.title = f'Generic {model_alias} created by trestle named {args.output}.'\n        sample_model.metadata.last_modified = datetime.now().astimezone()\n        sample_model.metadata.oscal_version = trestle.oscal.OSCAL_VERSION\n        sample_model.metadata.version = '0.0.0'\n\n        top_element = Element(sample_model, model_alias)\n\n        create_action = CreatePathAction(desired_model_path.resolve(), True)\n        write_action = WriteFileAction(\n            desired_model_path.resolve(), top_element, FileContentType.to_content_type(desired_model_path.suffix)\n        )\n\n        # create a plan to write the directory and file.\n        create_plan = Plan()\n        create_plan.add_action(create_action)\n        create_plan.add_action(write_action)\n        create_plan.execute()\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.create/#trestle.core.commands.create.CreateCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.create/#trestle.core.commands.create.CreateCmd-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.create/#trestle.core.commands.create.CreateCmd.create_object","title":"<code>create_object(model_alias, object_type, args)</code>  <code>classmethod</code>","text":"<p>Create a top level OSCAL object within the trestle directory, leveraging functionality in add.</p> Source code in <code>trestle/core/commands/create.py</code> <pre><code>@classmethod\ndef create_object(cls, model_alias: str, object_type: Type[TopLevelOscalModel], args: argparse.Namespace) -&gt; int:\n\"\"\"Create a top level OSCAL object within the trestle directory, leveraging functionality in add.\"\"\"\n    log.set_log_level_from_args(args)\n    trestle_root = args.trestle_root  # trestle root is set via command line in args. Default is cwd.\n    if not trestle_root or not file_utils.is_valid_project_root(args.trestle_root):\n        raise err.TrestleRootError(f'Given directory {trestle_root} is not a trestle project.')\n\n    plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n\n    desired_model_dir = trestle_root / plural_path / args.output\n\n    desired_model_path = desired_model_dir / (model_alias + '.' + args.extension)\n\n    if desired_model_path.exists():\n        raise err.TrestleError(f'OSCAL file to be created here: {desired_model_path} exists.')\n\n    # Create sample model.\n    sample_model = generators.generate_sample_model(object_type, include_optional=args.include_optional_fields)\n    # Presuming top level level model not sure how to do the typing for this.\n    sample_model.metadata.title = f'Generic {model_alias} created by trestle named {args.output}.'\n    sample_model.metadata.last_modified = datetime.now().astimezone()\n    sample_model.metadata.oscal_version = trestle.oscal.OSCAL_VERSION\n    sample_model.metadata.version = '0.0.0'\n\n    top_element = Element(sample_model, model_alias)\n\n    create_action = CreatePathAction(desired_model_path.resolve(), True)\n    write_action = WriteFileAction(\n        desired_model_path.resolve(), top_element, FileContentType.to_content_type(desired_model_path.suffix)\n    )\n\n    # create a plan to write the directory and file.\n    create_plan = Plan()\n    create_plan.add_action(create_action)\n    create_plan.add_action(write_action)\n    create_plan.execute()\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.describe/","title":"describe","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.describe/#trestle.core.commands.describe","title":"<code>trestle.core.commands.describe</code>","text":"<p>Trestle Describe Command.</p>"},{"location":"api_reference/trestle.core.commands.describe/#trestle.core.commands.describe.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.describe/#trestle.core.commands.describe-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.describe/#trestle.core.commands.describe.DescribeCmd","title":"<code> DescribeCmd            (CommandPlusDocs)         </code>","text":"<p>Describe contents of a model file including optional element path.</p> Source code in <code>trestle/core/commands/describe.py</code> <pre><code>class DescribeCmd(CommandPlusDocs):\n\"\"\"Describe contents of a model file including optional element path.\"\"\"\n\n    # The only output is via log lines.  No other results or side-effects.\n\n    name = 'describe'\n\n    def _init_arguments(self) -&gt; None:\n        logger.debug('Init arguments')\n        self.add_argument('-f', '--file', help='OSCAL file to import.', type=str, required=True)\n\n        self.add_argument(\n            '-e', '--element', help='Optional name of element in file to describe.', type=str, required=False\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            logger.debug('Entering trestle describe.')\n\n            log.set_log_level_from_args(args)\n\n            if args.file:\n                model_file = pathlib.Path(args.file)\n\n                element = '' if not args.element else args.element.strip(\"'\")\n                results = self.describe(model_file.resolve(), element, args.trestle_root)\n\n                return CmdReturnCodes.SUCCESS.value if len(results) &gt; 0 else CmdReturnCodes.COMMAND_ERROR.value\n            else:\n                raise TrestleIncorrectArgsError('No file specified for command describe.')\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while describing contents of a model')\n\n    @classmethod\n    def _clean_type_string(cls, text: str) -&gt; str:\n        text = text.replace(\"&lt;class '\", '').replace(\"'&gt;\", '')\n        text = text.replace('trestle.oscal.', '')\n        text = text.replace('pydantic.main.', 'stripped.')\n        return text\n\n    @classmethod\n    def _description_text(cls, sub_model: OscalBaseModel) -&gt; str:\n        clip_string = 100\n        if sub_model is None:\n            return 'None'\n        if type(sub_model) is list:\n            n_items = len(sub_model)\n            type_text = 'Unknown' if not n_items else f'{cls._clean_type_string(str(type(sub_model[0])))}'\n            text = f'list of {n_items} items of type {type_text}'\n            return text\n        if type(sub_model) is str:\n            return sub_model if len(sub_model) &lt; clip_string else sub_model[:clip_string] + '[truncated]'\n        if hasattr(sub_model, 'type_'):\n            return cls._clean_type_string(str(sub_model.type_))\n        return cls._clean_type_string(str(type(sub_model)))\n\n    @classmethod\n    def describe(cls, file_path: pathlib.Path, element_path_str: str, trestle_root: pathlib.Path) -&gt; List[str]:\n\"\"\"Describe the contents of the file.\n\n        Args:\n            file_path: pathlib.Path Path for model file to describe.\n            element_path_str: Element path of element in model to describe.  Can be ''.\n\n        Returns:\n            The list of lines of text in the description, or an empty list on failure\n        \"\"\"\n        # figure out the model type so we can read it\n        try:\n            model_type, _ = ModelUtils.get_stripped_model_type(file_path, trestle_root)\n            model: OscalBaseModel = model_type.oscal_read(file_path)\n        except TrestleError as e:\n            logger.warning(f'Error loading model {file_path} to describe: {e}')\n            return []\n\n        sub_model = model\n\n        # if an element path was provided, follow the path chain to the desired sub_model\n        if element_path_str:\n            if '*' in element_path_str or ',' in element_path_str:\n                logger.warning('Wildcards and commas are not allowed in the element path for describe.')\n                return []\n\n            if '.' not in element_path_str:\n                logger.warning('The element path for describe must either be omitted or contain at least 2 parts.')\n                return []\n\n            element_paths = utils.parse_element_arg(model, element_path_str)\n\n            sub_model_element = Element(model)\n\n            for element_path in element_paths:\n                sub_model = sub_model_element.get_at(element_path, False)\n                sub_model_element = Element(sub_model)\n\n        # now that we have the desired sub_model we can describe it\n\n        text_out: List[str] = []\n\n        # create top level text depending on whether an element path was used\n        element_text = '' if not element_path_str else f' at element path {element_path_str}'\n\n        if type(sub_model) is list:\n            text = f'Model file {file_path}{element_text} is a {cls._description_text(sub_model)}'\n            text_out.append(text)\n            logger.info(text)\n        else:\n            text = f'Model file {file_path}{element_text} is of type '\n            text += f'{cls._clean_type_string(str(type(sub_model)))} and contains:'\n            text_out.append(text)\n            logger.info(text)\n            for key in sub_model.__fields__.keys():\n                value = getattr(sub_model, key, None)\n                text = f'    {key}: {cls._description_text(value)}'\n                text_out.append(text)\n                logger.info(text)\n\n        return text_out\n</code></pre>"},{"location":"api_reference/trestle.core.commands.describe/#trestle.core.commands.describe.DescribeCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.describe/#trestle.core.commands.describe.DescribeCmd-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.describe/#trestle.core.commands.describe.DescribeCmd.describe","title":"<code>describe(file_path, element_path_str, trestle_root)</code>  <code>classmethod</code>","text":"<p>Describe the contents of the file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>pathlib.Path Path for model file to describe.</p> required <code>element_path_str</code> <code>str</code> <p>Element path of element in model to describe.  Can be ''.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The list of lines of text in the description, or an empty list on failure</p> Source code in <code>trestle/core/commands/describe.py</code> <pre><code>@classmethod\ndef describe(cls, file_path: pathlib.Path, element_path_str: str, trestle_root: pathlib.Path) -&gt; List[str]:\n\"\"\"Describe the contents of the file.\n\n    Args:\n        file_path: pathlib.Path Path for model file to describe.\n        element_path_str: Element path of element in model to describe.  Can be ''.\n\n    Returns:\n        The list of lines of text in the description, or an empty list on failure\n    \"\"\"\n    # figure out the model type so we can read it\n    try:\n        model_type, _ = ModelUtils.get_stripped_model_type(file_path, trestle_root)\n        model: OscalBaseModel = model_type.oscal_read(file_path)\n    except TrestleError as e:\n        logger.warning(f'Error loading model {file_path} to describe: {e}')\n        return []\n\n    sub_model = model\n\n    # if an element path was provided, follow the path chain to the desired sub_model\n    if element_path_str:\n        if '*' in element_path_str or ',' in element_path_str:\n            logger.warning('Wildcards and commas are not allowed in the element path for describe.')\n            return []\n\n        if '.' not in element_path_str:\n            logger.warning('The element path for describe must either be omitted or contain at least 2 parts.')\n            return []\n\n        element_paths = utils.parse_element_arg(model, element_path_str)\n\n        sub_model_element = Element(model)\n\n        for element_path in element_paths:\n            sub_model = sub_model_element.get_at(element_path, False)\n            sub_model_element = Element(sub_model)\n\n    # now that we have the desired sub_model we can describe it\n\n    text_out: List[str] = []\n\n    # create top level text depending on whether an element path was used\n    element_text = '' if not element_path_str else f' at element path {element_path_str}'\n\n    if type(sub_model) is list:\n        text = f'Model file {file_path}{element_text} is a {cls._description_text(sub_model)}'\n        text_out.append(text)\n        logger.info(text)\n    else:\n        text = f'Model file {file_path}{element_text} is of type '\n        text += f'{cls._clean_type_string(str(type(sub_model)))} and contains:'\n        text_out.append(text)\n        logger.info(text)\n        for key in sub_model.__fields__.keys():\n            value = getattr(sub_model, key, None)\n            text = f'    {key}: {cls._description_text(value)}'\n            text_out.append(text)\n            logger.info(text)\n\n    return text_out\n</code></pre>"},{"location":"api_reference/trestle.core.commands.href/","title":"href","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.href/#trestle.core.commands.href","title":"<code>trestle.core.commands.href</code>","text":"<p>Trestle Href Command.</p>"},{"location":"api_reference/trestle.core.commands.href/#trestle.core.commands.href.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.href/#trestle.core.commands.href-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.href/#trestle.core.commands.href.HrefCmd","title":"<code> HrefCmd            (CommandPlusDocs)         </code>","text":"<p>Change href of import in profile to point to catalog in trestle workspace.</p> <p>This command is needed when generating an SSP with a profile that imports a catalog from a temporary location different from the final intended location of the catalog.  Omit the href argument to see the list of current imports in the profile.</p> Source code in <code>trestle/core/commands/href.py</code> <pre><code>class HrefCmd(CommandPlusDocs):\n\"\"\"Change href of import in profile to point to catalog in trestle workspace.\n\n    This command is needed when generating an SSP with a profile that imports a catalog from a temporary\n    location different from the final intended location of the catalog.  Omit the href argument to see\n    the list of current imports in the profile.\n    \"\"\"\n\n    name = 'href'\n\n    def _init_arguments(self) -&gt; None:\n        logger.debug('Init arguments')\n        self.add_argument(\n            '-n', '--name', help='Name of trestle profile to modify (just its name).', type=str, required=True\n        )\n\n        self.add_argument(\n            '-hr',\n            '--href',\n            help='New href of form trestle://catalogs/mycat/catalog.json.',\n            type=str,\n            required=False,\n            default=''\n        )\n\n        self.add_argument(\n            '-i',\n            '--item',\n            help='Item number of href to modify.  Get list by running href with just -n &lt;prof_name&gt; to list values.',\n            type=int,\n            required=False,\n            default=0\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            logger.debug('Entering trestle href.')\n\n            log.set_log_level_from_args(args)\n\n            profile_name: str = args.name\n\n            new_href: str = args.href.strip(\"'\")\n\n            item_num = args.item\n\n            return self.change_import_href(args.trestle_root, profile_name, new_href, item_num)\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, f'Error while changing href or import in profile: {e}')\n\n    @classmethod\n    def change_import_href(cls, trestle_root: pathlib.Path, profile_name: str, new_href: str, import_num: int) -&gt; int:\n\"\"\"Change the href of the import in the profile to point to a catalog in a specific location.\n\n        A Profile has an Imports list containing at least one href of a catalog or profile to be imported.\n        If the item being referenced is currently in the same trestle workspace as the main profile, the original\n        href is likely different from the one needed to access the item from the profile.  Therefore,\n        in order for trestle to find the item directly from the profile, the href must be modified in a way that\n        trestle can load it.\n\n        If the item is already at the link referred to by the href as a valid URI or absolute file path then no\n        change is needed.  But if the item is being worked on in the same trestle directory as the profile,\n        the href should be modified to something like trestle://catalogs/my_catalog/catalog.json\n\n        This change only needs to be made once to the profile while the profile is being used to generate SSP's\n        from the local item, but if the final profile is released the href would need to be changed to the\n        intended final location of the referenced item.\n\n        Args:\n            trestle_root: trestle_root for this call\n            profile_name: Name of profile already imported into trestle containing href's to be changed\n            new_href: New value for the href of the import.  If blank just list the hrefs\n            import_num: Item number of the href to change.\n\n\n        Returns:\n            0 on success, 1 on failure\n\n        Assumptions and requirements:\n            The profile must be a valid profile in the trestle workspace.\n            The import must either be a valid uri, including local file, or trestle://\n            The original href is not checked and will be overwritten.\n            If href is the empty string, just list all hrefs.\n\n        Future work:\n            Allow multiple imports with matching hrefs.\n            Allow href to point to profile in trestle rather than catalog, and by name.\n            Allow full chaining of linked catalogs and profiles.\n\n        \"\"\"\n        profile_data, profile_path = load_validate_model_name(trestle_root, profile_name, Profile)\n        n_imports = len(profile_data.imports)\n        if not new_href:\n            logger.info(f'List of imports for profile {profile_name}:')\n            for ii, import_ in enumerate(profile_data.imports):\n                logger.info(f'{ii:2}: {import_.href}')\n            return CmdReturnCodes.SUCCESS.value\n        if n_imports &lt;= import_num:\n            raise TrestleError(f'Import number {import_num} is too large.  This profile has only {n_imports} imports.')\n\n        logger.info(f'Changing import {import_num} in profile {profile_name} from, to:')\n        logger.info(f'{profile_data.imports[import_num].href}')\n        logger.info(f'{new_href}')\n        profile_data.imports[import_num].href = new_href\n        profile_data.oscal_write(profile_path)\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.href/#trestle.core.commands.href.HrefCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.href/#trestle.core.commands.href.HrefCmd-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.href/#trestle.core.commands.href.HrefCmd.change_import_href","title":"<code>change_import_href(trestle_root, profile_name, new_href, import_num)</code>  <code>classmethod</code>","text":"<p>Change the href of the import in the profile to point to a catalog in a specific location.</p> <p>A Profile has an Imports list containing at least one href of a catalog or profile to be imported. If the item being referenced is currently in the same trestle workspace as the main profile, the original href is likely different from the one needed to access the item from the profile.  Therefore, in order for trestle to find the item directly from the profile, the href must be modified in a way that trestle can load it.</p> <p>If the item is already at the link referred to by the href as a valid URI or absolute file path then no change is needed.  But if the item is being worked on in the same trestle directory as the profile, the href should be modified to something like trestle://catalogs/my_catalog/catalog.json</p> <p>This change only needs to be made once to the profile while the profile is being used to generate SSP's from the local item, but if the final profile is released the href would need to be changed to the intended final location of the referenced item.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>trestle_root for this call</p> required <code>profile_name</code> <code>str</code> <p>Name of profile already imported into trestle containing href's to be changed</p> required <code>new_href</code> <code>str</code> <p>New value for the href of the import.  If blank just list the hrefs</p> required <code>import_num</code> <code>int</code> <p>Item number of the href to change.</p> required <p>Returns:</p> Type Description <code>int</code> <p>0 on success, 1 on failure</p> <p>Assumptions and requirements:     The profile must be a valid profile in the trestle workspace.     The import must either be a valid uri, including local file, or trestle://     The original href is not checked and will be overwritten.     If href is the empty string, just list all hrefs.</p> <p>Future work:     Allow multiple imports with matching hrefs.     Allow href to point to profile in trestle rather than catalog, and by name.     Allow full chaining of linked catalogs and profiles.</p> Source code in <code>trestle/core/commands/href.py</code> <pre><code>@classmethod\ndef change_import_href(cls, trestle_root: pathlib.Path, profile_name: str, new_href: str, import_num: int) -&gt; int:\n\"\"\"Change the href of the import in the profile to point to a catalog in a specific location.\n\n    A Profile has an Imports list containing at least one href of a catalog or profile to be imported.\n    If the item being referenced is currently in the same trestle workspace as the main profile, the original\n    href is likely different from the one needed to access the item from the profile.  Therefore,\n    in order for trestle to find the item directly from the profile, the href must be modified in a way that\n    trestle can load it.\n\n    If the item is already at the link referred to by the href as a valid URI or absolute file path then no\n    change is needed.  But if the item is being worked on in the same trestle directory as the profile,\n    the href should be modified to something like trestle://catalogs/my_catalog/catalog.json\n\n    This change only needs to be made once to the profile while the profile is being used to generate SSP's\n    from the local item, but if the final profile is released the href would need to be changed to the\n    intended final location of the referenced item.\n\n    Args:\n        trestle_root: trestle_root for this call\n        profile_name: Name of profile already imported into trestle containing href's to be changed\n        new_href: New value for the href of the import.  If blank just list the hrefs\n        import_num: Item number of the href to change.\n\n\n    Returns:\n        0 on success, 1 on failure\n\n    Assumptions and requirements:\n        The profile must be a valid profile in the trestle workspace.\n        The import must either be a valid uri, including local file, or trestle://\n        The original href is not checked and will be overwritten.\n        If href is the empty string, just list all hrefs.\n\n    Future work:\n        Allow multiple imports with matching hrefs.\n        Allow href to point to profile in trestle rather than catalog, and by name.\n        Allow full chaining of linked catalogs and profiles.\n\n    \"\"\"\n    profile_data, profile_path = load_validate_model_name(trestle_root, profile_name, Profile)\n    n_imports = len(profile_data.imports)\n    if not new_href:\n        logger.info(f'List of imports for profile {profile_name}:')\n        for ii, import_ in enumerate(profile_data.imports):\n            logger.info(f'{ii:2}: {import_.href}')\n        return CmdReturnCodes.SUCCESS.value\n    if n_imports &lt;= import_num:\n        raise TrestleError(f'Import number {import_num} is too large.  This profile has only {n_imports} imports.')\n\n    logger.info(f'Changing import {import_num} in profile {profile_name} from, to:')\n    logger.info(f'{profile_data.imports[import_num].href}')\n    logger.info(f'{new_href}')\n    profile_data.imports[import_num].href = new_href\n    profile_data.oscal_write(profile_path)\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.import_/","title":"import_","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.import_/#trestle.core.commands.import_","title":"<code>trestle.core.commands.import_</code>","text":"<p>Trestle Import Command.</p>"},{"location":"api_reference/trestle.core.commands.import_/#trestle.core.commands.import_.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.import_/#trestle.core.commands.import_-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.import_/#trestle.core.commands.import_.ImportCmd","title":"<code> ImportCmd            (CommandPlusDocs)         </code>","text":"<p>Import an existing full OSCAL model into the trestle workspace.</p> Source code in <code>trestle/core/commands/import_.py</code> <pre><code>class ImportCmd(CommandPlusDocs):\n\"\"\"Import an existing full OSCAL model into the trestle workspace.\"\"\"\n\n    name = 'import'\n\n    def _init_arguments(self) -&gt; None:\n        logger.debug('Init arguments')\n        self.add_argument(\n            '-f', '--file', help='OSCAL file to import - either file path or url.', type=str, required=True\n        )\n        self.add_argument('-o', '--output', help='Name of output element.', type=str, required=True)\n        self.add_argument('-r', '--regenerate', action='store_true', help=const.HELP_REGENERATE)\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Top level import run command.\"\"\"\n        try:\n            log.set_log_level_from_args(args)\n            trestle_root = args.trestle_root\n            if not file_utils.is_valid_project_root(trestle_root):\n                raise TrestleRootError(f'Attempt to import from non-valid trestle project root {trestle_root}')\n\n            input_uri = args.file\n            if cache.FetcherFactory.in_trestle_directory(trestle_root, input_uri):\n                raise TrestleError(\n                    f'Imported file {input_uri} cannot be from current trestle project. Use duplicate instead.'\n                )\n\n            content_type = FileContentType.to_content_type('.' + input_uri.split('.')[-1])\n\n            fetcher = cache.FetcherFactory.get_fetcher(trestle_root, str(input_uri))\n\n            model_read, parent_alias = fetcher.get_oscal(True)\n\n            # validate the loaded model in memory before writing out\n            # this will do any needed fixes to the file, such as assign missing catalog group ids\n            args_validate = argparse.Namespace(mode=const.VAL_MODE_ALL)\n            validator: Validator = validator_factory.get(args_validate)\n            if not validator.model_is_valid(model_read, True, trestle_root):\n                logger.warning(f'Validation of file to be imported {input_uri} did not pass.  Import failed.')\n                return CmdReturnCodes.COMMAND_ERROR.value\n\n            plural_path = ModelUtils.model_type_to_model_dir(parent_alias)\n\n            output_name = args.output\n\n            desired_model_dir = trestle_root / plural_path\n            desired_model_path: pathlib.Path = desired_model_dir / output_name / parent_alias\n            desired_model_path = desired_model_path.with_suffix(FileContentType.to_file_extension(content_type)\n                                                                ).resolve()\n\n            if desired_model_path.exists():\n                logger.warning(f'Cannot import because file to be imported here: {desired_model_path} already exists.')\n                return CmdReturnCodes.COMMAND_ERROR.value\n\n            if args.regenerate:\n                logger.debug(f'regenerating uuids in imported file {input_uri}')\n                model_read, lut, nchanged = ModelUtils.regenerate_uuids(model_read)\n                logger.debug(f'uuid lut has {len(lut.items())} entries and {nchanged} refs were updated')\n\n            top_element = Element(model_read)\n            create_action = CreatePathAction(desired_model_path, True)\n            write_action = WriteFileAction(desired_model_path, top_element, content_type)\n\n            # create a plan to create the directory and write the imported file.\n            import_plan = Plan()\n            import_plan.add_action(create_action)\n            import_plan.add_action(write_action)\n\n            import_plan.execute()\n\n            args = argparse.Namespace(\n                file=desired_model_path,\n                verbose=args.verbose,\n                trestle_root=args.trestle_root,\n                type=None,\n                all=None,\n                quiet=True\n            )\n            return CmdReturnCodes.SUCCESS.value\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while importing OSCAL file')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.import_/#trestle.core.commands.import_.ImportCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.init/","title":"init","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.init/#trestle.core.commands.init","title":"<code>trestle.core.commands.init</code>","text":"<p>Trestle Init Command.</p>"},{"location":"api_reference/trestle.core.commands.init/#trestle.core.commands.init.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.init/#trestle.core.commands.init-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.init/#trestle.core.commands.init.InitCmd","title":"<code> InitCmd            (CommandBase)         </code>","text":"<p>Initialize a trestle working directory.</p> Source code in <code>trestle/core/commands/init.py</code> <pre><code>class InitCmd(CommandBase):\n\"\"\"Initialize a trestle working directory.\"\"\"\n\n    name = 'init'\n\n    def _init_arguments(self) -&gt; None:\n\n        self.add_argument(const.INIT_FULL_SHORT, const.INIT_FULL_LONG, help=const.INIT_FULL_HELP, action='store_true')\n        self.add_argument(\n            const.INIT_LOCAL_SHORT, const.INIT_LOCAL_LONG, help=const.INIT_LOCAL_HELP, action='store_true'\n        )\n        self.add_argument(\n            const.INIT_GOVDOCS_SHORT, const.INIT_GOVDOCS_LONG, help=const.INIT_GOVDOCS_HELP, action='store_true'\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Create a trestle workspace in the current directory.\"\"\"\n        try:\n            log.set_log_level_from_args(args)\n            dir_path: pathlib.Path = args.trestle_root\n            if not dir_path.exists() or not dir_path.is_dir():\n                raise TrestleRootError(\n                    f'Initialization failed. Given directory {dir_path} does not exist or is not a directory.'\n                )\n\n            if not (args.full or args.local or args.govdocs):\n                # Running in full mode by default\n                args.full = True\n\n            init_dist_folder = True if args.full else False\n            init_oscal_folders = True if args.local or args.full else False\n            copy_config_file = True if args.full or args.local else False\n\n            self._create_directories(dir_path, init_oscal_folders, init_dist_folder)\n\n            if copy_config_file:\n                self._copy_config_file(dir_path)\n\n            logger.info(f'Initialized trestle project successfully in {dir_path}')\n\n            return CmdReturnCodes.SUCCESS.value\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Failed to initialize Trestle working directory.')\n\n    def _create_directories(self, root: pathlib.Path, create_model_folders: bool, create_dist_folder: bool) -&gt; None:\n\"\"\"Create the directory tree if it does not exist.\"\"\"\n        # Prepare directory list to be created\n        try:\n            directory_list = [root / pathlib.Path(const.TRESTLE_CONFIG_DIR)]\n\n            if create_model_folders:\n                for model_dir in const.MODEL_DIR_LIST:\n                    directory_list.append(root / pathlib.Path(model_dir))\n                    if create_dist_folder:\n                        directory_list.append(root / pathlib.Path(const.TRESTLE_DIST_DIR) / model_dir)\n\n            # Create directories\n            for directory in directory_list:\n                directory.mkdir(parents=True, exist_ok=True)\n                file_path = pathlib.Path(directory) / const.TRESTLE_KEEP_FILE\n                file_utils.make_hidden_file(file_path)\n        except OSError as e:\n            raise TrestleError(f'Error while creating directories: {e}')\n        except Exception as e:\n            raise TrestleError(f'Unexpected error while creating directories: {e}')\n\n    def _copy_config_file(self, root: pathlib.Path) -&gt; None:\n\"\"\"Copy the initial config.ini file to .trestle directory.\"\"\"\n        try:\n            source_path = pathlib.Path(resource_filename('trestle.resources', const.TRESTLE_CONFIG_FILE)).resolve()\n            destination_path = (root / pathlib.Path(const.TRESTLE_CONFIG_DIR) / const.TRESTLE_CONFIG_FILE).resolve()\n            copyfile(source_path, destination_path)\n\n        except (shutil.SameFileError, OSError) as e:\n            raise TrestleError(f'Error while copying config file: {e}')\n        except Exception as e:\n            raise TrestleError(f'Unexpected error while copying config file: {e}')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.init/#trestle.core.commands.init.InitCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.merge/","title":"merge","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.merge/#trestle.core.commands.merge","title":"<code>trestle.core.commands.merge</code>","text":"<p>Trestle Merge Command.</p>"},{"location":"api_reference/trestle.core.commands.merge/#trestle.core.commands.merge.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.merge/#trestle.core.commands.merge.trace","title":"<code>trace</code>","text":""},{"location":"api_reference/trestle.core.commands.merge/#trestle.core.commands.merge-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.merge/#trestle.core.commands.merge.MergeCmd","title":"<code> MergeCmd            (CommandPlusDocs)         </code>","text":"<p>Merge subcomponents on a trestle model.</p> Source code in <code>trestle/core/commands/merge.py</code> <pre><code>class MergeCmd(CommandPlusDocs):\n\"\"\"Merge subcomponents on a trestle model.\"\"\"\n\n    name = 'merge'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument(\n            f'-{const.ARG_ELEMENT_SHORT}',\n            f'--{const.ARG_ELEMENT}',\n            help=f'{const.ARG_DESC_ELEMENT}(s) to be merged. The last element is merged into the second last element.',\n            required=True\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Merge elements into the parent oscal model.\"\"\"\n        try:\n            log.set_log_level_from_args(args)\n\n            # remove any quotes passed in as on windows platforms\n            elements_clean = args.element.strip(\"'\")\n            element_paths = elements_clean.split(',')\n            trace.log(f'merge _run element paths {element_paths}')\n            cwd = Path.cwd()\n            rc = self.perform_all_merges(element_paths, cwd, args.trestle_root)\n            return rc\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while merging subcomponents on a trestle model')\n\n    @classmethod\n    def perform_all_merges(cls, element_paths: List[str], effective_cwd: Path, trestle_root: Path) -&gt; int:\n\"\"\"Run all merges over a list of element paths.\"\"\"\n        for element_path in element_paths:\n            logger.debug(f'merge {element_path}')\n            plan = cls.merge(effective_cwd, ElementPath(element_path), trestle_root)\n            plan.execute()\n        return CmdReturnCodes.SUCCESS.value\n\n    @classmethod\n    def merge(cls, effective_cwd: Path, element_path: ElementPath, trestle_root: Path) -&gt; Plan:\n\"\"\"Merge operations.\n\n        It returns a plan for the operation\n        \"\"\"\n        if not element_path.is_multipart():\n            raise TrestleError(\n                'Multiple parts of an element path must be passed to merge e.g. catalog.* or catalog.groups'\n            )\n\n        target_model_alias = element_path.get_last()\n        logger.debug(f'merge element path list: {element_path} target model alias {target_model_alias}')\n        # 1. Load desination model into a stripped model\n        # Load destination model\n        destination_path = element_path.get_preceding_path()\n        destination_model_alias = destination_path.get_last()\n        trace.log(f'merge destination model alias: {destination_model_alias}')\n        trace.log('merge getting contextual file type effective working directory')\n        # Destination model filetype\n        file_type = file_utils.get_contextual_file_type(effective_cwd)\n        trace.log(f'contextual file type is {file_type}')\n\n        file_ext = FileContentType.to_file_extension(file_type)\n        # Destination model filename\n        destination_model_path = (\n            effective_cwd / f'{classname_to_alias(destination_model_alias, AliasMode.JSON)}{file_ext}'\n        )\n        trace.log(f'destination model filename is {destination_model_path}')\n        destination_model_type, _ = ModelUtils.get_stripped_model_type(destination_model_path, trestle_root)\n\n        destination_model_object: OscalBaseModel = None\n        if destination_model_path.exists():\n            trace.log('dest filename exists so read it')\n            destination_model_object = destination_model_type.oscal_read(destination_model_path)\n        # 2. If target is wildcard, load distributed destination model and replace destination model.\n        # Handle WILDCARD '*' match. Return plan to load the destination model, with its distributed attributes\n        if target_model_alias == '*':\n            trace.log('handle target model alias wildcard')\n            collection_type = None\n            if destination_model_type.is_collection_container():\n                collection_type = destination_model_type.get_collection_type()\n\n            merged_model_type, _, merged_model_instance = ModelUtils.load_distributed(\n                destination_model_path, trestle_root, collection_type)\n            plan = Plan()\n            reset_destination_action = CreatePathAction(destination_model_path, clear_content=True)\n            wrapper_alias = destination_model_alias\n            write_destination_action = WriteFileAction(\n                destination_model_path, Element(merged_model_instance, wrapper_alias), content_type=file_type\n            )\n            remove_path_folder = effective_cwd / destination_model_alias\n            delete_target_action = RemovePathAction(remove_path_folder)\n            plan: Plan = Plan()\n            plan.add_action(reset_destination_action)\n            plan.add_action(write_destination_action)\n            plan.add_action(delete_target_action)\n            return plan\n\n        trace.log(f'get dest model with fields stripped: {target_model_alias}')\n        # Get destination model without the target field stripped\n        merged_model_type, _ = ModelUtils.get_stripped_model_type(destination_model_path, trestle_root,\n                                                                  aliases_not_to_be_stripped=[target_model_alias])\n        # 3. Load Target model. Target model could be stripped\n        try:\n            target_model_type = element_path.get_type(merged_model_type)\n        except Exception as e:\n            logger.debug(f'target model not found, element path list {element_path} type {merged_model_type}')\n            raise TrestleError(\n                f'Target model not found. Possibly merge of the elements not allowed at this point. {str(e)}'\n            )\n        target_model_path = effective_cwd / destination_model_alias\n        trace.log(f'look for target model path {target_model_path} at dest alias {destination_model_alias} rel to cwd')\n\n        # target_model filename - depends whether destination model is decomposed or not\n        if target_model_path.exists():\n            trace.log(f'target model path does exist so target path is subdir with target alias {target_model_alias}')\n            target_model_path = target_model_path / target_model_alias\n        else:\n            trace.log(f'target model filename does not exist so target path is target alias {target_model_alias}')\n            target_model_path = target_model_path / target_model_alias  # FIXME this is same as above\n        trace.log(f'final target model path is {target_model_path}')\n\n        # if target model is a file then handle file. If file doesn't exist, handle the directory,\n        # but in this case it's a list or a dict collection type\n        target_model_filename = target_model_path.with_suffix(file_ext)\n        if target_model_filename.exists():\n            trace.log(f'target model path with extension does exist so load distrib {target_model_filename}')\n            _, _, target_model_object = ModelUtils.load_distributed(target_model_filename, trestle_root)\n        else:\n            target_model_filename = Path(target_model_path)\n            trace.log(f'target model path plus extension does not exist so load distrib {target_model_filename}')\n            trace.log(f'get collection type for model type {target_model_type}')\n            collection_type = type_utils.get_origin(target_model_type)\n            trace.log(f'load {target_model_filename} as collection type {collection_type}')\n            _, _, target_model_object = ModelUtils.load_distributed(target_model_filename,\n                                                                    trestle_root, collection_type)\n\n        if hasattr(target_model_object, '__dict__') and '__root__' in target_model_object.__dict__:\n            trace.log('loaded object has dict and root so set target model object to root contents')\n            target_model_object = target_model_object.__dict__['__root__']\n        # 4. Insert target model into destination model.\n        merged_dict = {}\n        if destination_model_object is not None:\n            merged_dict = destination_model_object.__dict__\n        merged_dict[target_model_alias] = target_model_object\n        merged_model_object = merged_model_type(**merged_dict)  # type: ignore\n        merged_destination_element = Element(merged_model_object)\n        # 5. Create action  plan\n        trace.log(f'create path action clear content: {destination_model_path}')\n        reset_destination_action = CreatePathAction(destination_model_path, clear_content=True)\n        trace.log(f'write file action {destination_model_path}')\n        write_destination_action = WriteFileAction(\n            destination_model_path, merged_destination_element, content_type=file_type\n        )\n        # FIXME this will delete metadata.json but it will leave metadata/roles/roles.*\n        # need to clean up all lower dirs\n        trace.log(f'remove path action {target_model_filename}')\n        delete_target_action = RemovePathAction(target_model_filename)\n\n        plan: Plan = Plan()\n        plan.add_action(reset_destination_action)\n        plan.add_action(write_destination_action)\n        plan.add_action(delete_target_action)\n\n        # TODO: Destination model directory is empty or already merged? Then clean up.\n\n        return plan\n</code></pre>"},{"location":"api_reference/trestle.core.commands.merge/#trestle.core.commands.merge.MergeCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.merge/#trestle.core.commands.merge.MergeCmd-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.merge/#trestle.core.commands.merge.MergeCmd.merge","title":"<code>merge(effective_cwd, element_path, trestle_root)</code>  <code>classmethod</code>","text":"<p>Merge operations.</p> <p>It returns a plan for the operation</p> Source code in <code>trestle/core/commands/merge.py</code> <pre><code>@classmethod\ndef merge(cls, effective_cwd: Path, element_path: ElementPath, trestle_root: Path) -&gt; Plan:\n\"\"\"Merge operations.\n\n    It returns a plan for the operation\n    \"\"\"\n    if not element_path.is_multipart():\n        raise TrestleError(\n            'Multiple parts of an element path must be passed to merge e.g. catalog.* or catalog.groups'\n        )\n\n    target_model_alias = element_path.get_last()\n    logger.debug(f'merge element path list: {element_path} target model alias {target_model_alias}')\n    # 1. Load desination model into a stripped model\n    # Load destination model\n    destination_path = element_path.get_preceding_path()\n    destination_model_alias = destination_path.get_last()\n    trace.log(f'merge destination model alias: {destination_model_alias}')\n    trace.log('merge getting contextual file type effective working directory')\n    # Destination model filetype\n    file_type = file_utils.get_contextual_file_type(effective_cwd)\n    trace.log(f'contextual file type is {file_type}')\n\n    file_ext = FileContentType.to_file_extension(file_type)\n    # Destination model filename\n    destination_model_path = (\n        effective_cwd / f'{classname_to_alias(destination_model_alias, AliasMode.JSON)}{file_ext}'\n    )\n    trace.log(f'destination model filename is {destination_model_path}')\n    destination_model_type, _ = ModelUtils.get_stripped_model_type(destination_model_path, trestle_root)\n\n    destination_model_object: OscalBaseModel = None\n    if destination_model_path.exists():\n        trace.log('dest filename exists so read it')\n        destination_model_object = destination_model_type.oscal_read(destination_model_path)\n    # 2. If target is wildcard, load distributed destination model and replace destination model.\n    # Handle WILDCARD '*' match. Return plan to load the destination model, with its distributed attributes\n    if target_model_alias == '*':\n        trace.log('handle target model alias wildcard')\n        collection_type = None\n        if destination_model_type.is_collection_container():\n            collection_type = destination_model_type.get_collection_type()\n\n        merged_model_type, _, merged_model_instance = ModelUtils.load_distributed(\n            destination_model_path, trestle_root, collection_type)\n        plan = Plan()\n        reset_destination_action = CreatePathAction(destination_model_path, clear_content=True)\n        wrapper_alias = destination_model_alias\n        write_destination_action = WriteFileAction(\n            destination_model_path, Element(merged_model_instance, wrapper_alias), content_type=file_type\n        )\n        remove_path_folder = effective_cwd / destination_model_alias\n        delete_target_action = RemovePathAction(remove_path_folder)\n        plan: Plan = Plan()\n        plan.add_action(reset_destination_action)\n        plan.add_action(write_destination_action)\n        plan.add_action(delete_target_action)\n        return plan\n\n    trace.log(f'get dest model with fields stripped: {target_model_alias}')\n    # Get destination model without the target field stripped\n    merged_model_type, _ = ModelUtils.get_stripped_model_type(destination_model_path, trestle_root,\n                                                              aliases_not_to_be_stripped=[target_model_alias])\n    # 3. Load Target model. Target model could be stripped\n    try:\n        target_model_type = element_path.get_type(merged_model_type)\n    except Exception as e:\n        logger.debug(f'target model not found, element path list {element_path} type {merged_model_type}')\n        raise TrestleError(\n            f'Target model not found. Possibly merge of the elements not allowed at this point. {str(e)}'\n        )\n    target_model_path = effective_cwd / destination_model_alias\n    trace.log(f'look for target model path {target_model_path} at dest alias {destination_model_alias} rel to cwd')\n\n    # target_model filename - depends whether destination model is decomposed or not\n    if target_model_path.exists():\n        trace.log(f'target model path does exist so target path is subdir with target alias {target_model_alias}')\n        target_model_path = target_model_path / target_model_alias\n    else:\n        trace.log(f'target model filename does not exist so target path is target alias {target_model_alias}')\n        target_model_path = target_model_path / target_model_alias  # FIXME this is same as above\n    trace.log(f'final target model path is {target_model_path}')\n\n    # if target model is a file then handle file. If file doesn't exist, handle the directory,\n    # but in this case it's a list or a dict collection type\n    target_model_filename = target_model_path.with_suffix(file_ext)\n    if target_model_filename.exists():\n        trace.log(f'target model path with extension does exist so load distrib {target_model_filename}')\n        _, _, target_model_object = ModelUtils.load_distributed(target_model_filename, trestle_root)\n    else:\n        target_model_filename = Path(target_model_path)\n        trace.log(f'target model path plus extension does not exist so load distrib {target_model_filename}')\n        trace.log(f'get collection type for model type {target_model_type}')\n        collection_type = type_utils.get_origin(target_model_type)\n        trace.log(f'load {target_model_filename} as collection type {collection_type}')\n        _, _, target_model_object = ModelUtils.load_distributed(target_model_filename,\n                                                                trestle_root, collection_type)\n\n    if hasattr(target_model_object, '__dict__') and '__root__' in target_model_object.__dict__:\n        trace.log('loaded object has dict and root so set target model object to root contents')\n        target_model_object = target_model_object.__dict__['__root__']\n    # 4. Insert target model into destination model.\n    merged_dict = {}\n    if destination_model_object is not None:\n        merged_dict = destination_model_object.__dict__\n    merged_dict[target_model_alias] = target_model_object\n    merged_model_object = merged_model_type(**merged_dict)  # type: ignore\n    merged_destination_element = Element(merged_model_object)\n    # 5. Create action  plan\n    trace.log(f'create path action clear content: {destination_model_path}')\n    reset_destination_action = CreatePathAction(destination_model_path, clear_content=True)\n    trace.log(f'write file action {destination_model_path}')\n    write_destination_action = WriteFileAction(\n        destination_model_path, merged_destination_element, content_type=file_type\n    )\n    # FIXME this will delete metadata.json but it will leave metadata/roles/roles.*\n    # need to clean up all lower dirs\n    trace.log(f'remove path action {target_model_filename}')\n    delete_target_action = RemovePathAction(target_model_filename)\n\n    plan: Plan = Plan()\n    plan.add_action(reset_destination_action)\n    plan.add_action(write_destination_action)\n    plan.add_action(delete_target_action)\n\n    # TODO: Destination model directory is empty or already merged? Then clean up.\n\n    return plan\n</code></pre>"},{"location":"api_reference/trestle.core.commands.merge/#trestle.core.commands.merge.MergeCmd.perform_all_merges","title":"<code>perform_all_merges(element_paths, effective_cwd, trestle_root)</code>  <code>classmethod</code>","text":"<p>Run all merges over a list of element paths.</p> Source code in <code>trestle/core/commands/merge.py</code> <pre><code>@classmethod\ndef perform_all_merges(cls, element_paths: List[str], effective_cwd: Path, trestle_root: Path) -&gt; int:\n\"\"\"Run all merges over a list of element paths.\"\"\"\n    for element_path in element_paths:\n        logger.debug(f'merge {element_path}')\n        plan = cls.merge(effective_cwd, ElementPath(element_path), trestle_root)\n        plan.execute()\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.partial_object_validate/","title":"partial_object_validate","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.partial_object_validate/#trestle.core.commands.partial_object_validate","title":"<code>trestle.core.commands.partial_object_validate</code>","text":"<p>Trestle schema-validate command.</p>"},{"location":"api_reference/trestle.core.commands.partial_object_validate/#trestle.core.commands.partial_object_validate.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.partial_object_validate/#trestle.core.commands.partial_object_validate-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.partial_object_validate/#trestle.core.commands.partial_object_validate.PartialObjectValidate","title":"<code> PartialObjectValidate            (CommandBase)         </code>","text":"<p>Direct validation any oscal object in a file, including list objects.</p> Source code in <code>trestle/core/commands/partial_object_validate.py</code> <pre><code>class PartialObjectValidate(CommandBase):\n\"\"\"Direct validation any oscal object in a file, including list objects.\"\"\"\n\n    name = 'partial-object-validate'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument(\n            f'-{const.ARG_FILE_SHORT}',\n            f'--{const.ARG_FILE}',\n            help=const.ARG_DESC_FILE + ' to validate',\n            required=True,\n            type=pathlib.Path\n        )\n\n        self.add_argument(\n            f'-{const.ARG_ELEMENT_SHORT}',\n            f'--{const.ARG_ELEMENT}',\n            help=const.ARG_DESC_ELEMENT + ' to validate.',\n            required=True\n        )\n\n        self.add_argument(\n            '-nv', '--no-validators', help='Only perform the most basic validation of the file', action='store_true'\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n            file_path: pathlib.Path = args.file.resolve()\n            if not file_path.exists() or not file_path.is_file():\n                raise TrestleError('File path provided does not exist or is a directory')\n\n            element_str: str = args.element\n            if ',' in element_str:\n                logger.warning('Only a single element path is allowed.')\n\n            return self.partial_object_validate(file_path, element_str)\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while validating OSCAL file')\n\n    @classmethod\n    def partial_object_validate(cls, file_path: pathlib.Path, element_string: str) -&gt; int:\n\"\"\"Run a schema validation on a file inferring file type based on element string.\"\"\"\n        # get model type\n        logger.info(f'Validating {file_path}')\n        element_path = elements.ElementPath(element_string)\n        # get a wrapped object\n        obm_type = element_path.get_obm_wrapped_type()\n        obm_type.oscal_read(file_path)\n\n        logger.info(f'VALID: {file_path} for {element_string}')\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.partial_object_validate/#trestle.core.commands.partial_object_validate.PartialObjectValidate.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.partial_object_validate/#trestle.core.commands.partial_object_validate.PartialObjectValidate-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.partial_object_validate/#trestle.core.commands.partial_object_validate.PartialObjectValidate.partial_object_validate","title":"<code>partial_object_validate(file_path, element_string)</code>  <code>classmethod</code>","text":"<p>Run a schema validation on a file inferring file type based on element string.</p> Source code in <code>trestle/core/commands/partial_object_validate.py</code> <pre><code>@classmethod\ndef partial_object_validate(cls, file_path: pathlib.Path, element_string: str) -&gt; int:\n\"\"\"Run a schema validation on a file inferring file type based on element string.\"\"\"\n    # get model type\n    logger.info(f'Validating {file_path}')\n    element_path = elements.ElementPath(element_string)\n    # get a wrapped object\n    obm_type = element_path.get_obm_wrapped_type()\n    obm_type.oscal_read(file_path)\n\n    logger.info(f'VALID: {file_path} for {element_string}')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.remove/","title":"remove","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.remove/#trestle.core.commands.remove","title":"<code>trestle.core.commands.remove</code>","text":"<p>Trestle Remove Command.</p>"},{"location":"api_reference/trestle.core.commands.remove/#trestle.core.commands.remove.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.remove/#trestle.core.commands.remove-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.remove/#trestle.core.commands.remove.RemoveCmd","title":"<code> RemoveCmd            (CommandPlusDocs)         </code>","text":"<p>Remove a subcomponent from an existing model.</p> Source code in <code>trestle/core/commands/remove.py</code> <pre><code>class RemoveCmd(CommandPlusDocs):\n\"\"\"Remove a subcomponent from an existing model.\"\"\"\n\n    name = 'remove'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument(\n            f'-{const.ARG_FILE_SHORT}',\n            f'--{const.ARG_FILE}',\n            help=const.ARG_DESC_FILE + ' to remove component/subcomponent to.',\n            required=True\n        )\n        self.add_argument(\n            f'-{const.ARG_ELEMENT_SHORT}',\n            f'--{const.ARG_ELEMENT}',\n            help=const.ARG_DESC_ELEMENT + ' to remove.',\n            required=True\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Remove an OSCAL component/subcomponent to the specified component.\n\n        This method takes input a filename and a list of comma-seperated element path. Element paths are field aliases.\n        The method first finds the parent model from the file and loads the file into the model.\n        Then the method executes 'remove' for each of the element paths specified.\n        \"\"\"\n        try:\n            log.set_log_level_from_args(args)\n            args_dict = args.__dict__\n\n            file_path = pathlib.Path(args_dict[const.ARG_FILE]).resolve()\n            relative_path = file_path.relative_to(args.trestle_root)\n            # Get parent model and then load json into parent model\n            parent_model, parent_alias = ModelUtils.get_relative_model_type(relative_path)\n\n            parent_object = parent_model.oscal_read(file_path)\n            parent_element = Element(parent_object, parent_alias)\n\n            add_plan = Plan()\n\n            # Do _remove for each element_path specified in args\n            element_paths: List[str] = str(args_dict[const.ARG_ELEMENT]).split(',')\n            for elm_path_str in element_paths:\n                element_path = ElementPath(elm_path_str)\n                remove_action, parent_element = self.remove(element_path, parent_element)\n                add_plan.add_action(remove_action)\n\n            create_action = CreatePathAction(file_path, True)\n            write_action = WriteFileAction(file_path, parent_element, FileContentType.to_content_type(file_path.suffix))\n            add_plan.add_action(remove_action)\n            add_plan.add_action(create_action)\n            add_plan.add_action(write_action)\n\n            add_plan.execute()\n\n            return CmdReturnCodes.SUCCESS.value\n\n        except Exception as e:\n            return err.handle_generic_command_exception(e, logger, 'Error while removing OSCAL component')\n\n    @classmethod\n    def remove(cls, element_path: ElementPath, parent_element: Element) -&gt; Tuple[RemoveAction, Element]:\n\"\"\"For the element_path, remove a model from the parent_element of a given parent_model.\n\n        First we check if there is an existing element at that path\n        If not, we complain.\n        Then we set up an action plan to update the model (specified by file_path) in memory,\n        return the action and return the parent_element.\n\n        LIMITATIONS:\n        1. This does not remove elements of a list or dict. Instead, the entire list or dict is removed.\n        2. This cannot remove arbitrarily named elements that are not specified in the schema.\n        For example, \"responsible-parties\" contains named elements, e.g., \"organisation\". The tool will not\n        remove the \"organisation\" as it is not in the schema, but one can remove its elements, e.g., \"party-uuids\".\n        \"\"\"\n        element_path_list = element_path.get_full_path_parts()\n        if '*' in element_path_list:\n            raise err.TrestleError('trestle remove does not support Wildcard element path.')\n\n        deleting_element = parent_element.get_at(element_path)\n\n        if deleting_element is not None:\n            # The element already exists\n            if type(deleting_element) is list:\n                logger.warning(\n                    'Warning: trestle remove does not support removing elements of a list: '\n                    'this removes the entire list'\n                )\n            elif type(deleting_element) is dict:\n                logger.warning(\n                    'Warning: trestle remove does not support removing dict elements: '\n                    'this removes the entire dict element'\n                )\n        else:\n            raise err.TrestleError(f'Bad element path: {str(element_path)}')\n\n        remove_action = RemoveAction(parent_element, element_path)\n\n        return remove_action, parent_element\n</code></pre>"},{"location":"api_reference/trestle.core.commands.remove/#trestle.core.commands.remove.RemoveCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.remove/#trestle.core.commands.remove.RemoveCmd-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.remove/#trestle.core.commands.remove.RemoveCmd.remove","title":"<code>remove(element_path, parent_element)</code>  <code>classmethod</code>","text":"<p>For the element_path, remove a model from the parent_element of a given parent_model.</p> <p>First we check if there is an existing element at that path If not, we complain. Then we set up an action plan to update the model (specified by file_path) in memory, return the action and return the parent_element.</p> <p>LIMITATIONS: 1. This does not remove elements of a list or dict. Instead, the entire list or dict is removed. 2. This cannot remove arbitrarily named elements that are not specified in the schema. For example, \"responsible-parties\" contains named elements, e.g., \"organisation\". The tool will not remove the \"organisation\" as it is not in the schema, but one can remove its elements, e.g., \"party-uuids\".</p> Source code in <code>trestle/core/commands/remove.py</code> <pre><code>@classmethod\ndef remove(cls, element_path: ElementPath, parent_element: Element) -&gt; Tuple[RemoveAction, Element]:\n\"\"\"For the element_path, remove a model from the parent_element of a given parent_model.\n\n    First we check if there is an existing element at that path\n    If not, we complain.\n    Then we set up an action plan to update the model (specified by file_path) in memory,\n    return the action and return the parent_element.\n\n    LIMITATIONS:\n    1. This does not remove elements of a list or dict. Instead, the entire list or dict is removed.\n    2. This cannot remove arbitrarily named elements that are not specified in the schema.\n    For example, \"responsible-parties\" contains named elements, e.g., \"organisation\". The tool will not\n    remove the \"organisation\" as it is not in the schema, but one can remove its elements, e.g., \"party-uuids\".\n    \"\"\"\n    element_path_list = element_path.get_full_path_parts()\n    if '*' in element_path_list:\n        raise err.TrestleError('trestle remove does not support Wildcard element path.')\n\n    deleting_element = parent_element.get_at(element_path)\n\n    if deleting_element is not None:\n        # The element already exists\n        if type(deleting_element) is list:\n            logger.warning(\n                'Warning: trestle remove does not support removing elements of a list: '\n                'this removes the entire list'\n            )\n        elif type(deleting_element) is dict:\n            logger.warning(\n                'Warning: trestle remove does not support removing dict elements: '\n                'this removes the entire dict element'\n            )\n    else:\n        raise err.TrestleError(f'Bad element path: {str(element_path)}')\n\n    remove_action = RemoveAction(parent_element, element_path)\n\n    return remove_action, parent_element\n</code></pre>"},{"location":"api_reference/trestle.core.commands.replicate/","title":"replicate","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.replicate/#trestle.core.commands.replicate","title":"<code>trestle.core.commands.replicate</code>","text":"<p>Trestle Replicate Command.</p>"},{"location":"api_reference/trestle.core.commands.replicate/#trestle.core.commands.replicate.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.replicate/#trestle.core.commands.replicate-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.replicate/#trestle.core.commands.replicate.ReplicateCmd","title":"<code> ReplicateCmd            (CommandPlusDocs)         </code>","text":"<p>Replicate a top level model within the trestle directory structure.</p> Source code in <code>trestle/core/commands/replicate.py</code> <pre><code>class ReplicateCmd(CommandPlusDocs):\n\"\"\"Replicate a top level model within the trestle directory structure.\"\"\"\n\n    name = 'replicate'\n\n    def _init_arguments(self) -&gt; None:\n        logger.debug('Init arguments')\n\n        self.add_argument('model', help='Choose OSCAL model', choices=const.MODEL_TYPE_LIST)\n        self.add_argument('-n', '--name', help='Name of model to replicate.', type=str, required=True)\n        self.add_argument('-o', '--output', help='Name of replicated model.', type=str, required=True)\n        self.add_argument('-r', '--regenerate', action='store_true', help=const.HELP_REGENERATE)\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Execute and process the args.\"\"\"\n        try:\n            log.set_log_level_from_args(args)\n            return self.replicate_object(args.model, args)\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while replicating model')\n\n    @classmethod\n    def replicate_object(cls, model_alias: str, args: argparse.Namespace) -&gt; int:\n\"\"\"\n        Core replicate routine invoked by subcommands.\n\n        Args:\n            model_alias: Name of the top level model in the trestle directory.\n            args: CLI arguments\n        Returns:\n            A return code that can be used as standard posix codes. 0 is success.\n        \"\"\"\n        logger.debug('Entering replicate_object.')\n\n        # 1 Bad working directory if not running from current working directory\n        trestle_root = args.trestle_root  # trestle root is set via command line in args. Default is cwd.\n        if not trestle_root or not file_utils.is_valid_project_root(trestle_root):\n            raise TrestleError(f'Given directory: {trestle_root} is not a trestle project.')\n\n        plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n\n        # 2 Check that input file given exists.\n\n        input_file_stem = trestle_root / plural_path / args.name / model_alias\n        content_type = FileContentType.path_to_content_type(input_file_stem)\n        if content_type == FileContentType.UNKNOWN:\n            raise TrestleError(\n                f'Input file {args.name} has no json or yaml file at expected location {input_file_stem}.'\n            )\n\n        input_file = input_file_stem.with_suffix(FileContentType.to_file_extension(content_type))\n\n        # 3 Distributed load from file\n        _, model_alias, model_instance = ModelUtils.load_distributed(input_file, trestle_root)\n\n        rep_model_path = trestle_root / plural_path / args.output / (\n            model_alias + FileContentType.to_file_extension(content_type)\n        )\n\n        if rep_model_path.exists():\n            raise TrestleError(f'OSCAL file to be replicated here: {rep_model_path} exists.')\n\n        if args.regenerate:\n            logger.debug(f'regenerating uuids for model {input_file}')\n            model_instance, uuid_lut, n_refs_updated = ModelUtils.regenerate_uuids(model_instance)\n            logger.debug(f'{len(uuid_lut)} uuids generated and {n_refs_updated} references updated')\n\n        # 4 Prepare actions and plan\n        top_element = Element(model_instance)\n        create_action = CreatePathAction(rep_model_path, True)\n        write_action = WriteFileAction(rep_model_path, top_element, content_type)\n\n        # create a plan to create the directory and imported file.\n        replicate_plan = Plan()\n        replicate_plan.add_action(create_action)\n        replicate_plan.add_action(write_action)\n\n        replicate_plan.execute()\n\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.replicate/#trestle.core.commands.replicate.ReplicateCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.replicate/#trestle.core.commands.replicate.ReplicateCmd-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.replicate/#trestle.core.commands.replicate.ReplicateCmd.replicate_object","title":"<code>replicate_object(model_alias, args)</code>  <code>classmethod</code>","text":"<p>Core replicate routine invoked by subcommands.</p> <p>Parameters:</p> Name Type Description Default <code>model_alias</code> <code>str</code> <p>Name of the top level model in the trestle directory.</p> required <code>args</code> <code>Namespace</code> <p>CLI arguments</p> required <p>Returns:</p> Type Description <code>int</code> <p>A return code that can be used as standard posix codes. 0 is success.</p> Source code in <code>trestle/core/commands/replicate.py</code> <pre><code>@classmethod\ndef replicate_object(cls, model_alias: str, args: argparse.Namespace) -&gt; int:\n\"\"\"\n    Core replicate routine invoked by subcommands.\n\n    Args:\n        model_alias: Name of the top level model in the trestle directory.\n        args: CLI arguments\n    Returns:\n        A return code that can be used as standard posix codes. 0 is success.\n    \"\"\"\n    logger.debug('Entering replicate_object.')\n\n    # 1 Bad working directory if not running from current working directory\n    trestle_root = args.trestle_root  # trestle root is set via command line in args. Default is cwd.\n    if not trestle_root or not file_utils.is_valid_project_root(trestle_root):\n        raise TrestleError(f'Given directory: {trestle_root} is not a trestle project.')\n\n    plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n\n    # 2 Check that input file given exists.\n\n    input_file_stem = trestle_root / plural_path / args.name / model_alias\n    content_type = FileContentType.path_to_content_type(input_file_stem)\n    if content_type == FileContentType.UNKNOWN:\n        raise TrestleError(\n            f'Input file {args.name} has no json or yaml file at expected location {input_file_stem}.'\n        )\n\n    input_file = input_file_stem.with_suffix(FileContentType.to_file_extension(content_type))\n\n    # 3 Distributed load from file\n    _, model_alias, model_instance = ModelUtils.load_distributed(input_file, trestle_root)\n\n    rep_model_path = trestle_root / plural_path / args.output / (\n        model_alias + FileContentType.to_file_extension(content_type)\n    )\n\n    if rep_model_path.exists():\n        raise TrestleError(f'OSCAL file to be replicated here: {rep_model_path} exists.')\n\n    if args.regenerate:\n        logger.debug(f'regenerating uuids for model {input_file}')\n        model_instance, uuid_lut, n_refs_updated = ModelUtils.regenerate_uuids(model_instance)\n        logger.debug(f'{len(uuid_lut)} uuids generated and {n_refs_updated} references updated')\n\n    # 4 Prepare actions and plan\n    top_element = Element(model_instance)\n    create_action = CreatePathAction(rep_model_path, True)\n    write_action = WriteFileAction(rep_model_path, top_element, content_type)\n\n    # create a plan to create the directory and imported file.\n    replicate_plan = Plan()\n    replicate_plan.add_action(create_action)\n    replicate_plan.add_action(write_action)\n\n    replicate_plan.execute()\n\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/","title":"split","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split","title":"<code>trestle.core.commands.split</code>","text":"<p>Trestle Split Command.</p>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.trace","title":"<code>trace</code>","text":""},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.AliasTracker","title":"<code> AliasTracker            (TrestleBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Convenience class to track writing out of models.</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>class AliasTracker(TrestleBaseModel):\n\"\"\"Convenience class to track writing out of models.\"\"\"\n\n    # This tracks the parts that need to be split from each element\n    # and makes sure it is written out once\n\n    aliases: List[str]\n    written: bool = False\n\n    def add_alias(self, alias: str) -&gt; None:\n\"\"\"Add alias.\"\"\"\n        if alias not in self.aliases:\n            self.aliases.append(alias)\n\n    def get_aliases(self) -&gt; List[str]:\n\"\"\"Get the list of aliases.\"\"\"\n        return self.aliases\n\n    def needs_writing(self) -&gt; bool:\n\"\"\"Need to write the model.\"\"\"\n        return not self.written\n\n    def mark_written(self) -&gt; None:\n\"\"\"Mark this model as written.\"\"\"\n        self.written = True\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.AliasTracker.aliases","title":"<code>aliases: List[str]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.AliasTracker.written","title":"<code>written: bool</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.AliasTracker-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.AliasTracker.add_alias","title":"<code>add_alias(self, alias)</code>","text":"<p>Add alias.</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>def add_alias(self, alias: str) -&gt; None:\n\"\"\"Add alias.\"\"\"\n    if alias not in self.aliases:\n        self.aliases.append(alias)\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.AliasTracker.get_aliases","title":"<code>get_aliases(self)</code>","text":"<p>Get the list of aliases.</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>def get_aliases(self) -&gt; List[str]:\n\"\"\"Get the list of aliases.\"\"\"\n    return self.aliases\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.AliasTracker.mark_written","title":"<code>mark_written(self)</code>","text":"<p>Mark this model as written.</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>def mark_written(self) -&gt; None:\n\"\"\"Mark this model as written.\"\"\"\n    self.written = True\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.AliasTracker.needs_writing","title":"<code>needs_writing(self)</code>","text":"<p>Need to write the model.</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>def needs_writing(self) -&gt; bool:\n\"\"\"Need to write the model.\"\"\"\n    return not self.written\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.SplitCmd","title":"<code> SplitCmd            (CommandPlusDocs)         </code>","text":"<p>Split subcomponents on a trestle model.</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>class SplitCmd(CommandPlusDocs):\n\"\"\"Split subcomponents on a trestle model.\"\"\"\n\n    name = 'split'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument(\n            f'-{const.ARG_FILE_SHORT}', f'--{const.ARG_FILE}', help=const.ARG_DESC_FILE + ' to split.', required=False\n        )\n        self.add_argument(\n            f'-{const.ARG_ELEMENT_SHORT}',\n            f'--{const.ARG_ELEMENT}',\n            help=const.ARG_DESC_ELEMENT + ' to split.',\n            required=False\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Split an OSCAL file into elements.\"\"\"\n        try:\n            log.set_log_level_from_args(args)\n            trace.log('Entering trestle split.')\n            # get the Model\n            args_raw: Dict[str, str] = args.__dict__\n\n            # remove any quotes passed in as on windows platforms\n            elements_clean: str = args_raw[const.ARG_ELEMENT].strip(\"'\")\n\n            file_name = ''\n            file_name = '' if not args_raw[const.ARG_FILE] else args_raw[const.ARG_FILE]\n            # cwd must be in the model directory if file to split is not specified\n            effective_cwd = pathlib.Path.cwd()\n\n            return self.perform_split(effective_cwd, file_name, elements_clean, args.trestle_root)\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while performing a split operation')\n\n    @classmethod\n    def perform_split(\n        cls, effective_cwd: pathlib.Path, file_name: str, elements: str, trestle_root: pathlib.Path\n    ) -&gt; int:\n\"\"\"Perform the split operation.\n\n        Args:\n            effective_cwd: effective directory in which the the split operation is performed\n            file_name: file name of model to split, or '' if deduced from elements and cwd\n            elements: comma separated list of paths to strip from the file, with quotes removed\n\n        Returns:\n            0 on success and 1 on failure\n        \"\"\"\n        file_path_list: List[Tuple[str, str]] = []\n\n        if file_name:\n            file_path_list.append((file_name, elements))\n        else:\n            # cwd must be in the model directory if file to split is not specified\n            # find top directory for this model based on trestle root and cwd\n            model_dir = file_utils.extract_project_model_path(effective_cwd)\n            if model_dir is None:\n                raise TrestleError('Current directory must be within a model directory if file is not specified')\n\n            content_type: FileContentType = FileContentType.dir_to_content_type(model_dir)\n\n            # determine the file needed for each split path\n            element_paths = elements.split(',')\n            for path in element_paths:\n                element_path = ElementPath(path)\n                # if element path is relative use directory context to determine absolute path\n                element_path.make_absolute(model_dir, effective_cwd)\n                file_path = element_path.find_last_file_in_path(content_type, model_dir)\n                # now make the element path relative to the model file to be loaded\n                if file_path is None or element_path.make_relative(file_path.relative_to(model_dir)) != 0:\n                    raise TrestleError(f'Unable to match element path with files in model directory {element_path}')\n\n                file_path_list.append((file_path, element_path.to_string()))\n\n        # match paths to corresponding files since several paths may be split from the same file\n        file_path_dict: Dict[str, str] = {}\n        for file_path in file_path_list:\n            key = file_path[0]\n            path = file_path[1]\n            if key not in file_path_dict:\n                file_path_dict[key] = path\n            else:\n                current_path = file_path_dict[key]\n                file_path_dict[key] = f'{current_path},{path}'\n\n        for raw_file_name, element_path in file_path_dict.items():\n            file_path = file_utils.relative_resolve(pathlib.Path(raw_file_name), effective_cwd)\n            # this makes assumptions that the path is relative.\n            if not file_path.exists():\n                raise TrestleError(f'File {file_path} does not exist.')\n\n            content_type = FileContentType.to_content_type(file_path.suffix)\n\n            # find the base directory of the file\n            base_dir = file_path.parent\n            model_type, _ = ModelUtils.get_stripped_model_type(file_path, trestle_root)\n\n            model: OscalBaseModel = model_type.oscal_read(file_path)\n\n            if cmd_utils.split_is_too_fine(element_path, model):\n                raise TrestleError('Cannot split the model to the level of uuids, strings, etc.')\n\n            # use the model itself to resolve any wildcards and create list of element paths\n            logger.debug(f'split calling parse_element_args on {element_path}')\n            # use contextual mode to parse\n\n            element_paths: List[ElementPath] = cmd_utils.parse_element_args(\n                model, element_path.split(','), base_dir.relative_to(trestle_root)\n            )\n\n            # analyze the split tree and determine which aliases should be stripped from each file\n            aliases_to_strip = cls.find_aliases_to_strip(element_paths)\n\n            # need the file name relative to the base directory\n            file_name_no_path = str(file_path.name)\n\n            split_plan = cls.split_model(\n                model, element_paths, base_dir, content_type, file_name_no_path, aliases_to_strip\n            )\n            trash.store(file_path, True)\n\n            try:\n                split_plan.execute()\n            except Exception as e:\n                trash.recover(file_path, True)\n                raise TrestleError(f'Split has failed with error: {e}.')\n\n        return CmdReturnCodes.SUCCESS.value\n\n    @classmethod\n    def prepare_sub_model_split_actions(\n        cls,\n        sub_model_item: OscalBaseModel,\n        sub_model_dir: pathlib.Path,\n        file_prefix: str,\n        content_type: FileContentType\n    ) -&gt; List[Action]:\n\"\"\"Create split actions of sub model.\"\"\"\n        actions: List[Action] = []\n        file_name = cmd_utils.to_model_file_name(sub_model_item, file_prefix, content_type)\n        model_type = classname_to_alias(type(sub_model_item).__name__, AliasMode.JSON)\n        sub_model_file = sub_model_dir / file_name\n        actions.append(CreatePathAction(sub_model_file))\n        actions.append(WriteFileAction(sub_model_file, Element(sub_model_item, model_type), content_type))\n        return actions\n\n    @classmethod\n    def split_model_at_path_chain(\n        cls,\n        model_obj: OscalBaseModel,\n        element_paths: List[ElementPath],\n        base_dir: pathlib.Path,\n        content_type: FileContentType,\n        cur_path_index: int,\n        split_plan: Plan,\n        strip_root: bool,\n        root_file_name: str,\n        aliases_to_strip: Dict[str, AliasTracker],\n        last_one: bool = True\n    ) -&gt; int:\n\"\"\"Recursively split the model at the provided chain of element paths.\n\n        It assumes that a chain of element paths starts at the cur_path_index with the first path ending\n        with a wildcard (*)\n\n        If the wildcard follows an element that is inherently a list of items, the list of items is extracted.\n        But if the wildcard follows a generic model than members of that model class found in the model will be\n        split off.  But only the non-trivial elements are removed, i.e. not str, int, datetime, etc.\n\n        Args:\n            model_obj: The OscalBaseModel to be split\n            element_paths: The List[ElementPath] of elements to split, including embedded wildcards\n            base_dir: pathlib.Path of the file being split\n            content_type: json or yaml files\n            cur_path_index: Index into the list of element paths for the current split operation\n            split_plan: The accumulated plan of actions needed to perform the split\n            strip_root: Whether to strip elements from the root object\n            root_file_name: Filename of root file that gets split into a list of items\n            aliases_to_strip: AliasTracker previously loaded with aliases that need to be split from each element\n            last_one: bool indicating last item in array has been split and stripped model can now be written\n\n        Returns:\n            int representing the index where the chain of the path ends.\n\n        Examples:\n            For example, element paths could have a list of paths as below for a `ComponentDefinition` model where\n            the first path is the start of the chain.\n\n            For each of the sub model described by the first element path (e.g component-defintion.components.*) in the\n            chain, the subsequent paths (e.g component.control-implementations.*) will be applied recursively\n            to retrieve the sub-sub models:\n            [\n                'component-definition.component.*',\n                'component.control-implementations.*'\n            ]\n            for a command like below:\n            trestle split -f component.yaml -e component-definition.components.*.control-implementations.*\n        \"\"\"\n        if split_plan is None:\n            raise TrestleError('Split plan must have been initialized')\n\n        if cur_path_index &lt; 0:\n            raise TrestleError('Current index of the chain of paths cannot be less than 0')\n\n        # if there are no more element_paths, return the current plan\n        if cur_path_index &gt;= len(element_paths):\n            return cur_path_index\n\n        # initialize local variables\n        element = Element(model_obj)\n        stripped_field_alias: List[str] = []\n\n        # get the sub_model specified by the element_path of this round\n        element_path = element_paths[cur_path_index]\n\n        # does the next element_path point back at me\n        is_parent = cur_path_index + 1 &lt; len(element_paths) and element_paths[cur_path_index\n                                                                              + 1].get_parent() == element_path\n\n        # root dir name for sub models dir\n        # 00000__group.json will have the root_dir name as 00000__group for sub models of group\n        # catalog.json will have the root_dir name as catalog\n        root_dir = ''\n        if root_file_name != '':\n            root_dir = str(pathlib.Path(root_file_name).with_suffix(''))\n\n        sub_models = element.get_at(element_path, False)  # we call sub_models as in plural, but it can be just one\n\n        # assume cur_path_index is the end of the chain\n        # value of this variable may change during recursive split of the sub-models below\n        path_chain_end = cur_path_index\n\n        # if wildcard is present in the element_path and the next path in the chain has current path as the parent,\n        # Then deal with case of list, or split of arbitrary oscalbasemodel\n        if is_parent and element_path.get_last() is not ElementPath.WILDCARD:\n            # create dir for all sub model items\n            sub_models_dir = base_dir / element_path.to_root_path()\n            sub_model_plan = Plan()\n            path_chain_end = cls.split_model_at_path_chain(\n                sub_models,\n                element_paths,\n                sub_models_dir,\n                content_type,\n                cur_path_index + 1,\n                sub_model_plan,\n                True,\n                '',\n                aliases_to_strip\n            )\n            sub_model_actions = sub_model_plan.get_actions()\n            split_plan.add_actions(sub_model_actions)\n        elif element_path.get_last() == ElementPath.WILDCARD:\n            # extract sub-models into a dict with appropriate prefix\n            sub_model_items: Dict[str, OscalBaseModel] = {}\n            sub_models_dir = base_dir / element_path.to_file_path(root_dir=root_dir)\n            if isinstance(sub_models, list):\n                for i, sub_model_item in enumerate(sub_models):\n                    # e.g. `groups/00000_groups/`\n                    prefix = str(i).zfill(const.FILE_DIGIT_PREFIX_LENGTH)\n                    sub_model_items[prefix] = sub_model_item\n\n            # process list sub model items\n            count = 0\n            for key, sub_model_item in sub_model_items.items():\n                count += 1\n                # recursively split the sub-model if there are more element paths to traverse\n                # e.g. split component.control-implementations.*\n                require_recursive_split = cur_path_index + 1 &lt; len(element_paths) and element_paths[\n                    cur_path_index + 1].get_parent() == element_path\n\n                if require_recursive_split:\n                    # prepare individual directory for each sub-model\n                    sub_root_file_name = cmd_utils.to_model_file_name(sub_model_item, key, content_type)\n                    sub_model_plan = Plan()\n\n                    last_one: bool = count == len(sub_model_items)\n                    path_chain_end = cls.split_model_at_path_chain(\n                        sub_model_item,\n                        element_paths,\n                        sub_models_dir,\n                        content_type,\n                        cur_path_index + 1,\n                        sub_model_plan,\n                        True,\n                        sub_root_file_name,\n                        aliases_to_strip,\n                        last_one\n                    )\n                    sub_model_actions = sub_model_plan.get_actions()\n                else:\n                    sub_model_actions = cls.prepare_sub_model_split_actions(\n                        sub_model_item, sub_models_dir, key, content_type\n                    )\n\n                split_plan.add_actions(sub_model_actions)\n        else:\n            # the chain of path ends at the current index.\n            # so no recursive call. Let's just write the sub model to the file and get out\n            if sub_models is not None:\n                sub_model_file = base_dir / element_path.to_file_path(content_type, root_dir=root_dir)\n                split_plan.add_action(CreatePathAction(sub_model_file))\n                split_plan.add_action(\n                    WriteFileAction(sub_model_file, Element(sub_models, element_path.get_element_name()), content_type)\n                )\n\n        # Strip the root model and add a WriteAction for the updated model object in the plan\n        if strip_root:\n            full_path = element_path.get_full()\n            path = '.'.join(full_path.split('.')[:-1])\n            aliases = [element_path.get_element_name()]\n            need_to_write = True\n            use_alias_dict = aliases_to_strip is not None and path in aliases_to_strip\n            if use_alias_dict:\n                aliases = aliases_to_strip[path].get_aliases()\n                need_to_write = aliases_to_strip[path].needs_writing()\n\n            stripped_model = model_obj.stripped_instance(stripped_fields_aliases=aliases)\n            # can mark it written even if it doesn't need writing since it is empty\n            # but if an array only mark it written if it's the last one\n            if last_one and use_alias_dict:\n                aliases_to_strip[path].mark_written()\n            # If it's an empty model after stripping the fields, don't create path and don't write\n            field_list = [x for x in model_obj.__fields__.keys() if model_obj.__fields__[x] is not None]\n            if set(field_list) == set(stripped_field_alias):\n                return path_chain_end\n\n            if need_to_write:\n                if root_file_name != '':\n                    root_file = base_dir / root_file_name\n                else:\n                    root_file = base_dir / element_path.to_root_path(content_type)\n\n                split_plan.add_action(CreatePathAction(root_file))\n                wrapper_alias = classname_to_alias(stripped_model.__class__.__name__, AliasMode.JSON)\n                split_plan.add_action(WriteFileAction(root_file, Element(stripped_model, wrapper_alias), content_type))\n\n        # return the end of the current path chain\n        return path_chain_end\n\n    @classmethod\n    def split_model(\n        cls,\n        model_obj: OscalBaseModel,\n        element_paths: List[ElementPath],\n        base_dir: pathlib.Path,\n        content_type: FileContentType,\n        root_file_name: str,\n        aliases_to_strip: Dict[str, AliasTracker]\n    ) -&gt; Plan:\n\"\"\"Split the model at the provided element paths.\n\n        It returns a plan for the operation\n        \"\"\"\n        # initialize plan\n        split_plan = Plan()\n\n        # loop through the element path list and update the split_plan\n        stripped_field_alias = []\n        cur_path_index = 0\n        while cur_path_index &lt; len(element_paths):\n            # extract the sub element name for each of the root path of the path chain\n            element_path = element_paths[cur_path_index]\n\n            if element_path.get_parent() is None and len(element_path.get()) &gt; 1:\n                stripped_part = element_path.get()[1]\n                if stripped_part == ElementPath.WILDCARD:\n                    stripped_field_alias.append('__root__')\n                else:\n                    if stripped_part not in stripped_field_alias:\n                        stripped_field_alias.append(stripped_part)\n\n            # split model at the path chain\n            cur_path_index = cls.split_model_at_path_chain(\n                model_obj,\n                element_paths,\n                base_dir,\n                content_type,\n                cur_path_index,\n                split_plan,\n                False,\n                root_file_name,\n                aliases_to_strip\n            )\n\n            cur_path_index += 1\n\n        # strip the root model object and add a WriteAction\n        stripped_root = model_obj.stripped_instance(stripped_fields_aliases=stripped_field_alias)\n        # If it's an empty model after stripping the fields, don't create path and don't write\n        if set(model_obj.__fields__.keys()) == set(stripped_field_alias):\n            return split_plan\n        if root_file_name != '':\n            root_file = base_dir / root_file_name\n        else:\n            root_file = base_dir / element_paths[0].to_root_path(content_type)\n        split_plan.add_action(CreatePathAction(root_file, True))\n        wrapper_alias = classname_to_alias(stripped_root.__class__.__name__, AliasMode.JSON)\n        split_plan.add_action(WriteFileAction(root_file, Element(stripped_root, wrapper_alias), content_type))\n\n        return split_plan\n\n    @classmethod\n    def find_aliases_to_strip(cls, element_paths: List[ElementPath]) -&gt; Dict[str, AliasTracker]:\n\"\"\"Find list of aliases that need to be stripped as each element written out.\"\"\"\n        # A given path may be present in several split actions\n        # Need to determine all parts stripped at each node in order to strip them all and\n        # write the stripped model only once\n        tracker_map: Dict[str, AliasTracker] = {}\n        for element_path in element_paths:\n            path = element_path.get_full()\n            path_parts = path.split('.')\n            alias = path_parts[-1]\n            if len(path_parts) &gt; 2 and alias != '*':\n                root_path = '.'.join(path_parts[:-1])\n                if root_path in tracker_map:\n                    tracker_map[root_path].add_alias(alias)\n                else:\n                    tracker_map[root_path] = AliasTracker(aliases=[alias])\n        return tracker_map\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.SplitCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.SplitCmd-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.SplitCmd.find_aliases_to_strip","title":"<code>find_aliases_to_strip(element_paths)</code>  <code>classmethod</code>","text":"<p>Find list of aliases that need to be stripped as each element written out.</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>@classmethod\ndef find_aliases_to_strip(cls, element_paths: List[ElementPath]) -&gt; Dict[str, AliasTracker]:\n\"\"\"Find list of aliases that need to be stripped as each element written out.\"\"\"\n    # A given path may be present in several split actions\n    # Need to determine all parts stripped at each node in order to strip them all and\n    # write the stripped model only once\n    tracker_map: Dict[str, AliasTracker] = {}\n    for element_path in element_paths:\n        path = element_path.get_full()\n        path_parts = path.split('.')\n        alias = path_parts[-1]\n        if len(path_parts) &gt; 2 and alias != '*':\n            root_path = '.'.join(path_parts[:-1])\n            if root_path in tracker_map:\n                tracker_map[root_path].add_alias(alias)\n            else:\n                tracker_map[root_path] = AliasTracker(aliases=[alias])\n    return tracker_map\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.SplitCmd.perform_split","title":"<code>perform_split(effective_cwd, file_name, elements, trestle_root)</code>  <code>classmethod</code>","text":"<p>Perform the split operation.</p> <p>Parameters:</p> Name Type Description Default <code>effective_cwd</code> <code>Path</code> <p>effective directory in which the the split operation is performed</p> required <code>file_name</code> <code>str</code> <p>file name of model to split, or '' if deduced from elements and cwd</p> required <code>elements</code> <code>str</code> <p>comma separated list of paths to strip from the file, with quotes removed</p> required <p>Returns:</p> Type Description <code>int</code> <p>0 on success and 1 on failure</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>@classmethod\ndef perform_split(\n    cls, effective_cwd: pathlib.Path, file_name: str, elements: str, trestle_root: pathlib.Path\n) -&gt; int:\n\"\"\"Perform the split operation.\n\n    Args:\n        effective_cwd: effective directory in which the the split operation is performed\n        file_name: file name of model to split, or '' if deduced from elements and cwd\n        elements: comma separated list of paths to strip from the file, with quotes removed\n\n    Returns:\n        0 on success and 1 on failure\n    \"\"\"\n    file_path_list: List[Tuple[str, str]] = []\n\n    if file_name:\n        file_path_list.append((file_name, elements))\n    else:\n        # cwd must be in the model directory if file to split is not specified\n        # find top directory for this model based on trestle root and cwd\n        model_dir = file_utils.extract_project_model_path(effective_cwd)\n        if model_dir is None:\n            raise TrestleError('Current directory must be within a model directory if file is not specified')\n\n        content_type: FileContentType = FileContentType.dir_to_content_type(model_dir)\n\n        # determine the file needed for each split path\n        element_paths = elements.split(',')\n        for path in element_paths:\n            element_path = ElementPath(path)\n            # if element path is relative use directory context to determine absolute path\n            element_path.make_absolute(model_dir, effective_cwd)\n            file_path = element_path.find_last_file_in_path(content_type, model_dir)\n            # now make the element path relative to the model file to be loaded\n            if file_path is None or element_path.make_relative(file_path.relative_to(model_dir)) != 0:\n                raise TrestleError(f'Unable to match element path with files in model directory {element_path}')\n\n            file_path_list.append((file_path, element_path.to_string()))\n\n    # match paths to corresponding files since several paths may be split from the same file\n    file_path_dict: Dict[str, str] = {}\n    for file_path in file_path_list:\n        key = file_path[0]\n        path = file_path[1]\n        if key not in file_path_dict:\n            file_path_dict[key] = path\n        else:\n            current_path = file_path_dict[key]\n            file_path_dict[key] = f'{current_path},{path}'\n\n    for raw_file_name, element_path in file_path_dict.items():\n        file_path = file_utils.relative_resolve(pathlib.Path(raw_file_name), effective_cwd)\n        # this makes assumptions that the path is relative.\n        if not file_path.exists():\n            raise TrestleError(f'File {file_path} does not exist.')\n\n        content_type = FileContentType.to_content_type(file_path.suffix)\n\n        # find the base directory of the file\n        base_dir = file_path.parent\n        model_type, _ = ModelUtils.get_stripped_model_type(file_path, trestle_root)\n\n        model: OscalBaseModel = model_type.oscal_read(file_path)\n\n        if cmd_utils.split_is_too_fine(element_path, model):\n            raise TrestleError('Cannot split the model to the level of uuids, strings, etc.')\n\n        # use the model itself to resolve any wildcards and create list of element paths\n        logger.debug(f'split calling parse_element_args on {element_path}')\n        # use contextual mode to parse\n\n        element_paths: List[ElementPath] = cmd_utils.parse_element_args(\n            model, element_path.split(','), base_dir.relative_to(trestle_root)\n        )\n\n        # analyze the split tree and determine which aliases should be stripped from each file\n        aliases_to_strip = cls.find_aliases_to_strip(element_paths)\n\n        # need the file name relative to the base directory\n        file_name_no_path = str(file_path.name)\n\n        split_plan = cls.split_model(\n            model, element_paths, base_dir, content_type, file_name_no_path, aliases_to_strip\n        )\n        trash.store(file_path, True)\n\n        try:\n            split_plan.execute()\n        except Exception as e:\n            trash.recover(file_path, True)\n            raise TrestleError(f'Split has failed with error: {e}.')\n\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.SplitCmd.prepare_sub_model_split_actions","title":"<code>prepare_sub_model_split_actions(sub_model_item, sub_model_dir, file_prefix, content_type)</code>  <code>classmethod</code>","text":"<p>Create split actions of sub model.</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>@classmethod\ndef prepare_sub_model_split_actions(\n    cls,\n    sub_model_item: OscalBaseModel,\n    sub_model_dir: pathlib.Path,\n    file_prefix: str,\n    content_type: FileContentType\n) -&gt; List[Action]:\n\"\"\"Create split actions of sub model.\"\"\"\n    actions: List[Action] = []\n    file_name = cmd_utils.to_model_file_name(sub_model_item, file_prefix, content_type)\n    model_type = classname_to_alias(type(sub_model_item).__name__, AliasMode.JSON)\n    sub_model_file = sub_model_dir / file_name\n    actions.append(CreatePathAction(sub_model_file))\n    actions.append(WriteFileAction(sub_model_file, Element(sub_model_item, model_type), content_type))\n    return actions\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.SplitCmd.split_model","title":"<code>split_model(model_obj, element_paths, base_dir, content_type, root_file_name, aliases_to_strip)</code>  <code>classmethod</code>","text":"<p>Split the model at the provided element paths.</p> <p>It returns a plan for the operation</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>@classmethod\ndef split_model(\n    cls,\n    model_obj: OscalBaseModel,\n    element_paths: List[ElementPath],\n    base_dir: pathlib.Path,\n    content_type: FileContentType,\n    root_file_name: str,\n    aliases_to_strip: Dict[str, AliasTracker]\n) -&gt; Plan:\n\"\"\"Split the model at the provided element paths.\n\n    It returns a plan for the operation\n    \"\"\"\n    # initialize plan\n    split_plan = Plan()\n\n    # loop through the element path list and update the split_plan\n    stripped_field_alias = []\n    cur_path_index = 0\n    while cur_path_index &lt; len(element_paths):\n        # extract the sub element name for each of the root path of the path chain\n        element_path = element_paths[cur_path_index]\n\n        if element_path.get_parent() is None and len(element_path.get()) &gt; 1:\n            stripped_part = element_path.get()[1]\n            if stripped_part == ElementPath.WILDCARD:\n                stripped_field_alias.append('__root__')\n            else:\n                if stripped_part not in stripped_field_alias:\n                    stripped_field_alias.append(stripped_part)\n\n        # split model at the path chain\n        cur_path_index = cls.split_model_at_path_chain(\n            model_obj,\n            element_paths,\n            base_dir,\n            content_type,\n            cur_path_index,\n            split_plan,\n            False,\n            root_file_name,\n            aliases_to_strip\n        )\n\n        cur_path_index += 1\n\n    # strip the root model object and add a WriteAction\n    stripped_root = model_obj.stripped_instance(stripped_fields_aliases=stripped_field_alias)\n    # If it's an empty model after stripping the fields, don't create path and don't write\n    if set(model_obj.__fields__.keys()) == set(stripped_field_alias):\n        return split_plan\n    if root_file_name != '':\n        root_file = base_dir / root_file_name\n    else:\n        root_file = base_dir / element_paths[0].to_root_path(content_type)\n    split_plan.add_action(CreatePathAction(root_file, True))\n    wrapper_alias = classname_to_alias(stripped_root.__class__.__name__, AliasMode.JSON)\n    split_plan.add_action(WriteFileAction(root_file, Element(stripped_root, wrapper_alias), content_type))\n\n    return split_plan\n</code></pre>"},{"location":"api_reference/trestle.core.commands.split/#trestle.core.commands.split.SplitCmd.split_model_at_path_chain","title":"<code>split_model_at_path_chain(model_obj, element_paths, base_dir, content_type, cur_path_index, split_plan, strip_root, root_file_name, aliases_to_strip, last_one=True)</code>  <code>classmethod</code>","text":"<p>Recursively split the model at the provided chain of element paths.</p> <p>It assumes that a chain of element paths starts at the cur_path_index with the first path ending with a wildcard (*)</p> <p>If the wildcard follows an element that is inherently a list of items, the list of items is extracted. But if the wildcard follows a generic model than members of that model class found in the model will be split off.  But only the non-trivial elements are removed, i.e. not str, int, datetime, etc.</p> <p>Parameters:</p> Name Type Description Default <code>model_obj</code> <code>OscalBaseModel</code> <p>The OscalBaseModel to be split</p> required <code>element_paths</code> <code>List[trestle.core.models.elements.ElementPath]</code> <p>The List[ElementPath] of elements to split, including embedded wildcards</p> required <code>base_dir</code> <code>Path</code> <p>pathlib.Path of the file being split</p> required <code>content_type</code> <code>FileContentType</code> <p>json or yaml files</p> required <code>cur_path_index</code> <code>int</code> <p>Index into the list of element paths for the current split operation</p> required <code>split_plan</code> <code>Plan</code> <p>The accumulated plan of actions needed to perform the split</p> required <code>strip_root</code> <code>bool</code> <p>Whether to strip elements from the root object</p> required <code>root_file_name</code> <code>str</code> <p>Filename of root file that gets split into a list of items</p> required <code>aliases_to_strip</code> <code>Dict[str, trestle.core.commands.split.AliasTracker]</code> <p>AliasTracker previously loaded with aliases that need to be split from each element</p> required <code>last_one</code> <code>bool</code> <p>bool indicating last item in array has been split and stripped model can now be written</p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>int representing the index where the chain of the path ends.</p> <p>Examples:</p> <p>For example, element paths could have a list of paths as below for a <code>ComponentDefinition</code> model where the first path is the start of the chain.</p> <p>For each of the sub model described by the first element path (e.g component-defintion.components.) in the chain, the subsequent paths (e.g component.control-implementations.) will be applied recursively to retrieve the sub-sub models: [     'component-definition.component.',     'component.control-implementations.' ] for a command like below: trestle split -f component.yaml -e component-definition.components..control-implementations.</p> Source code in <code>trestle/core/commands/split.py</code> <pre><code>@classmethod\ndef split_model_at_path_chain(\n    cls,\n    model_obj: OscalBaseModel,\n    element_paths: List[ElementPath],\n    base_dir: pathlib.Path,\n    content_type: FileContentType,\n    cur_path_index: int,\n    split_plan: Plan,\n    strip_root: bool,\n    root_file_name: str,\n    aliases_to_strip: Dict[str, AliasTracker],\n    last_one: bool = True\n) -&gt; int:\n\"\"\"Recursively split the model at the provided chain of element paths.\n\n    It assumes that a chain of element paths starts at the cur_path_index with the first path ending\n    with a wildcard (*)\n\n    If the wildcard follows an element that is inherently a list of items, the list of items is extracted.\n    But if the wildcard follows a generic model than members of that model class found in the model will be\n    split off.  But only the non-trivial elements are removed, i.e. not str, int, datetime, etc.\n\n    Args:\n        model_obj: The OscalBaseModel to be split\n        element_paths: The List[ElementPath] of elements to split, including embedded wildcards\n        base_dir: pathlib.Path of the file being split\n        content_type: json or yaml files\n        cur_path_index: Index into the list of element paths for the current split operation\n        split_plan: The accumulated plan of actions needed to perform the split\n        strip_root: Whether to strip elements from the root object\n        root_file_name: Filename of root file that gets split into a list of items\n        aliases_to_strip: AliasTracker previously loaded with aliases that need to be split from each element\n        last_one: bool indicating last item in array has been split and stripped model can now be written\n\n    Returns:\n        int representing the index where the chain of the path ends.\n\n    Examples:\n        For example, element paths could have a list of paths as below for a `ComponentDefinition` model where\n        the first path is the start of the chain.\n\n        For each of the sub model described by the first element path (e.g component-defintion.components.*) in the\n        chain, the subsequent paths (e.g component.control-implementations.*) will be applied recursively\n        to retrieve the sub-sub models:\n        [\n            'component-definition.component.*',\n            'component.control-implementations.*'\n        ]\n        for a command like below:\n        trestle split -f component.yaml -e component-definition.components.*.control-implementations.*\n    \"\"\"\n    if split_plan is None:\n        raise TrestleError('Split plan must have been initialized')\n\n    if cur_path_index &lt; 0:\n        raise TrestleError('Current index of the chain of paths cannot be less than 0')\n\n    # if there are no more element_paths, return the current plan\n    if cur_path_index &gt;= len(element_paths):\n        return cur_path_index\n\n    # initialize local variables\n    element = Element(model_obj)\n    stripped_field_alias: List[str] = []\n\n    # get the sub_model specified by the element_path of this round\n    element_path = element_paths[cur_path_index]\n\n    # does the next element_path point back at me\n    is_parent = cur_path_index + 1 &lt; len(element_paths) and element_paths[cur_path_index\n                                                                          + 1].get_parent() == element_path\n\n    # root dir name for sub models dir\n    # 00000__group.json will have the root_dir name as 00000__group for sub models of group\n    # catalog.json will have the root_dir name as catalog\n    root_dir = ''\n    if root_file_name != '':\n        root_dir = str(pathlib.Path(root_file_name).with_suffix(''))\n\n    sub_models = element.get_at(element_path, False)  # we call sub_models as in plural, but it can be just one\n\n    # assume cur_path_index is the end of the chain\n    # value of this variable may change during recursive split of the sub-models below\n    path_chain_end = cur_path_index\n\n    # if wildcard is present in the element_path and the next path in the chain has current path as the parent,\n    # Then deal with case of list, or split of arbitrary oscalbasemodel\n    if is_parent and element_path.get_last() is not ElementPath.WILDCARD:\n        # create dir for all sub model items\n        sub_models_dir = base_dir / element_path.to_root_path()\n        sub_model_plan = Plan()\n        path_chain_end = cls.split_model_at_path_chain(\n            sub_models,\n            element_paths,\n            sub_models_dir,\n            content_type,\n            cur_path_index + 1,\n            sub_model_plan,\n            True,\n            '',\n            aliases_to_strip\n        )\n        sub_model_actions = sub_model_plan.get_actions()\n        split_plan.add_actions(sub_model_actions)\n    elif element_path.get_last() == ElementPath.WILDCARD:\n        # extract sub-models into a dict with appropriate prefix\n        sub_model_items: Dict[str, OscalBaseModel] = {}\n        sub_models_dir = base_dir / element_path.to_file_path(root_dir=root_dir)\n        if isinstance(sub_models, list):\n            for i, sub_model_item in enumerate(sub_models):\n                # e.g. `groups/00000_groups/`\n                prefix = str(i).zfill(const.FILE_DIGIT_PREFIX_LENGTH)\n                sub_model_items[prefix] = sub_model_item\n\n        # process list sub model items\n        count = 0\n        for key, sub_model_item in sub_model_items.items():\n            count += 1\n            # recursively split the sub-model if there are more element paths to traverse\n            # e.g. split component.control-implementations.*\n            require_recursive_split = cur_path_index + 1 &lt; len(element_paths) and element_paths[\n                cur_path_index + 1].get_parent() == element_path\n\n            if require_recursive_split:\n                # prepare individual directory for each sub-model\n                sub_root_file_name = cmd_utils.to_model_file_name(sub_model_item, key, content_type)\n                sub_model_plan = Plan()\n\n                last_one: bool = count == len(sub_model_items)\n                path_chain_end = cls.split_model_at_path_chain(\n                    sub_model_item,\n                    element_paths,\n                    sub_models_dir,\n                    content_type,\n                    cur_path_index + 1,\n                    sub_model_plan,\n                    True,\n                    sub_root_file_name,\n                    aliases_to_strip,\n                    last_one\n                )\n                sub_model_actions = sub_model_plan.get_actions()\n            else:\n                sub_model_actions = cls.prepare_sub_model_split_actions(\n                    sub_model_item, sub_models_dir, key, content_type\n                )\n\n            split_plan.add_actions(sub_model_actions)\n    else:\n        # the chain of path ends at the current index.\n        # so no recursive call. Let's just write the sub model to the file and get out\n        if sub_models is not None:\n            sub_model_file = base_dir / element_path.to_file_path(content_type, root_dir=root_dir)\n            split_plan.add_action(CreatePathAction(sub_model_file))\n            split_plan.add_action(\n                WriteFileAction(sub_model_file, Element(sub_models, element_path.get_element_name()), content_type)\n            )\n\n    # Strip the root model and add a WriteAction for the updated model object in the plan\n    if strip_root:\n        full_path = element_path.get_full()\n        path = '.'.join(full_path.split('.')[:-1])\n        aliases = [element_path.get_element_name()]\n        need_to_write = True\n        use_alias_dict = aliases_to_strip is not None and path in aliases_to_strip\n        if use_alias_dict:\n            aliases = aliases_to_strip[path].get_aliases()\n            need_to_write = aliases_to_strip[path].needs_writing()\n\n        stripped_model = model_obj.stripped_instance(stripped_fields_aliases=aliases)\n        # can mark it written even if it doesn't need writing since it is empty\n        # but if an array only mark it written if it's the last one\n        if last_one and use_alias_dict:\n            aliases_to_strip[path].mark_written()\n        # If it's an empty model after stripping the fields, don't create path and don't write\n        field_list = [x for x in model_obj.__fields__.keys() if model_obj.__fields__[x] is not None]\n        if set(field_list) == set(stripped_field_alias):\n            return path_chain_end\n\n        if need_to_write:\n            if root_file_name != '':\n                root_file = base_dir / root_file_name\n            else:\n                root_file = base_dir / element_path.to_root_path(content_type)\n\n            split_plan.add_action(CreatePathAction(root_file))\n            wrapper_alias = classname_to_alias(stripped_model.__class__.__name__, AliasMode.JSON)\n            split_plan.add_action(WriteFileAction(root_file, Element(stripped_model, wrapper_alias), content_type))\n\n    # return the end of the current path chain\n    return path_chain_end\n</code></pre>"},{"location":"api_reference/trestle.core.commands.task/","title":"task","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.task/#trestle.core.commands.task","title":"<code>trestle.core.commands.task</code>","text":"<p>Trestle task command.</p>"},{"location":"api_reference/trestle.core.commands.task/#trestle.core.commands.task.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.task/#trestle.core.commands.task-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.task/#trestle.core.commands.task.TaskCmd","title":"<code> TaskCmd            (CommandPlusDocs)         </code>","text":"<p>Run arbitrary trestle tasks in a simple and extensible methodology.</p> Source code in <code>trestle/core/commands/task.py</code> <pre><code>class TaskCmd(CommandPlusDocs):\n\"\"\"Run arbitrary trestle tasks in a simple and extensible methodology.\"\"\"\n\n    name = 'task'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument(\n            'task',\n            nargs='?',\n            type=str,\n            help='The name of the task to be run, trestle task -l will list available tasks.'\n        )\n        self.add_argument('-l', '--list', action='store_true', help='List the available tasks')\n        self.add_argument(\n            '-c', '--config', type=pathlib.Path, help='Pass a customized configuration file specifically for a task'\n        )\n        self.add_argument('-i', '--info', action='store_true', help='Print information about a particular task.')\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            logger.debug('Entering trestle task.')\n            log.set_log_level_from_args(args)\n            # Initial logic for conflicting args\n            if args.task and args.list:\n                raise TrestleIncorrectArgsError('Task name or -l can be provided not both.')\n\n            if not args.task and not args.list:\n                raise TrestleIncorrectArgsError(\n                    'Either a trestle task or \"-l/--list\" shoudl be passed as input arguments.'\n                )\n\n            # Ensure trestle directory (must be true)\n            trestle_root = args.trestle_root  # trestle root is set via command line in args. Default is cwd.\n            if not trestle_root or not file_utils.is_valid_project_root(args.trestle_root):\n                raise TrestleError(f'Given directory: {trestle_root} is not a trestle project.')\n\n            config_path = trestle_root / const.TRESTLE_CONFIG_DIR / const.TRESTLE_CONFIG_FILE\n\n            if args.config:\n                config_path = pathlib.Path(args.config)\n            if not config_path.exists():\n                raise TrestleError(f'Config file at {config_path} does not exist.')\n\n            # permit ${name} in config definitions\n            global_config = configparser.ConfigParser(interpolation=configparser.ExtendedInterpolation())\n            global_config.read_file(config_path.open('r', encoding=const.FILE_ENCODING))\n            # run setup\n            task_index = self._build_task_index()\n\n            # Clean to run\n            if args.list:\n                self._list_tasks(task_index)\n                return CmdReturnCodes.SUCCESS.value\n            # run the task\n            if args.task not in task_index.keys():\n                raise TrestleIncorrectArgsError(f'Unknown trestle task: {args.task}')\n\n            logger.debug(f'Loading task: {args.task}')\n            section_label = 'task.' + args.task\n            config_section: Optional[configparser.SectionProxy] = None\n            if section_label in global_config.sections():\n                config_section = global_config[section_label]\n            else:\n                logger.warning(\n                    f'Config file was not configured with the appropriate section for the task: \"[{section_label}]\"'\n                )\n\n            task = task_index[args.task](config_section)\n            if args.info:\n                task.print_info()\n                return CmdReturnCodes.SUCCESS.value\n\n            simulate_result = task.simulate()\n            if not (simulate_result == TaskOutcome.SIM_SUCCESS):\n                raise TrestleError(f'Task {args.task} reported a {simulate_result}')\n\n            actual_result = task.execute()\n            if not (actual_result == TaskOutcome.SUCCESS):\n                raise TrestleError(f'Task {args.task} reported a {actual_result}')\n\n            logger.info(f'Task: {args.task} executed successfully.')\n            return CmdReturnCodes.SUCCESS.value\n\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while executing Trestle task')\n\n    def _build_task_index(self) -&gt; Dict[str, Type[TaskBase]]:\n\"\"\"Build an index of all classes in which are tasks and present as a dictionary.\"\"\"\n        task_index: Dict[str, Type[TaskBase]] = {}\n        pkgpath = str(pathlib.Path(trestle.tasks.__file__).parent)\n        for _, name, _ in pkgutil.iter_modules([pkgpath]):\n            __import__(f'trestle.tasks.{name}')\n            clsmembers = inspect.getmembers(sys.modules[f'trestle.tasks.{name}'], inspect.isclass)\n            for candidate in clsmembers:\n                if issubclass(candidate[1], TaskBase):\n                    task_index[candidate[1].name] = candidate[1]\n        return task_index\n\n    def _list_tasks(self, task_index: Dict[str, Type[TaskBase]]) -&gt; None:\n        logger.info('Available tasks:')\n        for key in task_index.keys():\n            logger.info(f'    {key}')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.task/#trestle.core.commands.task.TaskCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.validate/","title":"validate","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.validate/#trestle.core.commands.validate","title":"<code>trestle.core.commands.validate</code>","text":"<p>Trestle Validate Command.</p>"},{"location":"api_reference/trestle.core.commands.validate/#trestle.core.commands.validate.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.validate/#trestle.core.commands.validate-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.validate/#trestle.core.commands.validate.ValidateCmd","title":"<code> ValidateCmd            (CommandPlusDocs)         </code>","text":"<p>Validate contents of a trestle model in different modes.</p> Source code in <code>trestle/core/commands/validate.py</code> <pre><code>class ValidateCmd(CommandPlusDocs):\n\"\"\"Validate contents of a trestle model in different modes.\"\"\"\n\n    name = ARG_VALIDATE\n\n    def _init_arguments(self) -&gt; None:\n        vfact.init_arguments(self)\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            log.set_log_level_from_args(args)\n\n            mode_args = argparse.Namespace(mode=VAL_MODE_ALL)\n            validator = vfact.validator_factory.get(mode_args)\n\n            return validator.validate(args)\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error while validating contents of a trestle model')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.validate/#trestle.core.commands.validate.ValidateCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.commands.version/","title":"version","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.commands.version/#trestle.core.commands.version","title":"<code>trestle.core.commands.version</code>","text":"<p>Trestle Validate Command.</p>"},{"location":"api_reference/trestle.core.commands.version/#trestle.core.commands.version.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.commands.version/#trestle.core.commands.version-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.commands.version/#trestle.core.commands.version.VersionCmd","title":"<code> VersionCmd            (CommandBase)         </code>","text":"<p>Output version info for trestle and OSCAL.</p> Source code in <code>trestle/core/commands/version.py</code> <pre><code>class VersionCmd(CommandBase):\n\"\"\"Output version info for trestle and OSCAL.\"\"\"\n\n    name = 'version'\n\n    def _init_arguments(self) -&gt; None:\n        self.add_argument('-n', '--name', help='Name of the OSCAL model', default=None, type=str)\n        self.add_argument(\n            '-t',\n            '--type',\n            help='Type of the model being queried: (catalog, profile, component-definition, ...)',\n            default=None,\n            type=str\n        )\n\n    def _get_version(self, type_name: str, obj_name: str, trestle_root: pathlib.Path) -&gt; str:\n\"\"\"Fetch the version of the OSCAL object from its metadata.\"\"\"\n        oscal_object, obj_path = ModelUtils.load_model_for_type(trestle_root, type_name, obj_name)\n\n        if not (oscal_object.metadata or oscal_object.metadata.version):\n            raise TrestleError(f'Unable to determine the version. Metadata version is missing in model: {obj_path}.')\n\n        return oscal_object.metadata.version\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        try:\n            status = CmdReturnCodes.COMMAND_ERROR.value\n\n            if not args.name and not args.type:\n                version_string = f'Trestle version v{__version__} based on OSCAL version {OSCAL_VERSION}'\n                self.out(version_string)\n                status = CmdReturnCodes.SUCCESS.value\n\n            if not (args.name and args.type) and (args.name or args.type):\n                raise TrestleError('Either both arguments --name and --type should be provided or none.')\n\n            if args.name and args.type:\n                trestle_root = pathlib.Path(args.trestle_root)\n                version = self._get_version(args.type, args.name, trestle_root)\n                version_string = f'Version of OSCAL object of {args.name} {args.type} is: {version}.'\n                self.out(version_string)\n                status = CmdReturnCodes.SUCCESS.value\n\n            return status\n        except Exception as e:  # pragma: no cover\n            return handle_generic_command_exception(e, logger, 'Error occurred when running trestle version')\n</code></pre>"},{"location":"api_reference/trestle.core.commands.version/#trestle.core.commands.version.VersionCmd.name","title":"<code>name</code>","text":""},{"location":"api_reference/trestle.core.control_context/","title":"control_context","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context","title":"<code>trestle.core.control_context</code>","text":"<p>Provide a context for control operations.</p>"},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ContextPurpose","title":"<code> ContextPurpose            (Enum)         </code>","text":"<p>Specify the modality of the control markdown.</p> Source code in <code>trestle/core/control_context.py</code> <pre><code>class ContextPurpose(Enum):\n\"\"\"Specify the modality of the control markdown.\"\"\"\n\n    CATALOG = 0\n    COMPONENT = 1\n    PROFILE = 2\n    SSP = 3\n</code></pre>"},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ContextPurpose.CATALOG","title":"<code>CATALOG</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ContextPurpose.COMPONENT","title":"<code>COMPONENT</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ContextPurpose.PROFILE","title":"<code>PROFILE</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ContextPurpose.SSP","title":"<code>SSP</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext","title":"<code> ControlContext        </code>  <code>dataclass</code>","text":"<p>Class encapsulating control markdown usage.</p> Source code in <code>trestle/core/control_context.py</code> <pre><code>class ControlContext:\n\"\"\"Class encapsulating control markdown usage.\"\"\"\n\n    purpose: ContextPurpose\n    to_markdown: bool\n    trestle_root: pathlib.Path\n    md_root: pathlib.Path\n    prompt_responses: bool\n    overwrite_header_values: bool\n    set_parameters_flag: bool\n    cli_yaml_header: Optional[Dict[Any, Any]] = None\n    sections_dict: Optional[Dict[str, str]] = None\n    profile: Optional[prof.Profile] = None\n    required_sections: Optional[List[str]] = None\n    allowed_sections: Optional[List[str]] = None\n    comp_def: Optional[comp.ComponentDefinition] = None\n    comp_name: Optional[str] = None\n    component: Optional[comp.DefinedComponent] = None\n    comp_def_name_list: Optional[List[str]] = None\n    inherited_props: Optional[Dict[str, Any]] = None\n    rules_dict: Optional[Dict[str, Dict[str, Any]]] = None\n    rules_params_dict: Optional[Dict[str, Dict[str, Any]]] = None\n    control_implementation: Optional[comp.ControlImplementation] = None\n    uri_name_map: Optional[Dict[str, str]] = None\n    comp_dict: Optional[CompDict] = None\n    merged_header: Optional[Dict[str, Any]] = None\n\n    @classmethod\n    def generate(\n        cls,\n        purpose: ContextPurpose,\n        to_markdown: bool,\n        trestle_root: pathlib.Path,\n        md_root: pathlib.Path,\n        prompt_responses=False,\n        overwrite_header_values=False,\n        set_parameters_flag=False,\n        cli_yaml_header: Optional[Dict[Any, Any]] = None,\n        sections_dict: Optional[Dict[str, str]] = None,\n        profile: Optional[prof.Profile] = None,\n        required_sections: Optional[List[str]] = None,\n        allowed_sections: Optional[List[str]] = None,\n        comp_def: Optional[comp.ComponentDefinition] = None,\n        comp_name: Optional[str] = None,\n        component: Optional[comp.DefinedComponent] = None,\n        comp_def_name_list: Optional[List[str]] = None,\n        inherited_props: Optional[Dict[str, Any]] = None,\n        rules_dict: Optional[Dict[str, Dict[str, Any]]] = None,\n        rules_params_dict: Optional[Dict[str, Dict[str, Any]]] = None,\n        control_implementation: Optional[comp.ControlImplementation] = None,\n        uri_name_map: Optional[Dict[str, str]] = None,\n        comp_dict: Optional[CompDict] = None,\n        merged_header: Optional[Dict[str, Any]] = None\n    ) -&gt; ControlContext:\n\"\"\"Generate control context of the needed type.\"\"\"\n        context = cls(\n            purpose,\n            to_markdown,\n            trestle_root,\n            md_root,\n            prompt_responses,\n            overwrite_header_values,\n            set_parameters_flag,\n            cli_yaml_header=cli_yaml_header,\n            sections_dict=sections_dict,\n            profile=profile,\n            required_sections=required_sections,\n            allowed_sections=allowed_sections,\n            comp_def=comp_def,\n            comp_name=comp_name,\n            component=component,\n            comp_def_name_list=comp_def_name_list,\n            inherited_props=inherited_props,\n            rules_dict=rules_dict,\n            rules_params_dict=rules_params_dict,\n            control_implementation=control_implementation,\n            uri_name_map=uri_name_map,\n            comp_dict=comp_dict\n        )\n        context.cli_yaml_header = as_dict(cli_yaml_header)\n        context.sections_dict = as_dict(sections_dict)\n        context.merged_header = as_dict(merged_header)\n        # catalog generate always sets params\n        if to_markdown:\n            context.set_parameters = True\n        return context\n\n    @classmethod\n    def clone(cls, context: ControlContext) -&gt; ControlContext:\n\"\"\"Create a deep clone of the context without duplicating large objects.\"\"\"\n        new_context = cls(\n            context.purpose,\n            context.to_markdown,\n            context.trestle_root,\n            context.md_root,\n            context.prompt_responses,\n            context.overwrite_header_values,\n            context.set_parameters_flag,\n            cli_yaml_header=copy.deepcopy(context.cli_yaml_header),\n            sections_dict=copy.deepcopy(context.sections_dict),\n            profile=context.profile,\n            required_sections=context.required_sections,\n            allowed_sections=context.allowed_sections,\n            comp_def=context.comp_def,\n            comp_name=context.comp_name,\n            component=context.component,\n            comp_def_name_list=context.comp_def_name_list,\n            inherited_props=copy.deepcopy(context.inherited_props),\n            rules_dict=copy.deepcopy(context.rules_dict),\n            rules_params_dict=copy.deepcopy(context.rules_params_dict),\n            control_implementation=copy.deepcopy(context.control_implementation),\n            uri_name_map=context.uri_name_map,\n            comp_dict=copy.deepcopy(context.comp_dict),\n            merged_header=copy.deepcopy(context.merged_header)\n        )\n        return new_context\n</code></pre>"},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.allowed_sections","title":"<code>allowed_sections: Optional[List[str]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.cli_yaml_header","title":"<code>cli_yaml_header: Optional[Dict[Any, Any]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.comp_def","title":"<code>comp_def: Optional[trestle.oscal.component.ComponentDefinition]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.comp_def_name_list","title":"<code>comp_def_name_list: Optional[List[str]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.comp_dict","title":"<code>comp_dict: Optional[Dict[str, Dict[str, trestle.core.control_interface.ComponentImpInfo]]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.comp_name","title":"<code>comp_name: Optional[str]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.component","title":"<code>component: Optional[trestle.oscal.component.DefinedComponent]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.control_implementation","title":"<code>control_implementation: Optional[trestle.oscal.component.ControlImplementation]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.inherited_props","title":"<code>inherited_props: Optional[Dict[str, Any]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.md_root","title":"<code>md_root: Path</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.merged_header","title":"<code>merged_header: Optional[Dict[str, Any]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.overwrite_header_values","title":"<code>overwrite_header_values: bool</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.profile","title":"<code>profile: Optional[trestle.oscal.profile.Profile]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.prompt_responses","title":"<code>prompt_responses: bool</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.purpose","title":"<code>purpose: ContextPurpose</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.required_sections","title":"<code>required_sections: Optional[List[str]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.rules_dict","title":"<code>rules_dict: Optional[Dict[str, Dict[str, Any]]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.rules_params_dict","title":"<code>rules_params_dict: Optional[Dict[str, Dict[str, Any]]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.sections_dict","title":"<code>sections_dict: Optional[Dict[str, str]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.set_parameters_flag","title":"<code>set_parameters_flag: bool</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.to_markdown","title":"<code>to_markdown: bool</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.trestle_root","title":"<code>trestle_root: Path</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.uri_name_map","title":"<code>uri_name_map: Optional[Dict[str, str]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.__eq__","title":"<code>__eq__(self, other)</code>  <code>special</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.__init__","title":"<code>__init__(self, purpose, to_markdown, trestle_root, md_root, prompt_responses, overwrite_header_values, set_parameters_flag, cli_yaml_header=None, sections_dict=None, profile=None, required_sections=None, allowed_sections=None, comp_def=None, comp_name=None, component=None, comp_def_name_list=None, inherited_props=None, rules_dict=None, rules_params_dict=None, control_implementation=None, uri_name_map=None, comp_dict=None, merged_header=None)</code>  <code>special</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":""},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.clone","title":"<code>clone(context)</code>  <code>classmethod</code>","text":"<p>Create a deep clone of the context without duplicating large objects.</p> Source code in <code>trestle/core/control_context.py</code> <pre><code>@classmethod\ndef clone(cls, context: ControlContext) -&gt; ControlContext:\n\"\"\"Create a deep clone of the context without duplicating large objects.\"\"\"\n    new_context = cls(\n        context.purpose,\n        context.to_markdown,\n        context.trestle_root,\n        context.md_root,\n        context.prompt_responses,\n        context.overwrite_header_values,\n        context.set_parameters_flag,\n        cli_yaml_header=copy.deepcopy(context.cli_yaml_header),\n        sections_dict=copy.deepcopy(context.sections_dict),\n        profile=context.profile,\n        required_sections=context.required_sections,\n        allowed_sections=context.allowed_sections,\n        comp_def=context.comp_def,\n        comp_name=context.comp_name,\n        component=context.component,\n        comp_def_name_list=context.comp_def_name_list,\n        inherited_props=copy.deepcopy(context.inherited_props),\n        rules_dict=copy.deepcopy(context.rules_dict),\n        rules_params_dict=copy.deepcopy(context.rules_params_dict),\n        control_implementation=copy.deepcopy(context.control_implementation),\n        uri_name_map=context.uri_name_map,\n        comp_dict=copy.deepcopy(context.comp_dict),\n        merged_header=copy.deepcopy(context.merged_header)\n    )\n    return new_context\n</code></pre>"},{"location":"api_reference/trestle.core.control_context/#trestle.core.control_context.ControlContext.generate","title":"<code>generate(purpose, to_markdown, trestle_root, md_root, prompt_responses=False, overwrite_header_values=False, set_parameters_flag=False, cli_yaml_header=None, sections_dict=None, profile=None, required_sections=None, allowed_sections=None, comp_def=None, comp_name=None, component=None, comp_def_name_list=None, inherited_props=None, rules_dict=None, rules_params_dict=None, control_implementation=None, uri_name_map=None, comp_dict=None, merged_header=None)</code>  <code>classmethod</code>","text":"<p>Generate control context of the needed type.</p> Source code in <code>trestle/core/control_context.py</code> <pre><code>@classmethod\ndef generate(\n    cls,\n    purpose: ContextPurpose,\n    to_markdown: bool,\n    trestle_root: pathlib.Path,\n    md_root: pathlib.Path,\n    prompt_responses=False,\n    overwrite_header_values=False,\n    set_parameters_flag=False,\n    cli_yaml_header: Optional[Dict[Any, Any]] = None,\n    sections_dict: Optional[Dict[str, str]] = None,\n    profile: Optional[prof.Profile] = None,\n    required_sections: Optional[List[str]] = None,\n    allowed_sections: Optional[List[str]] = None,\n    comp_def: Optional[comp.ComponentDefinition] = None,\n    comp_name: Optional[str] = None,\n    component: Optional[comp.DefinedComponent] = None,\n    comp_def_name_list: Optional[List[str]] = None,\n    inherited_props: Optional[Dict[str, Any]] = None,\n    rules_dict: Optional[Dict[str, Dict[str, Any]]] = None,\n    rules_params_dict: Optional[Dict[str, Dict[str, Any]]] = None,\n    control_implementation: Optional[comp.ControlImplementation] = None,\n    uri_name_map: Optional[Dict[str, str]] = None,\n    comp_dict: Optional[CompDict] = None,\n    merged_header: Optional[Dict[str, Any]] = None\n) -&gt; ControlContext:\n\"\"\"Generate control context of the needed type.\"\"\"\n    context = cls(\n        purpose,\n        to_markdown,\n        trestle_root,\n        md_root,\n        prompt_responses,\n        overwrite_header_values,\n        set_parameters_flag,\n        cli_yaml_header=cli_yaml_header,\n        sections_dict=sections_dict,\n        profile=profile,\n        required_sections=required_sections,\n        allowed_sections=allowed_sections,\n        comp_def=comp_def,\n        comp_name=comp_name,\n        component=component,\n        comp_def_name_list=comp_def_name_list,\n        inherited_props=inherited_props,\n        rules_dict=rules_dict,\n        rules_params_dict=rules_params_dict,\n        control_implementation=control_implementation,\n        uri_name_map=uri_name_map,\n        comp_dict=comp_dict\n    )\n    context.cli_yaml_header = as_dict(cli_yaml_header)\n    context.sections_dict = as_dict(sections_dict)\n    context.merged_header = as_dict(merged_header)\n    # catalog generate always sets params\n    if to_markdown:\n        context.set_parameters = True\n    return context\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/","title":"control_interface","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface","title":"<code>trestle.core.control_interface</code>","text":"<p>Handle queries and utility operations on controls in memory.</p>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.CompDict","title":"<code>CompDict</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ComponentImpInfo","title":"<code> ComponentImpInfo        </code>  <code>dataclass</code>","text":"<p>Class to capture component prose and status.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>class ComponentImpInfo:\n\"\"\"Class to capture component prose and status.\"\"\"\n\n    prose: str\n    rules: List[str]\n    props: List[common.Property]\n    # the lambda is needed to prevent a mutable from being used as a default\n    # without the lambda it would break python 3.11 and is a bug either way\n    status: common.ImplementationStatus = field(\n        default_factory=lambda: common.ImplementationStatus(state=const.STATUS_OPERATIONAL)\n    )\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ComponentImpInfo.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ComponentImpInfo.prose","title":"<code>prose: str</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ComponentImpInfo.rules","title":"<code>rules: List[str]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ComponentImpInfo.status","title":"<code>status: ImplementationStatus</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ComponentImpInfo.__eq__","title":"<code>__eq__(self, other)</code>  <code>special</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ComponentImpInfo.__init__","title":"<code>__init__(self, prose, rules, props, status=&lt;factory&gt;)</code>  <code>special</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ComponentImpInfo.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface","title":"<code> ControlInterface        </code>","text":"<p>Class to interact with controls in memory.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>class ControlInterface:\n\"\"\"Class to interact with controls in memory.\"\"\"\n\n    @staticmethod\n    def _wrap_label(label: str):\n        l_side = '\\['\n        r_side = '\\]'\n        wrapped = '' if label == '' else f'{l_side}{label}{r_side}'\n        return wrapped\n\n    @staticmethod\n    def _gap_join(a_str: str, b_str: str) -&gt; str:\n        a_clean = a_str.strip()\n        b_clean = b_str.strip()\n        if not b_clean:\n            return a_clean\n        gap = '\\n' if a_clean else ''\n        return a_clean + gap + b_clean\n\n    @staticmethod\n    def _get_control_section_part(part: common.Part, section_name: str) -&gt; str:\n\"\"\"Get the prose for a named section in the control.\"\"\"\n        prose = ''\n        if part.name == section_name and part.prose is not None:\n            prose = ControlInterface._gap_join(prose, part.prose)\n        if part.parts:\n            for sub_part in part.parts:\n                prose = ControlInterface._gap_join(\n                    prose, ControlInterface._get_control_section_part(sub_part, section_name)\n                )\n        return prose\n\n    @staticmethod\n    def get_control_section_prose(control: cat.Control, section_name: str) -&gt; str:\n\"\"\"Get the prose for the control section.\"\"\"\n        prose = ''\n        if control.parts:\n            for part in control.parts:\n                prose = ControlInterface._gap_join(\n                    prose, ControlInterface._get_control_section_part(part, section_name)\n                )\n        return prose\n\n    @staticmethod\n    def _find_section_info(part: common.Part, skip_section_list: List[str]) -&gt; Tuple[str, str, str]:\n\"\"\"Find section not in list.\"\"\"\n        if part.prose and part.name not in skip_section_list:\n            return part.id, part.name, part.title\n        if part.parts:\n            for sub_part in part.parts:\n                id_, name, title = ControlInterface._find_section_info(sub_part, skip_section_list)\n                if id_:\n                    return id_, name, title\n        return '', '', ''\n\n    @staticmethod\n    def _find_section(control: cat.Control, skip_section_list: List[str]) -&gt; Tuple[str, str, str]:\n\"\"\"Find next section not in list.\"\"\"\n        if control.parts:\n            for part in control.parts:\n                id_, name, title = ControlInterface._find_section_info(part, skip_section_list)\n                if id_:\n                    return id_, name, title\n        return '', '', ''\n\n    @staticmethod\n    def strip_to_make_ncname(label: str) -&gt; str:\n\"\"\"Strip chars to conform with NCNAME regex.\"\"\"\n        orig_label = label\n        # make sure first char is allowed\n        while label and label[0] not in const.NCNAME_UTF8_FIRST_CHAR_OPTIONS:\n            label = label[1:]\n        new_label = label[:1]\n        # now check remaining chars\n        if len(label) &gt; 1:\n            for ii in range(1, len(label)):\n                if label[ii] in const.NCNAME_UTF8_OTHER_CHAR_OPTIONS:\n                    new_label += label[ii]\n        # do final check to confirm it is NCNAME\n        match = re.search(const.NCNAME_REGEX, new_label)\n        if not match:\n            raise TrestleError(f'Unable to convert label {orig_label} to NCNAME format.')\n        return new_label\n\n    @staticmethod\n    def get_prop(item: TypeWithProps, prop_name: str, default: Optional[str] = None) -&gt; str:\n\"\"\"Get the property with that name or return empty string.\"\"\"\n        for prop in as_list(item.props):\n            if prop.name.strip().lower() == prop_name.strip().lower():\n                return prop.value.strip()\n        return default if default else ''\n\n    @staticmethod\n    def _delete_prop(part_control: TypeWithProps, prop_name: str) -&gt; None:\n\"\"\"Delete property with that name.\"\"\"\n        # assumes at most one instance\n        names = [prop.name for prop in as_list(part_control.props)]\n        if prop_name in names:\n            index = names.index(prop_name)\n            del part_control.props[index]\n        part_control.props = none_if_empty(part_control.props)\n\n    @staticmethod\n    def _replace_prop(part_control: TypeWithProps, new_prop: common.Property) -&gt; None:\n\"\"\"Delete property with that name if present and insert new one.\"\"\"\n        # assumes at most one instance\n        names = [prop.name for prop in as_list(part_control.props)]\n        if new_prop.name in names:\n            index = names.index(new_prop.name)\n            del part_control.props[index]\n        part_control.props = as_list(part_control.props)\n        part_control.props.append(new_prop)\n\n    @staticmethod\n    def _apply_params_format(param_str: Optional[str], params_format: Optional[str]) -&gt; Optional[str]:\n        if param_str is not None and params_format:\n            if params_format.count('.') &gt; 1:\n                raise TrestleError(\n                    f'Additional text {params_format} '\n                    f'for the parameter format cannot contain multiple dots (.)'\n                )\n            param_str = params_format.replace('.', param_str)\n        return param_str\n\n    @staticmethod\n    def create_statement_id(control_id: str, lower: bool = False) -&gt; str:\n\"\"\"Create the control statement id from the control id.\"\"\"\n        id_ = f'{control_id}_smt'\n        return id_.lower() if lower else id_\n\n    @staticmethod\n    def get_statement_id(control: cat.Control) -&gt; str:\n\"\"\"Find the statement id in the control.\"\"\"\n        for part in as_list(control.parts):\n            if part.name == const.STATEMENT:\n                return part.id\n        return ControlInterface.create_statement_id(control.id)\n\n    @staticmethod\n    def get_sort_id(control: cat.Control, allow_none=False) -&gt; Optional[str]:\n\"\"\"Get the sort-id for the control.\"\"\"\n        for prop in as_list(control.props):\n            if prop.name == const.SORT_ID:\n                return prop.value.strip()\n        return None if allow_none else control.id\n\n    @staticmethod\n    def get_label(item: TypeWithProps) -&gt; str:\n\"\"\"Get the label from the props of a part or control.\"\"\"\n        return ControlInterface.get_prop(item, 'label')\n\n    @staticmethod\n    def get_part_by_id(item: TypeWithParts, id_: str) -&gt; Optional[common.Part]:\n\"\"\"Find the part within this item's list of parts that matches id.\"\"\"\n        for part in as_list(item.parts):\n            if part.id == id_:\n                return part\n            deep_part = ControlInterface.get_part_by_id(part, id_)\n            if deep_part:\n                return deep_part\n        return None\n\n    @staticmethod\n    def get_part(part: common.Part, item_type: str, skip_id: Optional[str]) -&gt; List[Union[str, List[str]]]:\n\"\"\"\n        Find parts with the specified item type, within the given part.\n\n        For a part in a control find the parts in it that match the item_type\n        Return list of string formatted labels and associated descriptive prose\n        \"\"\"\n        items = []\n        if part.name in [const.STATEMENT, item_type]:\n            # the options here are to force the label to be the part.id or the part.label\n            # the label may be of the form (a) while the part.id is ac-1_smt.a.1.a\n            # here we choose the latter and extract the final element\n            label = ControlInterface.get_label(part)\n            label = part.id.split('.')[-1] if not label else label\n            wrapped_label = ControlInterface._wrap_label(label)\n            pad = '' if wrapped_label == '' or not part.prose else ' '\n            prose = '' if part.prose is None else part.prose\n            # top level prose has already been written out, if present\n            # use presence of . in id to tell if this is top level prose\n            if part.id != skip_id:\n                items.append(f'{wrapped_label}{pad}{prose}')\n            if part.parts:\n                sub_list = []\n                for prt in part.parts:\n                    sub_list.extend(ControlInterface.get_part(prt, item_type, skip_id))\n                sub_list.append('')\n                items.append(sub_list)\n        return items\n\n    @staticmethod\n    def _get_adds_for_control(profile: prof.Profile, control_id: str) -&gt; List[prof.Add]:\n\"\"\"Get the adds for a given control id from a profile.\"\"\"\n        adds: List[prof.Add] = []\n        if profile.modify:\n            for alter in as_list(profile.modify.alters):\n                if alter.control_id == control_id:\n                    adds.extend(as_list(alter.adds))\n        return adds\n\n    @staticmethod\n    def get_all_add_info(control_id: str, profile: prof.Profile) -&gt; List[PartInfo]:\n\"\"\"Get the adds for a control from a profile by control id.\"\"\"\n        part_infos = []\n        for add in ControlInterface._get_adds_for_control(profile, control_id):\n            # add control level props with no name\n            if add.props:\n                smt_part = add.by_id if add.by_id else ''\n                part_infos.append(PartInfo(name='', prose='', smt_part=smt_part, props=add.props))\n            # add part level props with part name\n            for part in as_list(add.parts):\n                subpart_info = ControlInterface._get_part_and_subpart_info(part, add.by_id)\n                part_infos.append(\n                    PartInfo(\n                        name=part.name, prose=part.prose, smt_part=add.by_id, props=part.props, parts=subpart_info\n                    )\n                )\n        return part_infos\n\n    @staticmethod\n    def _get_part_and_subpart_info(part: common.Part, add_by_id: str) -&gt; List[PartInfo]:\n\"\"\"Get part and its subparts info needed for markdown purposes.\"\"\"\n        part_infos = []\n        for subpart in as_list(part.parts):\n            subpart_info = None\n            if subpart.parts:\n                # Recursively add subparts info\n                subpart_info = ControlInterface._get_part_and_subpart_info(subpart, add_by_id)\n            part_infos.append(\n                PartInfo(\n                    name=subpart.name, prose=subpart.prose, smt_part=add_by_id, props=subpart.props, parts=subpart_info\n                )\n            )\n\n        return part_infos\n\n    @staticmethod\n    def get_section(control: cat.Control, skip_section_list: List[str]) -&gt; Tuple[str, str, str, str]:\n\"\"\"Get sections that are not in the list.\"\"\"\n        id_, name, title = ControlInterface._find_section(control, skip_section_list)\n        if id_:\n            return id_, name, title, ControlInterface.get_control_section_prose(control, name)\n        return '', '', '', ''\n\n    @staticmethod\n    def get_part_prose(control: cat.Control, part_name: str) -&gt; str:\n\"\"\"Get the prose for a named part.\"\"\"\n        prose = ''\n        for part in as_list(control.parts):\n            prose += ControlInterface._get_control_section_part(part, part_name)\n        return prose.strip()\n\n    @staticmethod\n    def setparam_to_param(param_id: str, set_param: prof.SetParameter) -&gt; common.Parameter:\n\"\"\"\n        Convert setparameter to parameter.\n\n        Args:\n            param_id: the id of the parameter\n            set_param: the set_parameter from a profile\n\n        Returns:\n            a Parameter with param_id and content from the SetParameter\n        \"\"\"\n        return common.Parameter(\n            id=param_id, values=set_param.values, select=set_param.select, label=set_param.label, props=set_param.props\n        )\n\n    @staticmethod\n    def uniquify_set_params(set_params: Optional[List[TypeWithParamId]]) -&gt; List[TypeWithParamId]:\n\"\"\"Remove items with same param_id with priority to later items.\"\"\"\n        found_ids: Set[str] = set()\n        unique_list: List[TypeWithParamId] = []\n        for set_param in reversed(as_list(set_params)):\n            if set_param.param_id not in found_ids:\n                unique_list.append(set_param)\n                found_ids.add(set_param.param_id)\n        return list(reversed(unique_list))\n\n    @staticmethod\n    def get_rules_dict_from_item(item: TypeWithProps) -&gt; Tuple[Dict[str, Dict[str, str]], List[common.Property]]:\n\"\"\"Get all rules found in this items props.\"\"\"\n        # rules is dict containing rule_id and description\n        rules_dict = {}\n        name = ''\n        desc = ''\n        id_ = ''\n        rules_props = []\n        for prop in as_list(item.props):\n            if prop.name == const.RULE_ID:\n                name = prop.value\n                id_ = prop.remarks\n                rules_props.append(prop)\n            elif prop.name == const.RULE_DESCRIPTION:\n                desc = prop.value\n                rules_props.append(prop)\n            # grab each pair in case there are multiple pairs\n            # then clear and look for new pair\n            if name and desc:\n                rules_dict[id_] = {'name': name, 'description': desc}\n                name = desc = id_ = ''\n        return rules_dict, rules_props\n\n    @staticmethod\n    def item_has_rules(item: TypeWithProps) -&gt; bool:\n\"\"\"Determine if the item has rules in its props.\"\"\"\n        _, rules_props = ControlInterface.get_rules_dict_from_item(item)\n        return bool(rules_props)\n\n    @staticmethod\n    def get_rule_list_for_item(item: TypeWithProps) -&gt; Tuple[List[str], List[common.Property]]:\n\"\"\"Get the list of rules applying to this item from its top level props.\"\"\"\n        props = []\n        rule_list = []\n        for prop in as_list(item.props):\n            if prop.name == const.RULE_ID:\n                rule_list.append(prop.value)\n                props.append(prop)\n        return rule_list, props\n\n    @staticmethod\n    def get_rule_list_for_imp_req(\n        imp_req: ossp.ImplementedRequirement\n    ) -&gt; Tuple[List[str], List[str], List[common.Property]]:\n\"\"\"Get the list of rules applying to an imp_req as two lists.\"\"\"\n        comp_rules, rule_props = ControlInterface.get_rule_list_for_item(imp_req)\n        statement_rules = set()\n        for statement in as_list(imp_req.statements):\n            stat_rules, statement_props = ControlInterface.get_rule_list_for_item(statement)\n            statement_rules.update(stat_rules)\n            rule_props.extend(statement_props)\n        return comp_rules, sorted(statement_rules), rule_props\n\n    @staticmethod\n    def get_params_dict_from_item(item: TypeWithProps) -&gt; Tuple[Dict[str, Dict[str, str]], List[common.Property]]:\n\"\"\"Get all params found in this item with rule_id as key.\"\"\"\n        # id, description, options - where options is a string containing comma-sep list of items\n        # params is dict with rule_id as key and value contains: param_name, description and choices\n        params: Dict[str, Dict[str, str]] = {}\n        props = []\n        for prop in as_list(item.props):\n            if prop.name == const.PARAMETER_ID:\n                rule_id = prop.remarks\n                param_name = prop.value\n                if rule_id in params:\n                    raise TrestleError(f'Duplicate param {param_name} found for rule {rule_id}')\n                # create new param for this rule\n                params[rule_id] = {'name': param_name}\n                props.append(prop)\n            elif prop.name == const.PARAMETER_DESCRIPTION:\n                rule_id = prop.remarks\n                if rule_id in params:\n                    params[rule_id]['description'] = prop.value\n                    props.append(prop)\n                else:\n                    raise TrestleError(f'Param description for rule {rule_id} found with no param_id')\n            elif prop.name == const.PARAMETER_VALUE_ALTERNATIVES:\n                rule_id = prop.remarks\n                if rule_id in params:\n                    params[rule_id]['options'] = prop.value\n                    props.append(prop)\n                else:\n                    raise TrestleError(f'Param options for rule {rule_id} found with no param_id')\n        new_params = {}\n        for rule_id, param in params.items():\n            if 'name' not in param:\n                logger.warning(f'Parameter for rule_id {rule_id} has no matching name.  Ignoring the param.')\n            else:\n                param['description'] = param.get('description', '')\n                param['options'] = param.get('options', '')\n                new_params[rule_id] = param\n        return new_params, props\n\n    @staticmethod\n    def get_rules_and_params_dict_from_item(\n        item: TypeWithProps\n    ) -&gt; Tuple[Dict[str, Dict[str, str]], Dict[str, Dict[str, str]], List[common.Property]]:\n\"\"\"Get the rule dict and params dict from item with props.\"\"\"\n        rules_dict, rules_props = ControlInterface.get_rules_dict_from_item(item)\n        params_dict, params_props = ControlInterface.get_params_dict_from_item(item)\n        rules_props.extend(params_props)\n        return rules_dict, params_dict, rules_props\n\n    @staticmethod\n    def get_set_params_from_item(\n        item: Union[comp.ControlImplementation, comp.ImplementedRequirement]\n    ) -&gt; Dict[str, comp.SetParameter]:\n\"\"\"Get set params that have values from control implementation or imp req.\"\"\"\n        return {\n            set_param.param_id: set_param\n            for set_param in as_filtered_list(item.set_parameters, lambda i: i.values)\n        }\n\n    @staticmethod\n    def merge_props(dest: Optional[List[common.Property]],\n                    src: Optional[List[common.Property]]) -&gt; List[common.Property]:\n\"\"\"Merge a source list of properties into a destination list.\"\"\"\n        if not src:\n            return dest\n        new_props: List[common.Property] = []\n        src_map = {prop.name: prop for prop in src}\n        dest_map = {prop.name: prop for prop in dest}\n        all_names = set(src_map.keys()).union(dest_map.keys())\n        for name in sorted(all_names):\n            if name in src_map and name not in dest_map:\n                new_props.append(src_map[name])\n            elif name in dest_map and name not in src_map:\n                new_props.append(dest_map[name])\n            else:\n                new_prop = dest_map[name]\n                src_prop = src_map[name]\n                new_prop.class_ = src_prop.class_ if src_prop.class_ else new_prop.class_\n                new_prop.ns = src_prop.ns if src_prop.ns else new_prop.ns\n                new_prop.remarks = src_prop.remarks if src_prop.remarks else new_prop.remarks\n                new_prop.uuid = src_prop.uuid if src_prop.uuid else new_prop.uuid\n                new_prop.value = src_prop.value\n                new_props.append(new_prop)\n        return new_props\n\n    @staticmethod\n    def merge_part(dest: common.Part, src: common.Part) -&gt; common.Part:\n\"\"\"Merge a source part into the destination part.\"\"\"\n        dest.name = src.name if src.name else dest.name\n        dest.ns = src.ns if src.ns else dest.ns\n        dest.props = none_if_empty(ControlInterface.merge_props(dest.props, src.props))\n        dest.prose = src.prose\n        dest.title = src.title if src.title else dest.title\n        ControlInterface.merge_parts(dest, src)\n        return dest\n\n    @staticmethod\n    def merge_parts(dest: TypeWithParts, src: TypeWithParts) -&gt; None:\n\"\"\"Merge the parts from the source into the destination.\"\"\"\n        if not dest.parts:\n            dest.parts = src.parts\n        elif not src.parts:\n            dest.parts = None\n        else:\n            new_parts: List[common.Part] = []\n            dest_map = {part.id: part for part in dest.parts}\n            for src_part in src.parts:\n                dest_part = dest_map.get(src_part.id, None)\n                if not dest_part:\n                    new_parts.append(src_part)\n                else:\n                    new_part = ControlInterface.merge_part(dest_part, src_part)\n                    if new_part:\n                        new_parts.append(new_part)\n            dest.parts = new_parts\n\n    @staticmethod\n    def merge_dicts_deep(\n        dest: Dict[Any, Any],\n        src: Dict[Any, Any],\n        overwrite_header_values: bool,\n        depth: int = 0,\n        level: int = 0\n    ) -&gt; None:\n\"\"\"\n        Merge dict src into dest.\n\n        New items are always added from src to dest.\n        Items present in both will be overriden dest if overwrite_header_values is True.\n        \"\"\"\n        for key in src.keys():\n            if key in dest:\n                if depth and level == depth:\n                    if overwrite_header_values:\n                        dest[key] = src[key]\n                    continue\n                # if they are both dicts, recurse\n                if isinstance(dest[key], dict) and isinstance(src[key], dict):\n                    ControlInterface.merge_dicts_deep(dest[key], src[key], overwrite_header_values, depth, level + 1)\n                # if they are both lists, add any item that is not already in the list\n                elif isinstance(dest[key], list) and isinstance(src[key], list):\n                    for item in src[key]:\n                        if item not in dest[key]:\n                            dest[key].append(item)\n                # otherwise override dest if needed\n                elif overwrite_header_values:\n                    dest[key] = src[key]\n            else:\n                # if the item was not already in dest, add it from src\n                dest[key] = src[key]\n\n    @staticmethod\n    def is_withdrawn(control: cat.Control) -&gt; bool:\n\"\"\"\n        Determine if control is marked Withdrawn.\n\n        Args:\n            control: The control that may be marked withdrawn.\n\n        Returns:\n            True if marked withdrawn, false otherwise.\n\n        This is determined by property with name 'status' with value 'Withdrawn'.\n        \"\"\"\n        for _ in as_filtered_list(\n                control.props,\n                lambda p: strip_lower_equals(p.name, 'status') and strip_lower_equals(p.value, 'withdrawn')):\n            return True\n        return False\n\n    @staticmethod\n    def _setparam_values_as_str(set_param: comp.SetParameter) -&gt; str:\n\"\"\"Convert values to string.\"\"\"\n        out_str = ''\n        for value in as_list(set_param.values):\n            value_str = string_from_root(value)\n            if value_str:\n                if out_str:\n                    out_str += ', '\n                out_str += value_str\n        return out_str\n\n    @staticmethod\n    def _param_values_as_str_list(param: common.Parameter) -&gt; List[str]:\n\"\"\"Convert param values to list of strings.\"\"\"\n        return as_list(param.values)\n\n    @staticmethod\n    def _param_values_as_str(param: common.Parameter, brackets=False) -&gt; Optional[str]:\n\"\"\"Convert param values to string with optional brackets.\"\"\"\n        if not param.values:\n            return None\n        values_str = ', '.join(ControlInterface._param_values_as_str_list(param))\n        return f'[{values_str}]' if brackets else values_str\n\n    @staticmethod\n    def _param_selection_as_str(param: common.Parameter, verbose: bool = False, brackets: bool = False) -&gt; str:\n\"\"\"Convert parameter selection to str.\"\"\"\n        if param.select and param.select.choice:\n            how_many_str = ''\n            # if all values are specified there is no how_many string and parens are dropped.  See ac-2.2\n            if param.select.how_many:\n                how_many_str = ' (one)' if param.select.how_many == const.ONE else ' (one or more)'\n            choices_str = '; '.join(as_list(param.select.choice))\n            choices_str = f'[{choices_str}]' if brackets else choices_str\n            choices_str = f'Selection{how_many_str}: {choices_str}' if verbose else choices_str\n            return choices_str\n        return ''\n\n    @staticmethod\n    def _param_label_choices_as_str(param: common.Parameter, verbose: bool = False, brackets: bool = False) -&gt; str:\n\"\"\"Convert param label or choices to string, using choices if present.\"\"\"\n        choices = ControlInterface._param_selection_as_str(param, verbose, brackets)\n        text = choices if choices else param.label\n        text = text if text else param.id\n        return text\n\n    @staticmethod\n    def _param_values_assignment_str(\n        param: common.Parameter,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; str:\n\"\"\"Convert param values, label or choices to string.\"\"\"\n        # use values if present\n        param_str = ControlInterface._param_values_as_str(param, False)\n        if param_str and value_assigned_prefix:\n            param_str = f'{value_assigned_prefix} {param_str}'\n        # otherwise use param selection if present\n        if not param_str:\n            param_str = ControlInterface._param_selection_as_str(param, True, False)\n        # finally use label and param_id as fallbacks\n        if not param_str:\n            param_str = param.label if param.label else param.id\n            if value_not_assigned_prefix:\n                param_str = f'{value_not_assigned_prefix} {param_str}'\n        return f'{param_str}'\n\n    @staticmethod\n    def _param_labels_assignment_str(\n        param: common.Parameter,\n        label_prefix: Optional[str] = None,\n    ) -&gt; str:\n\"\"\"Convert param label or choices to string.\"\"\"\n        # use values if present\n        param_str = ControlInterface._param_selection_as_str(param, True, False)\n        # finally use label and param_id as fallbacks\n        if not param_str:\n            param_str = param.label if param.label else param.id\n            if label_prefix:\n                param_str = f'{label_prefix} {param_str}'\n        return f'{param_str}'\n\n    @staticmethod\n    def param_to_str(\n        param: common.Parameter,\n        param_rep: ParameterRep,\n        verbose: bool = False,\n        brackets: bool = False,\n        params_format: Optional[str] = None,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; Optional[str]:\n\"\"\"\n        Convert parameter to string based on best available representation.\n\n        Args:\n            param: the parameter to convert\n            param_rep: how to represent the parameter\n            verbose: provide verbose text for selection choices\n            brackets: add brackets around the lists of items\n            params_format: a string containing a single dot that represents a form of highlighting around the param\n            value_assigned_prefix: string to place before the parameter string if a value was assigned\n            value_not_assigned_prefix: string to place before the parameter string if value not assigned\n\n        Returns:\n            formatted string or None\n        \"\"\"\n        param_str = None\n        if param_rep == ParameterRep.VALUE_OR_STRING_NONE:\n            param_str = ControlInterface._param_values_as_str(param)\n            param_str = param_str if param_str else 'None'\n        elif param_rep == ParameterRep.LABEL_OR_CHOICES:\n            param_str = ControlInterface._param_label_choices_as_str(param, verbose, brackets)\n        elif param_rep == ParameterRep.VALUE_OR_LABEL_OR_CHOICES:\n            param_str = ControlInterface._param_values_as_str(param)\n            if not param_str:\n                param_str = ControlInterface._param_label_choices_as_str(param, verbose, brackets)\n        elif param_rep == ParameterRep.VALUE_OR_EMPTY_STRING:\n            param_str = ControlInterface._param_values_as_str(param, brackets)\n            if not param_str:\n                param_str = ''\n        elif param_rep == ParameterRep.ASSIGNMENT_FORM:\n            param_str = ControlInterface._param_values_assignment_str(\n                param, value_assigned_prefix, value_not_assigned_prefix\n            )\n            if not param_str:\n                param_str = ''\n        elif param_rep == ParameterRep.LABEL_FORM:\n            param_str = ControlInterface._param_labels_assignment_str(param, value_not_assigned_prefix)\n            if not param_str:\n                param_str = ''\n        return ControlInterface._apply_params_format(param_str, params_format)\n\n    @staticmethod\n    def get_control_param_dict(control: cat.Control, values_only: bool) -&gt; Dict[str, common.Parameter]:\n\"\"\"\n        Create mapping of param id's to params for params in the control.\n\n        Args:\n            control: the control containing params of interest\n            values_only: only add params to the dict that have actual values\n\n        Returns:\n            Dictionary of param_id mapped to param\n\n        Notes:\n            Warning is given if there is a parameter with no ID\n        \"\"\"\n        param_dict: Dict[str, common.Parameter] = {}\n        for param in as_list(control.params):\n            if not param.id:\n                logger.warning(f'Control {control.id} has parameter with no id.  Ignoring.')\n            if param.values or not values_only:\n                param_dict[param.id] = param\n        return param_dict\n\n    @staticmethod\n    def _replace_ids_with_text(\n        prose: str,\n        param_rep: ParameterRep,\n        param_dict: Dict[str, common.Parameter],\n        params_format: Optional[str] = None,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; str:\n\"\"\"Find all instances of param_ids in prose and replace each with corresponding parameter representation.\n\n        Need to check all values in dict for a match\n        Reject matches where the string has an adjacent alphanumeric char: param_1 and param_10 or aparam_1\n        \"\"\"\n        for param in param_dict.values():\n            if param.id not in prose:\n                continue\n            # create the replacement text for the param_id\n            param_str = ControlInterface.param_to_str(\n                param, param_rep, False, False, params_format, value_assigned_prefix, value_not_assigned_prefix\n            )\n            # non-capturing groups are odd in re.sub so capture all 3 groups and replace the middle one\n            pattern = r'(^|[^a-zA-Z0-9_])' + param.id + r'($|[^a-zA-Z0-9_])'\n            prose = re.sub(pattern, r'\\1' + param_str + r'\\2', prose)\n        return prose\n\n    @staticmethod\n    def _replace_params(\n        text: str,\n        param_dict: Dict[str, common.Parameter],\n        params_format: Optional[str] = None,\n        param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n        show_value_warnings: bool = False,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; str:\n\"\"\"\n        Replace params found in moustaches with values from the param_dict.\n\n        A single line of prose may contain multiple moustaches.\n        \"\"\"\n        # first check if there are any moustache patterns in the text\n        if param_rep == ParameterRep.LEAVE_MOUSTACHE:\n            return text\n        orig_text = text\n        staches: List[str] = re.findall(r'{{.*?}}', text)\n        if not staches:\n            return text\n        # now have list of all staches including braces, e.g. ['{{foo}}', '{{bar}}']\n        # clean the staches so they just have the param ids\n        param_ids = []\n        for stache in staches:\n            # remove braces so these are just param_ids but may have extra chars\n            stache_contents = stache[2:(-2)]\n            param_id = stache_contents.replace('insert: param,', '').strip()\n            param_ids.append(param_id)\n\n        # now replace original stache text with param values\n        for i, _ in enumerate(staches):\n            # A moustache may refer to a param_id not listed in the control's params\n            if param_ids[i] not in param_dict:\n                if show_value_warnings:\n                    logger.warning(f'Control prose references param {param_ids[i]} not set in the control: {staches}')\n            elif param_dict[param_ids[i]] is not None:\n                param = param_dict[param_ids[i]]\n                param_str = ControlInterface.param_to_str(\n                    param, param_rep, False, False, params_format, value_assigned_prefix, value_not_assigned_prefix\n                )\n                text = text.replace(staches[i], param_str, 1).strip()\n                if show_value_warnings and param_rep != ParameterRep.LABEL_OR_CHOICES and not param.values:\n                    logger.warning(f'Parameter {param_id} has no values and was referenced by prose.')\n            elif show_value_warnings:\n                logger.warning(f'Control prose references param {param_ids[i]} with no specified value.')\n        # there may be staches remaining that we can't replace if not in param_dict\n        if text != orig_text:\n            while True:\n                new_text = ControlInterface._replace_params(\n                    text,\n                    param_dict,\n                    params_format,\n                    param_rep,\n                    show_value_warnings,\n                    value_assigned_prefix,\n                    value_not_assigned_prefix\n                )\n                if new_text == text:\n                    break\n                text = new_text\n        return text\n\n    @staticmethod\n    def _replace_part_prose(\n        control: cat.Control,\n        part: common.Part,\n        param_dict: Dict[str, common.Parameter],\n        params_format: Optional[str] = None,\n        param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n        show_value_warnings: bool = False,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; None:\n\"\"\"Replace the part prose according to set_param.\"\"\"\n        if part.prose is not None:\n            fixed_prose = ControlInterface._replace_params(\n                part.prose,\n                param_dict,\n                params_format,\n                param_rep,\n                show_value_warnings,\n                value_assigned_prefix,\n                value_not_assigned_prefix\n            )\n            # change the prose in the control itself\n            part.prose = fixed_prose\n        for prt in as_list(part.parts):\n            ControlInterface._replace_part_prose(\n                control,\n                prt,\n                param_dict,\n                params_format,\n                param_rep,\n                show_value_warnings,\n                value_assigned_prefix,\n                value_not_assigned_prefix\n            )\n        for sub_control in as_list(control.controls):\n            for prt in as_list(sub_control.parts):\n                ControlInterface._replace_part_prose(\n                    sub_control,\n                    prt,\n                    param_dict,\n                    params_format,\n                    param_rep,\n                    show_value_warnings,\n                    value_assigned_prefix,\n                    value_not_assigned_prefix\n                )\n\n    @staticmethod\n    def _replace_param_choices(\n        param: common.Parameter,\n        param_dict: Dict[str, common.Parameter],\n        params_format: Optional[str],\n        param_rep: ParameterRep,\n        show_value_warnings: bool,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; None:\n\"\"\"Set values for all choices param that refer to params with values.\"\"\"\n        if param.select:\n            new_choices: List[str] = []\n            for choice in as_list(param.select.choice):\n                new_choice = ControlInterface._replace_params(\n                    choice,\n                    param_dict,\n                    params_format,\n                    param_rep,\n                    show_value_warnings,\n                    value_assigned_prefix,\n                    value_not_assigned_prefix\n                )\n                new_choices.append(new_choice)\n            param.select.choice = new_choices\n\n    @staticmethod\n    def replace_control_prose(\n        control: cat.Control,\n        param_dict: Dict[str, common.Parameter],\n        params_format: Optional[str] = None,\n        param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n        show_value_warnings: bool = False,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; None:\n\"\"\"Replace the control prose according to set_param.\"\"\"\n        # first replace all choices that reference parameters\n        # note that in ASSIGNMENT_FORM each choice with a parameter will end up as [Assignment: value]\n        for param in as_list(control.params):\n            ControlInterface._replace_param_choices(\n                param,\n                param_dict,\n                params_format,\n                param_rep,\n                show_value_warnings,\n                value_assigned_prefix,\n                value_not_assigned_prefix\n            )\n        for part in as_list(control.parts):\n            if part.prose is not None:\n                fixed_prose = ControlInterface._replace_params(\n                    part.prose,\n                    param_dict,\n                    params_format,\n                    param_rep,\n                    show_value_warnings,\n                    value_assigned_prefix,\n                    value_not_assigned_prefix\n                )\n                # change the prose in the control itself\n                part.prose = fixed_prose\n            for prt in as_list(part.parts):\n                ControlInterface._replace_part_prose(\n                    control,\n                    prt,\n                    param_dict,\n                    params_format,\n                    param_rep,\n                    show_value_warnings,\n                    value_assigned_prefix,\n                    value_not_assigned_prefix\n                )\n\n    @staticmethod\n    def bad_header(header: str) -&gt; bool:\n\"\"\"Return true if header format is bad.\"\"\"\n        if not header or header[0] != '#':\n            return True\n        n = len(header)\n        if n &lt; 2:\n            return True\n        for ii in range(1, n):\n            if header[ii] == ' ':\n                return False\n            if header[ii] != '#':\n                return True\n        return True\n\n    @staticmethod\n    def get_component_by_name(comp_def: comp.ComponentDefinition, comp_name: str) -&gt; Optional[comp.DefinedComponent]:\n\"\"\"Get the component with this name from the comp_def.\"\"\"\n        for sub_comp in as_list(comp_def.components):\n            if sub_comp.title == comp_name:\n                return sub_comp\n        return None\n\n    @staticmethod\n    def get_status_from_props(item: TypeWithProps) -&gt; common.ImplementationStatus:\n\"\"\"Get the status of an item from its props.\"\"\"\n        status = common.ImplementationStatus(state=const.STATUS_PLANNED)\n        for prop in as_list(item.props):\n            if prop.name == const.IMPLEMENTATION_STATUS:\n                status = ControlInterface._prop_as_status(prop)\n                break\n        return status\n\n    @staticmethod\n    def clean_props(\n        props: Optional[List[common.Property]],\n        remove_imp_status: bool = True,\n        remove_all_rule_info: bool = False\n    ) -&gt; List[common.Property]:\n\"\"\"Remove duplicate props and implementation status.\"\"\"\n        new_props: List[common.Property] = []\n        found_props: Set[Tuple[str, str, str, str]] = set()\n        rule_tag_list = [\n            const.RULE_DESCRIPTION, const.RULE_ID, const.PARAMETER_DESCRIPTION, const.PARAMETER_VALUE_ALTERNATIVES\n        ]\n        # reverse the list so the latest items are kept\n        for prop in reversed(as_list(props)):\n            prop_tuple = (prop.name, as_string(prop.value), as_string(prop.ns), prop.remarks)\n            if prop_tuple in found_props or (prop.name == const.IMPLEMENTATION_STATUS and remove_imp_status):\n                continue\n            if remove_all_rule_info and prop.name in rule_tag_list:\n                continue\n            found_props.add(prop_tuple)\n            new_props.append(prop)\n        new_props.reverse()\n        return new_props\n\n    @staticmethod\n    def cull_props_by_rules(props: Optional[List[common.Property]], rules: List[str]) -&gt; List[common.Property]:\n\"\"\"Cull properties to the ones needed by rules.\"\"\"\n        needed_rule_ids: Set[str] = set()\n        culled_props: List[common.Property] = []\n        for prop in as_list(props):\n            if prop.value in rules and prop.remarks:\n                needed_rule_ids.add(prop.remarks)\n        for prop in as_list(props):\n            if prop.value in rules or prop.remarks in needed_rule_ids:\n                culled_props.append(prop)\n        return culled_props\n\n    @staticmethod\n    def _status_as_prop(status: common.ImplementationStatus) -&gt; common.Property:\n\"\"\"Convert status to property.\"\"\"\n        return common.Property(name=const.IMPLEMENTATION_STATUS, value=status.state, remarks=status.remarks)\n\n    @staticmethod\n    def _prop_as_status(prop: common.Property) -&gt; common.ImplementationStatus:\n\"\"\"Convert property to status.\"\"\"\n        return common.ImplementationStatus(state=prop.value, remarks=prop.remarks)\n\n    @staticmethod\n    def insert_status_in_props(item: TypeWithProps, status: common.ImplementationStatus) -&gt; None:\n\"\"\"Insert status content into props of the item.\"\"\"\n        prop = ControlInterface._status_as_prop(status)\n        ControlInterface._replace_prop(item, prop)\n\n    @staticmethod\n    def _copy_status_in_props(dest: TypeWithProps, src: TypeWithProps) -&gt; None:\n\"\"\"Copy status in props from one object to another.\"\"\"\n        status = ControlInterface.get_status_from_props(src)\n        ControlInterface.insert_status_in_props(dest, status)\n\n    @staticmethod\n    def insert_imp_req_into_component(\n        component: comp.DefinedComponent,\n        new_imp_req: comp.ImplementedRequirement,\n        profile_title: str,\n        trestle_root: pathlib.Path\n    ) -&gt; None:\n\"\"\"\n        Insert imp req into component by matching source title and control id to existing imp req.\n\n        Args:\n            component: The defined component receiving the imp_req\n            new_imp_req: The new imp_req being added\n            profile_title: The title of the source profile for the control implementation containing the imp_req\n\n        Notes:\n            Inserts the imp_req on the first match found.  Note it is possible two control implementations could\n            have the same source and specify the same control\n        \"\"\"\n        for control_imp in as_list(component.control_implementations):\n            _, control_imp_param_dict, _ = ControlInterface.get_rules_and_params_dict_from_item(control_imp)\n            control_imp_rule_param_ids = [d['name'] for d in control_imp_param_dict.values()]\n            if profile_title != ModelUtils.get_title_from_model_uri(trestle_root, control_imp.source):\n                continue\n            for imp_req in as_list(control_imp.implemented_requirements):\n                if imp_req.control_id != new_imp_req.control_id:\n                    continue\n                _, imp_req_param_dict, _ = ControlInterface.get_rules_and_params_dict_from_item(imp_req)\n                imp_req_rule_param_ids = [d['name'] for d in imp_req_param_dict]\n                status = ControlInterface.get_status_from_props(new_imp_req)\n                ControlInterface.insert_status_in_props(imp_req, status)\n                imp_req.description = new_imp_req.description\n                statement_dict = {stat.statement_id: stat for stat in as_list(imp_req.statements)}\n                # update set parameter values with values from markdown - but only for rule param vals\n                for set_param in as_list(new_imp_req.set_parameters):\n                    if set_param.param_id not in (control_imp_rule_param_ids + imp_req_rule_param_ids):\n                        continue\n                    found = False\n                    for dest_param in as_list(imp_req.set_parameters):\n                        if dest_param.param_id != set_param.param_id:\n                            continue\n                        dest_param.values = set_param.values\n                        found = True\n                        break\n                    # if rule parameter val was not already set by a set_param, make new set_param for it\n                    if found:\n                        continue\n                    # but first check if the parameter was already set with the same value in the control_imp\n                    # if so we don't need to insert a new set_param in imp_req\n                    for dest_param in as_list(control_imp.set_parameters):\n                        if dest_param.param_id != set_param.param_id:\n                            continue\n                        if dest_param.values == set_param.values:\n                            found = True\n                            break\n                    if found:\n                        continue\n                    imp_req.set_parameters = as_list(imp_req.set_parameters)\n                    imp_req.set_parameters.append(\n                        comp.SetParameter(param_id=set_param.param_id, values=set_param.values)\n                    )\n                new_statements: List[comp.Statement] = []\n                for statement in as_list(new_imp_req.statements):\n                    # get the original version of the statement if available, or use new one\n                    stat = statement_dict.get(statement.statement_id, statement)\n                    # update the description and status from markdown\n                    stat.description = statement.description\n                    ControlInterface._copy_status_in_props(stat, statement)\n                    new_statements.append(stat)\n                imp_req.statements = none_if_empty(new_statements)\n                return\n        logger.warning(\n            f'Unable to add imp req for component {component.title} control {new_imp_req.control_id} and source: {profile_title}'  # noqa E501\n        )\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.bad_header","title":"<code>bad_header(header)</code>  <code>staticmethod</code>","text":"<p>Return true if header format is bad.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef bad_header(header: str) -&gt; bool:\n\"\"\"Return true if header format is bad.\"\"\"\n    if not header or header[0] != '#':\n        return True\n    n = len(header)\n    if n &lt; 2:\n        return True\n    for ii in range(1, n):\n        if header[ii] == ' ':\n            return False\n        if header[ii] != '#':\n            return True\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.clean_props","title":"<code>clean_props(props, remove_imp_status=True, remove_all_rule_info=False)</code>  <code>staticmethod</code>","text":"<p>Remove duplicate props and implementation status.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef clean_props(\n    props: Optional[List[common.Property]],\n    remove_imp_status: bool = True,\n    remove_all_rule_info: bool = False\n) -&gt; List[common.Property]:\n\"\"\"Remove duplicate props and implementation status.\"\"\"\n    new_props: List[common.Property] = []\n    found_props: Set[Tuple[str, str, str, str]] = set()\n    rule_tag_list = [\n        const.RULE_DESCRIPTION, const.RULE_ID, const.PARAMETER_DESCRIPTION, const.PARAMETER_VALUE_ALTERNATIVES\n    ]\n    # reverse the list so the latest items are kept\n    for prop in reversed(as_list(props)):\n        prop_tuple = (prop.name, as_string(prop.value), as_string(prop.ns), prop.remarks)\n        if prop_tuple in found_props or (prop.name == const.IMPLEMENTATION_STATUS and remove_imp_status):\n            continue\n        if remove_all_rule_info and prop.name in rule_tag_list:\n            continue\n        found_props.add(prop_tuple)\n        new_props.append(prop)\n    new_props.reverse()\n    return new_props\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.create_statement_id","title":"<code>create_statement_id(control_id, lower=False)</code>  <code>staticmethod</code>","text":"<p>Create the control statement id from the control id.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef create_statement_id(control_id: str, lower: bool = False) -&gt; str:\n\"\"\"Create the control statement id from the control id.\"\"\"\n    id_ = f'{control_id}_smt'\n    return id_.lower() if lower else id_\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.cull_props_by_rules","title":"<code>cull_props_by_rules(props, rules)</code>  <code>staticmethod</code>","text":"<p>Cull properties to the ones needed by rules.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef cull_props_by_rules(props: Optional[List[common.Property]], rules: List[str]) -&gt; List[common.Property]:\n\"\"\"Cull properties to the ones needed by rules.\"\"\"\n    needed_rule_ids: Set[str] = set()\n    culled_props: List[common.Property] = []\n    for prop in as_list(props):\n        if prop.value in rules and prop.remarks:\n            needed_rule_ids.add(prop.remarks)\n    for prop in as_list(props):\n        if prop.value in rules or prop.remarks in needed_rule_ids:\n            culled_props.append(prop)\n    return culled_props\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_all_add_info","title":"<code>get_all_add_info(control_id, profile)</code>  <code>staticmethod</code>","text":"<p>Get the adds for a control from a profile by control id.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_all_add_info(control_id: str, profile: prof.Profile) -&gt; List[PartInfo]:\n\"\"\"Get the adds for a control from a profile by control id.\"\"\"\n    part_infos = []\n    for add in ControlInterface._get_adds_for_control(profile, control_id):\n        # add control level props with no name\n        if add.props:\n            smt_part = add.by_id if add.by_id else ''\n            part_infos.append(PartInfo(name='', prose='', smt_part=smt_part, props=add.props))\n        # add part level props with part name\n        for part in as_list(add.parts):\n            subpart_info = ControlInterface._get_part_and_subpart_info(part, add.by_id)\n            part_infos.append(\n                PartInfo(\n                    name=part.name, prose=part.prose, smt_part=add.by_id, props=part.props, parts=subpart_info\n                )\n            )\n    return part_infos\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_component_by_name","title":"<code>get_component_by_name(comp_def, comp_name)</code>  <code>staticmethod</code>","text":"<p>Get the component with this name from the comp_def.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_component_by_name(comp_def: comp.ComponentDefinition, comp_name: str) -&gt; Optional[comp.DefinedComponent]:\n\"\"\"Get the component with this name from the comp_def.\"\"\"\n    for sub_comp in as_list(comp_def.components):\n        if sub_comp.title == comp_name:\n            return sub_comp\n    return None\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_control_param_dict","title":"<code>get_control_param_dict(control, values_only)</code>  <code>staticmethod</code>","text":"<p>Create mapping of param id's to params for params in the control.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>cat.Control</code> <p>the control containing params of interest</p> required <code>values_only</code> <code>bool</code> <p>only add params to the dict that have actual values</p> required <p>Returns:</p> Type Description <code>Dict[str, common.Parameter]</code> <p>Dictionary of param_id mapped to param</p> <p>Notes</p> <p>Warning is given if there is a parameter with no ID</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_control_param_dict(control: cat.Control, values_only: bool) -&gt; Dict[str, common.Parameter]:\n\"\"\"\n    Create mapping of param id's to params for params in the control.\n\n    Args:\n        control: the control containing params of interest\n        values_only: only add params to the dict that have actual values\n\n    Returns:\n        Dictionary of param_id mapped to param\n\n    Notes:\n        Warning is given if there is a parameter with no ID\n    \"\"\"\n    param_dict: Dict[str, common.Parameter] = {}\n    for param in as_list(control.params):\n        if not param.id:\n            logger.warning(f'Control {control.id} has parameter with no id.  Ignoring.')\n        if param.values or not values_only:\n            param_dict[param.id] = param\n    return param_dict\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_control_section_prose","title":"<code>get_control_section_prose(control, section_name)</code>  <code>staticmethod</code>","text":"<p>Get the prose for the control section.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_control_section_prose(control: cat.Control, section_name: str) -&gt; str:\n\"\"\"Get the prose for the control section.\"\"\"\n    prose = ''\n    if control.parts:\n        for part in control.parts:\n            prose = ControlInterface._gap_join(\n                prose, ControlInterface._get_control_section_part(part, section_name)\n            )\n    return prose\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_label","title":"<code>get_label(item)</code>  <code>staticmethod</code>","text":"<p>Get the label from the props of a part or control.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_label(item: TypeWithProps) -&gt; str:\n\"\"\"Get the label from the props of a part or control.\"\"\"\n    return ControlInterface.get_prop(item, 'label')\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_params_dict_from_item","title":"<code>get_params_dict_from_item(item)</code>  <code>staticmethod</code>","text":"<p>Get all params found in this item with rule_id as key.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_params_dict_from_item(item: TypeWithProps) -&gt; Tuple[Dict[str, Dict[str, str]], List[common.Property]]:\n\"\"\"Get all params found in this item with rule_id as key.\"\"\"\n    # id, description, options - where options is a string containing comma-sep list of items\n    # params is dict with rule_id as key and value contains: param_name, description and choices\n    params: Dict[str, Dict[str, str]] = {}\n    props = []\n    for prop in as_list(item.props):\n        if prop.name == const.PARAMETER_ID:\n            rule_id = prop.remarks\n            param_name = prop.value\n            if rule_id in params:\n                raise TrestleError(f'Duplicate param {param_name} found for rule {rule_id}')\n            # create new param for this rule\n            params[rule_id] = {'name': param_name}\n            props.append(prop)\n        elif prop.name == const.PARAMETER_DESCRIPTION:\n            rule_id = prop.remarks\n            if rule_id in params:\n                params[rule_id]['description'] = prop.value\n                props.append(prop)\n            else:\n                raise TrestleError(f'Param description for rule {rule_id} found with no param_id')\n        elif prop.name == const.PARAMETER_VALUE_ALTERNATIVES:\n            rule_id = prop.remarks\n            if rule_id in params:\n                params[rule_id]['options'] = prop.value\n                props.append(prop)\n            else:\n                raise TrestleError(f'Param options for rule {rule_id} found with no param_id')\n    new_params = {}\n    for rule_id, param in params.items():\n        if 'name' not in param:\n            logger.warning(f'Parameter for rule_id {rule_id} has no matching name.  Ignoring the param.')\n        else:\n            param['description'] = param.get('description', '')\n            param['options'] = param.get('options', '')\n            new_params[rule_id] = param\n    return new_params, props\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_part","title":"<code>get_part(part, item_type, skip_id)</code>  <code>staticmethod</code>","text":"<p>Find parts with the specified item type, within the given part.</p> <p>For a part in a control find the parts in it that match the item_type Return list of string formatted labels and associated descriptive prose</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_part(part: common.Part, item_type: str, skip_id: Optional[str]) -&gt; List[Union[str, List[str]]]:\n\"\"\"\n    Find parts with the specified item type, within the given part.\n\n    For a part in a control find the parts in it that match the item_type\n    Return list of string formatted labels and associated descriptive prose\n    \"\"\"\n    items = []\n    if part.name in [const.STATEMENT, item_type]:\n        # the options here are to force the label to be the part.id or the part.label\n        # the label may be of the form (a) while the part.id is ac-1_smt.a.1.a\n        # here we choose the latter and extract the final element\n        label = ControlInterface.get_label(part)\n        label = part.id.split('.')[-1] if not label else label\n        wrapped_label = ControlInterface._wrap_label(label)\n        pad = '' if wrapped_label == '' or not part.prose else ' '\n        prose = '' if part.prose is None else part.prose\n        # top level prose has already been written out, if present\n        # use presence of . in id to tell if this is top level prose\n        if part.id != skip_id:\n            items.append(f'{wrapped_label}{pad}{prose}')\n        if part.parts:\n            sub_list = []\n            for prt in part.parts:\n                sub_list.extend(ControlInterface.get_part(prt, item_type, skip_id))\n            sub_list.append('')\n            items.append(sub_list)\n    return items\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_part_by_id","title":"<code>get_part_by_id(item, id_)</code>  <code>staticmethod</code>","text":"<p>Find the part within this item's list of parts that matches id.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_part_by_id(item: TypeWithParts, id_: str) -&gt; Optional[common.Part]:\n\"\"\"Find the part within this item's list of parts that matches id.\"\"\"\n    for part in as_list(item.parts):\n        if part.id == id_:\n            return part\n        deep_part = ControlInterface.get_part_by_id(part, id_)\n        if deep_part:\n            return deep_part\n    return None\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_part_prose","title":"<code>get_part_prose(control, part_name)</code>  <code>staticmethod</code>","text":"<p>Get the prose for a named part.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_part_prose(control: cat.Control, part_name: str) -&gt; str:\n\"\"\"Get the prose for a named part.\"\"\"\n    prose = ''\n    for part in as_list(control.parts):\n        prose += ControlInterface._get_control_section_part(part, part_name)\n    return prose.strip()\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_prop","title":"<code>get_prop(item, prop_name, default=None)</code>  <code>staticmethod</code>","text":"<p>Get the property with that name or return empty string.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_prop(item: TypeWithProps, prop_name: str, default: Optional[str] = None) -&gt; str:\n\"\"\"Get the property with that name or return empty string.\"\"\"\n    for prop in as_list(item.props):\n        if prop.name.strip().lower() == prop_name.strip().lower():\n            return prop.value.strip()\n    return default if default else ''\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_rule_list_for_imp_req","title":"<code>get_rule_list_for_imp_req(imp_req)</code>  <code>staticmethod</code>","text":"<p>Get the list of rules applying to an imp_req as two lists.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_rule_list_for_imp_req(\n    imp_req: ossp.ImplementedRequirement\n) -&gt; Tuple[List[str], List[str], List[common.Property]]:\n\"\"\"Get the list of rules applying to an imp_req as two lists.\"\"\"\n    comp_rules, rule_props = ControlInterface.get_rule_list_for_item(imp_req)\n    statement_rules = set()\n    for statement in as_list(imp_req.statements):\n        stat_rules, statement_props = ControlInterface.get_rule_list_for_item(statement)\n        statement_rules.update(stat_rules)\n        rule_props.extend(statement_props)\n    return comp_rules, sorted(statement_rules), rule_props\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_rule_list_for_item","title":"<code>get_rule_list_for_item(item)</code>  <code>staticmethod</code>","text":"<p>Get the list of rules applying to this item from its top level props.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_rule_list_for_item(item: TypeWithProps) -&gt; Tuple[List[str], List[common.Property]]:\n\"\"\"Get the list of rules applying to this item from its top level props.\"\"\"\n    props = []\n    rule_list = []\n    for prop in as_list(item.props):\n        if prop.name == const.RULE_ID:\n            rule_list.append(prop.value)\n            props.append(prop)\n    return rule_list, props\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_rules_and_params_dict_from_item","title":"<code>get_rules_and_params_dict_from_item(item)</code>  <code>staticmethod</code>","text":"<p>Get the rule dict and params dict from item with props.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_rules_and_params_dict_from_item(\n    item: TypeWithProps\n) -&gt; Tuple[Dict[str, Dict[str, str]], Dict[str, Dict[str, str]], List[common.Property]]:\n\"\"\"Get the rule dict and params dict from item with props.\"\"\"\n    rules_dict, rules_props = ControlInterface.get_rules_dict_from_item(item)\n    params_dict, params_props = ControlInterface.get_params_dict_from_item(item)\n    rules_props.extend(params_props)\n    return rules_dict, params_dict, rules_props\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_rules_dict_from_item","title":"<code>get_rules_dict_from_item(item)</code>  <code>staticmethod</code>","text":"<p>Get all rules found in this items props.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_rules_dict_from_item(item: TypeWithProps) -&gt; Tuple[Dict[str, Dict[str, str]], List[common.Property]]:\n\"\"\"Get all rules found in this items props.\"\"\"\n    # rules is dict containing rule_id and description\n    rules_dict = {}\n    name = ''\n    desc = ''\n    id_ = ''\n    rules_props = []\n    for prop in as_list(item.props):\n        if prop.name == const.RULE_ID:\n            name = prop.value\n            id_ = prop.remarks\n            rules_props.append(prop)\n        elif prop.name == const.RULE_DESCRIPTION:\n            desc = prop.value\n            rules_props.append(prop)\n        # grab each pair in case there are multiple pairs\n        # then clear and look for new pair\n        if name and desc:\n            rules_dict[id_] = {'name': name, 'description': desc}\n            name = desc = id_ = ''\n    return rules_dict, rules_props\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_section","title":"<code>get_section(control, skip_section_list)</code>  <code>staticmethod</code>","text":"<p>Get sections that are not in the list.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_section(control: cat.Control, skip_section_list: List[str]) -&gt; Tuple[str, str, str, str]:\n\"\"\"Get sections that are not in the list.\"\"\"\n    id_, name, title = ControlInterface._find_section(control, skip_section_list)\n    if id_:\n        return id_, name, title, ControlInterface.get_control_section_prose(control, name)\n    return '', '', '', ''\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_set_params_from_item","title":"<code>get_set_params_from_item(item)</code>  <code>staticmethod</code>","text":"<p>Get set params that have values from control implementation or imp req.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_set_params_from_item(\n    item: Union[comp.ControlImplementation, comp.ImplementedRequirement]\n) -&gt; Dict[str, comp.SetParameter]:\n\"\"\"Get set params that have values from control implementation or imp req.\"\"\"\n    return {\n        set_param.param_id: set_param\n        for set_param in as_filtered_list(item.set_parameters, lambda i: i.values)\n    }\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_sort_id","title":"<code>get_sort_id(control, allow_none=False)</code>  <code>staticmethod</code>","text":"<p>Get the sort-id for the control.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_sort_id(control: cat.Control, allow_none=False) -&gt; Optional[str]:\n\"\"\"Get the sort-id for the control.\"\"\"\n    for prop in as_list(control.props):\n        if prop.name == const.SORT_ID:\n            return prop.value.strip()\n    return None if allow_none else control.id\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_statement_id","title":"<code>get_statement_id(control)</code>  <code>staticmethod</code>","text":"<p>Find the statement id in the control.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_statement_id(control: cat.Control) -&gt; str:\n\"\"\"Find the statement id in the control.\"\"\"\n    for part in as_list(control.parts):\n        if part.name == const.STATEMENT:\n            return part.id\n    return ControlInterface.create_statement_id(control.id)\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.get_status_from_props","title":"<code>get_status_from_props(item)</code>  <code>staticmethod</code>","text":"<p>Get the status of an item from its props.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef get_status_from_props(item: TypeWithProps) -&gt; common.ImplementationStatus:\n\"\"\"Get the status of an item from its props.\"\"\"\n    status = common.ImplementationStatus(state=const.STATUS_PLANNED)\n    for prop in as_list(item.props):\n        if prop.name == const.IMPLEMENTATION_STATUS:\n            status = ControlInterface._prop_as_status(prop)\n            break\n    return status\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.insert_imp_req_into_component","title":"<code>insert_imp_req_into_component(component, new_imp_req, profile_title, trestle_root)</code>  <code>staticmethod</code>","text":"<p>Insert imp req into component by matching source title and control id to existing imp req.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>comp.DefinedComponent</code> <p>The defined component receiving the imp_req</p> required <code>new_imp_req</code> <code>comp.ImplementedRequirement</code> <p>The new imp_req being added</p> required <code>profile_title</code> <code>str</code> <p>The title of the source profile for the control implementation containing the imp_req</p> required <p>Notes</p> <p>Inserts the imp_req on the first match found.  Note it is possible two control implementations could have the same source and specify the same control</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef insert_imp_req_into_component(\n    component: comp.DefinedComponent,\n    new_imp_req: comp.ImplementedRequirement,\n    profile_title: str,\n    trestle_root: pathlib.Path\n) -&gt; None:\n\"\"\"\n    Insert imp req into component by matching source title and control id to existing imp req.\n\n    Args:\n        component: The defined component receiving the imp_req\n        new_imp_req: The new imp_req being added\n        profile_title: The title of the source profile for the control implementation containing the imp_req\n\n    Notes:\n        Inserts the imp_req on the first match found.  Note it is possible two control implementations could\n        have the same source and specify the same control\n    \"\"\"\n    for control_imp in as_list(component.control_implementations):\n        _, control_imp_param_dict, _ = ControlInterface.get_rules_and_params_dict_from_item(control_imp)\n        control_imp_rule_param_ids = [d['name'] for d in control_imp_param_dict.values()]\n        if profile_title != ModelUtils.get_title_from_model_uri(trestle_root, control_imp.source):\n            continue\n        for imp_req in as_list(control_imp.implemented_requirements):\n            if imp_req.control_id != new_imp_req.control_id:\n                continue\n            _, imp_req_param_dict, _ = ControlInterface.get_rules_and_params_dict_from_item(imp_req)\n            imp_req_rule_param_ids = [d['name'] for d in imp_req_param_dict]\n            status = ControlInterface.get_status_from_props(new_imp_req)\n            ControlInterface.insert_status_in_props(imp_req, status)\n            imp_req.description = new_imp_req.description\n            statement_dict = {stat.statement_id: stat for stat in as_list(imp_req.statements)}\n            # update set parameter values with values from markdown - but only for rule param vals\n            for set_param in as_list(new_imp_req.set_parameters):\n                if set_param.param_id not in (control_imp_rule_param_ids + imp_req_rule_param_ids):\n                    continue\n                found = False\n                for dest_param in as_list(imp_req.set_parameters):\n                    if dest_param.param_id != set_param.param_id:\n                        continue\n                    dest_param.values = set_param.values\n                    found = True\n                    break\n                # if rule parameter val was not already set by a set_param, make new set_param for it\n                if found:\n                    continue\n                # but first check if the parameter was already set with the same value in the control_imp\n                # if so we don't need to insert a new set_param in imp_req\n                for dest_param in as_list(control_imp.set_parameters):\n                    if dest_param.param_id != set_param.param_id:\n                        continue\n                    if dest_param.values == set_param.values:\n                        found = True\n                        break\n                if found:\n                    continue\n                imp_req.set_parameters = as_list(imp_req.set_parameters)\n                imp_req.set_parameters.append(\n                    comp.SetParameter(param_id=set_param.param_id, values=set_param.values)\n                )\n            new_statements: List[comp.Statement] = []\n            for statement in as_list(new_imp_req.statements):\n                # get the original version of the statement if available, or use new one\n                stat = statement_dict.get(statement.statement_id, statement)\n                # update the description and status from markdown\n                stat.description = statement.description\n                ControlInterface._copy_status_in_props(stat, statement)\n                new_statements.append(stat)\n            imp_req.statements = none_if_empty(new_statements)\n            return\n    logger.warning(\n        f'Unable to add imp req for component {component.title} control {new_imp_req.control_id} and source: {profile_title}'  # noqa E501\n    )\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.insert_status_in_props","title":"<code>insert_status_in_props(item, status)</code>  <code>staticmethod</code>","text":"<p>Insert status content into props of the item.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef insert_status_in_props(item: TypeWithProps, status: common.ImplementationStatus) -&gt; None:\n\"\"\"Insert status content into props of the item.\"\"\"\n    prop = ControlInterface._status_as_prop(status)\n    ControlInterface._replace_prop(item, prop)\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.is_withdrawn","title":"<code>is_withdrawn(control)</code>  <code>staticmethod</code>","text":"<p>Determine if control is marked Withdrawn.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>cat.Control</code> <p>The control that may be marked withdrawn.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if marked withdrawn, false otherwise.</p> <p>This is determined by property with name 'status' with value 'Withdrawn'.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef is_withdrawn(control: cat.Control) -&gt; bool:\n\"\"\"\n    Determine if control is marked Withdrawn.\n\n    Args:\n        control: The control that may be marked withdrawn.\n\n    Returns:\n        True if marked withdrawn, false otherwise.\n\n    This is determined by property with name 'status' with value 'Withdrawn'.\n    \"\"\"\n    for _ in as_filtered_list(\n            control.props,\n            lambda p: strip_lower_equals(p.name, 'status') and strip_lower_equals(p.value, 'withdrawn')):\n        return True\n    return False\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.item_has_rules","title":"<code>item_has_rules(item)</code>  <code>staticmethod</code>","text":"<p>Determine if the item has rules in its props.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef item_has_rules(item: TypeWithProps) -&gt; bool:\n\"\"\"Determine if the item has rules in its props.\"\"\"\n    _, rules_props = ControlInterface.get_rules_dict_from_item(item)\n    return bool(rules_props)\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.merge_dicts_deep","title":"<code>merge_dicts_deep(dest, src, overwrite_header_values, depth=0, level=0)</code>  <code>staticmethod</code>","text":"<p>Merge dict src into dest.</p> <p>New items are always added from src to dest. Items present in both will be overriden dest if overwrite_header_values is True.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef merge_dicts_deep(\n    dest: Dict[Any, Any],\n    src: Dict[Any, Any],\n    overwrite_header_values: bool,\n    depth: int = 0,\n    level: int = 0\n) -&gt; None:\n\"\"\"\n    Merge dict src into dest.\n\n    New items are always added from src to dest.\n    Items present in both will be overriden dest if overwrite_header_values is True.\n    \"\"\"\n    for key in src.keys():\n        if key in dest:\n            if depth and level == depth:\n                if overwrite_header_values:\n                    dest[key] = src[key]\n                continue\n            # if they are both dicts, recurse\n            if isinstance(dest[key], dict) and isinstance(src[key], dict):\n                ControlInterface.merge_dicts_deep(dest[key], src[key], overwrite_header_values, depth, level + 1)\n            # if they are both lists, add any item that is not already in the list\n            elif isinstance(dest[key], list) and isinstance(src[key], list):\n                for item in src[key]:\n                    if item not in dest[key]:\n                        dest[key].append(item)\n            # otherwise override dest if needed\n            elif overwrite_header_values:\n                dest[key] = src[key]\n        else:\n            # if the item was not already in dest, add it from src\n            dest[key] = src[key]\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.merge_part","title":"<code>merge_part(dest, src)</code>  <code>staticmethod</code>","text":"<p>Merge a source part into the destination part.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef merge_part(dest: common.Part, src: common.Part) -&gt; common.Part:\n\"\"\"Merge a source part into the destination part.\"\"\"\n    dest.name = src.name if src.name else dest.name\n    dest.ns = src.ns if src.ns else dest.ns\n    dest.props = none_if_empty(ControlInterface.merge_props(dest.props, src.props))\n    dest.prose = src.prose\n    dest.title = src.title if src.title else dest.title\n    ControlInterface.merge_parts(dest, src)\n    return dest\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.merge_parts","title":"<code>merge_parts(dest, src)</code>  <code>staticmethod</code>","text":"<p>Merge the parts from the source into the destination.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef merge_parts(dest: TypeWithParts, src: TypeWithParts) -&gt; None:\n\"\"\"Merge the parts from the source into the destination.\"\"\"\n    if not dest.parts:\n        dest.parts = src.parts\n    elif not src.parts:\n        dest.parts = None\n    else:\n        new_parts: List[common.Part] = []\n        dest_map = {part.id: part for part in dest.parts}\n        for src_part in src.parts:\n            dest_part = dest_map.get(src_part.id, None)\n            if not dest_part:\n                new_parts.append(src_part)\n            else:\n                new_part = ControlInterface.merge_part(dest_part, src_part)\n                if new_part:\n                    new_parts.append(new_part)\n        dest.parts = new_parts\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.merge_props","title":"<code>merge_props(dest, src)</code>  <code>staticmethod</code>","text":"<p>Merge a source list of properties into a destination list.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef merge_props(dest: Optional[List[common.Property]],\n                src: Optional[List[common.Property]]) -&gt; List[common.Property]:\n\"\"\"Merge a source list of properties into a destination list.\"\"\"\n    if not src:\n        return dest\n    new_props: List[common.Property] = []\n    src_map = {prop.name: prop for prop in src}\n    dest_map = {prop.name: prop for prop in dest}\n    all_names = set(src_map.keys()).union(dest_map.keys())\n    for name in sorted(all_names):\n        if name in src_map and name not in dest_map:\n            new_props.append(src_map[name])\n        elif name in dest_map and name not in src_map:\n            new_props.append(dest_map[name])\n        else:\n            new_prop = dest_map[name]\n            src_prop = src_map[name]\n            new_prop.class_ = src_prop.class_ if src_prop.class_ else new_prop.class_\n            new_prop.ns = src_prop.ns if src_prop.ns else new_prop.ns\n            new_prop.remarks = src_prop.remarks if src_prop.remarks else new_prop.remarks\n            new_prop.uuid = src_prop.uuid if src_prop.uuid else new_prop.uuid\n            new_prop.value = src_prop.value\n            new_props.append(new_prop)\n    return new_props\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.param_to_str","title":"<code>param_to_str(param, param_rep, verbose=False, brackets=False, params_format=None, value_assigned_prefix=None, value_not_assigned_prefix=None)</code>  <code>staticmethod</code>","text":"<p>Convert parameter to string based on best available representation.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>common.Parameter</code> <p>the parameter to convert</p> required <code>param_rep</code> <code>ParameterRep</code> <p>how to represent the parameter</p> required <code>verbose</code> <code>bool</code> <p>provide verbose text for selection choices</p> <code>False</code> <code>brackets</code> <code>bool</code> <p>add brackets around the lists of items</p> <code>False</code> <code>params_format</code> <code>Optional[str]</code> <p>a string containing a single dot that represents a form of highlighting around the param</p> <code>None</code> <code>value_assigned_prefix</code> <code>Optional[str]</code> <p>string to place before the parameter string if a value was assigned</p> <code>None</code> <code>value_not_assigned_prefix</code> <code>Optional[str]</code> <p>string to place before the parameter string if value not assigned</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>formatted string or None</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef param_to_str(\n    param: common.Parameter,\n    param_rep: ParameterRep,\n    verbose: bool = False,\n    brackets: bool = False,\n    params_format: Optional[str] = None,\n    value_assigned_prefix: Optional[str] = None,\n    value_not_assigned_prefix: Optional[str] = None\n) -&gt; Optional[str]:\n\"\"\"\n    Convert parameter to string based on best available representation.\n\n    Args:\n        param: the parameter to convert\n        param_rep: how to represent the parameter\n        verbose: provide verbose text for selection choices\n        brackets: add brackets around the lists of items\n        params_format: a string containing a single dot that represents a form of highlighting around the param\n        value_assigned_prefix: string to place before the parameter string if a value was assigned\n        value_not_assigned_prefix: string to place before the parameter string if value not assigned\n\n    Returns:\n        formatted string or None\n    \"\"\"\n    param_str = None\n    if param_rep == ParameterRep.VALUE_OR_STRING_NONE:\n        param_str = ControlInterface._param_values_as_str(param)\n        param_str = param_str if param_str else 'None'\n    elif param_rep == ParameterRep.LABEL_OR_CHOICES:\n        param_str = ControlInterface._param_label_choices_as_str(param, verbose, brackets)\n    elif param_rep == ParameterRep.VALUE_OR_LABEL_OR_CHOICES:\n        param_str = ControlInterface._param_values_as_str(param)\n        if not param_str:\n            param_str = ControlInterface._param_label_choices_as_str(param, verbose, brackets)\n    elif param_rep == ParameterRep.VALUE_OR_EMPTY_STRING:\n        param_str = ControlInterface._param_values_as_str(param, brackets)\n        if not param_str:\n            param_str = ''\n    elif param_rep == ParameterRep.ASSIGNMENT_FORM:\n        param_str = ControlInterface._param_values_assignment_str(\n            param, value_assigned_prefix, value_not_assigned_prefix\n        )\n        if not param_str:\n            param_str = ''\n    elif param_rep == ParameterRep.LABEL_FORM:\n        param_str = ControlInterface._param_labels_assignment_str(param, value_not_assigned_prefix)\n        if not param_str:\n            param_str = ''\n    return ControlInterface._apply_params_format(param_str, params_format)\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.replace_control_prose","title":"<code>replace_control_prose(control, param_dict, params_format=None, param_rep=&lt;ParameterRep.VALUE_OR_LABEL_OR_CHOICES: 3&gt;, show_value_warnings=False, value_assigned_prefix=None, value_not_assigned_prefix=None)</code>  <code>staticmethod</code>","text":"<p>Replace the control prose according to set_param.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef replace_control_prose(\n    control: cat.Control,\n    param_dict: Dict[str, common.Parameter],\n    params_format: Optional[str] = None,\n    param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n    show_value_warnings: bool = False,\n    value_assigned_prefix: Optional[str] = None,\n    value_not_assigned_prefix: Optional[str] = None\n) -&gt; None:\n\"\"\"Replace the control prose according to set_param.\"\"\"\n    # first replace all choices that reference parameters\n    # note that in ASSIGNMENT_FORM each choice with a parameter will end up as [Assignment: value]\n    for param in as_list(control.params):\n        ControlInterface._replace_param_choices(\n            param,\n            param_dict,\n            params_format,\n            param_rep,\n            show_value_warnings,\n            value_assigned_prefix,\n            value_not_assigned_prefix\n        )\n    for part in as_list(control.parts):\n        if part.prose is not None:\n            fixed_prose = ControlInterface._replace_params(\n                part.prose,\n                param_dict,\n                params_format,\n                param_rep,\n                show_value_warnings,\n                value_assigned_prefix,\n                value_not_assigned_prefix\n            )\n            # change the prose in the control itself\n            part.prose = fixed_prose\n        for prt in as_list(part.parts):\n            ControlInterface._replace_part_prose(\n                control,\n                prt,\n                param_dict,\n                params_format,\n                param_rep,\n                show_value_warnings,\n                value_assigned_prefix,\n                value_not_assigned_prefix\n            )\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.setparam_to_param","title":"<code>setparam_to_param(param_id, set_param)</code>  <code>staticmethod</code>","text":"<p>Convert setparameter to parameter.</p> <p>Parameters:</p> Name Type Description Default <code>param_id</code> <code>str</code> <p>the id of the parameter</p> required <code>set_param</code> <code>prof.SetParameter</code> <p>the set_parameter from a profile</p> required <p>Returns:</p> Type Description <code>common.Parameter</code> <p>a Parameter with param_id and content from the SetParameter</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef setparam_to_param(param_id: str, set_param: prof.SetParameter) -&gt; common.Parameter:\n\"\"\"\n    Convert setparameter to parameter.\n\n    Args:\n        param_id: the id of the parameter\n        set_param: the set_parameter from a profile\n\n    Returns:\n        a Parameter with param_id and content from the SetParameter\n    \"\"\"\n    return common.Parameter(\n        id=param_id, values=set_param.values, select=set_param.select, label=set_param.label, props=set_param.props\n    )\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.strip_to_make_ncname","title":"<code>strip_to_make_ncname(label)</code>  <code>staticmethod</code>","text":"<p>Strip chars to conform with NCNAME regex.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef strip_to_make_ncname(label: str) -&gt; str:\n\"\"\"Strip chars to conform with NCNAME regex.\"\"\"\n    orig_label = label\n    # make sure first char is allowed\n    while label and label[0] not in const.NCNAME_UTF8_FIRST_CHAR_OPTIONS:\n        label = label[1:]\n    new_label = label[:1]\n    # now check remaining chars\n    if len(label) &gt; 1:\n        for ii in range(1, len(label)):\n            if label[ii] in const.NCNAME_UTF8_OTHER_CHAR_OPTIONS:\n                new_label += label[ii]\n    # do final check to confirm it is NCNAME\n    match = re.search(const.NCNAME_REGEX, new_label)\n    if not match:\n        raise TrestleError(f'Unable to convert label {orig_label} to NCNAME format.')\n    return new_label\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ControlInterface.uniquify_set_params","title":"<code>uniquify_set_params(set_params)</code>  <code>staticmethod</code>","text":"<p>Remove items with same param_id with priority to later items.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>@staticmethod\ndef uniquify_set_params(set_params: Optional[List[TypeWithParamId]]) -&gt; List[TypeWithParamId]:\n\"\"\"Remove items with same param_id with priority to later items.\"\"\"\n    found_ids: Set[str] = set()\n    unique_list: List[TypeWithParamId] = []\n    for set_param in reversed(as_list(set_params)):\n        if set_param.param_id not in found_ids:\n            unique_list.append(set_param)\n            found_ids.add(set_param.param_id)\n    return list(reversed(unique_list))\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ParameterRep","title":"<code> ParameterRep            (Enum)         </code>","text":"<p>Enum for ways to represent a parameter.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>class ParameterRep(Enum):\n\"\"\"Enum for ways to represent a parameter.\"\"\"\n\n    LEAVE_MOUSTACHE = 0\n    VALUE_OR_STRING_NONE = 1\n    LABEL_OR_CHOICES = 2\n    VALUE_OR_LABEL_OR_CHOICES = 3\n    VALUE_OR_EMPTY_STRING = 4\n    ASSIGNMENT_FORM = 5\n    LABEL_FORM = 6\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ParameterRep.ASSIGNMENT_FORM","title":"<code>ASSIGNMENT_FORM</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ParameterRep.LABEL_FORM","title":"<code>LABEL_FORM</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ParameterRep.LABEL_OR_CHOICES","title":"<code>LABEL_OR_CHOICES</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ParameterRep.LEAVE_MOUSTACHE","title":"<code>LEAVE_MOUSTACHE</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ParameterRep.VALUE_OR_EMPTY_STRING","title":"<code>VALUE_OR_EMPTY_STRING</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ParameterRep.VALUE_OR_LABEL_OR_CHOICES","title":"<code>VALUE_OR_LABEL_OR_CHOICES</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.ParameterRep.VALUE_OR_STRING_NONE","title":"<code>VALUE_OR_STRING_NONE</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo","title":"<code> PartInfo        </code>  <code>dataclass</code>","text":"<p>Class to capture control part info needed in markdown.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>class PartInfo:\n\"\"\"Class to capture control part info needed in markdown.\"\"\"\n\n    name: str\n    prose: str\n    smt_part: str = ''\n    props: Optional[List[common.Property]] = None\n    parts: Optional[List[PartInfo]] = None\n\n    def to_dicts(self, part_id_map: Dict[str, str]) -&gt; Tuple[Dict[str, Any], List[Dict[str, Any]]]:\n\"\"\"Convert the part info to a dict or list of props.\"\"\"\n        prop_list = []\n        part = {}\n        # if it has a part name then it is a part with prose\n        if self.name:\n            part['name'] = part_id_map.get(self.name, self.name)\n            if self.prose:\n                part['prose'] = self.prose\n            if self.parts:\n                all_subparts = []\n                for subpart in self.parts:\n                    subpart_dict, _ = subpart.to_dicts(part_id_map)\n                    all_subparts.append(subpart_dict)\n                part['parts'] = all_subparts\n\n        # otherwise it is a list of props\n        else:\n            for prop in as_list(self.props):\n                prop_d = {'name': prop.name, 'value': prop.value}\n                if prop.ns:\n                    prop_d['ns'] = str(prop.ns)\n                if self.smt_part:\n                    prop_d['smt-part'] = part_id_map.get(self.smt_part, self.smt_part)\n                prop_list.append(prop_d)\n        return part, prop_list\n</code></pre>"},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo.name","title":"<code>name: str</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo.parts","title":"<code>parts: Optional[List[trestle.core.control_interface.PartInfo]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo.props","title":"<code>props: Optional[List[trestle.oscal.common.Property]]</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo.prose","title":"<code>prose: str</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo.smt_part","title":"<code>smt_part: str</code>  <code>dataclass-field</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo.__eq__","title":"<code>__eq__(self, other)</code>  <code>special</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo.__init__","title":"<code>__init__(self, name, prose, smt_part='', props=None, parts=None)</code>  <code>special</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":""},{"location":"api_reference/trestle.core.control_interface/#trestle.core.control_interface.PartInfo.to_dicts","title":"<code>to_dicts(self, part_id_map)</code>","text":"<p>Convert the part info to a dict or list of props.</p> Source code in <code>trestle/core/control_interface.py</code> <pre><code>def to_dicts(self, part_id_map: Dict[str, str]) -&gt; Tuple[Dict[str, Any], List[Dict[str, Any]]]:\n\"\"\"Convert the part info to a dict or list of props.\"\"\"\n    prop_list = []\n    part = {}\n    # if it has a part name then it is a part with prose\n    if self.name:\n        part['name'] = part_id_map.get(self.name, self.name)\n        if self.prose:\n            part['prose'] = self.prose\n        if self.parts:\n            all_subparts = []\n            for subpart in self.parts:\n                subpart_dict, _ = subpart.to_dicts(part_id_map)\n                all_subparts.append(subpart_dict)\n            part['parts'] = all_subparts\n\n    # otherwise it is a list of props\n    else:\n        for prop in as_list(self.props):\n            prop_d = {'name': prop.name, 'value': prop.value}\n            if prop.ns:\n                prop_d['ns'] = str(prop.ns)\n            if self.smt_part:\n                prop_d['smt-part'] = part_id_map.get(self.smt_part, self.smt_part)\n            prop_list.append(prop_d)\n    return part, prop_list\n</code></pre>"},{"location":"api_reference/trestle.core.control_reader/","title":"control_reader","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader","title":"<code>trestle.core.control_reader</code>","text":"<p>Handle reading of writing controls from markdown.</p>"},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader.ControlReader","title":"<code> ControlReader        </code>","text":"<p>Class to read controls from markdown.</p> Source code in <code>trestle/core/control_reader.py</code> <pre><code>class ControlReader:\n\"\"\"Class to read controls from markdown.\"\"\"\n\n    @staticmethod\n    def _clean_prose(prose: List[str]) -&gt; List[str]:\n        # remove empty and horizontal rule lines at start and end of list of prose lines\n        forward_index = 0\n        for line in prose:\n            if line.strip() and not line.startswith('____'):\n                break\n            forward_index += 1\n        new_prose = prose[forward_index:]\n        reverse_index = 0\n        for line in reversed(new_prose):\n            if line.strip() and not line.startswith('____'):\n                break\n            reverse_index += 1\n        clean_prose = new_prose[:len(new_prose) - reverse_index]\n        clean_prose = clean_prose if clean_prose else ['']\n        # if there is no useful prose this will return [''] and allow generation of a statement with empty prose\n        return clean_prose\n\n    @staticmethod\n    def _comp_name_in_dict(comp_name: str, comp_dict: CompDict) -&gt; str:\n\"\"\"If the name is already in the dict in a similar form, stick to that form.\"\"\"\n        simple_name = ControlReader.simplify_name(comp_name)\n        for name in comp_dict.keys():\n            if simple_name == ControlReader.simplify_name(name):\n                return name\n        return comp_name\n\n    @staticmethod\n    def _add_node_to_dict(\n        comp_name: Optional[str],\n        label: str,\n        comp_dict: CompDict,\n        node: ControlMarkdownNode,\n        control_id: str,\n        comp_list: List[str],\n        context: ControlContext\n    ) -&gt; None:\n\"\"\"\n        Extract the label, prose, possible component name - along with implementation status.\n\n        In component mode there is only one component and its name is not in markdown.\n        In ssp mode there are many components in each md file.\n        \"\"\"\n        component_mode = context.purpose == ContextPurpose.COMPONENT\n        # for ssp, ### marks component name but for component it is ##\n        # if it is a header, make sure it has correct format\n        if node.key and node.key[0] == '#' and ControlInterface.bad_header(node.key):\n            raise TrestleError(f'Improper header format for control {control_id}: {node.key}')\n        if not component_mode:\n            # look for component name heading if present\n            prefix = '### '\n            if node.key.startswith(prefix):\n                if len(node.key.split()) &lt;= 1:\n                    raise TrestleError(\n                        f'Header line in control {control_id} markdown starts with {prefix} but has no content.'\n                    )\n                comp_name = node.key.split(' ', 1)[1].strip()\n                simp_comp_name = ControlReader.simplify_name(comp_name)\n                if simp_comp_name in comp_list:\n                    raise TrestleError(\n                        f'Control {control_id} has a section with two component headings for {comp_name}.  '\n                        'Please combine the sections so there is only one heading for each component in a '\n                        'statement.'\n                    )\n                comp_list.append(simp_comp_name)\n                comp_name = ControlReader._comp_name_in_dict(comp_name, comp_dict)\n\n        # prose may be empty in md and we want to capture that so put it in the comp_dict\n        prose = '\\n'.join(ControlReader._clean_prose(node.content.text))\n        # add the prose to the comp_dict, creating new entry as needed\n        if comp_name in comp_dict:\n            if label in comp_dict[comp_name]:\n                comp_dict[comp_name][label].prose = prose\n            else:\n                # create new entry with prose\n                comp_dict[comp_name][label] = ComponentImpInfo(prose=prose, rules=[], props=[])\n        elif comp_name:\n            comp_dict[comp_name] = {label: ComponentImpInfo(prose=prose, rules=[], props=[])}\n\n        # build list of subnodes that get handled specially so they aren't processed here\n        subnode_kill: List[int] = []\n        status_str = None\n        remarks_str = None\n        rules_list: List[str] = []\n        for ii, subnode in enumerate(node.subnodes):\n            if subnode.key.find(const.IMPLEMENTATION_STATUS_REMARKS_HEADER) &gt;= 0:\n                remarks_str = subnode.key.split(maxsplit=4)[-1]\n                subnode_kill.append(ii)\n            elif subnode.key.find(const.IMPLEMENTATION_STATUS_HEADER) &gt;= 0:\n                status_str = subnode.key.split(maxsplit=3)[-1]\n                subnode_kill.append(ii)\n            elif subnode.key.find('Rules:') &gt;= 0:\n                rules_list = [text[2:] for text in subnode.content.text if text.startswith('- ')]\n                subnode_kill.append(ii)\n        if status_str:\n            new_status = common.ImplementationStatus(state=status_str, remarks=remarks_str)\n            if comp_name not in comp_dict:\n                comp_dict[comp_name] = {}\n            if label not in comp_dict[comp_name]:\n                comp_dict[comp_name][label] = ComponentImpInfo(prose='', rules=[], props=[])\n            comp_dict[comp_name][label].status = new_status\n        if rules_list:\n            comp_dict[comp_name][label].rules = rules_list\n        delete_list_from_list(node.subnodes, subnode_kill)\n        for subnode in as_list(node.subnodes):\n            ControlReader._add_node_to_dict(comp_name, label, comp_dict, subnode, control_id, comp_list, context)\n\n    @staticmethod\n    def _insert_header_content(\n        imp_req: generic.GenericImplementedRequirement, header: Dict[str, Any], control_id: str\n    ) -&gt; None:\n\"\"\"Insert yaml header content into the imp_req and its by_comps as props.\"\"\"\n        dict_ = header.get(const.TRESTLE_PROPS_TAG, {})\n        roles = as_list(dict_.get(const.RESPONSIBLE_ROLES, []))\n        props = []\n        responsible_roles = []\n        for role in roles:\n            if isinstance(role, str):\n                # role_id must conform to NCNAME regex\n                role = role.strip().replace(' ', '_')\n                if role:\n                    responsible_roles.append(common.ResponsibleRole(role_id=role))\n            else:\n                logger.warning(f'Role in header for control {control_id} not recognized: {role}')\n        if props:\n            imp_req.props = as_list(imp_req.props)\n            imp_req.props.extend(props)\n        if responsible_roles:\n            imp_req.responsible_roles = as_list(imp_req.responsible_roles)\n            imp_req.responsible_roles.extend(responsible_roles)\n            imp_req.responsible_roles = none_if_empty(imp_req.responsible_roles)\n            # enforce single list of resp. roles for control and each by_comp\n            for by_comp in as_list(imp_req.by_components):\n                by_comp.responsible_roles = imp_req.responsible_roles\n\n    @staticmethod\n    def simplify_name(name: str) -&gt; str:\n\"\"\"Simplify the name to ignore variations in case, space, hyphen, underscore, slash.\"\"\"\n        return name.lower().replace(' ', '').replace('-', '').replace('_', '').replace('/', '')\n\n    @staticmethod\n    def _get_label_from_implementation_header(imp_header: str):\n        # assumed to be of form: Implementation for part a.\n        split_header = imp_header.split(' ', 4)\n        if len(split_header) != 5:\n            raise TrestleError(f'Implementation header cannot be parsed for statement part: {imp_header}')\n        return split_header[4].strip()\n\n    @staticmethod\n    def read_control_info_from_md(control_file: pathlib.Path,\n                                  context: ControlContext) -&gt; Tuple[Dict[str, List[str]], CompDict]:\n\"\"\"\n        Find all labels and associated implementation prose in the markdown for this control.\n\n        Args:\n            control_file: path to the control markdown file\n            context: context of the control usage\n\n        Returns:\n            The yaml header as dict in second part of tuple.\n            Adds to the passed in comp_dict.\n        \"\"\"\n        yaml_header = {}\n        comp_dict = {}\n\n        if not control_file.exists():\n            return yaml_header, comp_dict\n        # if the file exists, load the contents but do not use prose from comp_dict\n        # for non ssp or component mode just use empty string for comp\n        comp_name = ''\n        try:\n            control_id = control_file.stem\n            if context.purpose == ContextPurpose.COMPONENT:\n                comp_name = context.comp_name if context.comp_name else const.SSP_MAIN_COMP_NAME\n\n            md_api = MarkdownAPI()\n            yaml_header, control_md = md_api.processor.process_markdown(control_file)\n\n            # first get the header strings, including statement labels, for statement imp reqs\n            imp_string = '## Implementation '\n            headers = control_md.get_all_headers_for_level(2)\n            # get e.g. ## Implementation a.  ## Implementation b. etc\n            imp_header_list = [header for header in headers if header.startswith(imp_string)]\n\n            # now get the (one) header for the main solution\n            main_headers = list(control_md.get_all_headers_for_key(const.SSP_MD_IMPLEMENTATION_QUESTION, False))\n            # should be only one header, so warn if others found\n            if main_headers:\n                if len(main_headers) &gt; 1:\n                    logger.warning(\n                        f'Control {control_id} has {len(main_headers)} main header responses.  Will use first one only.'\n                    )\n                main_header = main_headers[0]\n                node = control_md.get_all_nodes_for_keys([main_header], False)[0]\n                # this node is top level so it will have empty label\n                # it may have subnodes of Rules, Implementation Status, Implementaton Remarks\n                ControlReader._add_node_to_dict(comp_name, '', comp_dict, node, control_id, [], context)\n            for imp_header in imp_header_list:\n                label = ControlReader._get_label_from_implementation_header(imp_header)\n                node = control_md.get_node_for_key(imp_header)\n                ControlReader._add_node_to_dict(comp_name, label, comp_dict, node, control_id, [], context)\n\n        except TrestleError as e:\n            raise TrestleError(f'Error occurred reading {control_file}: {e}')\n        return yaml_header, comp_dict\n\n    @staticmethod\n    def _handle_empty_prose(prose: str, id_: str) -&gt; str:\n\"\"\"Regard prompt text or id_ as no prose and return blank string.\"\"\"\n        if prose.startswith(const.SSP_ADD_IMPLEMENTATION_PREFIX) or prose == id_:\n            return ''\n        return prose\n\n    @staticmethod\n    def read_implemented_requirement(control_file: pathlib.Path,\n                                     context: ControlContext) -&gt; Tuple[str, comp.ImplementedRequirement]:\n\"\"\"\n        Get the implementated requirement associated with given control and link to existing components or new ones.\n\n        Args:\n            control_file: path of the control markdown file\n            context: context of the control usage\n\n        Returns:\n            Tuple: The control sort-id and the one implemented requirement for this control.\n\n        Notes:\n            Each statement may have several responses, with each response in a by_component for a specific component.\n            statement_map keeps track of statements that may have several by_component responses.\n            This is only used during component assemble and only for updating one component.\n        \"\"\"\n        control_id = control_file.stem\n        md_header, md_comp_dict = ControlReader.read_control_info_from_md(control_file, context)\n        comp_name = context.component.title\n\n        statement_map: Dict[str, comp.Statement] = {}\n        # create a new implemented requirement linked to the control id to hold the statements\n        imp_req = gens.generate_sample_model(comp.ImplementedRequirement)\n        imp_req.control_id = control_id\n\n        imp_req.statements = []\n        comp_dict = md_comp_dict[comp_name]\n        for label, comp_info in comp_dict.items():\n            # only assemble responses with associated rules\n            if not comp_info.rules:\n                continue\n            # if no label it applies to the imp_req itself rather than a statement\n            if not label:\n                imp_req.description = ControlReader._handle_empty_prose(comp_info.prose, control_id)\n                ControlInterface.insert_status_in_props(imp_req, comp_info.status)\n                continue\n            statement_id = ControlInterface.create_statement_id(control_id)\n            if label in ['', const.STATEMENT]:\n                statement_part_id = statement_id\n            else:\n                clean_label = label.strip('.')\n                statement_part_id = ControlInterface.strip_to_make_ncname(f'{statement_id}.{clean_label}')\n            if statement_part_id in statement_map:\n                statement = statement_map[statement_part_id]\n            else:\n                statement = gens.generate_sample_model(comp.Statement)\n                statement.statement_id = statement_part_id\n                statement_map[statement_part_id] = statement\n            statement.description = comp_info.prose\n            statement.props = none_if_empty(ControlInterface.clean_props(comp_info.props))\n            ControlInterface.insert_status_in_props(statement, comp_info.status)\n\n        imp_req.statements = list(statement_map.values())\n        imp_req.set_parameters = []\n\n        for _, param_dict_list in md_header.get(const.COMP_DEF_RULES_PARAM_VALS_TAG, {}).items():\n            for param_dict in param_dict_list:\n                values = param_dict.get(const.VALUES, [])\n                comp_values = param_dict.get(const.COMPONENT_VALUES, [])\n                values = comp_values if comp_values else values\n                set_param = ossp.SetParameter(param_id=param_dict['name'], values=values)\n                imp_req.set_parameters.append(set_param)\n        imp_req.statements = none_if_empty(list(statement_map.values()))\n        imp_req.set_parameters = none_if_empty(imp_req.set_parameters)\n\n        ControlReader._insert_header_content(imp_req, md_header, control_id)\n        sort_id = md_header.get(const.SORT_ID, control_id)\n        return sort_id, imp_req\n\n    @staticmethod\n    def _get_props_list(control_id: str, label_map: Dict[str, str],\n                        yaml_header: Dict[str, Any]) -&gt; Tuple[List[common.Property], Dict[str, List[common.Property]]]:\n\"\"\"Get the list of props in the yaml header of this control as separate lists with and without by_id.\"\"\"\n        prop_list = yaml_header.get(const.TRESTLE_ADD_PROPS_TAG, [])\n        props = []\n        props_by_id = {}\n        for prop_d in prop_list:\n            by_id = prop_d.get('smt-part', None)\n            if by_id and control_id in label_map:\n                by_id = label_map[control_id].get(by_id, by_id)\n            prop = common.Property(name=prop_d['name'], value=prop_d['value'], ns=prop_d.get('ns', None))\n            if by_id:\n                if by_id not in props_by_id:\n                    props_by_id[by_id] = []\n                props_by_id[by_id].append(prop)\n            else:\n                props.append(prop)\n        return props, props_by_id\n\n    @staticmethod\n    def read_editable_content(\n        control_path: pathlib.Path,\n        required_sections_list: List[str],\n        part_label_to_id_map: Dict[str, Dict[str, str]],\n        cli_section_dict: Dict[str, str],\n        write_mode: bool\n    ) -&gt; Tuple[str, List[prof.Alter], Dict[str, Any]]:\n\"\"\"Get parts for the markdown control corresponding to Editable Content - along with the set-parameter dict.\"\"\"\n        control_id = control_path.stem\n\n        md_api = MarkdownAPI()\n        yaml_header, control_tree = md_api.processor.process_control_markdown(control_path, cli_section_dict, part_label_to_id_map)  # noqa: E501\n        # extract the sort_id if present in header\n        sort_id = yaml_header.get(const.SORT_ID, control_id)\n\n        editable_node = None\n        for header in list(control_tree.get_all_headers_for_level(1)):\n            if header.startswith('# Editable'):\n                editable_node = control_tree.get_node_for_key(header)\n                break\n        if not editable_node:\n            return sort_id, [], {}\n\n        editable_parts = control_tree.get_editable_parts_and_subparts()\n        by_id_parts = control_tree.get_by_id_parts()\n        found_sections = [p.name for p in editable_parts]\n\n        # Validate that all required sections have a prose\n        for editable_part in editable_parts:\n            if not write_mode and editable_part.name in required_sections_list and editable_part.prose.startswith(\n                    const.PROFILE_ADD_REQUIRED_SECTION_FOR_CONTROL_TEXT):\n                raise TrestleError(f'Control {control_id} is missing prose for required section {editable_part.title}')\n\n        # Validate that all required sections are present\n        missing_sections = set(required_sections_list) - set(found_sections)\n        if missing_sections:\n            raise TrestleError(f'Control {control_id} is missing required sections {missing_sections}')\n        param_dict: Dict[str, Any] = {}\n        # get set_params from the header and add to parm_dict\n        header_params = yaml_header.get(const.SET_PARAMS_TAG, {})\n        if header_params:\n            param_dict.update(header_params)\n\n        props, props_by_id = ControlReader._get_props_list(control_id, part_label_to_id_map, yaml_header)\n\n        # When adding props without by_id it can either be starting or ending and we default to ending\n        # This is the default behavior as described for implicit binding in\n        # https://pages.nist.gov/OSCAL/concepts/processing/profile-resolution/\n        # When adding props to a part using by_id, it is the same situation because it cannot be before or after since\n        # props are not in the same list as parts\n\n        adds: List[prof.Add] = []\n\n        # add the parts and props at control level\n        if editable_parts or props:\n            adds.append(\n                prof.Add(\n                    parts=none_if_empty(editable_parts), props=none_if_empty(props), position=prof.Position.ending\n                )\n            )\n\n        # add the parts and props at the part level, by-id\n        by_ids = set(by_id_parts.keys()).union(props_by_id.keys())\n        for by_id in sorted(by_ids):\n            parts = by_id_parts.get(by_id, None)\n            props = props_by_id.get(by_id, None)\n            adds.append(prof.Add(parts=parts, props=props, position=prof.Position.ending, by_id=by_id))\n\n        new_alters = []\n        if adds:\n            new_alters = [prof.Alter(control_id=control_id, adds=adds)]\n        return sort_id, new_alters, param_dict\n\n    @staticmethod\n    def _update_display_prop_namespace(item: TypeWithProps):\n\"\"\"Set namespace for special property display_name.\"\"\"\n        for prop in as_list(item.props):\n            if prop.name == const.DISPLAY_NAME:\n                prop.ns = const.TRESTLE_GENERIC_NS\n\n    @staticmethod\n    def read_control(control_path: pathlib.Path, set_parameters_flag: bool) -&gt; Tuple[cat.Control, str]:\n\"\"\"Read the control and group title from the markdown file.\"\"\"\n        control = gens.generate_sample_model(cat.Control)\n        md_api = MarkdownAPI()\n        yaml_header, control_tree = md_api.processor.process_control_markdown(control_path)\n        control_titles = list(control_tree.get_all_headers_for_level(1))\n        if len(control_titles) == 0:\n            raise TrestleError(f'Control markdown: {control_path} contains no control title.')\n        if len(control_titles) &gt; 1:\n            raise TrestleError(f'Control markdown: {control_path} contains multiple control titles {control_titles}.')\n\n        control.id = control_tree.subnodes[0].content.control_id\n        group_title = control_tree.subnodes[0].content.control_group\n        control.title = control_tree.subnodes[0].content.control_title\n\n        control_statement = control_tree.get_control_statement()\n        statement_part = control_statement.content.part\n\n        control.parts = [statement_part] if statement_part else None\n        control_objective = control_tree.get_control_objective()\n        if control_objective is not None:\n            objective_part = control_objective.content.part\n            if objective_part:\n                if control.parts:\n                    control.parts.append(objective_part)\n                else:\n                    control.parts = [objective_part]\n\n        control_guidance = control_tree.get_control_guidance()\n        if control_guidance is not None:\n            guidance_part = control_guidance.content.part\n            if guidance_part:\n                if control.parts:\n                    control.parts.append(guidance_part)\n                else:\n                    control.parts = [guidance_part]\n\n        all_other_parts = []\n        for section_node in control_tree.get_other_control_parts():\n            parts = section_node.content.part\n            all_other_parts.extend([parts])\n        if all_other_parts:\n            if control.parts:\n                control.parts.extend(all_other_parts)\n            else:\n                control.parts = all_other_parts\n\n        if set_parameters_flag:\n            params: Dict[str, str] = yaml_header.get(const.SET_PARAMS_TAG, [])\n            if params:\n                control.params = []\n                for id_, param_dict in params.items():\n                    param_dict['id'] = id_\n                    param = ModelUtils.dict_to_parameter(param_dict)\n                    # if display_name is in list of properties, set its namespace\n                    ControlReader._update_display_prop_namespace(param)\n                    control.params.append(param)\n        sort_id = deep_get(yaml_header, [const.TRESTLE_GLOBAL_TAG, const.SORT_ID], None)\n        if sort_id:\n            control.props = control.props if control.props else []\n            control.props.append(common.Property(name=const.SORT_ID, value=sort_id))\n        return control, group_title\n</code></pre>"},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader.ControlReader-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader.ControlReader.read_control","title":"<code>read_control(control_path, set_parameters_flag)</code>  <code>staticmethod</code>","text":"<p>Read the control and group title from the markdown file.</p> Source code in <code>trestle/core/control_reader.py</code> <pre><code>@staticmethod\ndef read_control(control_path: pathlib.Path, set_parameters_flag: bool) -&gt; Tuple[cat.Control, str]:\n\"\"\"Read the control and group title from the markdown file.\"\"\"\n    control = gens.generate_sample_model(cat.Control)\n    md_api = MarkdownAPI()\n    yaml_header, control_tree = md_api.processor.process_control_markdown(control_path)\n    control_titles = list(control_tree.get_all_headers_for_level(1))\n    if len(control_titles) == 0:\n        raise TrestleError(f'Control markdown: {control_path} contains no control title.')\n    if len(control_titles) &gt; 1:\n        raise TrestleError(f'Control markdown: {control_path} contains multiple control titles {control_titles}.')\n\n    control.id = control_tree.subnodes[0].content.control_id\n    group_title = control_tree.subnodes[0].content.control_group\n    control.title = control_tree.subnodes[0].content.control_title\n\n    control_statement = control_tree.get_control_statement()\n    statement_part = control_statement.content.part\n\n    control.parts = [statement_part] if statement_part else None\n    control_objective = control_tree.get_control_objective()\n    if control_objective is not None:\n        objective_part = control_objective.content.part\n        if objective_part:\n            if control.parts:\n                control.parts.append(objective_part)\n            else:\n                control.parts = [objective_part]\n\n    control_guidance = control_tree.get_control_guidance()\n    if control_guidance is not None:\n        guidance_part = control_guidance.content.part\n        if guidance_part:\n            if control.parts:\n                control.parts.append(guidance_part)\n            else:\n                control.parts = [guidance_part]\n\n    all_other_parts = []\n    for section_node in control_tree.get_other_control_parts():\n        parts = section_node.content.part\n        all_other_parts.extend([parts])\n    if all_other_parts:\n        if control.parts:\n            control.parts.extend(all_other_parts)\n        else:\n            control.parts = all_other_parts\n\n    if set_parameters_flag:\n        params: Dict[str, str] = yaml_header.get(const.SET_PARAMS_TAG, [])\n        if params:\n            control.params = []\n            for id_, param_dict in params.items():\n                param_dict['id'] = id_\n                param = ModelUtils.dict_to_parameter(param_dict)\n                # if display_name is in list of properties, set its namespace\n                ControlReader._update_display_prop_namespace(param)\n                control.params.append(param)\n    sort_id = deep_get(yaml_header, [const.TRESTLE_GLOBAL_TAG, const.SORT_ID], None)\n    if sort_id:\n        control.props = control.props if control.props else []\n        control.props.append(common.Property(name=const.SORT_ID, value=sort_id))\n    return control, group_title\n</code></pre>"},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader.ControlReader.read_control_info_from_md","title":"<code>read_control_info_from_md(control_file, context)</code>  <code>staticmethod</code>","text":"<p>Find all labels and associated implementation prose in the markdown for this control.</p> <p>Parameters:</p> Name Type Description Default <code>control_file</code> <code>Path</code> <p>path to the control markdown file</p> required <code>context</code> <code>ControlContext</code> <p>context of the control usage</p> required <p>Returns:</p> Type Description <code>Tuple[Dict[str, List[str]], Dict[str, Dict[str, trestle.core.control_interface.ComponentImpInfo]]]</code> <p>The yaml header as dict in second part of tuple. Adds to the passed in comp_dict.</p> Source code in <code>trestle/core/control_reader.py</code> <pre><code>@staticmethod\ndef read_control_info_from_md(control_file: pathlib.Path,\n                              context: ControlContext) -&gt; Tuple[Dict[str, List[str]], CompDict]:\n\"\"\"\n    Find all labels and associated implementation prose in the markdown for this control.\n\n    Args:\n        control_file: path to the control markdown file\n        context: context of the control usage\n\n    Returns:\n        The yaml header as dict in second part of tuple.\n        Adds to the passed in comp_dict.\n    \"\"\"\n    yaml_header = {}\n    comp_dict = {}\n\n    if not control_file.exists():\n        return yaml_header, comp_dict\n    # if the file exists, load the contents but do not use prose from comp_dict\n    # for non ssp or component mode just use empty string for comp\n    comp_name = ''\n    try:\n        control_id = control_file.stem\n        if context.purpose == ContextPurpose.COMPONENT:\n            comp_name = context.comp_name if context.comp_name else const.SSP_MAIN_COMP_NAME\n\n        md_api = MarkdownAPI()\n        yaml_header, control_md = md_api.processor.process_markdown(control_file)\n\n        # first get the header strings, including statement labels, for statement imp reqs\n        imp_string = '## Implementation '\n        headers = control_md.get_all_headers_for_level(2)\n        # get e.g. ## Implementation a.  ## Implementation b. etc\n        imp_header_list = [header for header in headers if header.startswith(imp_string)]\n\n        # now get the (one) header for the main solution\n        main_headers = list(control_md.get_all_headers_for_key(const.SSP_MD_IMPLEMENTATION_QUESTION, False))\n        # should be only one header, so warn if others found\n        if main_headers:\n            if len(main_headers) &gt; 1:\n                logger.warning(\n                    f'Control {control_id} has {len(main_headers)} main header responses.  Will use first one only.'\n                )\n            main_header = main_headers[0]\n            node = control_md.get_all_nodes_for_keys([main_header], False)[0]\n            # this node is top level so it will have empty label\n            # it may have subnodes of Rules, Implementation Status, Implementaton Remarks\n            ControlReader._add_node_to_dict(comp_name, '', comp_dict, node, control_id, [], context)\n        for imp_header in imp_header_list:\n            label = ControlReader._get_label_from_implementation_header(imp_header)\n            node = control_md.get_node_for_key(imp_header)\n            ControlReader._add_node_to_dict(comp_name, label, comp_dict, node, control_id, [], context)\n\n    except TrestleError as e:\n        raise TrestleError(f'Error occurred reading {control_file}: {e}')\n    return yaml_header, comp_dict\n</code></pre>"},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader.ControlReader.read_editable_content","title":"<code>read_editable_content(control_path, required_sections_list, part_label_to_id_map, cli_section_dict, write_mode)</code>  <code>staticmethod</code>","text":"<p>Get parts for the markdown control corresponding to Editable Content - along with the set-parameter dict.</p> Source code in <code>trestle/core/control_reader.py</code> <pre><code>@staticmethod\ndef read_editable_content(\n    control_path: pathlib.Path,\n    required_sections_list: List[str],\n    part_label_to_id_map: Dict[str, Dict[str, str]],\n    cli_section_dict: Dict[str, str],\n    write_mode: bool\n) -&gt; Tuple[str, List[prof.Alter], Dict[str, Any]]:\n\"\"\"Get parts for the markdown control corresponding to Editable Content - along with the set-parameter dict.\"\"\"\n    control_id = control_path.stem\n\n    md_api = MarkdownAPI()\n    yaml_header, control_tree = md_api.processor.process_control_markdown(control_path, cli_section_dict, part_label_to_id_map)  # noqa: E501\n    # extract the sort_id if present in header\n    sort_id = yaml_header.get(const.SORT_ID, control_id)\n\n    editable_node = None\n    for header in list(control_tree.get_all_headers_for_level(1)):\n        if header.startswith('# Editable'):\n            editable_node = control_tree.get_node_for_key(header)\n            break\n    if not editable_node:\n        return sort_id, [], {}\n\n    editable_parts = control_tree.get_editable_parts_and_subparts()\n    by_id_parts = control_tree.get_by_id_parts()\n    found_sections = [p.name for p in editable_parts]\n\n    # Validate that all required sections have a prose\n    for editable_part in editable_parts:\n        if not write_mode and editable_part.name in required_sections_list and editable_part.prose.startswith(\n                const.PROFILE_ADD_REQUIRED_SECTION_FOR_CONTROL_TEXT):\n            raise TrestleError(f'Control {control_id} is missing prose for required section {editable_part.title}')\n\n    # Validate that all required sections are present\n    missing_sections = set(required_sections_list) - set(found_sections)\n    if missing_sections:\n        raise TrestleError(f'Control {control_id} is missing required sections {missing_sections}')\n    param_dict: Dict[str, Any] = {}\n    # get set_params from the header and add to parm_dict\n    header_params = yaml_header.get(const.SET_PARAMS_TAG, {})\n    if header_params:\n        param_dict.update(header_params)\n\n    props, props_by_id = ControlReader._get_props_list(control_id, part_label_to_id_map, yaml_header)\n\n    # When adding props without by_id it can either be starting or ending and we default to ending\n    # This is the default behavior as described for implicit binding in\n    # https://pages.nist.gov/OSCAL/concepts/processing/profile-resolution/\n    # When adding props to a part using by_id, it is the same situation because it cannot be before or after since\n    # props are not in the same list as parts\n\n    adds: List[prof.Add] = []\n\n    # add the parts and props at control level\n    if editable_parts or props:\n        adds.append(\n            prof.Add(\n                parts=none_if_empty(editable_parts), props=none_if_empty(props), position=prof.Position.ending\n            )\n        )\n\n    # add the parts and props at the part level, by-id\n    by_ids = set(by_id_parts.keys()).union(props_by_id.keys())\n    for by_id in sorted(by_ids):\n        parts = by_id_parts.get(by_id, None)\n        props = props_by_id.get(by_id, None)\n        adds.append(prof.Add(parts=parts, props=props, position=prof.Position.ending, by_id=by_id))\n\n    new_alters = []\n    if adds:\n        new_alters = [prof.Alter(control_id=control_id, adds=adds)]\n    return sort_id, new_alters, param_dict\n</code></pre>"},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader.ControlReader.read_implemented_requirement","title":"<code>read_implemented_requirement(control_file, context)</code>  <code>staticmethod</code>","text":"<p>Get the implementated requirement associated with given control and link to existing components or new ones.</p> <p>Parameters:</p> Name Type Description Default <code>control_file</code> <code>Path</code> <p>path of the control markdown file</p> required <code>context</code> <code>ControlContext</code> <p>context of the control usage</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>The control sort-id and the one implemented requirement for this control.</p> <p>Notes</p> <p>Each statement may have several responses, with each response in a by_component for a specific component. statement_map keeps track of statements that may have several by_component responses. This is only used during component assemble and only for updating one component.</p> Source code in <code>trestle/core/control_reader.py</code> <pre><code>@staticmethod\ndef read_implemented_requirement(control_file: pathlib.Path,\n                                 context: ControlContext) -&gt; Tuple[str, comp.ImplementedRequirement]:\n\"\"\"\n    Get the implementated requirement associated with given control and link to existing components or new ones.\n\n    Args:\n        control_file: path of the control markdown file\n        context: context of the control usage\n\n    Returns:\n        Tuple: The control sort-id and the one implemented requirement for this control.\n\n    Notes:\n        Each statement may have several responses, with each response in a by_component for a specific component.\n        statement_map keeps track of statements that may have several by_component responses.\n        This is only used during component assemble and only for updating one component.\n    \"\"\"\n    control_id = control_file.stem\n    md_header, md_comp_dict = ControlReader.read_control_info_from_md(control_file, context)\n    comp_name = context.component.title\n\n    statement_map: Dict[str, comp.Statement] = {}\n    # create a new implemented requirement linked to the control id to hold the statements\n    imp_req = gens.generate_sample_model(comp.ImplementedRequirement)\n    imp_req.control_id = control_id\n\n    imp_req.statements = []\n    comp_dict = md_comp_dict[comp_name]\n    for label, comp_info in comp_dict.items():\n        # only assemble responses with associated rules\n        if not comp_info.rules:\n            continue\n        # if no label it applies to the imp_req itself rather than a statement\n        if not label:\n            imp_req.description = ControlReader._handle_empty_prose(comp_info.prose, control_id)\n            ControlInterface.insert_status_in_props(imp_req, comp_info.status)\n            continue\n        statement_id = ControlInterface.create_statement_id(control_id)\n        if label in ['', const.STATEMENT]:\n            statement_part_id = statement_id\n        else:\n            clean_label = label.strip('.')\n            statement_part_id = ControlInterface.strip_to_make_ncname(f'{statement_id}.{clean_label}')\n        if statement_part_id in statement_map:\n            statement = statement_map[statement_part_id]\n        else:\n            statement = gens.generate_sample_model(comp.Statement)\n            statement.statement_id = statement_part_id\n            statement_map[statement_part_id] = statement\n        statement.description = comp_info.prose\n        statement.props = none_if_empty(ControlInterface.clean_props(comp_info.props))\n        ControlInterface.insert_status_in_props(statement, comp_info.status)\n\n    imp_req.statements = list(statement_map.values())\n    imp_req.set_parameters = []\n\n    for _, param_dict_list in md_header.get(const.COMP_DEF_RULES_PARAM_VALS_TAG, {}).items():\n        for param_dict in param_dict_list:\n            values = param_dict.get(const.VALUES, [])\n            comp_values = param_dict.get(const.COMPONENT_VALUES, [])\n            values = comp_values if comp_values else values\n            set_param = ossp.SetParameter(param_id=param_dict['name'], values=values)\n            imp_req.set_parameters.append(set_param)\n    imp_req.statements = none_if_empty(list(statement_map.values()))\n    imp_req.set_parameters = none_if_empty(imp_req.set_parameters)\n\n    ControlReader._insert_header_content(imp_req, md_header, control_id)\n    sort_id = md_header.get(const.SORT_ID, control_id)\n    return sort_id, imp_req\n</code></pre>"},{"location":"api_reference/trestle.core.control_reader/#trestle.core.control_reader.ControlReader.simplify_name","title":"<code>simplify_name(name)</code>  <code>staticmethod</code>","text":"<p>Simplify the name to ignore variations in case, space, hyphen, underscore, slash.</p> Source code in <code>trestle/core/control_reader.py</code> <pre><code>@staticmethod\ndef simplify_name(name: str) -&gt; str:\n\"\"\"Simplify the name to ignore variations in case, space, hyphen, underscore, slash.\"\"\"\n    return name.lower().replace(' ', '').replace('-', '').replace('_', '').replace('/', '')\n</code></pre>"},{"location":"api_reference/trestle.core.control_writer/","title":"control_writer","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.control_writer/#trestle.core.control_writer","title":"<code>trestle.core.control_writer</code>","text":"<p>Handle writing of controls to markdown.</p>"},{"location":"api_reference/trestle.core.control_writer/#trestle.core.control_writer.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.control_writer/#trestle.core.control_writer-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.control_writer/#trestle.core.control_writer.ControlWriter","title":"<code> ControlWriter        </code>","text":"<p>Class to write controls as markdown.</p> Source code in <code>trestle/core/control_writer.py</code> <pre><code>class ControlWriter():\n\"\"\"Class to write controls as markdown.\"\"\"\n\n    def __init__(self):\n\"\"\"Initialize the class.\"\"\"\n        self._md_file: Optional[MDWriter] = None\n\n    def _add_part_and_its_items(self, control: cat.Control, name: str, item_type: str) -&gt; None:\n\"\"\"For a given control add its one statement and its items to the md file after replacing params.\"\"\"\n        items = []\n        if control.parts:\n            for part in control.parts:\n                if part.name == name:\n                    # If the part has prose write it as a raw line and not list element\n                    skip_id = part.id\n                    if part.prose:\n                        self._md_file.new_line(part.prose)\n                    items.append(ControlInterface.get_part(part, item_type, skip_id))\n            # unwrap the list if it is many levels deep\n            while not isinstance(items, str) and len(items) == 1:\n                items = items[0]\n            self._md_file.new_paragraph()\n            self._md_file.new_list(items)\n\n    def _add_yaml_header(self, yaml_header: Optional[Dict]) -&gt; None:\n        if yaml_header:\n            self._md_file.add_yaml_header(yaml_header)\n\n    def _add_control_statement(self, control: cat.Control, group_title: str, print_group_title=True) -&gt; None:\n\"\"\"Add the control statement and items to the md file.\"\"\"\n        self._md_file.new_paragraph()\n        control_id = control.id\n        group_name = ''\n        control_title = control.title\n\n        if print_group_title:\n            group_name = ' \\[' + group_title + '\\]'\n\n        title = f'{control_id} -{group_name} {control_title}'\n\n        header_title = 'Control Statement'\n        self._md_file.new_header(level=1, title=title)\n        self._md_file.new_header(level=2, title=header_title)\n        self._md_file.set_indent_level(-1)\n        self._add_part_and_its_items(control, const.STATEMENT, 'item')\n        self._md_file.set_indent_level(-1)\n\n    def _add_control_objective(self, control: cat.Control) -&gt; None:\n        if control.parts:\n            for part in control.parts:\n                if part.name == 'objective':\n                    self._md_file.new_paragraph()\n                    heading_title = 'Control Objective'\n                    self._md_file.new_header(level=2, title=heading_title)\n                    self._md_file.set_indent_level(-1)\n                    self._add_part_and_its_items(control, 'objective', 'objective')\n                    self._md_file.set_indent_level(-1)\n                    return\n\n    def _add_sections(self, control: cat.Control, allowed_sections: Optional[List[str]]) -&gt; None:\n\"\"\"Add the extra control sections after the main ones.\"\"\"\n        skip_section_list = [const.STATEMENT, 'item', 'objective']\n        while True:\n            _, name, title, prose = ControlInterface.get_section(control, skip_section_list)\n            if not name:\n                return\n            if allowed_sections and name not in allowed_sections:\n                skip_section_list.append(name)\n                continue\n            if prose:\n                # section title will be from the section_dict, the part title, or the part name in that order\n                # this way the user-provided section title can override the part title\n                section_title = self._sections_dict.get(name, title) if self._sections_dict else title\n                section_title = section_title if section_title else name\n                skip_section_list.append(name)\n                self._md_file.new_header(level=2, title=f'Control {section_title}')\n                self._md_file.new_line(prose)\n                self._md_file.new_paragraph()\n\n    def _insert_status(self, status: ImplementationStatus, level: int) -&gt; None:\n        self._md_file.new_header(level=level, title=f'{const.IMPLEMENTATION_STATUS_HEADER}: {status.state}')\n        # this used to output remarks also\n\n    def _insert_rules(self, rules: List[str], level: int) -&gt; None:\n        if rules:\n            self._md_file.new_header(level=level, title='Rules:')\n            self._md_file.set_indent_level(0)\n            self._md_file.new_list(rules)\n            self._md_file.set_indent_level(-1)\n\n    def _insert_comp_info(\n        self, part_label: str, comp_info: Dict[str, ComponentImpInfo], context: ControlContext\n    ) -&gt; None:\n\"\"\"Insert prose and status from the component info.\"\"\"\n        level = 3 if context.purpose == ContextPurpose.COMPONENT else 4\n        if part_label in comp_info:\n            info = comp_info[part_label]\n            if context.purpose in [ContextPurpose.COMPONENT, ContextPurpose.SSP] and not info.rules:\n                return\n            self._md_file.new_paragraph()\n            if info.prose:\n                self._md_file.new_line(info.prose)\n            else:\n                self._md_file.new_line(f'{const.SSP_ADD_IMPLEMENTATION_FOR_ITEM_TEXT} {part_label} --&gt;')\n\n            self._insert_rules(info.rules, level)\n            self._insert_status(info.status, level)\n        else:\n            self._insert_status(ImplementationStatus(state=const.STATUS_PLANNED), level)\n\n    def _add_component_control_prompts(self, control_id: str, comp_dict: CompDict, context: ControlContext) -&gt; bool:\n\"\"\"Add prompts to the markdown for the control itself, per component.\"\"\"\n        if context.purpose not in [ContextPurpose.COMPONENT, ContextPurpose.SSP]:\n            return False\n        self._md_file.new_paraline(const.STATUS_PROMPT)\n        self._md_file.new_paraline(const.RULES_WARNING)\n        did_write = False\n        # do special handling for This System\n        if context.purpose == ContextPurpose.SSP:\n            self._md_file.new_paragraph()\n            self._md_file.new_header(3, const.SSP_MAIN_COMP_NAME)\n            self._md_file.new_paragraph()\n            prose = f'{const.SSP_ADD_THIS_SYSTEM_IMPLEMENTATION_FOR_CONTROL_TEXT}: {control_id} --&gt;'\n            status = ImplementationStatus(state=const.STATUS_PLANNED)\n            if const.SSP_MAIN_COMP_NAME in comp_dict:\n                comp_info = list(comp_dict[const.SSP_MAIN_COMP_NAME].values())[0]\n                if comp_info.prose:\n                    prose = comp_info.prose\n                status = comp_info.status\n            self._md_file.new_paraline(prose)\n            self._insert_status(status, 4)\n            did_write = True\n        sorted_comp_names = sorted(comp_dict.keys())\n        for comp_name in sorted_comp_names:\n            dic = comp_dict[comp_name]\n            # This System already handled\n            if comp_name == const.SSP_MAIN_COMP_NAME:\n                continue\n            for comp_info in [val for key, val in dic.items() if key == '']:\n                # don't output component name for component markdown since only one component\n                if context.purpose != ContextPurpose.COMPONENT:\n                    self._md_file.new_header(3, comp_name)\n                prose = comp_info.prose if comp_info.prose != control_id else ''\n                if not prose:\n                    prose = f'{const.SSP_ADD_IMPLEMENTATION_FOR_CONTROL_TEXT}: {control_id} --&gt;'\n                self._md_file.new_paraline(prose)\n                level = 3 if context.purpose == ContextPurpose.COMPONENT else 4\n                self._insert_rules(comp_info.rules, level)\n                self._insert_status(comp_info.status, level)\n                did_write = True\n        return did_write\n\n    def _add_implementation_response_prompts(\n        self, control: cat.Control, comp_dict: CompDict, context: ControlContext\n    ) -&gt; None:\n\"\"\"Add the response request text for all parts to the markdown along with the header.\"\"\"\n        self._md_file.new_hr()\n        self._md_file.new_paragraph()\n        # top level request for implementation details\n        self._md_file.new_header(level=2, title=f'{const.SSP_MD_IMPLEMENTATION_QUESTION}')\n\n        # write out control level prose and status\n        did_write_part = self._add_component_control_prompts(control.id, comp_dict, context)\n\n        # if the control has no parts written out then enter implementation in the top level entry\n        # but if it does have parts written out, leave top level blank and provide details in the parts\n        # Note that parts corresponding to sections don't get written out here so a check is needed\n        # If we have responses per component then enter them in separate ### sections\n        if control.parts:\n            for part in control.parts:\n                if part.parts and part.name == const.STATEMENT:\n                    for prt in part.parts:\n                        if prt.name != 'item':\n                            continue\n                        # if no label guess the label from the sub-part id\n                        part_label = ControlInterface.get_label(prt)\n                        part_label = prt.id.split('.')[-1] if not part_label else part_label\n                        # only write out part if rules apply to it\n                        rules_apply = False\n                        for _, dic in comp_dict.items():\n                            if part_label in dic and dic[part_label].rules:\n                                rules_apply = True\n                                break\n                        if not rules_apply:\n                            continue\n                        if not did_write_part:\n                            self._md_file.new_line(const.SSP_MD_LEAVE_BLANK_TEXT)\n                            # insert extra line to make mdformat happy\n                            self._md_file._add_line_raw('')\n                        self._md_file.new_hr()\n                        self._md_file.new_header(level=2, title=f'Implementation for part {part_label}')\n                        wrote_label_content = False\n                        sorted_comp_names = sorted(comp_dict.keys())\n                        for comp_name in sorted_comp_names:\n                            dic = comp_dict[comp_name]\n                            if comp_name == const.SSP_MAIN_COMP_NAME:\n                                continue\n                            if part_label in dic:\n                                # insert the component name for ssp but not for comp_def\n                                # because there should only be one component in generated comp_def markdown\n                                if context.purpose != ContextPurpose.COMPONENT:\n                                    self._md_file.new_header(level=3, title=comp_name)\n                                self._insert_comp_info(part_label, dic, context)\n                                wrote_label_content = True\n                        if not wrote_label_content:\n                            level = 3 if context.purpose == ContextPurpose.COMPONENT else 4\n                            self._insert_status(ImplementationStatus(state=const.STATUS_PLANNED), level)\n                        self._md_file.new_paragraph()\n                        did_write_part = True\n        # if we loaded nothing for this control yet then it must need a fresh prompt for the control statement\n        if not comp_dict and not did_write_part:\n            self._md_file.new_line(f'{const.SSP_ADD_IMPLEMENTATION_FOR_CONTROL_TEXT}: {control.id} --&gt;')\n            if context.purpose in [ContextPurpose.COMPONENT, ContextPurpose.SSP]:\n                status = ControlInterface.get_status_from_props(control)\n                self._insert_status(status, 3)\n        if not did_write_part:\n            part_label = ''\n            for comp_name, dic in comp_dict.items():\n                if part_label in dic:\n                    if comp_name != const.SSP_MAIN_COMP_NAME:\n                        self._md_file.new_header(level=3, title=comp_name)\n                    self._insert_comp_info(part_label, dic, context)\n        self._md_file.new_hr()\n\n    def _dump_subpart_infos(self, level: int, part: Dict[str, Any]) -&gt; None:\n        name = part['name']\n        title = self._sections_dict.get(name, name) if self._sections_dict else name\n        self._md_file.new_header(level=level, title=title)\n        if 'prose' in part:\n            self._md_file.new_paraline(part['prose'])\n        for subpart in as_list(part.get('parts', None)):\n            self._dump_subpart_infos(level + 1, subpart)\n\n    def _dump_subparts(self, level: int, part: Part) -&gt; None:\n        name = part.name\n        title = self._sections_dict.get(name, name) if self._sections_dict else name\n        self._md_file.new_header(level=level, title=title)\n        if part.prose:\n            self._md_file.new_paraline(part.prose)\n        for subpart in as_list(part.parts):\n            self._dump_subparts(level + 1, subpart)\n\n    def _dump_section(self, level: int, part: Part, added_sections: List[str], prefix: str) -&gt; None:\n        title = self._sections_dict.get(part.name, part.name) if self._sections_dict else part.name\n        title = f'{prefix} {title}' if prefix else title\n        self._md_file.new_header(level=level, title=title)\n        if part.prose:\n            self._md_file.new_paraline(part.prose)\n        for subpart in as_list(part.parts):\n            self._dump_subparts(level + 1, subpart)\n        added_sections.append(part.name)\n\n    def _dump_section_info(self, level: int, part: Dict[str, Any], added_sections: List[str], prefix: str) -&gt; None:\n        part_prose = part.get('prose', None)\n        part_subparts = part.get('parts', None)\n        name = part['name']\n        title = self._sections_dict.get(name, name) if self._sections_dict else name\n        title = f'{prefix} {title}' if prefix else title\n        self._md_file.new_header(level=level, title=title)\n        if part_prose:\n            self._md_file.new_paraline(part_prose)\n        for subpart in as_list(part_subparts):\n            self._dump_subpart_infos(level + 1, subpart)\n        added_sections.append(name)\n\n    def _add_additional_content(\n        self,\n        control: cat.Control,\n        profile: prof.Profile,\n        header: Dict[str, Any],\n        part_id_map: Dict[str, str],\n        found_alters: List[prof.Alter]\n    ) -&gt; List[str]:\n        # get part and subpart info from adds of the profile\n        part_infos = ControlInterface.get_all_add_info(control.id, profile)\n        has_content = len(part_infos) &gt; 0\n\n        self._md_file.new_header(level=1, title=const.EDITABLE_CONTENT)\n        self._md_file.new_line('&lt;!-- Make additions and edits below --&gt;')\n        self._md_file.new_line(\n            '&lt;!-- The above represents the contents of the control as received by the profile, prior to additions. --&gt;'  # noqa E501\n        )\n        self._md_file.new_line(\n            '&lt;!-- If the profile makes additions to the control, they will appear below. --&gt;'  # noqa E501\n        )\n        self._md_file.new_line(\n            '&lt;!-- The above markdown may not be edited but you may edit the content below, and/or introduce new additions to be made by the profile. --&gt;'  # noqa E501\n        )\n        self._md_file.new_line(\n            '&lt;!-- If there is a yaml header at the top, parameter values may be edited. Use --set-parameters to incorporate the changes during assembly. --&gt;'  # noqa E501\n        )\n        self._md_file.new_line(\n            '&lt;!-- The content here will then replace what is in the profile for this control, after running profile-assemble. --&gt;'  # noqa E501\n        )\n        if has_content:\n            self._md_file.new_line(\n                '&lt;!-- The added parts in the profile for this control are below.  You may edit them and/or add new ones. --&gt;'  # noqa E501\n            )\n        else:\n            self._md_file.new_line(\n                '&lt;!-- The current profile has no added parts for this control, but you may add new ones here. --&gt;'\n            )\n        self._md_file.new_line(\n            '&lt;!-- Each addition must have a heading either of the form ## Control my_addition_name --&gt;'\n        )\n        self._md_file.new_line('&lt;!-- or ## Part a. (where the a. refers to one of the control statement labels.) --&gt;')\n        self._md_file.new_line('&lt;!-- \"## Control\" parts are new parts added after the statement part. --&gt;')\n        self._md_file.new_line(\n            '&lt;!-- \"## Part\" parts are new parts added into the top-level statement part with that label. --&gt;'\n        )\n        self._md_file.new_line('&lt;!-- Subparts may be added with nested hash levels of the form ### My Subpart Name --&gt;')\n        self._md_file.new_line('&lt;!-- underneath the parent ## Control or ## Part being added --&gt;')\n        self._md_file.new_line(\n            '&lt;!-- See https://ibm.github.io/compliance-trestle/tutorials/ssp_profile_catalog_authoring/ssp_profile_catalog_authoring for guidance. --&gt;'  # noqa E501\n        )\n        # next is to make mdformat happy\n        self._md_file._add_line_raw('')\n\n        added_sections: List[str] = []\n\n        control_part_id_map = part_id_map.get(control.id, {})\n        statement_id = ControlInterface.get_statement_id(control)\n\n        # if the file already has markdown content, read its alters\n        if self._md_file.exists():\n            if const.TRESTLE_ADD_PROPS_TAG in header:\n                header.pop(const.TRESTLE_ADD_PROPS_TAG)\n            for alter in found_alters:\n                for add in as_list(alter.adds):\n                    # by_id could refer to statement (Control) or part (Part)\n                    if add.by_id:\n                        # is this a part that goes after the control statement\n                        if add.by_id == statement_id:\n                            for part in as_list(add.parts):\n                                if part.prose or part.parts:\n                                    self._dump_section(2, part, added_sections, 'Control')\n                        else:\n                            # or is it a sub-part of a statement part\n                            part_label = control_part_id_map.get(add.by_id, add.by_id)\n                            if add.parts:\n                                self._md_file.new_header(level=2, title=f'Part {part_label}')\n                                for part in as_list(add.parts):\n                                    if part.prose or part.parts:\n                                        name = part.name\n                                        # need special handling for statement parts because their name is 'item'\n                                        # get the short name as last piece of the part id after the '.'\n                                        if name == 'item':\n                                            name = part.id.split('.')[-1]\n                                        title = self._sections_dict.get(name, name) if self._sections_dict else name\n                                        self._md_file.new_header(level=3, title=title)\n                                        if part.prose:\n                                            self._md_file.new_paraline(part.prose)\n                                        for subpart in as_list(part.parts):\n                                            self._dump_subparts(3, subpart)\n                                        added_sections.append(name)\n                    else:\n                        # if not by_id just add at end of control's parts\n                        for part in as_list(add.parts):\n                            if part.prose or part.parts:\n                                self._dump_section(2, part, added_sections, 'Control')\n                    if add.props:\n                        if const.TRESTLE_ADD_PROPS_TAG not in header:\n                            header[const.TRESTLE_ADD_PROPS_TAG] = []\n                        by_id = add.by_id\n                        part_info = PartInfo(name='', prose='', props=add.props, smt_part=by_id)\n                        _, prop_list = part_info.to_dicts(part_id_map.get(control.id, {}))\n                        header[const.TRESTLE_ADD_PROPS_TAG].extend(prop_list)\n        else:\n            # md does not already exist so fill in directly\n            in_part = ''\n            for part_info in part_infos:\n                part, prop_list = part_info.to_dicts(part_id_map.get(control.id, {}))\n                # is this part of a statement part\n                if part_info.smt_part and part_info.prose and part_info.smt_part in control_part_id_map:\n                    # avoid outputting ## Part again if in same part\n                    if not part_info.smt_part == in_part:\n                        in_part = part_info.smt_part\n                        part_label = control_part_id_map.get(part_info.smt_part, part_info.smt_part)\n                        self._md_file.new_header(level=2, title=f'Part {part_label}')\n                    self._dump_section_info(3, part, added_sections, '')\n                # is it a control part\n                elif part_info.prose or part_info.parts:\n                    in_part = ''\n                    self._dump_section_info(2, part, added_sections, 'Control')\n                elif prop_list:\n                    in_part = ''\n                    if const.TRESTLE_ADD_PROPS_TAG not in header:\n                        header[const.TRESTLE_ADD_PROPS_TAG] = []\n                    header[const.TRESTLE_ADD_PROPS_TAG].extend(prop_list)\n        return added_sections\n\n    def _prompt_required_sections(self, required_sections: List[str], added_sections: List[str]) -&gt; None:\n\"\"\"Add prompts for any required sections that haven't already been written out.\"\"\"\n        missing_sections = set(required_sections).difference(added_sections)\n        for section in sorted(missing_sections):\n            section_title = self._sections_dict.get(section, section)\n            self._md_file.new_header(2, f'Control {section_title}')\n            self._md_file.new_line(f'{const.PROFILE_ADD_REQUIRED_SECTION_FOR_CONTROL_TEXT}: {section_title} --&gt;')\n\n    @staticmethod\n    def _merge_headers(memory_header: Dict[str, Any], md_header: Dict[str, Any],\n                       context: ControlContext) -&gt; Dict[str, Any]:\n        merged_header = copy.deepcopy(md_header)\n        ControlInterface.merge_dicts_deep(merged_header, memory_header, False, 1)\n        return merged_header\n\n    def write_control_for_editing(\n        self,\n        context: ControlContext,\n        control: cat.Control,\n        dest_path: pathlib.Path,\n        group_title: str,\n        part_id_map: Dict[str, str],\n        found_alters: List[prof.Alter]\n    ) -&gt; None:\n\"\"\"\n        Write out the control in markdown format into the specified directory.\n\n        Args:\n            context: The context of the control usage\n            control: The control to write as markdown\n            dest_path: Path to the directory where the control will be written\n            group_title: Title of the group containing the control\n            part_id_map: Mapping of part_id to label\n            found_alters: List of alters read from the markdown file - if it exists\n\n        Returns:\n            None\n\n        Notes:\n            The filename is constructed from the control's id and created in the dest_path.\n            If a yaml header is present in the file, new values in provided header will not replace those in the\n            markdown header unless overwrite_header_values is true.  If it is true then overwrite any existing values,\n            but in all cases new items from the provided header will be added to the markdown header.\n            If the markdown file already exists, its current header and prose are read.\n            Controls are checked if they are marked withdrawn, and if so they are not written out.\n        \"\"\"\n        if ControlInterface.is_withdrawn(control):\n            logger.debug(f'Not writing out control {control.id} since it is marked Withdrawn.')\n            return\n\n        control_file = dest_path / (control.id + const.MARKDOWN_FILE_EXT)\n        # read the existing markdown header and content if it exists\n        md_header, comp_dict = ControlReader.read_control_info_from_md(control_file, context)\n        # replace the memory comp_dict with the md one if control exists\n        if comp_dict:\n            context.comp_dict = comp_dict\n\n        header_comment_dict = {const.TRESTLE_ADD_PROPS_TAG: const.YAML_PROPS_COMMENT}\n        if context.to_markdown:\n            if context.purpose == ContextPurpose.PROFILE:\n                header_comment_dict[const.SET_PARAMS_TAG] = const.YAML_PROFILE_VALUES_COMMENT\n            elif context.purpose == ContextPurpose.SSP:\n                header_comment_dict[const.SET_PARAMS_TAG] = const.YAML_SSP_VALUES_COMMENT\n                header_comment_dict[const.COMP_DEF_RULES_PARAM_VALS_TAG] = const.YAML_RULE_PARAM_VALUES_SSP_COMMENT\n            elif context.purpose == ContextPurpose.COMPONENT:\n                header_comment_dict[const.COMP_DEF_RULES_PARAM_VALS_TAG\n                                    ] = const.YAML_RULE_PARAM_VALUES_COMPONENT_COMMENT\n\n        # begin adding info to the md file\n        self._md_file = MDWriter(control_file, header_comment_dict)\n        self._sections_dict = context.sections_dict\n\n        context.merged_header = ControlWriter._merge_headers(context.merged_header, md_header, context)\n        # if the control has an explicitly defined sort-id and there is none in the yaml_header, then insert it\n        # in the yaml header and allow overwrite_header_values to control whether it overwrites an existing one\n        # in the markdown header\n        context.cli_yaml_header = as_dict(context.cli_yaml_header)\n        if context.purpose != ContextPurpose.PROFILE:\n            ControlInterface.merge_dicts_deep(\n                context.merged_header, context.cli_yaml_header, context.overwrite_header_values\n            )\n        # the global contents are special and get overwritten on generate\n        set_or_pop(\n            context.merged_header,\n            const.TRESTLE_GLOBAL_TAG,\n            context.cli_yaml_header.get(const.TRESTLE_GLOBAL_TAG, None)\n        )\n        sort_id = ControlInterface.get_sort_id(control, True)\n        if sort_id:\n            deep_set(context.merged_header, [const.TRESTLE_GLOBAL_TAG, const.SORT_ID], sort_id)\n\n        # merge any provided sections with sections in the header, with priority to the one from context (e.g. CLI)\n        header_sections_dict = context.merged_header.get(const.SECTIONS_TAG, {})\n        merged_sections_dict = merge_dicts(header_sections_dict, context.sections_dict)\n        set_or_pop(context.merged_header, const.SECTIONS_TAG, merged_sections_dict)\n\n        # now begin filling in content from the control in memory\n        self._add_control_statement(control, group_title)\n\n        self._add_control_objective(control)\n\n        # add allowed sections to the markdown\n        self._add_sections(control, context.allowed_sections)\n\n        # prompt responses for imp reqs using special format if comp_def mode\n        if context.prompt_responses:\n            self._add_implementation_response_prompts(control, context.comp_dict, context)\n\n        # for profile generate\n        # add sections corresponding to added parts in the profile\n        added_sections: List[str] = []\n        if context.purpose == ContextPurpose.PROFILE:\n            added_sections = self._add_additional_content(\n                control, context.profile, context.merged_header, part_id_map, found_alters\n            )\n\n        self._add_yaml_header(context.merged_header)\n\n        if context.required_sections:\n            self._prompt_required_sections(context.required_sections, added_sections)\n\n        self._md_file.write_out()\n</code></pre>"},{"location":"api_reference/trestle.core.control_writer/#trestle.core.control_writer.ControlWriter-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.control_writer/#trestle.core.control_writer.ControlWriter.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize the class.</p> Source code in <code>trestle/core/control_writer.py</code> <pre><code>def __init__(self):\n\"\"\"Initialize the class.\"\"\"\n    self._md_file: Optional[MDWriter] = None\n</code></pre>"},{"location":"api_reference/trestle.core.control_writer/#trestle.core.control_writer.ControlWriter.write_control_for_editing","title":"<code>write_control_for_editing(self, context, control, dest_path, group_title, part_id_map, found_alters)</code>","text":"<p>Write out the control in markdown format into the specified directory.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ControlContext</code> <p>The context of the control usage</p> required <code>control</code> <code>Control</code> <p>The control to write as markdown</p> required <code>dest_path</code> <code>Path</code> <p>Path to the directory where the control will be written</p> required <code>group_title</code> <code>str</code> <p>Title of the group containing the control</p> required <code>part_id_map</code> <code>Dict[str, str]</code> <p>Mapping of part_id to label</p> required <code>found_alters</code> <code>List[trestle.oscal.profile.Alter]</code> <p>List of alters read from the markdown file - if it exists</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Notes</p> <p>The filename is constructed from the control's id and created in the dest_path. If a yaml header is present in the file, new values in provided header will not replace those in the markdown header unless overwrite_header_values is true.  If it is true then overwrite any existing values, but in all cases new items from the provided header will be added to the markdown header. If the markdown file already exists, its current header and prose are read. Controls are checked if they are marked withdrawn, and if so they are not written out.</p> Source code in <code>trestle/core/control_writer.py</code> <pre><code>def write_control_for_editing(\n    self,\n    context: ControlContext,\n    control: cat.Control,\n    dest_path: pathlib.Path,\n    group_title: str,\n    part_id_map: Dict[str, str],\n    found_alters: List[prof.Alter]\n) -&gt; None:\n\"\"\"\n    Write out the control in markdown format into the specified directory.\n\n    Args:\n        context: The context of the control usage\n        control: The control to write as markdown\n        dest_path: Path to the directory where the control will be written\n        group_title: Title of the group containing the control\n        part_id_map: Mapping of part_id to label\n        found_alters: List of alters read from the markdown file - if it exists\n\n    Returns:\n        None\n\n    Notes:\n        The filename is constructed from the control's id and created in the dest_path.\n        If a yaml header is present in the file, new values in provided header will not replace those in the\n        markdown header unless overwrite_header_values is true.  If it is true then overwrite any existing values,\n        but in all cases new items from the provided header will be added to the markdown header.\n        If the markdown file already exists, its current header and prose are read.\n        Controls are checked if they are marked withdrawn, and if so they are not written out.\n    \"\"\"\n    if ControlInterface.is_withdrawn(control):\n        logger.debug(f'Not writing out control {control.id} since it is marked Withdrawn.')\n        return\n\n    control_file = dest_path / (control.id + const.MARKDOWN_FILE_EXT)\n    # read the existing markdown header and content if it exists\n    md_header, comp_dict = ControlReader.read_control_info_from_md(control_file, context)\n    # replace the memory comp_dict with the md one if control exists\n    if comp_dict:\n        context.comp_dict = comp_dict\n\n    header_comment_dict = {const.TRESTLE_ADD_PROPS_TAG: const.YAML_PROPS_COMMENT}\n    if context.to_markdown:\n        if context.purpose == ContextPurpose.PROFILE:\n            header_comment_dict[const.SET_PARAMS_TAG] = const.YAML_PROFILE_VALUES_COMMENT\n        elif context.purpose == ContextPurpose.SSP:\n            header_comment_dict[const.SET_PARAMS_TAG] = const.YAML_SSP_VALUES_COMMENT\n            header_comment_dict[const.COMP_DEF_RULES_PARAM_VALS_TAG] = const.YAML_RULE_PARAM_VALUES_SSP_COMMENT\n        elif context.purpose == ContextPurpose.COMPONENT:\n            header_comment_dict[const.COMP_DEF_RULES_PARAM_VALS_TAG\n                                ] = const.YAML_RULE_PARAM_VALUES_COMPONENT_COMMENT\n\n    # begin adding info to the md file\n    self._md_file = MDWriter(control_file, header_comment_dict)\n    self._sections_dict = context.sections_dict\n\n    context.merged_header = ControlWriter._merge_headers(context.merged_header, md_header, context)\n    # if the control has an explicitly defined sort-id and there is none in the yaml_header, then insert it\n    # in the yaml header and allow overwrite_header_values to control whether it overwrites an existing one\n    # in the markdown header\n    context.cli_yaml_header = as_dict(context.cli_yaml_header)\n    if context.purpose != ContextPurpose.PROFILE:\n        ControlInterface.merge_dicts_deep(\n            context.merged_header, context.cli_yaml_header, context.overwrite_header_values\n        )\n    # the global contents are special and get overwritten on generate\n    set_or_pop(\n        context.merged_header,\n        const.TRESTLE_GLOBAL_TAG,\n        context.cli_yaml_header.get(const.TRESTLE_GLOBAL_TAG, None)\n    )\n    sort_id = ControlInterface.get_sort_id(control, True)\n    if sort_id:\n        deep_set(context.merged_header, [const.TRESTLE_GLOBAL_TAG, const.SORT_ID], sort_id)\n\n    # merge any provided sections with sections in the header, with priority to the one from context (e.g. CLI)\n    header_sections_dict = context.merged_header.get(const.SECTIONS_TAG, {})\n    merged_sections_dict = merge_dicts(header_sections_dict, context.sections_dict)\n    set_or_pop(context.merged_header, const.SECTIONS_TAG, merged_sections_dict)\n\n    # now begin filling in content from the control in memory\n    self._add_control_statement(control, group_title)\n\n    self._add_control_objective(control)\n\n    # add allowed sections to the markdown\n    self._add_sections(control, context.allowed_sections)\n\n    # prompt responses for imp reqs using special format if comp_def mode\n    if context.prompt_responses:\n        self._add_implementation_response_prompts(control, context.comp_dict, context)\n\n    # for profile generate\n    # add sections corresponding to added parts in the profile\n    added_sections: List[str] = []\n    if context.purpose == ContextPurpose.PROFILE:\n        added_sections = self._add_additional_content(\n            control, context.profile, context.merged_header, part_id_map, found_alters\n        )\n\n    self._add_yaml_header(context.merged_header)\n\n    if context.required_sections:\n        self._prompt_required_sections(context.required_sections, added_sections)\n\n    self._md_file.write_out()\n</code></pre>"},{"location":"api_reference/trestle.core.docs_control_writer/","title":"docs_control_writer","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.docs_control_writer/#trestle.core.docs_control_writer","title":"<code>trestle.core.docs_control_writer</code>","text":"<p>Handle writing of controls to markdown for docs purposes.</p>"},{"location":"api_reference/trestle.core.docs_control_writer/#trestle.core.docs_control_writer.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.docs_control_writer/#trestle.core.docs_control_writer-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.docs_control_writer/#trestle.core.docs_control_writer.DocsControlWriter","title":"<code> DocsControlWriter            (ControlWriter)         </code>","text":"<p>Class to write controls as markdown for docs purposes.</p> Source code in <code>trestle/core/docs_control_writer.py</code> <pre><code>class DocsControlWriter(ControlWriter):\n\"\"\"Class to write controls as markdown for docs purposes.\"\"\"\n\n    def write_control_with_sections(\n        self,\n        control: cat.Control,\n        profile: prof.Profile,\n        group_title: str,\n        sections: List[str],\n        sections_dict: Optional[Dict[str, str]] = None,\n        label_column: bool = True,\n        add_group_to_title: bool = False\n    ) -&gt; str:\n\"\"\"Write the control into markdown file with specified sections.\"\"\"\n        self._md_file = MDWriter(None)\n        self._sections_dict = sections_dict if sections_dict else {}\n        tag_pattern = '{: #[.]}'  # noqa: FS003 - not f string but tag\n        if not isinstance(group_title, str):\n            raise TrestleError(f'Group title must be provided and be a string, instead received: {group_title}')\n\n        for section in sections:\n            if 'statement' == section:\n                self._add_control_statement(control, group_title, add_group_to_title, tag_pattern=tag_pattern)\n\n            elif const.OBJECTIVE_PART == section:\n                self._add_control_objective(control, tag_pattern=tag_pattern)\n\n            elif 'table_of_parameters' == section:\n                self.get_param_table(\n                    control, label_column, section_dict=sections_dict, tag_pattern=tag_pattern, md_file=self._md_file\n                )\n            else:\n                self._add_one_section(control, profile, section, tag_pattern=tag_pattern)\n\n        return '\\n'.join(self._md_file._lines)\n\n    def get_control_statement_ssp(self, control: cat.Control) -&gt; List[str]:\n\"\"\"Get the control statement as formatted markdown from a control formatted for SSP.\"\"\"\n        self._md_file = MDWriter(None)\n        self._add_control_statement_ssp(control)\n        return self._md_file.get_lines()\n\n    def get_param_table(\n        self,\n        control: cat.Control,\n        label_column: bool = False,\n        section_dict: Optional[Dict[str, str]] = None,\n        tag_pattern: str = None,\n        md_file: MDWriter = None\n    ) -&gt; List[str]:\n\"\"\"Get parameters of a control as a markdown table for ssp_io, with optional third label column.\"\"\"\n\n        def _get_displayname_if_exists(param_id: str) -&gt; str:\n            for param in as_filtered_list(control.params, lambda p: p.id == param_id):\n                for prop in as_filtered_list(param.props, lambda p: p.name == const.DISPLAY_NAME):\n                    return prop.value\n            return param_id\n\n        param_dict = ControlInterface.get_control_param_dict(control, False)\n\n        if param_dict:\n            if md_file:\n                self._md_file = md_file\n            else:\n                self._md_file = MDWriter(None)\n            header_title = 'Table of Parameters'\n            if section_dict:\n                header_title = section_dict.get(const.TABLE_OF_PARAMS_PART, 'Table of Parameters')\n            self._md_file.new_paragraph()\n            self._md_file.new_header(level=2, title=header_title, add_new_line_after_header=not tag_pattern)\n            if tag_pattern:\n                self._md_file.new_line(tag_pattern.replace('[.]', header_title.replace(' ', '-').lower()))\n                self._md_file.new_paragraph()\n            self._md_file.set_indent_level(-1)\n            if label_column:\n                self._md_file.new_table(\n                    [\n                        [\n                            _get_displayname_if_exists(key),\n                            ControlInterface.param_to_str(param_dict[key], ParameterRep.VALUE_OR_EMPTY_STRING),\n                            ControlInterface.param_to_str(param_dict[key], ParameterRep.LABEL_OR_CHOICES, True),\n                        ] for key in param_dict.keys()\n                    ], ['Parameter ID', 'Values', 'Label or Choices']\n                )\n            else:\n                self._md_file.new_table(\n                    [\n                        [\n                            _get_displayname_if_exists(key),\n                            ControlInterface.param_to_str(param_dict[key], ParameterRep.VALUE_OR_LABEL_OR_CHOICES)\n                        ] for key in param_dict.keys()\n                    ], ['Parameter ID', 'Values']\n                )\n            self._md_file.set_indent_level(-1)\n            if tag_pattern:\n                bottom_tag_pattern = '{: #\\\"Parameters for [.]\\\" caption-side=\\\"top\\\"}'  # noqa: FS003 - not f string\n                control_id = self._get_pretty_control_id_if_exists(control)\n                self._md_file.new_line(bottom_tag_pattern.replace('[.]', control_id))\n                self._md_file.new_paragraph()\n            return self._md_file.get_lines()\n\n        return []\n\n    def _add_control_statement(\n        self, control: cat.Control, group_title: str, print_group_title=True, tag_pattern: str = None\n    ) -&gt; None:\n\"\"\"Add the control statement and items to the md file.\"\"\"\n        self._md_file.new_paragraph()\n\n        group_name = ''\n        control_title = control.title\n\n        if print_group_title:\n            group_name = ' \\[' + group_title + '\\]'\n\n        control_id = self._get_pretty_control_id_if_exists(control)\n\n        title = f'{control_id} -{group_name} {control_title}'\n\n        header_title = self._sections_dict.get(const.STATEMENT, 'Control Statement')\n        self._md_file.new_header(level=1, title=title, add_new_line_after_header=not tag_pattern)\n        if tag_pattern:\n            self._md_file.new_line(tag_pattern.replace('[.]', control.id))\n            self._md_file.new_paragraph()\n\n        self._md_file.new_header(level=2, title=header_title, add_new_line_after_header=not tag_pattern)\n        if tag_pattern:\n            self._md_file.new_line(tag_pattern.replace('[.]', header_title.replace(' ', '-').lower()))\n            self._md_file.new_paragraph()\n\n        self._md_file.set_indent_level(-1)\n        self._add_part_and_its_items(control, 'statement', 'item')\n        self._md_file.set_indent_level(-1)\n\n    def _add_control_objective(self, control: cat.Control, tag_pattern: str = None) -&gt; None:\n        if control.parts:\n            for part in control.parts:\n                if part.name == const.OBJECTIVE_PART:\n                    self._md_file.new_paragraph()\n                    heading_title = self._sections_dict.get(const.OBJECTIVE_PART, 'Control Objective')\n                    self._md_file.new_header(level=2, title=heading_title, add_new_line_after_header=not tag_pattern)\n                    if tag_pattern:\n                        self._md_file.new_line(tag_pattern.replace('[.]', heading_title.replace(' ', '-').lower()))\n                        self._md_file.new_paragraph()\n                    self._md_file.set_indent_level(-1)\n                    self._add_part_and_its_items(control, const.OBJECTIVE_PART, const.OBJECTIVE_PART)\n                    self._md_file.set_indent_level(-1)\n                    return\n\n    def _add_one_section(\n        self, control: cat.Control, profile: prof.Profile, section: str, tag_pattern: Optional[str] = None\n    ) -&gt; None:\n\"\"\"Add specific control section.\"\"\"\n        prose = ControlInterface.get_control_section_prose(control, section)\n        if prose:\n            section_title = self._sections_dict.get(section, section)\n            heading_title = f'{section_title}'\n            self._md_file.new_header(level=2, title=heading_title, add_new_line_after_header=not tag_pattern)\n            if tag_pattern:\n                self._md_file.new_line(tag_pattern.replace('[.]', heading_title.replace(' ', '-').lower()))\n                self._md_file.new_paragraph()\n            self._md_file.new_line(prose)\n            self._md_file.new_paragraph()\n        else:\n            # write parts and subparts if exist\n            part_infos = ControlInterface.get_all_add_info(control.id, profile)\n            for part_info in part_infos:\n                if part_info.name == section:\n                    self._write_part_info(part_info, section, tag_pattern)\n                    break\n\n    def _write_part_info(\n        self,\n        part_info: PartInfo,\n        section_name: str,\n        tag_pattern: Optional[str] = None,\n        section_prefix: str = '',\n        heading_level: int = 2\n    ):\n        section_title = self._sections_dict.get(section_name, part_info.name)\n\n        heading_title = f'{section_title}'\n        tag_section_name = section_prefix + f'{section_title}'\n        tag_section_name = re.sub(const.MATCH_ALL_EXCEPT_LETTERS_UNDERSCORE_SPACE_REGEX, '', tag_section_name)\n        tag_section_name = tag_section_name.replace(' ', '-').replace('_', '-').lower()\n        self._md_file.new_header(level=heading_level, title=heading_title, add_new_line_after_header=not tag_pattern)\n        if tag_pattern:\n            self._md_file.new_line(tag_pattern.replace('[.]', tag_section_name))\n            self._md_file.new_paragraph()\n        self._md_file.new_line(part_info.prose)\n        self._md_file.new_paragraph()\n\n        for subpart_info in as_list(part_info.parts):\n            self._write_part_info(\n                subpart_info, subpart_info.name, tag_pattern, tag_section_name + '-', heading_level + 1\n            )\n\n    def _get_pretty_control_id_if_exists(self, control: cat.Control) -&gt; str:\n        control_id = control.id.upper()\n        if control.props:\n            # Take control id from the properties\n            for prop in control.props:\n                if prop.name == 'label':\n                    control_id = prop.value\n                    break\n        return control_id\n\n    def _add_control_statement_ssp(self, control: cat.Control) -&gt; None:\n\"\"\"Add the control statement and items to the markdown SSP.\"\"\"\n        self._md_file.new_paragraph()\n        label = ControlInterface.get_label(control)\n        label = label if label else control.id.upper()\n        title = f'{label} - {control.title}'\n        self._md_file.new_header(level=1, title=title)\n        self._md_file.new_header(level=2, title='Control Statement')\n        self._md_file.set_indent_level(-1)\n        self._add_part_and_its_items(control, 'statement', 'item')\n        self._md_file.set_indent_level(-1)\n</code></pre>"},{"location":"api_reference/trestle.core.docs_control_writer/#trestle.core.docs_control_writer.DocsControlWriter-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.docs_control_writer/#trestle.core.docs_control_writer.DocsControlWriter.get_control_statement_ssp","title":"<code>get_control_statement_ssp(self, control)</code>","text":"<p>Get the control statement as formatted markdown from a control formatted for SSP.</p> Source code in <code>trestle/core/docs_control_writer.py</code> <pre><code>def get_control_statement_ssp(self, control: cat.Control) -&gt; List[str]:\n\"\"\"Get the control statement as formatted markdown from a control formatted for SSP.\"\"\"\n    self._md_file = MDWriter(None)\n    self._add_control_statement_ssp(control)\n    return self._md_file.get_lines()\n</code></pre>"},{"location":"api_reference/trestle.core.docs_control_writer/#trestle.core.docs_control_writer.DocsControlWriter.get_param_table","title":"<code>get_param_table(self, control, label_column=False, section_dict=None, tag_pattern=None, md_file=None)</code>","text":"<p>Get parameters of a control as a markdown table for ssp_io, with optional third label column.</p> Source code in <code>trestle/core/docs_control_writer.py</code> <pre><code>def get_param_table(\n    self,\n    control: cat.Control,\n    label_column: bool = False,\n    section_dict: Optional[Dict[str, str]] = None,\n    tag_pattern: str = None,\n    md_file: MDWriter = None\n) -&gt; List[str]:\n\"\"\"Get parameters of a control as a markdown table for ssp_io, with optional third label column.\"\"\"\n\n    def _get_displayname_if_exists(param_id: str) -&gt; str:\n        for param in as_filtered_list(control.params, lambda p: p.id == param_id):\n            for prop in as_filtered_list(param.props, lambda p: p.name == const.DISPLAY_NAME):\n                return prop.value\n        return param_id\n\n    param_dict = ControlInterface.get_control_param_dict(control, False)\n\n    if param_dict:\n        if md_file:\n            self._md_file = md_file\n        else:\n            self._md_file = MDWriter(None)\n        header_title = 'Table of Parameters'\n        if section_dict:\n            header_title = section_dict.get(const.TABLE_OF_PARAMS_PART, 'Table of Parameters')\n        self._md_file.new_paragraph()\n        self._md_file.new_header(level=2, title=header_title, add_new_line_after_header=not tag_pattern)\n        if tag_pattern:\n            self._md_file.new_line(tag_pattern.replace('[.]', header_title.replace(' ', '-').lower()))\n            self._md_file.new_paragraph()\n        self._md_file.set_indent_level(-1)\n        if label_column:\n            self._md_file.new_table(\n                [\n                    [\n                        _get_displayname_if_exists(key),\n                        ControlInterface.param_to_str(param_dict[key], ParameterRep.VALUE_OR_EMPTY_STRING),\n                        ControlInterface.param_to_str(param_dict[key], ParameterRep.LABEL_OR_CHOICES, True),\n                    ] for key in param_dict.keys()\n                ], ['Parameter ID', 'Values', 'Label or Choices']\n            )\n        else:\n            self._md_file.new_table(\n                [\n                    [\n                        _get_displayname_if_exists(key),\n                        ControlInterface.param_to_str(param_dict[key], ParameterRep.VALUE_OR_LABEL_OR_CHOICES)\n                    ] for key in param_dict.keys()\n                ], ['Parameter ID', 'Values']\n            )\n        self._md_file.set_indent_level(-1)\n        if tag_pattern:\n            bottom_tag_pattern = '{: #\\\"Parameters for [.]\\\" caption-side=\\\"top\\\"}'  # noqa: FS003 - not f string\n            control_id = self._get_pretty_control_id_if_exists(control)\n            self._md_file.new_line(bottom_tag_pattern.replace('[.]', control_id))\n            self._md_file.new_paragraph()\n        return self._md_file.get_lines()\n\n    return []\n</code></pre>"},{"location":"api_reference/trestle.core.docs_control_writer/#trestle.core.docs_control_writer.DocsControlWriter.write_control_with_sections","title":"<code>write_control_with_sections(self, control, profile, group_title, sections, sections_dict=None, label_column=True, add_group_to_title=False)</code>","text":"<p>Write the control into markdown file with specified sections.</p> Source code in <code>trestle/core/docs_control_writer.py</code> <pre><code>def write_control_with_sections(\n    self,\n    control: cat.Control,\n    profile: prof.Profile,\n    group_title: str,\n    sections: List[str],\n    sections_dict: Optional[Dict[str, str]] = None,\n    label_column: bool = True,\n    add_group_to_title: bool = False\n) -&gt; str:\n\"\"\"Write the control into markdown file with specified sections.\"\"\"\n    self._md_file = MDWriter(None)\n    self._sections_dict = sections_dict if sections_dict else {}\n    tag_pattern = '{: #[.]}'  # noqa: FS003 - not f string but tag\n    if not isinstance(group_title, str):\n        raise TrestleError(f'Group title must be provided and be a string, instead received: {group_title}')\n\n    for section in sections:\n        if 'statement' == section:\n            self._add_control_statement(control, group_title, add_group_to_title, tag_pattern=tag_pattern)\n\n        elif const.OBJECTIVE_PART == section:\n            self._add_control_objective(control, tag_pattern=tag_pattern)\n\n        elif 'table_of_parameters' == section:\n            self.get_param_table(\n                control, label_column, section_dict=sections_dict, tag_pattern=tag_pattern, md_file=self._md_file\n            )\n        else:\n            self._add_one_section(control, profile, section, tag_pattern=tag_pattern)\n\n    return '\\n'.join(self._md_file._lines)\n</code></pre>"},{"location":"api_reference/trestle.core.draw_io/","title":"draw_io","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io","title":"<code>trestle.core.draw_io</code>","text":"<p>Functionality for reading information from a drawio file.</p>"},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIO","title":"<code> DrawIO        </code>","text":"<p>Access and process drawio data / metadata.</p> Source code in <code>trestle/core/draw_io.py</code> <pre><code>class DrawIO():\n\"\"\"Access and process drawio data / metadata.\"\"\"\n\n    def __init__(self, file_path: pathlib.Path) -&gt; None:\n\"\"\"\n        Load drawio object into memory.\n\n        args:\n            file_path: Path to the drawio object.\n        \"\"\"\n        self.file_path: pathlib.Path = file_path\n        self._load()\n        self.banned_keys = ['id', 'label']\n\n    def _load(self) -&gt; None:\n\"\"\"Load the file.\"\"\"\n        if not self.file_path.exists() or self.file_path.is_dir():\n            raise TrestleError(f'Candidate drawio file {str(self.file_path)} does not exist or is a directory')\n        try:\n            self.raw_xml = defusedxml.ElementTree.parse(self.file_path, forbid_dtd=True)\n        except Exception as e:\n            raise TrestleError(f'Exception loading Element tree from file: {e}')\n        self.mx_file = self.raw_xml.getroot()\n        if not self.mx_file.tag == 'mxfile':\n            raise TrestleError('DrawIO file is not a draw io file (mxfile)')\n        self.diagrams = []\n        for diagram in list(self.mx_file):\n            # Determine if compressed or not\n            # Assumption 1 mxGraphModel\n            n_children = len(list(diagram))\n            if n_children == 0:\n                # Compressed object\n                self.diagrams.append(self._uncompress(diagram.text))\n            elif n_children == 1:\n                self.diagrams.append(list(diagram)[0])\n            else:\n                raise TrestleError('Unhandled behaviour in drawio read.')\n\n    def _uncompress(self, compressed_text: str) -&gt; Element:\n\"\"\"\n        Given a compressed object from a drawio file return an xml element for the mxGraphModel.\n\n        Args:\n            compressed_text: A compressed mxGraphModel from inside an mxfile\n\n        Returns:\n            An element containing the mxGraphModel\n        \"\"\"\n        # Assume b64 encode\n        decoded = base64.b64decode(compressed_text)\n        clean_text = unquote(zlib.decompress(decoded, -15).decode(const.FILE_ENCODING))\n        element = defusedxml.ElementTree.fromstring(clean_text, forbid_dtd=True)\n        if not element.tag == 'mxGraphModel':\n            raise TrestleError('Unknown data structure within a compressed drawio file.')\n        return element\n\n    def get_metadata(self) -&gt; List[Dict[str, str]]:\n\"\"\"Get metadata from each tab if it exists or provide an empty dict.\"\"\"\n        # Note that id and label are special for drawio.\n        md_list: List[Dict[str, str]] = []\n        for diagram in self.diagrams:\n            md_dict: Dict[str, str] = {}\n            # Drawio creates data within a root and then an object element type\n            children = list(diagram)\n            root_obj = children[0]\n            md_objects = root_obj.findall('object')\n            # Should always be true - to test presumptions.\n            if len(md_objects) == 0:\n                md_list.append(md_dict)\n                continue\n            items = md_objects[0].items()\n            for item in items:\n                key = item[0]\n                val = item[1]\n                if key in self.banned_keys:\n                    continue\n                md_dict[key] = val\n            md_list.append(md_dict)\n        return md_list\n\n    @classmethod\n    def restructure_metadata(cls, input_dict: Dict[str, str]) -&gt; Dict[str, Any]:\n\"\"\"Restructure metadata into a hierarchial dict assuming a period separator.\"\"\"\n        # get the list of duplicate keys\n        # Get a count of keys\n        result = {}\n        key_map = {}\n        for keys in input_dict.keys():\n            stub = keys.split('.')[0]\n            tmp = key_map.get(stub, [])\n            tmp.append(keys)\n            key_map[stub] = tmp\n\n        for key, values in key_map.items():\n            holding = {}\n            if len(values) == 1 and key == values[0]:\n                result[key] = input_dict[key]\n            else:\n                for value in values:\n                    holding[value.split('.', 1)[-1]] = input_dict[value]\n                result[key] = cls.restructure_metadata(holding)\n        return result\n\n    def write_drawio_with_metadata(\n        self, path: pathlib.Path, metadata: Dict, diagram_metadata_idx: int, target_path: pathlib.Path = None\n    ) -&gt; None:\n\"\"\"\n        Write modified metadata to drawio file.\n\n        Writes given metadata to 'object' element attributes inside of the selected drawio diagram element.\n        Currently supports writing only uncompressed elements.\n\n        Args:\n            path: path to write modified drawio file to\n            metadata: dictionary of modified metadata to insert to drawio\n            diagram_metadata_idx: index of diagram which metadata was modified\n            target_path: if not provided the changes will be written to path\n        \"\"\"\n        flattened_dict = self._flatten_dictionary(metadata)\n        if diagram_metadata_idx &gt;= len(list(self.diagrams)):\n            raise TrestleError(f'Drawio file {path} does not contain a diagram for index {diagram_metadata_idx}')\n\n        diagram = list(self.diagrams)[diagram_metadata_idx]\n        children = list(diagram)\n        root_obj = children[0]\n        md_objects = root_obj.findall('object')\n        if len(md_objects) == 0:\n            raise TrestleError(f'Unable to write metadata, diagram in drawio file {path} does not have objects.')\n\n        for key in md_objects[0].attrib.copy():\n            if key not in flattened_dict.keys() and key not in self.banned_keys:\n                # outdated key delete\n                del md_objects[0].attrib[key]\n                continue\n            if key in self.banned_keys:\n                continue\n            md_objects[0].attrib[key] = flattened_dict[key]\n        for key in flattened_dict.keys():\n            if key in self.banned_keys:\n                continue\n            md_objects[0].attrib[key] = flattened_dict[key]\n        parent_diagram = self.mx_file.findall('diagram')[diagram_metadata_idx]\n        if len(parent_diagram.findall('mxGraphModel')) == 0:\n            parent_diagram.insert(0, diagram)\n\n        if target_path:\n            self.raw_xml.write(target_path)\n        else:\n            self.raw_xml.write(path)\n\n    def _flatten_dictionary(self, metadata: Dict, parent_key='', separator='.') -&gt; Dict[str, str]:\n\"\"\"Flatten hierarchial dict back to xml attributes.\"\"\"\n        items = []\n        for key, value in metadata.items():\n            new_key = parent_key + separator + key if parent_key else key\n            if isinstance(value, Dict):\n                items.extend(self._flatten_dictionary(value, new_key, separator).items())\n            else:\n                items.append((new_key, value))\n        return dict(items)\n</code></pre>"},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIO-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIO.__init__","title":"<code>__init__(self, file_path)</code>  <code>special</code>","text":"<p>Load drawio object into memory.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>Path to the drawio object.</p> required Source code in <code>trestle/core/draw_io.py</code> <pre><code>def __init__(self, file_path: pathlib.Path) -&gt; None:\n\"\"\"\n    Load drawio object into memory.\n\n    args:\n        file_path: Path to the drawio object.\n    \"\"\"\n    self.file_path: pathlib.Path = file_path\n    self._load()\n    self.banned_keys = ['id', 'label']\n</code></pre>"},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIO.get_metadata","title":"<code>get_metadata(self)</code>","text":"<p>Get metadata from each tab if it exists or provide an empty dict.</p> Source code in <code>trestle/core/draw_io.py</code> <pre><code>def get_metadata(self) -&gt; List[Dict[str, str]]:\n\"\"\"Get metadata from each tab if it exists or provide an empty dict.\"\"\"\n    # Note that id and label are special for drawio.\n    md_list: List[Dict[str, str]] = []\n    for diagram in self.diagrams:\n        md_dict: Dict[str, str] = {}\n        # Drawio creates data within a root and then an object element type\n        children = list(diagram)\n        root_obj = children[0]\n        md_objects = root_obj.findall('object')\n        # Should always be true - to test presumptions.\n        if len(md_objects) == 0:\n            md_list.append(md_dict)\n            continue\n        items = md_objects[0].items()\n        for item in items:\n            key = item[0]\n            val = item[1]\n            if key in self.banned_keys:\n                continue\n            md_dict[key] = val\n        md_list.append(md_dict)\n    return md_list\n</code></pre>"},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIO.restructure_metadata","title":"<code>restructure_metadata(input_dict)</code>  <code>classmethod</code>","text":"<p>Restructure metadata into a hierarchial dict assuming a period separator.</p> Source code in <code>trestle/core/draw_io.py</code> <pre><code>@classmethod\ndef restructure_metadata(cls, input_dict: Dict[str, str]) -&gt; Dict[str, Any]:\n\"\"\"Restructure metadata into a hierarchial dict assuming a period separator.\"\"\"\n    # get the list of duplicate keys\n    # Get a count of keys\n    result = {}\n    key_map = {}\n    for keys in input_dict.keys():\n        stub = keys.split('.')[0]\n        tmp = key_map.get(stub, [])\n        tmp.append(keys)\n        key_map[stub] = tmp\n\n    for key, values in key_map.items():\n        holding = {}\n        if len(values) == 1 and key == values[0]:\n            result[key] = input_dict[key]\n        else:\n            for value in values:\n                holding[value.split('.', 1)[-1]] = input_dict[value]\n            result[key] = cls.restructure_metadata(holding)\n    return result\n</code></pre>"},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIO.write_drawio_with_metadata","title":"<code>write_drawio_with_metadata(self, path, metadata, diagram_metadata_idx, target_path=None)</code>","text":"<p>Write modified metadata to drawio file.</p> <p>Writes given metadata to 'object' element attributes inside of the selected drawio diagram element. Currently supports writing only uncompressed elements.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>path to write modified drawio file to</p> required <code>metadata</code> <code>Dict</code> <p>dictionary of modified metadata to insert to drawio</p> required <code>diagram_metadata_idx</code> <code>int</code> <p>index of diagram which metadata was modified</p> required <code>target_path</code> <code>Path</code> <p>if not provided the changes will be written to path</p> <code>None</code> Source code in <code>trestle/core/draw_io.py</code> <pre><code>def write_drawio_with_metadata(\n    self, path: pathlib.Path, metadata: Dict, diagram_metadata_idx: int, target_path: pathlib.Path = None\n) -&gt; None:\n\"\"\"\n    Write modified metadata to drawio file.\n\n    Writes given metadata to 'object' element attributes inside of the selected drawio diagram element.\n    Currently supports writing only uncompressed elements.\n\n    Args:\n        path: path to write modified drawio file to\n        metadata: dictionary of modified metadata to insert to drawio\n        diagram_metadata_idx: index of diagram which metadata was modified\n        target_path: if not provided the changes will be written to path\n    \"\"\"\n    flattened_dict = self._flatten_dictionary(metadata)\n    if diagram_metadata_idx &gt;= len(list(self.diagrams)):\n        raise TrestleError(f'Drawio file {path} does not contain a diagram for index {diagram_metadata_idx}')\n\n    diagram = list(self.diagrams)[diagram_metadata_idx]\n    children = list(diagram)\n    root_obj = children[0]\n    md_objects = root_obj.findall('object')\n    if len(md_objects) == 0:\n        raise TrestleError(f'Unable to write metadata, diagram in drawio file {path} does not have objects.')\n\n    for key in md_objects[0].attrib.copy():\n        if key not in flattened_dict.keys() and key not in self.banned_keys:\n            # outdated key delete\n            del md_objects[0].attrib[key]\n            continue\n        if key in self.banned_keys:\n            continue\n        md_objects[0].attrib[key] = flattened_dict[key]\n    for key in flattened_dict.keys():\n        if key in self.banned_keys:\n            continue\n        md_objects[0].attrib[key] = flattened_dict[key]\n    parent_diagram = self.mx_file.findall('diagram')[diagram_metadata_idx]\n    if len(parent_diagram.findall('mxGraphModel')) == 0:\n        parent_diagram.insert(0, diagram)\n\n    if target_path:\n        self.raw_xml.write(target_path)\n    else:\n        self.raw_xml.write(path)\n</code></pre>"},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIOMetadataValidator","title":"<code> DrawIOMetadataValidator        </code>","text":"<p>Validator to check whether drawio metadata meets validation expectations.</p> Source code in <code>trestle/core/draw_io.py</code> <pre><code>class DrawIOMetadataValidator():\n\"\"\"Validator to check whether drawio metadata meets validation expectations.\"\"\"\n\n    def __init__(self, template_path: pathlib.Path, must_be_first_tab: bool = True) -&gt; None:\n\"\"\"\n        Initialize drawio validator.\n\n        Args:\n            template_path: Path to a templated drawio file where metadata will be looked up on the first tab only.\n            must_be_first_tab: Whether to search the candidate file for a metadata across multiple tabs.\n        \"\"\"\n        self.template_path = template_path\n        self.must_be_first_tab = must_be_first_tab\n        # Load metadat from template\n        template_drawio = DrawIO(self.template_path)\n        # Zero index as must be first tab\n        self.template_metadata = template_drawio.get_metadata()[0]\n        self.template_version = MarkdownValidator.extract_template_version(self.template_metadata)\n        if self.template_version not in str(self.template_path):\n            raise TrestleError(\n                f'Version of the template {self.template_version} does not match the path {self.template_path}.'\n                + f'Move the template to the folder {self.template_version}'\n            )\n        if 'Version' in self.template_metadata.keys() and self.template_metadata['Version'] != self.template_version:\n            raise TrestleError(f'Version does not match template-version in template: {self.template_path}.')\n\n    def validate(self, candidate: pathlib.Path) -&gt; bool:\n\"\"\"\n        Run drawio validation against a candidate file.\n\n        Args:\n            candidate: The path to a candidate markdown file to be validated.\n\n        Returns:\n            Whether or not the validation passes.\n\n        Raises:\n            err.TrestleError: If a file IO / formatting error occurs.\n        \"\"\"\n        logging.info(f'Validating drawio file {candidate} against template file {self.template_path}')\n        candidate_drawio = DrawIO(candidate)\n        drawio_metadata = candidate_drawio.get_metadata()\n\n        if self.must_be_first_tab:\n            return MarkdownValidator.compare_keys(self.template_metadata, drawio_metadata[0])\n        for md_tab in drawio_metadata:\n            status = MarkdownValidator.compare_keys(self.template_metadata, md_tab)\n            if status:\n                return status\n        return False\n</code></pre>"},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIOMetadataValidator-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIOMetadataValidator.__init__","title":"<code>__init__(self, template_path, must_be_first_tab=True)</code>  <code>special</code>","text":"<p>Initialize drawio validator.</p> <p>Parameters:</p> Name Type Description Default <code>template_path</code> <code>Path</code> <p>Path to a templated drawio file where metadata will be looked up on the first tab only.</p> required <code>must_be_first_tab</code> <code>bool</code> <p>Whether to search the candidate file for a metadata across multiple tabs.</p> <code>True</code> Source code in <code>trestle/core/draw_io.py</code> <pre><code>def __init__(self, template_path: pathlib.Path, must_be_first_tab: bool = True) -&gt; None:\n\"\"\"\n    Initialize drawio validator.\n\n    Args:\n        template_path: Path to a templated drawio file where metadata will be looked up on the first tab only.\n        must_be_first_tab: Whether to search the candidate file for a metadata across multiple tabs.\n    \"\"\"\n    self.template_path = template_path\n    self.must_be_first_tab = must_be_first_tab\n    # Load metadat from template\n    template_drawio = DrawIO(self.template_path)\n    # Zero index as must be first tab\n    self.template_metadata = template_drawio.get_metadata()[0]\n    self.template_version = MarkdownValidator.extract_template_version(self.template_metadata)\n    if self.template_version not in str(self.template_path):\n        raise TrestleError(\n            f'Version of the template {self.template_version} does not match the path {self.template_path}.'\n            + f'Move the template to the folder {self.template_version}'\n        )\n    if 'Version' in self.template_metadata.keys() and self.template_metadata['Version'] != self.template_version:\n        raise TrestleError(f'Version does not match template-version in template: {self.template_path}.')\n</code></pre>"},{"location":"api_reference/trestle.core.draw_io/#trestle.core.draw_io.DrawIOMetadataValidator.validate","title":"<code>validate(self, candidate)</code>","text":"<p>Run drawio validation against a candidate file.</p> <p>Parameters:</p> Name Type Description Default <code>candidate</code> <code>Path</code> <p>The path to a candidate markdown file to be validated.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the validation passes.</p> <p>Exceptions:</p> Type Description <code>err.TrestleError</code> <p>If a file IO / formatting error occurs.</p> Source code in <code>trestle/core/draw_io.py</code> <pre><code>def validate(self, candidate: pathlib.Path) -&gt; bool:\n\"\"\"\n    Run drawio validation against a candidate file.\n\n    Args:\n        candidate: The path to a candidate markdown file to be validated.\n\n    Returns:\n        Whether or not the validation passes.\n\n    Raises:\n        err.TrestleError: If a file IO / formatting error occurs.\n    \"\"\"\n    logging.info(f'Validating drawio file {candidate} against template file {self.template_path}')\n    candidate_drawio = DrawIO(candidate)\n    drawio_metadata = candidate_drawio.get_metadata()\n\n    if self.must_be_first_tab:\n        return MarkdownValidator.compare_keys(self.template_metadata, drawio_metadata[0])\n    for md_tab in drawio_metadata:\n        status = MarkdownValidator.compare_keys(self.template_metadata, md_tab)\n        if status:\n            return status\n    return False\n</code></pre>"},{"location":"api_reference/trestle.core.duplicates_validator/","title":"duplicates_validator","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.duplicates_validator/#trestle.core.duplicates_validator","title":"<code>trestle.core.duplicates_validator</code>","text":"<p>Validate by confirming no duplicate uuids.</p>"},{"location":"api_reference/trestle.core.duplicates_validator/#trestle.core.duplicates_validator-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.duplicates_validator/#trestle.core.duplicates_validator.DuplicatesValidator","title":"<code> DuplicatesValidator            (Validator)         </code>","text":"<p>Validator to check for duplicate uuids and param_ids in the model.</p> Source code in <code>trestle/core/duplicates_validator.py</code> <pre><code>class DuplicatesValidator(Validator):\n\"\"\"Validator to check for duplicate uuids and param_ids in the model.\"\"\"\n\n    def model_is_valid(self, model: OscalBaseModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None) -&gt; bool:\n\"\"\"\n        Test if the model is valid and contains no duplicate uuids or param_ids.\n\n        args:\n            model: An Oscal model that can be passed to the validator.\n            quiet: Don't report msgs unless invalid.\n\n        returns:\n            True (valid) if the model does not contain duplicate uuid's.\n        \"\"\"\n        if not ModelUtils.has_no_duplicate_values_by_name(model, 'uuid'):\n            return False\n        # only profile, comp-def and ssp have set-params and only set-params have param_id\n        # param_id is required to be unique in profiles but not in other models\n        if isinstance(model, Profile):\n            return ModelUtils.has_no_duplicate_values_by_name(model, 'param_id')\n        return True\n</code></pre>"},{"location":"api_reference/trestle.core.duplicates_validator/#trestle.core.duplicates_validator.DuplicatesValidator-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.duplicates_validator/#trestle.core.duplicates_validator.DuplicatesValidator.model_is_valid","title":"<code>model_is_valid(self, model, quiet, trestle_root=None)</code>","text":"<p>Test if the model is valid and contains no duplicate uuids or param_ids.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>OscalBaseModel</code> <p>An Oscal model that can be passed to the validator.</p> required <code>quiet</code> <code>bool</code> <p>Don't report msgs unless invalid.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True (valid) if the model does not contain duplicate uuid's.</p> Source code in <code>trestle/core/duplicates_validator.py</code> <pre><code>def model_is_valid(self, model: OscalBaseModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None) -&gt; bool:\n\"\"\"\n    Test if the model is valid and contains no duplicate uuids or param_ids.\n\n    args:\n        model: An Oscal model that can be passed to the validator.\n        quiet: Don't report msgs unless invalid.\n\n    returns:\n        True (valid) if the model does not contain duplicate uuid's.\n    \"\"\"\n    if not ModelUtils.has_no_duplicate_values_by_name(model, 'uuid'):\n        return False\n    # only profile, comp-def and ssp have set-params and only set-params have param_id\n    # param_id is required to be unique in profiles but not in other models\n    if isinstance(model, Profile):\n        return ModelUtils.has_no_duplicate_values_by_name(model, 'param_id')\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.generators/","title":"generators","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.generators/#trestle.core.generators","title":"<code>trestle.core.generators</code>","text":"<p>Capabilities to allow the generation of various oscal objects.</p>"},{"location":"api_reference/trestle.core.generators/#trestle.core.generators.TG","title":"<code>TG</code>","text":""},{"location":"api_reference/trestle.core.generators/#trestle.core.generators.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.generators/#trestle.core.generators-functions","title":"Functions","text":""},{"location":"api_reference/trestle.core.generators/#trestle.core.generators.generate_sample_model","title":"<code>generate_sample_model(model, include_optional=False, depth=-1)</code>","text":"<p>Given a model class, generate an object of that class with sample values.</p> <p>Can generate optional variables with an enabled flag. Any array objects will have a single entry injected into it.</p> <p>Note: Trestle generate will not activate recursive loops irrespective of the depth flag.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Union[Type[~TG], List[~TG], Dict[str, ~TG]]</code> <p>The model type provided. Typically for a user as an OscalBaseModel Subclass.</p> required <code>include_optional</code> <code>bool</code> <p>Whether or not to generate optional fields.</p> <code>False</code> <code>depth</code> <code>int</code> <p>Depth of the tree at which optional fields are generated. Negative values (default) removes the limit.</p> <code>-1</code> <p>Returns:</p> Type Description <code>~TG</code> <p>The generated instance with a pro-forma values filled out as best as possible.</p> Source code in <code>trestle/core/generators.py</code> <pre><code>def generate_sample_model(\n    model: Union[Type[TG], List[TG], Dict[str, TG]], include_optional: bool = False, depth: int = -1\n) -&gt; TG:\n\"\"\"Given a model class, generate an object of that class with sample values.\n\n    Can generate optional variables with an enabled flag. Any array objects will have a single entry injected into it.\n\n    Note: Trestle generate will not activate recursive loops irrespective of the depth flag.\n\n    Args:\n        model: The model type provided. Typically for a user as an OscalBaseModel Subclass.\n        include_optional: Whether or not to generate optional fields.\n        depth: Depth of the tree at which optional fields are generated. Negative values (default) removes the limit.\n\n    Returns:\n        The generated instance with a pro-forma values filled out as best as possible.\n    \"\"\"\n    effective_optional = include_optional and not depth == 0\n\n    model_type = model\n    # This block normalizes model type down to\n    if utils.is_collection_field_type(model):  # type: ignore\n        model_type = utils.get_origin(model)  # type: ignore\n        model = utils.get_inner_type(model)  # type: ignore\n    model = cast(TG, model)\n\n    model_dict = {}\n    # this block is needed to avoid situations where an inbuilt is inside a list / dict.\n    # the only time dict ever appears is with include_all, which is handled specially\n    # the only type of collection possible after OSCAL 1.0.0 is list\n    if safe_is_sub(model, OscalBaseModel):\n        for field in model.__fields__:\n            if field == 'include_all':\n                if include_optional:\n                    model_dict[field] = {}\n                continue\n            outer_type = model.__fields__[field].outer_type_\n            # next appears to be needed for python 3.7\n            if utils.get_origin(outer_type) == Union:\n                outer_type = outer_type.__args__[0]\n            if model.__fields__[field].required or effective_optional:\n                # FIXME could be ForwardRef('SystemComponentStatus')\n                if utils.is_collection_field_type(outer_type):\n                    inner_type = utils.get_inner_type(outer_type)\n                    if inner_type == model:\n                        continue\n                    model_dict[field] = generate_sample_model(\n                        outer_type, include_optional=include_optional, depth=depth - 1\n                    )\n                elif safe_is_sub(outer_type, OscalBaseModel):\n                    model_dict[field] = generate_sample_model(\n                        outer_type, include_optional=include_optional, depth=depth - 1\n                    )\n                else:\n                    # Hacking here:\n                    # Root models should ideally not exist, however, sometimes we are stuck with them.\n                    # If that is the case we need sufficient information on the type in order to generate a model.\n                    # E.g. we need the type of the container.\n                    if field == '__root__' and hasattr(model, '__name__'):\n                        model_dict[field] = generate_sample_value_by_type(\n                            outer_type, str_utils.classname_to_alias(model.__name__, AliasMode.FIELD)\n                        )\n                    else:\n                        model_dict[field] = generate_sample_value_by_type(outer_type, field)\n        # Note: this assumes list constrains in oscal are always 1 as a minimum size. if two this may still fail.\n    else:\n        if model_type is list:\n            return [generate_sample_value_by_type(model, '')]\n        if model_type is dict:\n            return {const.REPLACE_ME: generate_sample_value_by_type(model, '')}\n        raise err.TrestleError('Unhandled collection type.')\n    if model_type is list:\n        return [model(**model_dict)]\n    if model_type is dict:\n        return {const.REPLACE_ME: model(**model_dict)}\n    return model(**model_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generators/#trestle.core.generators.generate_sample_value_by_type","title":"<code>generate_sample_value_by_type(type_, field_name)</code>","text":"<p>Given a type, return sample value.</p> <p>Includes the Optional use of passing down a parent_model</p> Source code in <code>trestle/core/generators.py</code> <pre><code>def generate_sample_value_by_type(\n    type_: type,\n    field_name: str,\n) -&gt; Union[datetime, bool, int, str, float, Enum]:\n\"\"\"Given a type, return sample value.\n\n    Includes the Optional use of passing down a parent_model\n    \"\"\"\n    # FIXME: Should be in separate generator module as it inherits EVERYTHING\n    if type_ is datetime:\n        return datetime.now().astimezone()\n    if type_ is bool:\n        return False\n    if type_ is int:\n        return 0\n    if type_ is float:\n        return 0.00\n    if safe_is_sub(type_, ConstrainedStr) or (hasattr(type_, '__name__') and 'ConstrainedStr' in type_.__name__):\n        # This code here is messy. we need to meet a set of constraints. If we do\n        # TODO: handle regex directly\n        if 'uuid' == field_name:\n            return str(uuid.uuid4())\n        # some things like location_uuid in lists arrive here with field_name=''\n        if type_.regex and type_.regex.pattern.startswith('^[0-9A-Fa-f]{8}'):\n            return const.SAMPLE_UUID_STR\n        if field_name == 'date_authorized':\n            return str(date.today().isoformat())\n        if field_name == 'oscal_version':\n            return OSCAL_VERSION\n        if 'uuid' in field_name:\n            return const.SAMPLE_UUID_STR\n        # Only case where are UUID is required but not in name.\n        if field_name.rstrip('s') == 'member_of_organization':\n            return const.SAMPLE_UUID_STR\n        return const.REPLACE_ME\n    if hasattr(type_, '__name__') and 'ConstrainedIntValue' in type_.__name__:\n        # create an int value as close to the floor as possible does not test upper bound\n        multiple = type_.multiple_of if type_.multiple_of else 1  # default to every integer\n        # this command is a bit of a problem\n        floor = type_.ge if type_.ge else 0\n        floor = type_.gt + 1 if type_.gt else floor\n        if math.remainder(floor, multiple) == 0:\n            return floor\n        return (floor + 1) * multiple\n    if safe_is_sub(type_, Enum):\n        # keys and values diverge due to hypens in oscal names\n        return type_(list(type_.__members__.values())[0])\n    if type_ is str:\n        if field_name == 'oscal_version':\n            return OSCAL_VERSION\n        return const.REPLACE_ME\n    if type_ is pydantic.networks.EmailStr:\n        return pydantic.networks.EmailStr('dummy@sample.com')\n    if type_ is pydantic.networks.AnyUrl:\n        # TODO: Cleanup: this should be usable from a url.. but it's not inuitive.\n        return pydantic.networks.AnyUrl('https://sample.com/replaceme.html', scheme='http', host='sample.com')\n    if type_ is list:\n        raise err.TrestleError(f'Unable to generate sample for type {type_}')\n    # default to empty dict for anything else\n    return {}\n</code></pre>"},{"location":"api_reference/trestle.core.generators/#trestle.core.generators.safe_is_sub","title":"<code>safe_is_sub(sub, parent)</code>","text":"<p>Is this a subclass of parent.</p> Source code in <code>trestle/core/generators.py</code> <pre><code>def safe_is_sub(sub: Any, parent: Any) -&gt; bool:\n\"\"\"Is this a subclass of parent.\"\"\"\n    is_class = inspect.isclass(sub)\n    return is_class and issubclass(sub, parent)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/","title":"generic_oscal","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal","title":"<code>trestle.core.generic_oscal</code>","text":"<p>Generic classes to support both SSP and DefinedComponents.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.IMPLEMENTED_REQUIREMENTS","title":"<code>IMPLEMENTED_REQUIREMENTS</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent","title":"<code> GenericByComponent            (TrestleBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Generic ByComponent for SSP and DefinedComponent.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>class GenericByComponent(TrestleBaseModel):\n\"\"\"Generic ByComponent for SSP and DefinedComponent.\"\"\"\n\n    # only in SSP\n    component_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'  # noqa FS003\n    ) = Field(\n        ...,\n        alias='component_uuid',\n        description='A machine-oriented identifier reference to the component that is implemeting a given control.',\n        title='Component Universally Unique Identifier Reference',\n    )\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'  # noqa FS003\n    ) = Field(\n        ...,\n        description=  # noqa E251\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this by-component entry elsewhere in this or other OSCAL instances. The locally defined UUID of the by-component entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',  # noqa E501\n        title='By-Component Universally Unique Identifier',\n    )\n    description: str = Field(\n        ...,\n        description=  # noqa E251\n        'An implementation statement that describes how a control or a control statement is implemented within the referenced system component.',  # noqa E501\n        title='Control Implementation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    set_parameters: Optional[List[GenericSetParameter]] = Field(None, alias='set-parameters')\n    implementation_status: Optional[common.ImplementationStatus] = Field(None, alias='implementation-status')\n    # removed export, inherited, satisfied\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n\n    @staticmethod\n    def generate() -&gt; GenericByComponent:\n\"\"\"Generate instance of generic ByComponent.\"\"\"\n        uuid = str(uuid4())\n        return GenericByComponent(component_uuid=const.SAMPLE_UUID_STR, uuid=uuid, description='')\n\n    def as_ssp(self) -&gt; ossp.ByComponent:\n\"\"\"Convert to ssp format.\"\"\"\n        set_params = []\n        for set_param in as_list(self.set_parameters):\n            new_set_param = ossp.SetParameter(\n                param_id=set_param.param_id, values=set_param.values, remarks=set_param.remarks\n            )\n            set_params.append(new_set_param)\n        set_params = none_if_empty(set_params)\n        return ossp.ByComponent(\n            component_uuid=self.component_uuid,\n            uuid=self.uuid,\n            description=self.description,\n            props=self.props,\n            links=self.links,\n            set_parameters=set_params,\n            implementation_status=self.implementation_status,\n            responsible_roles=self.responsible_roles\n        )\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.component_uuid","title":"<code>component_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to the component that is implemeting a given control.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An implementation statement that describes how a control or a control statement is implemented within the referenced system component.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.implementation_status","title":"<code>implementation_status: ImplementationStatus</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.set_parameters","title":"<code>set_parameters: Optional[List[GenericSetParameter]]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this by-component entry elsewhere in this or other OSCAL instances. The locally defined UUID of the by-component entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.as_ssp","title":"<code>as_ssp(self)</code>","text":"<p>Convert to ssp format.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>def as_ssp(self) -&gt; ossp.ByComponent:\n\"\"\"Convert to ssp format.\"\"\"\n    set_params = []\n    for set_param in as_list(self.set_parameters):\n        new_set_param = ossp.SetParameter(\n            param_id=set_param.param_id, values=set_param.values, remarks=set_param.remarks\n        )\n        set_params.append(new_set_param)\n    set_params = none_if_empty(set_params)\n    return ossp.ByComponent(\n        component_uuid=self.component_uuid,\n        uuid=self.uuid,\n        description=self.description,\n        props=self.props,\n        links=self.links,\n        set_parameters=set_params,\n        implementation_status=self.implementation_status,\n        responsible_roles=self.responsible_roles\n    )\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericByComponent.generate","title":"<code>generate()</code>  <code>staticmethod</code>","text":"<p>Generate instance of generic ByComponent.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>@staticmethod\ndef generate() -&gt; GenericByComponent:\n\"\"\"Generate instance of generic ByComponent.\"\"\"\n    uuid = str(uuid4())\n    return GenericByComponent(component_uuid=const.SAMPLE_UUID_STR, uuid=uuid, description='')\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent","title":"<code> GenericComponent            (TrestleBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Generic component for SSP SystemComponent and DefinedComponent.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>class GenericComponent(TrestleBaseModel):\n\"\"\"Generic component for SSP SystemComponent and DefinedComponent.\"\"\"\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'  # noqa FS003 F722\n    ) = Field(\n        ...,\n        description=  # noqa E251\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',  # noqa E501\n        title='Component Identifier',\n    )\n    type: constr(regex=r'^\\S(.*\\S)?$') = Field(  # noqa A003 F722\n        ...,\n        description='A category describing the purpose of the component.',\n        title='Component Type',\n    )\n    title: str = Field(\n        ...,\n        description='A human readable name for the component.',\n        title='Component Title',\n    )\n    description: str = Field(\n        ...,\n        description='A description of the component, including information about its function.',\n        title='Component Description',\n    )\n    purpose: Optional[str] = Field(\n        None,\n        description='A summary of the technological or business purpose of the component.',\n        title='Purpose',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    protocols: Optional[List[common.Protocol]] = Field(None)\n    # ssp does not have a list of ci's but it does have one ci\n    control_implementations: Optional[List[GenericControlImplementation]] = Field(None, alias='control-implementations')\n    remarks: Optional[str] = None\n    # ssp has\n    status: common.ImplementationStatus\n\n    def as_defined_component(self) -&gt; comp.DefinedComponent:\n\"\"\"Convert to DefinedComponent.\"\"\"\n        status = self.status\n        class_dict = copy.deepcopy(self.__dict__)\n        class_dict.pop('status', None)\n        def_comp = comp.DefinedComponent(**class_dict)\n        ControlInterface.insert_status_in_props(def_comp, status)\n        return def_comp\n\n    @classmethod\n    def from_defined_component(cls, def_comp: comp.DefinedComponent) -&gt; GenericComponent:\n\"\"\"Convert defined component to generic.\"\"\"\n        status = ControlInterface.get_status_from_props(def_comp)\n        class_dict = copy.deepcopy(def_comp.__dict__)\n        if 'control_implementations' in class_dict:\n            new_cis = []\n            for ci in class_dict['control_implementations']:\n                new_cis.append(GenericControlImplementation.from_component_ci(ci))\n            class_dict['control-implementations'] = new_cis\n            class_dict.pop('control_implementations', None)\n        class_dict['status'] = status\n        return cls(**class_dict)\n\n    def as_system_component(self, status_override: str = '') -&gt; ossp.SystemComponent:\n\"\"\"Convert to SystemComponent.\"\"\"\n        class_dict = copy.deepcopy(self.__dict__)\n        class_dict.pop('control_implementations', None)\n        status_str = self.status.state if self.status else const.STATUS_OPERATIONAL\n        status_str = status_override if status_override else status_str\n        if status_str not in ['under-development', 'operational', 'disposition', 'other']:\n            logger.warning(\n                f'SystemComponent status {status_str} not recognized.  Setting to {const.STATUS_OPERATIONAL}'\n            )\n            status_str = const.STATUS_OPERATIONAL\n        class_dict['status'] = ossp.Status(state=status_str, remarks=self.status.remarks)\n        return ossp.SystemComponent(**class_dict)\n\n    @staticmethod\n    def generate() -&gt; GenericComponent:\n\"\"\"Generate instance of GenericComponent.\"\"\"\n        uuid = str(uuid4())\n        status = common.ImplementationStatus(state=const.STATUS_OPERATIONAL)\n        return GenericComponent(uuid=uuid, type=const.REPLACE_ME, title='', description='', status=status)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.control_implementations","title":"<code>control_implementations: List[trestle.core.generic_oscal.GenericControlImplementation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of the component, including information about its function.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.protocols","title":"<code>protocols: List[trestle.oscal.common.Protocol]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.purpose","title":"<code>purpose: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the technological or business purpose of the component.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.status","title":"<code>status: ImplementationStatus</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human readable name for the component.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A category describing the purpose of the component.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.as_defined_component","title":"<code>as_defined_component(self)</code>","text":"<p>Convert to DefinedComponent.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>def as_defined_component(self) -&gt; comp.DefinedComponent:\n\"\"\"Convert to DefinedComponent.\"\"\"\n    status = self.status\n    class_dict = copy.deepcopy(self.__dict__)\n    class_dict.pop('status', None)\n    def_comp = comp.DefinedComponent(**class_dict)\n    ControlInterface.insert_status_in_props(def_comp, status)\n    return def_comp\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.as_system_component","title":"<code>as_system_component(self, status_override='')</code>","text":"<p>Convert to SystemComponent.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>def as_system_component(self, status_override: str = '') -&gt; ossp.SystemComponent:\n\"\"\"Convert to SystemComponent.\"\"\"\n    class_dict = copy.deepcopy(self.__dict__)\n    class_dict.pop('control_implementations', None)\n    status_str = self.status.state if self.status else const.STATUS_OPERATIONAL\n    status_str = status_override if status_override else status_str\n    if status_str not in ['under-development', 'operational', 'disposition', 'other']:\n        logger.warning(\n            f'SystemComponent status {status_str} not recognized.  Setting to {const.STATUS_OPERATIONAL}'\n        )\n        status_str = const.STATUS_OPERATIONAL\n    class_dict['status'] = ossp.Status(state=status_str, remarks=self.status.remarks)\n    return ossp.SystemComponent(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.from_defined_component","title":"<code>from_defined_component(def_comp)</code>  <code>classmethod</code>","text":"<p>Convert defined component to generic.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>@classmethod\ndef from_defined_component(cls, def_comp: comp.DefinedComponent) -&gt; GenericComponent:\n\"\"\"Convert defined component to generic.\"\"\"\n    status = ControlInterface.get_status_from_props(def_comp)\n    class_dict = copy.deepcopy(def_comp.__dict__)\n    if 'control_implementations' in class_dict:\n        new_cis = []\n        for ci in class_dict['control_implementations']:\n            new_cis.append(GenericControlImplementation.from_component_ci(ci))\n        class_dict['control-implementations'] = new_cis\n        class_dict.pop('control_implementations', None)\n    class_dict['status'] = status\n    return cls(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericComponent.generate","title":"<code>generate()</code>  <code>staticmethod</code>","text":"<p>Generate instance of GenericComponent.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>@staticmethod\ndef generate() -&gt; GenericComponent:\n\"\"\"Generate instance of GenericComponent.\"\"\"\n    uuid = str(uuid4())\n    status = common.ImplementationStatus(state=const.STATUS_OPERATIONAL)\n    return GenericComponent(uuid=uuid, type=const.REPLACE_ME, title='', description='', status=status)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation","title":"<code> GenericControlImplementation            (TrestleBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Generic control implementation for SSP and CompDef.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>class GenericControlImplementation(TrestleBaseModel):\n\"\"\"Generic control implementation for SSP and CompDef.\"\"\"\n\n    # not in ssp\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'  # noqa FS003 F722\n    ) = Field(\n        ...,\n        description=  # noqa E251\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference a set of implemented controls elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation set can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',  # noqa E501\n        title='Control Implementation Set Identifier',\n    )\n    # not in ssp\n    source: str = Field(\n        ...,\n        description=  # noqa E251\n        'A reference to an OSCAL catalog or profile providing the referenced control or subcontrol definition.',  # noqa E501\n        title='Source Resource Reference',\n    )\n    description: str = Field(\n        ...,\n        description=  # noqa E251\n        'A description of how the specified set of controls are implemented for the containing component or capability.',  # noqa E501\n        title='Control Implementation Description',\n    )\n    # not in ssp\n    props: Optional[List[common.Property]] = Field(None)\n    # not in ssp\n    links: Optional[List[common.Link]] = Field(None)\n    set_parameters: Optional[List[GenericSetParameter]] = Field(None, alias='set-parameters')\n    implemented_requirements: List[GenericImplementedRequirement] = Field(..., alias='implemented-requirements')\n\n    @staticmethod\n    def generate() -&gt; GenericControlImplementation:\n\"\"\"Generate instance of this class.\"\"\"\n        uuid = str(uuid4())\n        imp_reqs = [GenericImplementedRequirement.generate()]\n        class_dict = {\n            'uuid': uuid,\n            'control-id': const.REPLACE_ME,\n            'source': const.REPLACE_ME,\n            'description': '',\n            'implemented-requirements': imp_reqs\n        }\n        return GenericControlImplementation(**class_dict)\n\n    @classmethod\n    def from_component_ci(cls, control_imp: comp.ControlImplementation) -&gt; GenericControlImplementation:\n\"\"\"Convert component control imp to generic.\"\"\"\n        class_dict = copy.deepcopy(control_imp.__dict__)\n        if IMPLEMENTED_REQUIREMENTS in class_dict:\n            new_irs = []\n            ir_list = class_dict.get(IMPLEMENTED_REQUIREMENTS, None)\n            for ir in as_list(ir_list):\n                new_ir = GenericImplementedRequirement.from_comp_def(ir)\n                new_irs.append(new_ir)\n            class_dict['implemented-requirements'] = none_if_empty(new_irs)\n            class_dict.pop(IMPLEMENTED_REQUIREMENTS, None)\n            new_sps = []\n            sp_list = class_dict.get('set_parameters', None)\n            for sp in as_list(sp_list):\n                new_sps.append(GenericSetParameter.from_defined_component(sp))\n            class_dict['set-parameters'] = none_if_empty(new_sps)\n            class_dict.pop('set_parameters', None)\n\n        return cls(**class_dict)\n\n    def as_ssp(self) -&gt; ossp.ControlImplementation:\n\"\"\"Represent in ssp form.\"\"\"\n        imp_reqs = []\n        for imp_req in self.implemented_requirements:\n            imp_reqs.append(imp_req.as_ssp())\n        class_dict = self.__dict__\n        for prop in ['uuid', 'source', 'props', 'links', IMPLEMENTED_REQUIREMENTS]:\n            class_dict.pop(prop, None)\n        if imp_reqs:\n            class_dict['implemented-requirements'] = imp_reqs\n            class_dict.pop(IMPLEMENTED_REQUIREMENTS, None)\n        return ossp.ControlImplementation(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of how the specified set of controls are implemented for the containing component or capability.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.implemented_requirements","title":"<code>implemented_requirements: List[trestle.core.generic_oscal.GenericImplementedRequirement]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.set_parameters","title":"<code>set_parameters: List[trestle.core.generic_oscal.GenericSetParameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.source","title":"<code>source: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A reference to an OSCAL catalog or profile providing the referenced control or subcontrol definition.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference a set of implemented controls elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation set can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.as_ssp","title":"<code>as_ssp(self)</code>","text":"<p>Represent in ssp form.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>def as_ssp(self) -&gt; ossp.ControlImplementation:\n\"\"\"Represent in ssp form.\"\"\"\n    imp_reqs = []\n    for imp_req in self.implemented_requirements:\n        imp_reqs.append(imp_req.as_ssp())\n    class_dict = self.__dict__\n    for prop in ['uuid', 'source', 'props', 'links', IMPLEMENTED_REQUIREMENTS]:\n        class_dict.pop(prop, None)\n    if imp_reqs:\n        class_dict['implemented-requirements'] = imp_reqs\n        class_dict.pop(IMPLEMENTED_REQUIREMENTS, None)\n    return ossp.ControlImplementation(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.from_component_ci","title":"<code>from_component_ci(control_imp)</code>  <code>classmethod</code>","text":"<p>Convert component control imp to generic.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>@classmethod\ndef from_component_ci(cls, control_imp: comp.ControlImplementation) -&gt; GenericControlImplementation:\n\"\"\"Convert component control imp to generic.\"\"\"\n    class_dict = copy.deepcopy(control_imp.__dict__)\n    if IMPLEMENTED_REQUIREMENTS in class_dict:\n        new_irs = []\n        ir_list = class_dict.get(IMPLEMENTED_REQUIREMENTS, None)\n        for ir in as_list(ir_list):\n            new_ir = GenericImplementedRequirement.from_comp_def(ir)\n            new_irs.append(new_ir)\n        class_dict['implemented-requirements'] = none_if_empty(new_irs)\n        class_dict.pop(IMPLEMENTED_REQUIREMENTS, None)\n        new_sps = []\n        sp_list = class_dict.get('set_parameters', None)\n        for sp in as_list(sp_list):\n            new_sps.append(GenericSetParameter.from_defined_component(sp))\n        class_dict['set-parameters'] = none_if_empty(new_sps)\n        class_dict.pop('set_parameters', None)\n\n    return cls(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericControlImplementation.generate","title":"<code>generate()</code>  <code>staticmethod</code>","text":"<p>Generate instance of this class.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>@staticmethod\ndef generate() -&gt; GenericControlImplementation:\n\"\"\"Generate instance of this class.\"\"\"\n    uuid = str(uuid4())\n    imp_reqs = [GenericImplementedRequirement.generate()]\n    class_dict = {\n        'uuid': uuid,\n        'control-id': const.REPLACE_ME,\n        'source': const.REPLACE_ME,\n        'description': '',\n        'implemented-requirements': imp_reqs\n    }\n    return GenericControlImplementation(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement","title":"<code> GenericImplementedRequirement            (TrestleBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Generic ImplementedRequirement for SSP and DefinedComponent.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>class GenericImplementedRequirement(TrestleBaseModel):\n\"\"\"Generic ImplementedRequirement for SSP and DefinedComponent.\"\"\"\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'  # noqa FS003 F722\n    ) = Field(\n        ...,\n        description=  # noqa E251\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference a specific control implementation elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',  # noqa E501\n        title='Control Implementation Identifier',\n    )\n    control_id: constr(\n        regex=  # noqa E251\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'  # noqa E501\n    ) = Field(\n        ...,\n        alias='control-id',\n        description=  # noqa E251\n        'A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).',  # noqa E501\n        title='Control Identifier Reference',\n    )\n    # only compdef has description\n    description: str = Field(\n        ...,\n        description=  # noqa E251\n        'A description of how the specified control is implemented for the containing component or capability.',  # noqa E501\n        title='Control Implementation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    set_parameters: Optional[List[GenericSetParameter]] = Field(None, alias='set-parameters')\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    statements: Optional[List[GenericStatement]] = Field(None)\n    remarks: Optional[str] = None\n    # ssp has following\n    by_components: Optional[List[GenericByComponent]] = Field(None, alias='by-components')\n\n    @staticmethod\n    def generate() -&gt; GenericImplementedRequirement:\n\"\"\"Generate instance of this class.\"\"\"\n        uuid = str(uuid4())\n        class_dict = {'uuid': uuid, 'control-id': const.REPLACE_ME, 'description': ''}\n        return GenericImplementedRequirement(**class_dict)\n\n    @classmethod\n    def from_comp_def(cls, imp_req: comp.ImplementedRequirement) -&gt; GenericImplementedRequirement:\n\"\"\"Convert component form of imp req to generic.\"\"\"\n        class_dict = copy.deepcopy(imp_req.__dict__)\n        class_dict['control-id'] = class_dict.pop('control_id', None)\n        return cls(**class_dict)\n\n    def as_ssp(self) -&gt; ossp.ImplementedRequirement:\n\"\"\"Convert to ssp form.\"\"\"\n        class_dict = copy.deepcopy(self.__dict__)\n        del class_dict['description']\n        new_stat_list = []\n        for statement in as_list(self.statements):\n            new_stat_list.append(statement.as_ssp())\n        if new_stat_list:\n            class_dict['statements'] = new_stat_list\n        return ossp.ImplementedRequirement(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.by_components","title":"<code>by_components: List[trestle.core.generic_oscal.GenericByComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.control_id","title":"<code>control_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of how the specified control is implemented for the containing component or capability.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.set_parameters","title":"<code>set_parameters: List[trestle.core.generic_oscal.GenericSetParameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.statements","title":"<code>statements: List[trestle.core.generic_oscal.GenericStatement]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference a specific control implementation elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.as_ssp","title":"<code>as_ssp(self)</code>","text":"<p>Convert to ssp form.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>def as_ssp(self) -&gt; ossp.ImplementedRequirement:\n\"\"\"Convert to ssp form.\"\"\"\n    class_dict = copy.deepcopy(self.__dict__)\n    del class_dict['description']\n    new_stat_list = []\n    for statement in as_list(self.statements):\n        new_stat_list.append(statement.as_ssp())\n    if new_stat_list:\n        class_dict['statements'] = new_stat_list\n    return ossp.ImplementedRequirement(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.from_comp_def","title":"<code>from_comp_def(imp_req)</code>  <code>classmethod</code>","text":"<p>Convert component form of imp req to generic.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>@classmethod\ndef from_comp_def(cls, imp_req: comp.ImplementedRequirement) -&gt; GenericImplementedRequirement:\n\"\"\"Convert component form of imp req to generic.\"\"\"\n    class_dict = copy.deepcopy(imp_req.__dict__)\n    class_dict['control-id'] = class_dict.pop('control_id', None)\n    return cls(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericImplementedRequirement.generate","title":"<code>generate()</code>  <code>staticmethod</code>","text":"<p>Generate instance of this class.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>@staticmethod\ndef generate() -&gt; GenericImplementedRequirement:\n\"\"\"Generate instance of this class.\"\"\"\n    uuid = str(uuid4())\n    class_dict = {'uuid': uuid, 'control-id': const.REPLACE_ME, 'description': ''}\n    return GenericImplementedRequirement(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericSetParameter","title":"<code> GenericSetParameter            (TrestleBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Generic SetParameter for SSP and DefinedComponent.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>class GenericSetParameter(TrestleBaseModel):\n\"\"\"Generic SetParameter for SSP and DefinedComponent.\"\"\"\n\n    param_id: constr(\n        regex=  # noqa E251\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'  # noqa E501\n    ) = Field(\n        ...,\n        alias='param-id',\n        description=  # noqa E251\n        \"A human-oriented reference to a parameter within a control, who's catalog has been imported into the current implementation context.\",  # noqa E501\n        title='Parameter ID',\n    )\n    values: List[str] = Field(...)\n    remarks: Optional[str] = None\n\n    @staticmethod\n    def from_defined_component(sp: comp.SetParameter):\n\"\"\"Generate generic set parameter from comp_def version.\"\"\"\n        class_dict = {'param-id': sp.param_id, 'values': sp.values, 'remarks': sp.remarks}\n        return GenericSetParameter(**class_dict)\n\n    def to_ssp(self):\n\"\"\"Convert to ssp format.\"\"\"\n        return (ossp.SetParameter(param_id=self.param_id, values=self.values, remarks=self.remarks))\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericSetParameter-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericSetParameter.param_id","title":"<code>param_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented reference to a parameter within a control, who's catalog has been imported into the current implementation context.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericSetParameter.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericSetParameter.values","title":"<code>values: List[str]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericSetParameter-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericSetParameter.from_defined_component","title":"<code>from_defined_component(sp)</code>  <code>staticmethod</code>","text":"<p>Generate generic set parameter from comp_def version.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>@staticmethod\ndef from_defined_component(sp: comp.SetParameter):\n\"\"\"Generate generic set parameter from comp_def version.\"\"\"\n    class_dict = {'param-id': sp.param_id, 'values': sp.values, 'remarks': sp.remarks}\n    return GenericSetParameter(**class_dict)\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericSetParameter.to_ssp","title":"<code>to_ssp(self)</code>","text":"<p>Convert to ssp format.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>def to_ssp(self):\n\"\"\"Convert to ssp format.\"\"\"\n    return (ossp.SetParameter(param_id=self.param_id, values=self.values, remarks=self.remarks))\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement","title":"<code> GenericStatement            (TrestleBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Generic statement for SSP and DefinedComp.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>class GenericStatement(TrestleBaseModel):\n\"\"\"Generic statement for SSP and DefinedComp.\"\"\"\n\n    statement_id: constr(\n        regex=  # noqa E251\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'  # noqa FS003 E501\n    ) = Field(\n        ...,\n        alias='statement_id',\n        description='A human-oriented identifier reference to a control statement.',\n        title='Control Statement Reference',\n    )\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'  # noqa FS003 F722\n    ) = Field(\n        ...,\n        description=  # noqa E251\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this control statement elsewhere in this or other OSCAL instances. The UUID of the control statement in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).',  # noqa E501\n        title='Control Statement Reference Universally Unique Identifier',\n    )\n    # this is not in ssp statement\n    description: str = Field(\n        ...,\n        description='A summary of how the containing control statement is implemented by the component or capability.',\n        title='Statement Implementation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n    # ssp has following\n    by_components: Optional[List[GenericByComponent]] = Field(None, alias='by-components')\n\n    def as_ssp(self) -&gt; ossp.Statement:\n\"\"\"Represent in ssp form.\"\"\"\n        class_dict = copy.deepcopy(self.__dict__)\n        class_dict.pop('description', None)\n        by_comps = []\n        for by_comp in as_list(self.by_components):\n            new_by_comp = by_comp.as_ssp()\n            by_comps.append(new_by_comp)\n        return ossp.Statement(\n            statement_id=self.statement_id,\n            uuid=self.uuid,\n            props=self.props,\n            links=self.links,\n            responsible_roles=self.responsible_roles,\n            by_components=by_comps,\n            remarks=self.remarks\n        )\n</code></pre>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement.by_components","title":"<code>by_components: List[trestle.core.generic_oscal.GenericByComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A summary of how the containing control statement is implemented by the component or capability.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement.statement_id","title":"<code>statement_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control statement.</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this control statement elsewhere in this or other OSCAL instances. The UUID of the control statement in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).</p>"},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.generic_oscal/#trestle.core.generic_oscal.GenericStatement.as_ssp","title":"<code>as_ssp(self)</code>","text":"<p>Represent in ssp form.</p> Source code in <code>trestle/core/generic_oscal.py</code> <pre><code>def as_ssp(self) -&gt; ossp.Statement:\n\"\"\"Represent in ssp form.\"\"\"\n    class_dict = copy.deepcopy(self.__dict__)\n    class_dict.pop('description', None)\n    by_comps = []\n    for by_comp in as_list(self.by_components):\n        new_by_comp = by_comp.as_ssp()\n        by_comps.append(new_by_comp)\n    return ossp.Statement(\n        statement_id=self.statement_id,\n        uuid=self.uuid,\n        props=self.props,\n        links=self.links,\n        responsible_roles=self.responsible_roles,\n        by_components=by_comps,\n        remarks=self.remarks\n    )\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/","title":"jinja","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja","title":"<code>trestle.core.jinja</code>","text":"<p>Trestle utilities to customize .</p>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDCleanInclude","title":"<code> MDCleanInclude            (TrestleJinjaExtension)         </code>","text":"<p>Inject the parameter of the tag as the resulting content.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>class MDCleanInclude(TrestleJinjaExtension):\n\"\"\"Inject the parameter of the tag as the resulting content.\"\"\"\n\n    tags = {'md_clean_include'}\n\n    def __init__(self, environment: Environment) -&gt; None:\n\"\"\"Ensure enviroment is set and carried into class vars.\"\"\"\n        super().__init__(environment)\n\n    def parse(self, parser):\n\"\"\"Execute parsing of md token and return nodes.\"\"\"\n        kwargs = None\n        expected_heading_level = None\n        count = 0\n        while parser.stream.current.type != lexer.TOKEN_BLOCK_END:\n            count = count + 1\n            if count &gt; self.max_tag_parse:\n                raise err.TrestleError('Unexpected Jinja tag structure provided, please review docs.')\n            token = parser.stream.current\n            if token.test('name:md_clean_include'):\n                parser.stream.expect(lexer.TOKEN_NAME)\n                markdown_source = parser.stream.expect(lexer.TOKEN_STRING)\n            elif kwargs is not None:\n                arg = token.value\n                next(parser.stream)\n                parser.stream.expect(lexer.TOKEN_ASSIGN)\n                token = parser.stream.current\n                exp = self.parse_expression(parser)\n                kwargs[arg] = exp.value\n            else:\n                if parser.stream.look().type == lexer.TOKEN_ASSIGN:\n                    kwargs = {}\n                continue\n        md_content, _, _ = self.environment.loader.get_source(self.environment, markdown_source.value)\n        fm = frontmatter.loads(md_content)\n        content = fm.content\n        content += '\\n\\n'\n        if kwargs is not None:\n            expected_heading_level = kwargs.get('heading_level')\n        if expected_heading_level is not None:\n            content = adjust_heading_level(content, expected_heading_level)\n\n        local_parser = Parser(self.environment, content)\n        top_level_output = local_parser.parse()\n\n        return top_level_output.body\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDCleanInclude.identifier","title":"<code>identifier: ClassVar[str]</code>","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDCleanInclude.tags","title":"<code>tags: Set[str]</code>","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDCleanInclude-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDCleanInclude.__init__","title":"<code>__init__(self, environment)</code>  <code>special</code>","text":"Source code in <code>trestle/core/jinja.py</code> <pre><code>def __init__(self, environment: Environment) -&gt; None:\n\"\"\"Ensure enviroment is set and carried into class vars.\"\"\"\n    super().__init__(environment)\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDCleanInclude.parse","title":"<code>parse(self, parser)</code>","text":"<p>Execute parsing of md token and return nodes.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>def parse(self, parser):\n\"\"\"Execute parsing of md token and return nodes.\"\"\"\n    kwargs = None\n    expected_heading_level = None\n    count = 0\n    while parser.stream.current.type != lexer.TOKEN_BLOCK_END:\n        count = count + 1\n        if count &gt; self.max_tag_parse:\n            raise err.TrestleError('Unexpected Jinja tag structure provided, please review docs.')\n        token = parser.stream.current\n        if token.test('name:md_clean_include'):\n            parser.stream.expect(lexer.TOKEN_NAME)\n            markdown_source = parser.stream.expect(lexer.TOKEN_STRING)\n        elif kwargs is not None:\n            arg = token.value\n            next(parser.stream)\n            parser.stream.expect(lexer.TOKEN_ASSIGN)\n            token = parser.stream.current\n            exp = self.parse_expression(parser)\n            kwargs[arg] = exp.value\n        else:\n            if parser.stream.look().type == lexer.TOKEN_ASSIGN:\n                kwargs = {}\n            continue\n    md_content, _, _ = self.environment.loader.get_source(self.environment, markdown_source.value)\n    fm = frontmatter.loads(md_content)\n    content = fm.content\n    content += '\\n\\n'\n    if kwargs is not None:\n        expected_heading_level = kwargs.get('heading_level')\n    if expected_heading_level is not None:\n        content = adjust_heading_level(content, expected_heading_level)\n\n    local_parser = Parser(self.environment, content)\n    top_level_output = local_parser.parse()\n\n    return top_level_output.body\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDDatestamp","title":"<code> MDDatestamp            (TrestleJinjaExtension)         </code>","text":"<p>Inject the parameter of the tag as the resulting content.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>class MDDatestamp(TrestleJinjaExtension):\n\"\"\"Inject the parameter of the tag as the resulting content.\"\"\"\n\n    tags = {'md_datestamp'}\n\n    def __init__(self, environment: Environment) -&gt; None:\n\"\"\"Ensure enviroment is set and carried into class vars.\"\"\"\n        super().__init__(environment)\n\n    def parse(self, parser):\n\"\"\"Execute parsing of md token and return nodes.\"\"\"\n        kwargs = None\n        count = 0\n        while parser.stream.current.type != lexer.TOKEN_BLOCK_END:\n            count = count + 1\n            token = parser.stream.current\n            if count &gt; self.max_tag_parse:\n                raise err.TrestleError(f'Unexpected Jinja tag structure provided at token {token.value}')\n            if token.test('name:md_datestamp'):\n                parser.stream.expect(lexer.TOKEN_NAME)\n            elif kwargs is not None:\n                arg = token.value\n                next(parser.stream)\n                parser.stream.expect(lexer.TOKEN_ASSIGN)\n                token = parser.stream.current\n                exp = self.parse_expression(parser)\n                kwargs[arg] = exp.value\n            else:\n                if parser.stream.look().type == lexer.TOKEN_ASSIGN or parser.stream.look().type == lexer.TOKEN_STRING:\n                    kwargs = {}\n                continue\n\n        if kwargs is not None:\n            if 'format' in kwargs and type(kwargs['format'] is str):\n                date_string = date.today().strftime(kwargs['format'])\n            else:\n                date_string = date.today().strftime(markdown_const.JINJA_DATESTAMP_FORMAT)\n            if 'newline' in kwargs and kwargs['newline'] is False:\n                pass\n            else:\n                date_string += '\\n\\n'\n        else:\n            date_string = date.today().strftime(markdown_const.JINJA_DATESTAMP_FORMAT) + '\\n\\n'\n\n        local_parser = Parser(self.environment, date_string)\n        datestamp_output = local_parser.parse()\n\n        return datestamp_output.body\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDDatestamp.identifier","title":"<code>identifier: ClassVar[str]</code>","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDDatestamp.tags","title":"<code>tags: Set[str]</code>","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDDatestamp-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDDatestamp.__init__","title":"<code>__init__(self, environment)</code>  <code>special</code>","text":"Source code in <code>trestle/core/jinja.py</code> <pre><code>def __init__(self, environment: Environment) -&gt; None:\n\"\"\"Ensure enviroment is set and carried into class vars.\"\"\"\n    super().__init__(environment)\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDDatestamp.parse","title":"<code>parse(self, parser)</code>","text":"<p>Execute parsing of md token and return nodes.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>def parse(self, parser):\n\"\"\"Execute parsing of md token and return nodes.\"\"\"\n    kwargs = None\n    count = 0\n    while parser.stream.current.type != lexer.TOKEN_BLOCK_END:\n        count = count + 1\n        token = parser.stream.current\n        if count &gt; self.max_tag_parse:\n            raise err.TrestleError(f'Unexpected Jinja tag structure provided at token {token.value}')\n        if token.test('name:md_datestamp'):\n            parser.stream.expect(lexer.TOKEN_NAME)\n        elif kwargs is not None:\n            arg = token.value\n            next(parser.stream)\n            parser.stream.expect(lexer.TOKEN_ASSIGN)\n            token = parser.stream.current\n            exp = self.parse_expression(parser)\n            kwargs[arg] = exp.value\n        else:\n            if parser.stream.look().type == lexer.TOKEN_ASSIGN or parser.stream.look().type == lexer.TOKEN_STRING:\n                kwargs = {}\n            continue\n\n    if kwargs is not None:\n        if 'format' in kwargs and type(kwargs['format'] is str):\n            date_string = date.today().strftime(kwargs['format'])\n        else:\n            date_string = date.today().strftime(markdown_const.JINJA_DATESTAMP_FORMAT)\n        if 'newline' in kwargs and kwargs['newline'] is False:\n            pass\n        else:\n            date_string += '\\n\\n'\n    else:\n        date_string = date.today().strftime(markdown_const.JINJA_DATESTAMP_FORMAT) + '\\n\\n'\n\n    local_parser = Parser(self.environment, date_string)\n    datestamp_output = local_parser.parse()\n\n    return datestamp_output.body\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDSectionInclude","title":"<code> MDSectionInclude            (TrestleJinjaExtension)         </code>","text":"<p>Inject the parameter of the tag as the resulting content.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>class MDSectionInclude(TrestleJinjaExtension):\n\"\"\"Inject the parameter of the tag as the resulting content.\"\"\"\n\n    tags = {'mdsection_include'}\n\n    def __init__(self, environment: Environment) -&gt; None:\n\"\"\"Ensure enviroment is set and carried into class vars.\"\"\"\n        super().__init__(environment)\n\n    def parse(self, parser):\n\"\"\"Execute parsing of md token and return nodes.\"\"\"\n        kwargs = None\n        expected_heading_level = None\n        count = 0\n        while parser.stream.current.type != lexer.TOKEN_BLOCK_END:\n            count = count + 1\n            if count &gt; self.max_tag_parse:\n                raise err.TrestleError('Unexpected Jinja tag structure provided, please review docs.')\n            token = parser.stream.current\n            if token.test('name:mdsection_include'):\n                parser.stream.expect(lexer.TOKEN_NAME)\n                markdown_source = parser.stream.expect(lexer.TOKEN_STRING)\n                section_title = parser.stream.expect(lexer.TOKEN_STRING)\n            elif kwargs is not None:\n                arg = token.value\n                next(parser.stream)\n                parser.stream.expect(lexer.TOKEN_ASSIGN)\n                token = parser.stream.current\n                exp = self.parse_expression(parser)\n                kwargs[arg] = exp.value\n            else:\n                if parser.stream.look().type == lexer.TOKEN_ASSIGN:\n                    kwargs = {}\n                continue\n        # Use the established environment to source the file\n        md_content, _, _ = self.environment.loader.get_source(self.environment, markdown_source.value)\n        fm = frontmatter.loads(md_content)\n        if not fm.metadata == {}:\n            logger.warning('Non zero metadata on MD section include - ignoring')\n        full_md = docs_markdown_node.DocsMarkdownNode.build_tree_from_markdown(fm.content.split('\\n'))\n        md_section = full_md.get_node_for_key(section_title.value, strict_matching=True)\n        # adjust\n        if kwargs is not None:\n            expected_heading_level = kwargs.get('heading_level')\n        if expected_heading_level is not None:\n            level = md_section.get_node_header_lvl()\n            delta = int(expected_heading_level) - level\n            if not delta == 0:\n                md_section.change_header_level_by(delta)\n        if not md_section:\n            raise err.TrestleError(\n                f'Unable to retrieve section \"{section_title.value}\"\" from {markdown_source.value} jinja template.'\n            )\n        local_parser = Parser(self.environment, md_section.content.raw_text)\n        top_level_output = local_parser.parse()\n\n        return top_level_output.body\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDSectionInclude.identifier","title":"<code>identifier: ClassVar[str]</code>","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDSectionInclude.tags","title":"<code>tags: Set[str]</code>","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDSectionInclude-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDSectionInclude.__init__","title":"<code>__init__(self, environment)</code>  <code>special</code>","text":"Source code in <code>trestle/core/jinja.py</code> <pre><code>def __init__(self, environment: Environment) -&gt; None:\n\"\"\"Ensure enviroment is set and carried into class vars.\"\"\"\n    super().__init__(environment)\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.MDSectionInclude.parse","title":"<code>parse(self, parser)</code>","text":"<p>Execute parsing of md token and return nodes.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>def parse(self, parser):\n\"\"\"Execute parsing of md token and return nodes.\"\"\"\n    kwargs = None\n    expected_heading_level = None\n    count = 0\n    while parser.stream.current.type != lexer.TOKEN_BLOCK_END:\n        count = count + 1\n        if count &gt; self.max_tag_parse:\n            raise err.TrestleError('Unexpected Jinja tag structure provided, please review docs.')\n        token = parser.stream.current\n        if token.test('name:mdsection_include'):\n            parser.stream.expect(lexer.TOKEN_NAME)\n            markdown_source = parser.stream.expect(lexer.TOKEN_STRING)\n            section_title = parser.stream.expect(lexer.TOKEN_STRING)\n        elif kwargs is not None:\n            arg = token.value\n            next(parser.stream)\n            parser.stream.expect(lexer.TOKEN_ASSIGN)\n            token = parser.stream.current\n            exp = self.parse_expression(parser)\n            kwargs[arg] = exp.value\n        else:\n            if parser.stream.look().type == lexer.TOKEN_ASSIGN:\n                kwargs = {}\n            continue\n    # Use the established environment to source the file\n    md_content, _, _ = self.environment.loader.get_source(self.environment, markdown_source.value)\n    fm = frontmatter.loads(md_content)\n    if not fm.metadata == {}:\n        logger.warning('Non zero metadata on MD section include - ignoring')\n    full_md = docs_markdown_node.DocsMarkdownNode.build_tree_from_markdown(fm.content.split('\\n'))\n    md_section = full_md.get_node_for_key(section_title.value, strict_matching=True)\n    # adjust\n    if kwargs is not None:\n        expected_heading_level = kwargs.get('heading_level')\n    if expected_heading_level is not None:\n        level = md_section.get_node_header_lvl()\n        delta = int(expected_heading_level) - level\n        if not delta == 0:\n            md_section.change_header_level_by(delta)\n    if not md_section:\n        raise err.TrestleError(\n            f'Unable to retrieve section \"{section_title.value}\"\" from {markdown_source.value} jinja template.'\n        )\n    local_parser = Parser(self.environment, md_section.content.raw_text)\n    top_level_output = local_parser.parse()\n\n    return top_level_output.body\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.TrestleJinjaExtension","title":"<code> TrestleJinjaExtension            (Extension)         </code>","text":"<p>Class to define common methods to be inherited from for use in trestle.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>class TrestleJinjaExtension(Extension):\n\"\"\"Class to define common methods to be inherited from for use in trestle.\"\"\"\n\n    # This\n    max_tag_parse = 20\n\n    def __init__(self, environment: Environment) -&gt; None:\n\"\"\"Ensure enviroment is set and carried into class vars.\"\"\"\n        super().__init__(environment)\n\n    @staticmethod\n    def parse_expression(parser):\n\"\"\"Safely parse jinja expression.\"\"\"\n        # Licensed under MIT from:\n        # https://github.com/MoritzS/jinja2-django-tags/blob/master/jdj_tags/extensions.py#L424\n        # Due to how the jinja2 parser works, it treats \"foo\" \"bar\" as a single\n        # string literal as it is the case in python.\n        # But the url tag in django supports multiple string arguments, e.g.\n        # \"{% url 'my_view' 'arg1' 'arg2' %}\".\n        # That's why we have to check if it's a string literal first.\n        token = parser.stream.current\n        if token.test(lexer.TOKEN_STRING):\n            expr = nodes.Const(token.value, lineno=token.lineno)\n            next(parser.stream)\n        else:\n            expr = parser.parse_expression(False)\n\n        return expr\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.TrestleJinjaExtension.identifier","title":"<code>identifier: ClassVar[str]</code>","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.TrestleJinjaExtension.max_tag_parse","title":"<code>max_tag_parse</code>","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.TrestleJinjaExtension-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.TrestleJinjaExtension.__init__","title":"<code>__init__(self, environment)</code>  <code>special</code>","text":"<p>Ensure enviroment is set and carried into class vars.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>def __init__(self, environment: Environment) -&gt; None:\n\"\"\"Ensure enviroment is set and carried into class vars.\"\"\"\n    super().__init__(environment)\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.TrestleJinjaExtension.parse_expression","title":"<code>parse_expression(parser)</code>  <code>staticmethod</code>","text":"<p>Safely parse jinja expression.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>@staticmethod\ndef parse_expression(parser):\n\"\"\"Safely parse jinja expression.\"\"\"\n    # Licensed under MIT from:\n    # https://github.com/MoritzS/jinja2-django-tags/blob/master/jdj_tags/extensions.py#L424\n    # Due to how the jinja2 parser works, it treats \"foo\" \"bar\" as a single\n    # string literal as it is the case in python.\n    # But the url tag in django supports multiple string arguments, e.g.\n    # \"{% url 'my_view' 'arg1' 'arg2' %}\".\n    # That's why we have to check if it's a string literal first.\n    token = parser.stream.current\n    if token.test(lexer.TOKEN_STRING):\n        expr = nodes.Const(token.value, lineno=token.lineno)\n        next(parser.stream)\n    else:\n        expr = parser.parse_expression(False)\n\n    return expr\n</code></pre>"},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja-functions","title":"Functions","text":""},{"location":"api_reference/trestle.core.jinja/#trestle.core.jinja.adjust_heading_level","title":"<code>adjust_heading_level(input_md, expected)</code>","text":"<p>Adjust the header level of a markdown string such that the most significant header matches the expected #'s.</p> Source code in <code>trestle/core/jinja.py</code> <pre><code>def adjust_heading_level(input_md: str, expected: int) -&gt; str:\n\"\"\"Adjust the header level of a markdown string such that the most significant header matches the expected #'s.\"\"\"\n    output_md = input_md\n    mdn = docs_markdown_node.DocsMarkdownNode.build_tree_from_markdown(input_md.split('\\n'))\n    if mdn.subnodes:\n        mdn_top_heading = mdn.subnodes[0].get_node_header_lvl()\n        delta = int(expected) - mdn_top_heading\n        if not delta == 0:\n            mdn.change_header_level_by(delta)\n            output_md = mdn.content.raw_text\n    return output_md\n</code></pre>"},{"location":"api_reference/trestle.core.links_validator/","title":"links_validator","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.links_validator/#trestle.core.links_validator","title":"<code>trestle.core.links_validator</code>","text":"<p>Validate catalog by confirming control links match resources in backmatter.</p>"},{"location":"api_reference/trestle.core.links_validator/#trestle.core.links_validator.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.links_validator/#trestle.core.links_validator-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.links_validator/#trestle.core.links_validator.LinksValidator","title":"<code> LinksValidator            (Validator)         </code>","text":"<p>Validator to confirm all uuids in links and prose match resources in backmatter.</p> Source code in <code>trestle/core/links_validator.py</code> <pre><code>class LinksValidator(Validator):\n\"\"\"Validator to confirm all uuids in links and prose match resources in backmatter.\"\"\"\n\n    def model_is_valid(\n        self, model: TopLevelOscalModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None\n    ) -&gt; bool:\n\"\"\"\n        Test if the model is valid.\n\n        args:\n            model: A top level OSCAL model.\n            quiet: Don't report msgs unless invalid.\n\n        returns:\n            Always returns True, but gives warning if links and resources are not one-to-one.\n        \"\"\"\n        refs = ModelUtils.find_uuid_refs(model)\n\n        # find uuids in backmatter\n        links: List[str] = []\n        if model.back_matter and model.back_matter.resources:\n            links = [res.uuid for res in model.back_matter.resources]\n            seen: Set[str] = set()\n            dupes = [uuid for uuid in links if uuid in seen or seen.add(uuid)]\n            if dupes:\n                if not quiet:\n                    logger.warning(f'Backmatter has  {len(dupes)} duplicate link uuids.')\n                logger.debug(f'Backmatter has {len(dupes)} duplicate link uuids: {dupes}')\n\n        links = set(links)\n        in_refs = refs.difference(links)\n        if in_refs:\n            if not quiet:\n                logger.warning(f'Model references {len(refs)} uuids and {len(in_refs)} of them are not in resources.')\n            logger.debug(f'Model references {len(in_refs)} uuids not in resources: {in_refs}')\n\n        in_links = links.difference(refs)\n        if in_links:\n            if not quiet:\n                logger.warning(f'Resources have {len(links)} uuids and {len(in_links)} are not referenced by model.')\n            logger.debug(f'Resources have {len(in_links)} uuids not referenced by model: {in_links}')\n\n        # This validator is intended just to give warnings, so it always returns True\n        return True\n</code></pre>"},{"location":"api_reference/trestle.core.links_validator/#trestle.core.links_validator.LinksValidator-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.links_validator/#trestle.core.links_validator.LinksValidator.model_is_valid","title":"<code>model_is_valid(self, model, quiet, trestle_root=None)</code>","text":"<p>Test if the model is valid.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>~TopLevelOscalModel</code> <p>A top level OSCAL model.</p> required <code>quiet</code> <code>bool</code> <p>Don't report msgs unless invalid.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Always returns True, but gives warning if links and resources are not one-to-one.</p> Source code in <code>trestle/core/links_validator.py</code> <pre><code>def model_is_valid(\n    self, model: TopLevelOscalModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None\n) -&gt; bool:\n\"\"\"\n    Test if the model is valid.\n\n    args:\n        model: A top level OSCAL model.\n        quiet: Don't report msgs unless invalid.\n\n    returns:\n        Always returns True, but gives warning if links and resources are not one-to-one.\n    \"\"\"\n    refs = ModelUtils.find_uuid_refs(model)\n\n    # find uuids in backmatter\n    links: List[str] = []\n    if model.back_matter and model.back_matter.resources:\n        links = [res.uuid for res in model.back_matter.resources]\n        seen: Set[str] = set()\n        dupes = [uuid for uuid in links if uuid in seen or seen.add(uuid)]\n        if dupes:\n            if not quiet:\n                logger.warning(f'Backmatter has  {len(dupes)} duplicate link uuids.')\n            logger.debug(f'Backmatter has {len(dupes)} duplicate link uuids: {dupes}')\n\n    links = set(links)\n    in_refs = refs.difference(links)\n    if in_refs:\n        if not quiet:\n            logger.warning(f'Model references {len(refs)} uuids and {len(in_refs)} of them are not in resources.')\n        logger.debug(f'Model references {len(in_refs)} uuids not in resources: {in_refs}')\n\n    in_links = links.difference(refs)\n    if in_links:\n        if not quiet:\n            logger.warning(f'Resources have {len(links)} uuids and {len(in_links)} are not referenced by model.')\n        logger.debug(f'Resources have {len(in_links)} uuids not referenced by model: {in_links}')\n\n    # This validator is intended just to give warnings, so it always returns True\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/","title":"base_markdown_node","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node","title":"<code>trestle.core.markdown.base_markdown_node</code>","text":"<p>A base markdown node.</p>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode","title":"<code> BaseMarkdownNode        </code>","text":"<p>Markdown will be read to the tree.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>class BaseMarkdownNode:\n\"\"\"Markdown will be read to the tree.\"\"\"\n\n    def __init__(self, key: str, content: BaseSectionContent, starting_line: int):\n\"\"\"Initialize markdown node.\"\"\"\n        self.subnodes: List[BaseMarkdownNode] = []\n        self.key = key\n        self.content = content\n        self.starting_line = starting_line\n\n    @classmethod\n    def build_tree_from_markdown(cls, lines: List[str]):\n\"\"\"Construct a tree out of the given markdown.\"\"\"\n        ob = cls.__new__(cls)\n        start_level = ob._get_max_header_lvl(lines)\n        ob, _ = ob._build_tree(lines, 'root', 0, start_level)\n        return ob\n\n    def get_all_headers_for_level(self, level: int) -&gt; Iterable[str]:\n\"\"\"Return all headers per specified level of hierarchy.\"\"\"\n        return list(\n            filter(lambda header: self._get_header_level_if_valid(header) == level, self.content.subnodes_keys)\n        ).__iter__()\n\n    def get_node_for_key(self, key: str, strict_matching: bool = True) -&gt; Optional[BaseMarkdownNode]:\n\"\"\"Return a first node for the given key, substring matching is supported. The method is case insensitive.\"\"\"\n        if not strict_matching:\n            if not any([key.lower() in el.lower() for el in self.content.subnodes_keys]):\n                return None\n            elif len(as_filtered_list(self.content.subnodes_keys, lambda el: key.lower() in el.lower())) &gt; 1:\n                logger.warning(f'Multiple nodes for {key} were found, only the first one will be returned.')\n        else:\n            if key.lower() not in [el.lower() for el in self.content.subnodes_keys]:\n                return None\n            elif len(as_filtered_list(self.content.subnodes_keys, lambda el: el.lower() == key.lower())) &gt; 1:\n                logger.warning(f'Multiple nodes for {key} were found, only the first one will be returned.')\n\n        return self._rec_traverse(self, key, strict_matching)\n\n    def get_all_nodes_for_keys(\n        self,\n        keys: List[str],\n        strict_matching: bool = True,\n        stop_recurse_on_first_match: bool = False\n    ) -&gt; List[BaseMarkdownNode]:\n\"\"\"\n        Return all nodes for the given keys, substring matching is supported.\n\n        Args:\n            keys: List of strings for the headers being collected\n            strict_matching: Force exact match of key with header vs. simple substring match\n            stop_recurse_on_first_match: Return first match of any of the keys and don't search subnodes\n\n        Returns: List of found markdown nodes\n        \"\"\"\n        if not strict_matching:\n            if not any([key in el for el in self.content.subnodes_keys for key in keys]):\n                return []\n        elif not set(keys).intersection(self.content.subnodes_keys):\n            return []\n\n        return self._rec_traverse_all(self, keys, strict_matching, stop_recurse_on_first_match)\n\n    def get_all_headers_for_key(self, key: str, strict_matching: bool = True) -&gt; Iterable[str]:\n\"\"\"Return all headers contained in the node with a given key.\"\"\"\n        if strict_matching:\n            return list(filter(lambda header: key == header, self.content.subnodes_keys)).__iter__()\n        else:\n            return list(filter(lambda header: key in header, self.content.subnodes_keys)).__iter__()\n\n    def get_node_header_lvl(self) -&gt; Optional[int]:\n\"\"\"Return current node header level.\"\"\"\n        return self._get_header_level_if_valid(self.key)\n\n    def change_header_level_by(self, delta_level: int) -&gt; None:\n\"\"\"\n        Change all headers in the tree by specified level up or down.\n\n        All children nodes will be modified by specified level as well.\n\n        Args:\n            delta_level: each header will be modified by this number, can be negative.\n        \"\"\"\n        # construct a map\n        header_map = {}\n        if self.key != 'root':\n            new_key = self._modify_header_level(self.key, delta_level)\n            header_map[self.key] = new_key\n        for key in self.content.subnodes_keys:\n            new_key = self._modify_header_level(key, delta_level)\n            header_map[key] = new_key\n\n        # go through all contents and modify headers\n        self._rec_traverse_header_update(self, header_map)\n\n    def delete_nodes_text(self, keys: List[str], strict_matching: bool = True) -&gt; List[str]:\n\"\"\"Remove text from this node that is found in matching subnodes.\"\"\"\n        text_lines = self.content.raw_text.split('\\n')\n        matching_nodes = self.get_all_nodes_for_keys(keys, strict_matching, True)\n        # need to delete from end and proceed backwards\n        sorted_nodes = sorted(matching_nodes, key=lambda node: node.starting_line, reverse=True)\n        for node in sorted_nodes:\n            last_line = node.starting_line + len(node.content.raw_text.split('\\n'))\n            delete_list_from_list(text_lines, list(range(node.starting_line, last_line)))\n        return text_lines\n\n    @abstractmethod\n    def _build_tree(self, lines: List[str], root_key: str, starting_line: int,\n                    level: int) -&gt; Tuple[BaseMarkdownNode, int]:\n\"\"\"Build a tree from the markdown recursively.\"\"\"\n        pass\n\n    def _modify_header_level(self, header: str, delta_level: int) -&gt; str:\n\"\"\"Modify header level by specified level.\"\"\"\n        if delta_level == 0:\n            logger.debug('Nothing to modify in header, level 0 is given.')\n            return header\n\n        current_level = self._get_header_level_if_valid(header)\n        if current_level is None:\n            current_level = 0\n        if current_level + delta_level &lt; 0:\n            logger.warning(\n                f'Cannot substract {delta_level} as level of {header} is {current_level}. All `#` will be removed.'\n            )\n            delta_level = current_level * -1\n\n        if current_level + delta_level == 0:\n            replacement = ''\n        else:\n            replacement = '#' * (current_level + delta_level)\n        header = header.replace('#' * current_level, replacement)\n\n        return header.strip(' ')\n\n    def _get_header_level_if_valid(self, line: str) -&gt; Optional[int]:\n\"\"\"\n        Return a level of the header if the given line is indeed a header.\n\n        Level of the header is determined by the number of # symbols.\n        \"\"\"\n        header_symbols = re.match(md_const.HEADER_REGEX, line)\n        # Header is valid only if it line starts with header\n        if header_symbols is not None and header_symbols.regs[0][0] == 0:\n            return header_symbols.regs[0][1]\n        return None\n\n    def _does_start_with(self, line: str, start_chars: str) -&gt; bool:\n\"\"\"Determine whether the line starts with given characters.\"\"\"\n        return line.startswith(start_chars)\n\n    def _does_contain(self, line: str, reg: str) -&gt; bool:\n\"\"\"Determine if the line matches regex.\"\"\"\n        if len(line) == 0 and reg != r'':\n            return False\n        regexp = re.compile(reg)\n        return regexp.search(line) is not None\n\n    def _read_code_lines(self, lines: List[str], line: str, i: int) -&gt; tuple[list[str], int]:\n\"\"\"Read code block.\"\"\"\n        code_lines = [line]\n        while True:\n            if i &gt;= len(lines):\n                raise TrestleError(f'Code block is not closed: {code_lines}')\n\n            line = lines[i]\n            code_lines.append(line)\n            i += 1\n            if self._does_contain(line, md_const.CODEBLOCK_DEF):\n                break\n        return code_lines, i\n\n    def _read_html_block(self, lines: List[str], line: str, i: int, ending_regex: str) -&gt; tuple[list[str], int]:\n\"\"\"Read html block.\"\"\"\n        html_block = [line]\n        if self._does_contain(line, r'&lt;br[ /]*&gt;'):\n            return html_block, i\n        if self._does_contain(line, ending_regex):\n            return html_block, i\n        while True:\n            if i &gt;= len(lines):\n                raise TrestleError(f'HTML block is not closed: {html_block}')\n\n            line = lines[i]\n            html_block.append(line)\n            i += 1\n            if self._does_contain(line, ending_regex):\n                break\n        return html_block, i\n\n    def _read_table_block(self, lines: List[str], line: str, i: int) -&gt; tuple[list[str], int]:\n\"\"\"Read table.\"\"\"\n        table_block = [line]\n        while True:\n            if i &gt;= len(lines):\n                return table_block, i\n\n            line = lines[i]\n            if not self._does_contain(line, md_const.TABLE_REGEX):\n                table_block.append(line)\n                break\n            table_block.append(line)\n            i += 1\n        return table_block, i\n\n    def _rec_traverse(self, node: BaseMarkdownNode, key: str, strict_matching: bool) -&gt; Optional[BaseMarkdownNode]:\n\"\"\"\n        Recursevely traverses the tree and searches for the given key.\n\n        If strict matching is turned off, node will be matched if key is a substring of the node's header.\n        \"\"\"\n        if key.lower() == node.key.lower() or (not strict_matching and key.lower() in node.key.lower()):\n            return node\n        if (not strict_matching and any([key.lower() in el.lower()\n                                         for el in node.content.subnodes_keys])) or (key.lower() in [\n                                             el.lower() for el in node.content.subnodes_keys\n                                         ]):\n            for subnode in node.subnodes:\n                matched_node = self._rec_traverse(subnode, key, strict_matching)\n                if matched_node is not None:\n                    return matched_node\n\n        return None\n\n    def _rec_traverse_all(\n        self, node: BaseMarkdownNode, keys: List[str], strict_matching: bool, stop_recurse_on_first_match: bool\n    ) -&gt; List[BaseMarkdownNode]:\n\"\"\"\n        Recursevely traverse the tree and find all nodes matching the keys.\n\n        If strict matching is turned off, nodes will be matched if key is a substring of the node's header.\n        stop_recurse_on_first_match will return only the highest level key match and not any subnodes\n        \"\"\"\n        found_nodes: List[BaseMarkdownNode] = []\n        for key in keys:\n            if key == node.key or (not strict_matching and key in node.key):\n                found_nodes.append(node)\n                if stop_recurse_on_first_match:\n                    return found_nodes\n        for subnode in node.subnodes:\n            matched_nodes = self._rec_traverse_all(subnode, keys, strict_matching, stop_recurse_on_first_match)\n            found_nodes.extend(matched_nodes)\n        return found_nodes\n\n    def _rec_traverse_header_update(self, node: BaseMarkdownNode, header_map: Dict[str, str]) -&gt; None:\n\"\"\"Recursively traverse tree and update the contents.\"\"\"\n        if node:\n            if node.key != 'root':\n                new_key = header_map[node.key]\n                node.key = new_key\n\n            # update text\n            lines = node.content.raw_text.split('\\n')\n            if lines:\n                for i in range(0, len(lines)):\n                    line = lines[i]\n                    if line in header_map.keys():\n                        new_key = header_map[line]\n                        lines[i] = new_key\n                    elif line.strip(' ') in header_map.keys():\n                        # keep spaces if any\n                        new_key = header_map[line.strip(' ')]\n                        lines[i] = line.replace(line.strip(' '), new_key)\n\n                node.content.raw_text = '\\n'.join(lines)\n\n            # update subnodes\n            if node.content.subnodes_keys:\n                for i in range(0, len(node.content.subnodes_keys)):\n                    subnode_key = node.content.subnodes_keys[i]\n                    if subnode_key in header_map.keys():\n                        new_key = header_map[subnode_key]\n                        node.content.subnodes_keys[i] = new_key\n\n        for subnode in node.subnodes:\n            self._rec_traverse_header_update(subnode, header_map)\n\n    def _get_max_header_lvl(self, lines: List[str]):\n\"\"\"Go through all lines to determine highest header level. Less # means higher.\"\"\"\n        min_lvl = math.inf\n        for line in lines:\n            line = line.strip(' ')\n            header_lvl = self._get_header_level_if_valid(line)\n\n            if header_lvl is not None and header_lvl &lt; min_lvl:\n                min_lvl = header_lvl\n\n        return min_lvl - 1\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode.__init__","title":"<code>__init__(self, key, content, starting_line)</code>  <code>special</code>","text":"<p>Initialize markdown node.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def __init__(self, key: str, content: BaseSectionContent, starting_line: int):\n\"\"\"Initialize markdown node.\"\"\"\n    self.subnodes: List[BaseMarkdownNode] = []\n    self.key = key\n    self.content = content\n    self.starting_line = starting_line\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode.build_tree_from_markdown","title":"<code>build_tree_from_markdown(lines)</code>  <code>classmethod</code>","text":"<p>Construct a tree out of the given markdown.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>@classmethod\ndef build_tree_from_markdown(cls, lines: List[str]):\n\"\"\"Construct a tree out of the given markdown.\"\"\"\n    ob = cls.__new__(cls)\n    start_level = ob._get_max_header_lvl(lines)\n    ob, _ = ob._build_tree(lines, 'root', 0, start_level)\n    return ob\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode.change_header_level_by","title":"<code>change_header_level_by(self, delta_level)</code>","text":"<p>Change all headers in the tree by specified level up or down.</p> <p>All children nodes will be modified by specified level as well.</p> <p>Parameters:</p> Name Type Description Default <code>delta_level</code> <code>int</code> <p>each header will be modified by this number, can be negative.</p> required Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def change_header_level_by(self, delta_level: int) -&gt; None:\n\"\"\"\n    Change all headers in the tree by specified level up or down.\n\n    All children nodes will be modified by specified level as well.\n\n    Args:\n        delta_level: each header will be modified by this number, can be negative.\n    \"\"\"\n    # construct a map\n    header_map = {}\n    if self.key != 'root':\n        new_key = self._modify_header_level(self.key, delta_level)\n        header_map[self.key] = new_key\n    for key in self.content.subnodes_keys:\n        new_key = self._modify_header_level(key, delta_level)\n        header_map[key] = new_key\n\n    # go through all contents and modify headers\n    self._rec_traverse_header_update(self, header_map)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode.delete_nodes_text","title":"<code>delete_nodes_text(self, keys, strict_matching=True)</code>","text":"<p>Remove text from this node that is found in matching subnodes.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def delete_nodes_text(self, keys: List[str], strict_matching: bool = True) -&gt; List[str]:\n\"\"\"Remove text from this node that is found in matching subnodes.\"\"\"\n    text_lines = self.content.raw_text.split('\\n')\n    matching_nodes = self.get_all_nodes_for_keys(keys, strict_matching, True)\n    # need to delete from end and proceed backwards\n    sorted_nodes = sorted(matching_nodes, key=lambda node: node.starting_line, reverse=True)\n    for node in sorted_nodes:\n        last_line = node.starting_line + len(node.content.raw_text.split('\\n'))\n        delete_list_from_list(text_lines, list(range(node.starting_line, last_line)))\n    return text_lines\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode.get_all_headers_for_key","title":"<code>get_all_headers_for_key(self, key, strict_matching=True)</code>","text":"<p>Return all headers contained in the node with a given key.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def get_all_headers_for_key(self, key: str, strict_matching: bool = True) -&gt; Iterable[str]:\n\"\"\"Return all headers contained in the node with a given key.\"\"\"\n    if strict_matching:\n        return list(filter(lambda header: key == header, self.content.subnodes_keys)).__iter__()\n    else:\n        return list(filter(lambda header: key in header, self.content.subnodes_keys)).__iter__()\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode.get_all_headers_for_level","title":"<code>get_all_headers_for_level(self, level)</code>","text":"<p>Return all headers per specified level of hierarchy.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def get_all_headers_for_level(self, level: int) -&gt; Iterable[str]:\n\"\"\"Return all headers per specified level of hierarchy.\"\"\"\n    return list(\n        filter(lambda header: self._get_header_level_if_valid(header) == level, self.content.subnodes_keys)\n    ).__iter__()\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode.get_all_nodes_for_keys","title":"<code>get_all_nodes_for_keys(self, keys, strict_matching=True, stop_recurse_on_first_match=False)</code>","text":"<p>Return all nodes for the given keys, substring matching is supported.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>List[str]</code> <p>List of strings for the headers being collected</p> required <code>strict_matching</code> <code>bool</code> <p>Force exact match of key with header vs. simple substring match</p> <code>True</code> <code>stop_recurse_on_first_match</code> <code>bool</code> <p>Return first match of any of the keys and don't search subnodes</p> <code>False</code> <p>Returns: List of found markdown nodes</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def get_all_nodes_for_keys(\n    self,\n    keys: List[str],\n    strict_matching: bool = True,\n    stop_recurse_on_first_match: bool = False\n) -&gt; List[BaseMarkdownNode]:\n\"\"\"\n    Return all nodes for the given keys, substring matching is supported.\n\n    Args:\n        keys: List of strings for the headers being collected\n        strict_matching: Force exact match of key with header vs. simple substring match\n        stop_recurse_on_first_match: Return first match of any of the keys and don't search subnodes\n\n    Returns: List of found markdown nodes\n    \"\"\"\n    if not strict_matching:\n        if not any([key in el for el in self.content.subnodes_keys for key in keys]):\n            return []\n    elif not set(keys).intersection(self.content.subnodes_keys):\n        return []\n\n    return self._rec_traverse_all(self, keys, strict_matching, stop_recurse_on_first_match)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode.get_node_for_key","title":"<code>get_node_for_key(self, key, strict_matching=True)</code>","text":"<p>Return a first node for the given key, substring matching is supported. The method is case insensitive.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def get_node_for_key(self, key: str, strict_matching: bool = True) -&gt; Optional[BaseMarkdownNode]:\n\"\"\"Return a first node for the given key, substring matching is supported. The method is case insensitive.\"\"\"\n    if not strict_matching:\n        if not any([key.lower() in el.lower() for el in self.content.subnodes_keys]):\n            return None\n        elif len(as_filtered_list(self.content.subnodes_keys, lambda el: key.lower() in el.lower())) &gt; 1:\n            logger.warning(f'Multiple nodes for {key} were found, only the first one will be returned.')\n    else:\n        if key.lower() not in [el.lower() for el in self.content.subnodes_keys]:\n            return None\n        elif len(as_filtered_list(self.content.subnodes_keys, lambda el: el.lower() == key.lower())) &gt; 1:\n            logger.warning(f'Multiple nodes for {key} were found, only the first one will be returned.')\n\n    return self._rec_traverse(self, key, strict_matching)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseMarkdownNode.get_node_header_lvl","title":"<code>get_node_header_lvl(self)</code>","text":"<p>Return current node header level.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def get_node_header_lvl(self) -&gt; Optional[int]:\n\"\"\"Return current node header level.\"\"\"\n    return self._get_header_level_if_valid(self.key)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseSectionContent","title":"<code> BaseSectionContent        </code>","text":"<p>A content of the node.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>class BaseSectionContent:\n\"\"\"A content of the node.\"\"\"\n\n    def __init__(self):\n\"\"\"Initialize section content.\"\"\"\n        self.raw_text = ''\n        self.subnodes_keys = []\n\n    def union(self, node: BaseMarkdownNode) -&gt; None:\n\"\"\"Unites contents together.\"\"\"\n        self.subnodes_keys.append(node.key)\n        self.subnodes_keys.extend(node.content.subnodes_keys)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseSectionContent-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseSectionContent.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize section content.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def __init__(self):\n\"\"\"Initialize section content.\"\"\"\n    self.raw_text = ''\n    self.subnodes_keys = []\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.base_markdown_node/#trestle.core.markdown.base_markdown_node.BaseSectionContent.union","title":"<code>union(self, node)</code>","text":"<p>Unites contents together.</p> Source code in <code>trestle/core/markdown/base_markdown_node.py</code> <pre><code>def union(self, node: BaseMarkdownNode) -&gt; None:\n\"\"\"Unites contents together.\"\"\"\n    self.subnodes_keys.append(node.key)\n    self.subnodes_keys.extend(node.content.subnodes_keys)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/","title":"control_markdown_node","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node","title":"<code>trestle.core.markdown.control_markdown_node</code>","text":"<p>A control markdown node.</p>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.tree_context","title":"<code>tree_context</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlMarkdownNode","title":"<code> ControlMarkdownNode            (BaseMarkdownNode)         </code>","text":"<p>Markdown will be read to the tree.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>class ControlMarkdownNode(BaseMarkdownNode):\n\"\"\"Markdown will be read to the tree.\"\"\"\n\n    def __init__(self, key: str, content: ControlSectionContent, starting_line: int):\n\"\"\"Initialize markdown node.\"\"\"\n        super(ControlMarkdownNode, self).__init__(key, content, starting_line)\n        self.content: ControlSectionContent = content\n\n    def _build_tree(self,\n                    lines: List[str],\n                    root_key: str,\n                    starting_line: int,\n                    level: int,\n                    parent_part_id: str = '') -&gt; Tuple[ControlMarkdownNode, int]:\n\"\"\"\n        Build a tree from the markdown recursively.\n\n        The tree is contructed with valid headers as node's keys\n        and node's content contains everything that is under that header.\n        The subsections are placed into node's children with the same structure.\n\n        A header is valid iff the line starts with # and it is not:\n          1. Inside of the html blocks\n          2. Inside single lined in the &lt;&gt; tags\n          3. Inside the html comment\n          4. Inside any table, code block or blockquotes\n\n        Specific Control Rules:\n          1. If we are in control statement or objective, no subsections are allowed.\n        \"\"\"\n        content = ControlSectionContent()\n        node_children = []\n        i = starting_line\n\n        section_heading_type = self._get_section_heading_type(root_key)\n\n        part_id, part_name, part_title, by_id_part = self._get_part_info_from_section_name(root_key, parent_part_id,\n                                                                                           section_heading_type)\n\n        current_key_lvl = self._get_header_level_if_valid(root_key)\n\n        if section_heading_type == ControlSectionType.UNDEFINED and tree_context.control_id:\n            logger.warning(\n                f'Undefined section {root_key} is found in the markdown for control {tree_context.control_id}. '\n                f'This section will be ignored. Please make sure the spelling is correct.'\n            )\n\n        if current_key_lvl and current_key_lvl == 1 and section_heading_type != ControlSectionType.EDITABLE_CONTENT:\n            # Parse control title\n            if tree_context.control_id:\n                logger.debug(\n                    f'Duplicate control_id is found for the markdown {root_key}, '\n                    f'make sure you have reset tree context before reading another markdown.'\n                    f'Use markdown processor to avoid this error.'\n                )\n                raise TrestleError(\n                    f'Multiple top-level headers are found but only one header is allowed. See line {root_key} '\n                    f'for control {tree_context.control_id}.'\n                )\n            tree_context.control_id, tree_context.control_group, tree_context.control_title = ControlMarkdownNode._parse_control_title_line(root_key)  # noqa: E501\n            content.control_id = tree_context.control_id\n            content.control_group = tree_context.control_group\n            content.control_title = tree_context.control_title\n\n        def _strip_prose_or_none(part: Optional[common.Part]):\n            if part and part.prose:\n                part.prose = part.prose.strip() if part.prose.strip() else None\n\n        def _add_child_prose_if_need(part: common.Part, text: str, should_add: bool):\n            if should_add:\n                part.prose += text\n\n        while i &lt; len(lines):\n            line = lines[i].strip(' ')\n            header_lvl = self._get_header_level_if_valid(line)\n\n            if header_lvl is not None:\n                if header_lvl &gt;= level + 1:\n                    if section_heading_type in [ControlSectionType.STATEMENT, ControlSectionType.OBJECTIVE]:\n                        raise TrestleError(\n                            f'Control Statement or Objective sections cannot contain subsections but found: {line}.'\n                            f'Please delete this subsection and refer to docs on the required format.'\n                        )\n                    # build subtree\n                    subtree, i = self._build_tree(lines, line, i + 1, level + 1, part_id)\n                    node_children.append(subtree)\n                    content.union(subtree)\n                    if content.part and subtree.content.part and section_heading_type not in [\n                            ControlSectionType.STATEMENT, ControlSectionType.OBJECTIVE, ControlSectionType.GUIDANCE\n                    ]:\n                        # Control statement, objective and guidance have special treatment\n                        # in those sections any subsections go to the prose rather than subparts.\n                        content.part.parts = as_list(content.part.parts)\n                        content.part.parts.append(subtree.content.part)\n                    # Control parts can have general markdown in the prose, if we are in the control part\n                    # add its contents under the prose of a parent\n                    _add_child_prose_if_need(\n                        content.part,\n                        subtree.content.raw_text,\n                        section_heading_type\n                        in [ControlSectionType.STATEMENT, ControlSectionType.OBJECTIVE, ControlSectionType.GUIDANCE]\n                    )\n                    continue\n                else:\n                    i -= 1  # need to revert back one line to properly handle next heading\n                    break  # level of the header is above or equal to the current level, subtree is over\n\n            if section_heading_type not in [ControlSectionType.UNDEFINED, ControlSectionType.EDITABLE_CONTENT]:\n                # Read part\n                content.part = self._create_part_if_needed(content.part, part_name, part_id)\n                content.part.title = part_title\n                read_parts = section_heading_type in [ControlSectionType.STATEMENT, ControlSectionType.OBJECTIVE]\n                if by_id_part and section_heading_type == ControlSectionType.EDITABLE_BY_ID_PART:\n                    content.by_id_name = by_id_part\n                i = self._process_part_line(i, line, lines, content.part, read_parts=read_parts)\n                continue\n\n            # Nothing to do, simply increment\n            i += 1\n\n        first_line_to_grab = starting_line - 1 if starting_line else 0\n        content.raw_text = '\\n'.join(lines[first_line_to_grab:i])\n\n        _strip_prose_or_none(content.part)\n\n        md_node = ControlMarkdownNode(key=root_key, content=content, starting_line=first_line_to_grab)\n        md_node.subnodes = node_children\n        return md_node, i\n\n    def get_control_statement(self) -&gt; Optional[ControlMarkdownNode]:\n\"\"\"Get control statement node.\"\"\"\n        return self.get_node_for_key('## Control Statement')\n\n    def get_control_objective(self) -&gt; Optional[ControlMarkdownNode]:\n\"\"\"Get control objective node.\"\"\"\n        return self.get_node_for_key(const.CONTROL_OBJECTIVE_HEADER)\n\n    def get_control_guidance(self) -&gt; Optional[ControlMarkdownNode]:\n\"\"\"Get control guidance node.\"\"\"\n        return self.get_node_for_key('## Control Guidance')\n\n    def get_by_id_parts(self) -&gt; Dict[str, List[common.Part]]:\n\"\"\"Get by id editable parts.\"\"\"\n        part_id_to_parts_map = {}\n        for node_key in as_filtered_list(self.content.subnodes_keys, lambda k: re.match(const.PART_REGEX, k)):\n            # A by id part section\n            part_node = self.get_node_for_key(node_key)\n            if not part_node.content.part:\n                raise TrestleError(f'Error no part was found in section {part_node.key}.')\n            if part_node.content.by_id_name not in part_id_to_parts_map:\n                part_id_to_parts_map[part_node.content.by_id_name] = []\n            for subpart in part_node.subnodes:\n                # We only care about subsections of ## Part section\n                if subpart.content.part:\n                    part_id_to_parts_map[part_node.content.by_id_name].append(subpart.content.part)\n\n        return part_id_to_parts_map\n\n    def get_editable_parts_and_subparts(self) -&gt; Optional[List[common.Part]]:\n\"\"\"Get editable parts and subparts if exist.\"\"\"\n        by_id_parts = self.get_by_id_parts()\n        exclude_parts_id = list(by_id_parts.keys())\n        editable_node = self.get_node_for_key(f'# {const.EDITABLE_CONTENT}')\n        parts = self._get_subparts(editable_node, exclude_parts_id)\n        return parts\n\n    def _get_subparts(self,\n                      control_node: ControlMarkdownNode,\n                      exclude_ids: List[str] = None) -&gt; Optional[List[common.Part]]:\n\"\"\"Get subparts of the control part node if exists.\"\"\"\n        if not control_node:\n            raise TrestleError(\n                'No control node was provided to extract subparts. '\n                'Please make sure your markdown contains # Editable Content section.'\n            )\n        parts = []\n        for editable_part in as_filtered_list(control_node.subnodes, lambda p: p.content.part is not None):\n            if editable_part.content.part.id not in exclude_ids:\n                parts.append(editable_part.content.part)\n        return parts\n\n    def _get_section_heading_type(self, root_key: str) -&gt; ControlSectionType:\n\"\"\"Determine the section type based on the heading.\"\"\"\n        if root_key.lower() == '## control statement':\n            return ControlSectionType.STATEMENT\n        elif root_key.lower() == '## control objective':\n            return ControlSectionType.OBJECTIVE\n        elif root_key.lower() == '## control guidance':\n            return ControlSectionType.GUIDANCE\n        elif self._does_contain(root_key, const.PART_REGEX):\n            return ControlSectionType.EDITABLE_BY_ID_PART\n        elif f'# {const.EDITABLE_CONTENT}'.lower() in root_key.lower():\n            return ControlSectionType.EDITABLE_CONTENT\n        elif self._does_contain(root_key, const.CONTROL_REGEX):\n            return ControlSectionType.GENERIC_CONTROL_PART\n        elif '### ' in root_key.lower():\n            return ControlSectionType.GENERIC_SUBPART\n\n        return ControlSectionType.UNDEFINED\n\n    def _get_part_info_from_section_name(self, root_key: str, parent_id: str,\n                                         section_heading_type: ControlSectionType) -&gt; Tuple[str, str, str, str]:\n\"\"\"Get part information such as id, name and title based on the section heading.\"\"\"\n        part_id = ''\n        part_name = ''\n        part_title = None\n        by_part_id = None  # special case used for ## Part\n\n        if section_heading_type in [ControlSectionType.GUIDANCE, ControlSectionType.GENERIC_CONTROL_PART]:\n            prefix = const.CONTROL_HEADER + ' '\n            control_md_heading_label = root_key[len(prefix):].strip()\n            control_md_heading_label_ncname = ControlInterface.strip_to_make_ncname(control_md_heading_label)\n            control_md_heading_label_snakename = spaces_and_caps_to_snake(control_md_heading_label)\n\n        if section_heading_type == ControlSectionType.STATEMENT:\n            part_id = ControlInterface.create_statement_id(tree_context.control_id)\n            part_name = const.STATEMENT\n\n        if section_heading_type == ControlSectionType.OBJECTIVE:\n            part_id = f'{tree_context.control_id}_obj'\n            part_name = 'objective'\n\n        if section_heading_type == ControlSectionType.GUIDANCE:\n            # Read control guidance to a part object\n            part_id = ControlInterface.strip_to_make_ncname(tree_context.control_id + '_gdn')\n            part_name = control_md_heading_label_ncname\n\n        if section_heading_type == ControlSectionType.EDITABLE_BY_ID_PART:\n            # Read editable part\n            by_part_label = re.match(const.PART_REGEX, root_key.lower()).groups(0)[0]\n            control_label_map = tree_context.part_label_to_id_map.get(tree_context.control_id, None)\n            if control_label_map is None:\n                raise TrestleError(f'No label map found for control {tree_context.control_id}')\n            by_part_id = control_label_map.get(by_part_label, None)\n            if by_part_id is None:\n                raise TrestleError(f'No part id found for label {by_part_label} in control {tree_context.control_id}')\n\n            part_name = spaces_and_caps_to_snake(root_key.replace('#', '').replace('.', '').strip())\n            part_id = f'{by_part_id}'\n            part_title = root_key.replace('#', '').strip()\n\n        if section_heading_type == ControlSectionType.GENERIC_CONTROL_PART:\n            # Read other control parts to a part objects\n            part_name = control_md_heading_label_snakename\n            if tree_context.section_to_part_name_map:\n                if control_md_heading_label in tree_context.section_to_part_name_map:\n                    part_name = tree_context.section_to_part_name_map[control_md_heading_label]\n\n                part_id = f'{tree_context.control_id}_{part_name}'\n                part_title = control_md_heading_label\n            else:\n                part_id = spaces_and_caps_to_snake(tree_context.control_id + '_' + control_md_heading_label)\n\n        if section_heading_type == ControlSectionType.GENERIC_SUBPART:\n            # Read other control parts to a part objects\n            match = re.match(const.AFTER_HASHES_REGEX, root_key)\n            if not match:\n                raise TrestleError(f'Unexpected editable header {root_key} found in part {part_id}')\n            part_name_raw = match.groups(0)[0]\n            part_name = spaces_and_caps_to_snake(part_name_raw)\n            parent_suffix = parent_id + '.' if parent_id else ''\n            part_id = parent_suffix + part_name\n\n        return part_id, part_name, part_title, by_part_id\n\n    def get_other_control_parts(self) -&gt; List[Optional[ControlMarkdownNode]]:\n\"\"\"Get all other control parts that are not statement, guidance or objective.\"\"\"\n        all_other_nodes = []\n        all_control_sections = self.get_all_headers_for_key(const.CONTROL_HEADER, False)\n        control_statement = self.get_control_statement()\n        control_objective = self.get_control_objective()\n        control_guidance = self.get_control_guidance()\n        control_statement_heading = control_statement.key if control_statement else ''\n        control_objective_heading = control_objective.key if control_objective else ''\n        control_guidance_heading = control_guidance.key if control_guidance else ''\n        for heading_key in all_control_sections:\n            if heading_key not in {control_statement_heading, control_objective_heading, control_guidance_heading}:\n                section_node = self.get_node_for_key(heading_key)\n                all_other_nodes.append(section_node)\n\n        return all_other_nodes\n\n    def _create_part_if_needed(self, content_part: common.Part, part_name: str, part_id: str, prose: str = ''):\n\"\"\"Create a new part if does not exist or return existing part.\"\"\"\n        if not content_part:\n            if not tree_context.control_id:\n                raise TrestleError(\n                    f'Unexpected error, control id, group and title should be before ## Control {part_name}.'\n                    'However, none was found.'\n                )\n\n            content_part = common.Part(name=part_name, id=part_id, prose=prose)\n\n        return content_part\n\n    def _process_part_line(\n        self, line_idx: int, line: str, lines: List[str], part: common.Part, read_parts: bool = True\n    ) -&gt; int:\n\"\"\"\n        Process line for the part.\n\n        If the read_parts is given and the line starts with '-' then\n        the markdown list will be read to the subparts of the given part.\n        \"\"\"\n        if self._does_start_with(line, HTML_COMMENT_START):\n            comment_lines, line_idx = self._read_html_block(lines, line, line_idx + 1, HTML_COMMENT_END_REGEX)\n            if line_idx &gt;= len(lines):\n                return line_idx\n            line = lines[line_idx]\n\n        if self._does_start_with(line, CODEBLOCK_DEF):\n            code_lines, line_idx = self._read_code_lines(lines, line, line_idx + 1)\n            if line_idx &gt;= len(lines):\n                return line_idx\n            line = lines[line_idx]\n            part.prose += '\\n'.join(code_lines)\n\n        if not line:\n            # Empty line\n            part.prose += '\\n'\n            line_idx += 1\n            return line_idx\n\n        if line.lstrip()[0] != '-' or not read_parts:\n            # Line of text in prose\n            part.prose += line + '\\n'\n            line_idx += 1\n        else:\n            # A part of inside of statement part\n            if read_parts:\n                end_idx, parts = self._read_parts(0, line_idx, lines, part.id, [])\n                part.parts = none_if_empty(parts)\n                line_idx = end_idx\n            else:\n                logger.warning(\n                    f'{part.name} does not support subparts, ignoring {line} in control {tree_context.control_id}.'\n                )\n                line_idx += 1\n\n        return line_idx\n\n    def _read_parts(self, indent: int, ii: int, lines: List[str], parent_id: str,\n                    parts: List[common.Part]) -&gt; Tuple[int, List[common.Part]]:\n\"\"\"If indentation level goes up or down, create new list or close current one.\"\"\"\n        while True:\n            ii, new_indent, line = ControlMarkdownNode._get_next_indent(ii, lines)\n            if new_indent &lt; 0:\n                # we are done reading control statement\n                return ii, parts\n            if new_indent == indent:\n                # create new item part and add to current list of parts\n                id_text, prose = ControlMarkdownNode._read_part_id_prose(line)\n                # id_text is the part id and needs to be as a label property value\n                # if none is there then create one from previous part, or use default\n                if not id_text:\n                    prev_label = ControlInterface.get_label(parts[-1]) if parts else ''\n                    id_text = ControlMarkdownNode._create_next_label(prev_label, indent)\n                id_ = ControlInterface.strip_to_make_ncname(parent_id.rstrip('.') + '.' + id_text.strip('.'))\n                name = 'objective' if id_.find('_obj') &gt; 0 else 'item'\n                prop = common.Property(name='label', value=id_text)\n                part = common.Part(name=name, id=id_, prose=prose, props=[prop])\n                parts.append(part)\n                ii += 1\n            elif new_indent &gt; indent:\n                # add new list of parts to last part and continue\n                if len(parts) == 0:\n                    raise TrestleError(f'Improper indentation structure: {line}')\n                ii, new_parts = self._read_parts(new_indent, ii, lines, parts[-1].id, [])\n                if new_parts:\n                    parts[-1].parts = new_parts\n            else:\n                # return list of sub-parts\n                return ii, parts\n\n    @staticmethod\n    def _indent(line: str) -&gt; int:\n\"\"\"Measure indent of non-empty line.\"\"\"\n        if not line:\n            raise TrestleError('Empty line queried for indent.')\n        if line[0] not in [' ', '-']:\n            return -1\n        for ii in range(len(line)):\n            if line[ii] == '-':\n                return ii\n            # if line is indented it must start with -\n            if line[ii] != ' ':\n                break\n        raise TrestleError(f'List elements must start with -: {line}')\n\n    @staticmethod\n    def _parse_control_title_line(line: str) -&gt; Tuple[str, str, str]:\n\"\"\"Process the title line and extract the control id, group title (in brackets) and control title.\"\"\"\n        if line.count('-') == 0:\n            raise TrestleError(f'Markdown control title format error, missing - after control id: {line}')\n        split_line = line.split()\n        if len(split_line) &lt; 3 or split_line[2] != '-':\n            raise TrestleError(f'Cannot parse control markdown title for control_id group and title: {line}')\n        # first token after the #\n        control_id = split_line[1]\n        group_title_start = line.find('\\[')\n        group_title_end = line.find('\\]')\n        if group_title_start &lt; 0 or group_title_end &lt; 0 or group_title_start &gt; group_title_end:\n            raise TrestleError(f'unable to read group title for control {control_id}')\n        group_title = line[group_title_start + 2:group_title_end].strip()\n        control_title = line[group_title_end + 2:].strip()\n        return control_id, group_title, control_title\n\n    @staticmethod\n    def _read_part_id_prose(line: str) -&gt; Tuple[str, str]:\n\"\"\"Extract the part id letter or number and prose from line.\"\"\"\n        start = line.find('\\\\[')\n        end = line.find('\\\\]')\n        prose = line.strip() if start &lt; 0 else line[end + 2:].strip()\n        id_ = '' if start &lt; 0 or end &lt; 0 else line[start + 2:end]\n        return id_, prose\n\n    @staticmethod\n    def _create_next_label(prev_label: str, indent: int) -&gt; str:\n\"\"\"\n        Create new label at indent level based on previous label if available.\n\n        If previous label is available, make this the next one in the sequence.\n        Otherwise start with a or 1 on alternate levels of indentation.\n        If alphabetic label reaches z, next one is aa.\n        Numeric ranges from 1 to 9, then 10 etc.\n        \"\"\"\n        if not prev_label:\n            # assume indent goes in steps of 2\n            return ['a', '1'][(indent // 2) % 2]\n        label_prefix = ''\n        label_suffix = prev_label\n        is_char = prev_label[-1] in string.ascii_letters\n        # if it isn't ending in letter or digit just append 'a' to end\n        if not is_char and prev_label[-1] not in string.digits:\n            return prev_label + 'a'\n        # break in middle of string if mixed types\n        if len(prev_label) &gt; 1:\n            ii = len(prev_label) - 1\n            while ii &gt;= 0:\n                if prev_label[ii] not in string.ascii_letters + string.digits:\n                    break\n                if (prev_label[ii] in string.ascii_letters) != is_char:\n                    break\n                ii -= 1\n            if ii &gt;= 0:\n                label_prefix = prev_label[:(ii + 1)]\n                label_suffix = prev_label[(ii + 1):]\n\n        return label_prefix + ControlMarkdownNode._bump_label(label_suffix)\n\n    @staticmethod\n    def _bump_label(label: str) -&gt; str:\n\"\"\"\n        Find next label given a string of 1 or more pure letters or digits.\n\n        The input must be either a string of digits or a string of ascii letters - or empty string.\n        \"\"\"\n        if not label:\n            return 'a'\n        if label[0] in string.digits:\n            return str(int(label) + 1)\n        if len(label) == 1 and label[0].lower() &lt; 'z':\n            return chr(ord(label[0]) + 1)\n        # if this happens to be a string of letters, force it lowercase and bump\n        label = label.lower()\n        factor = 1\n        value = 0\n        # delta is needed because a counts as 0 when first value on right, but 1 for all others\n        delta = 0\n        for letter in label[::-1]:\n            value += (ord(letter) - ord('a') + delta) * factor\n            factor *= 26\n            delta = 1\n\n        value += 1\n\n        new_label = ''\n        delta = 0\n        while value &gt; 0:\n            new_label += chr(ord('a') + value % 26 - delta)\n            value = value // 26\n            delta = 1\n        return new_label[::-1]\n\n    @staticmethod\n    def _get_next_indent(ii: int, lines: List[str], skip_empty_lines: bool = True) -&gt; Tuple[int, int, str]:\n\"\"\"Seek to next content line.  ii remains at line read.\"\"\"\n        while 0 &lt;= ii &lt; len(lines):\n            line = lines[ii]\n            if line and not line.isspace():\n                if line[0] == '#':\n                    return ii, -1, line\n                indent = ControlMarkdownNode._indent(line)\n                if indent &gt;= 0:\n                    # extract text after -\n                    start = indent + 1\n                    while start &lt; len(line) and line[start] == ' ':\n                        start += 1\n                    if start &gt;= len(line):\n                        raise TrestleError(f'Invalid line {line}')\n                    return ii, indent, line[start:]\n                return ii, indent, line\n            elif not skip_empty_lines:\n                return ii, -1, line\n            ii += 1\n        return ii, -1, ''\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlMarkdownNode-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlMarkdownNode.__init__","title":"<code>__init__(self, key, content, starting_line)</code>  <code>special</code>","text":"Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def __init__(self, key: str, content: ControlSectionContent, starting_line: int):\n\"\"\"Initialize markdown node.\"\"\"\n    super(ControlMarkdownNode, self).__init__(key, content, starting_line)\n    self.content: ControlSectionContent = content\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlMarkdownNode.get_by_id_parts","title":"<code>get_by_id_parts(self)</code>","text":"<p>Get by id editable parts.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def get_by_id_parts(self) -&gt; Dict[str, List[common.Part]]:\n\"\"\"Get by id editable parts.\"\"\"\n    part_id_to_parts_map = {}\n    for node_key in as_filtered_list(self.content.subnodes_keys, lambda k: re.match(const.PART_REGEX, k)):\n        # A by id part section\n        part_node = self.get_node_for_key(node_key)\n        if not part_node.content.part:\n            raise TrestleError(f'Error no part was found in section {part_node.key}.')\n        if part_node.content.by_id_name not in part_id_to_parts_map:\n            part_id_to_parts_map[part_node.content.by_id_name] = []\n        for subpart in part_node.subnodes:\n            # We only care about subsections of ## Part section\n            if subpart.content.part:\n                part_id_to_parts_map[part_node.content.by_id_name].append(subpart.content.part)\n\n    return part_id_to_parts_map\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlMarkdownNode.get_control_guidance","title":"<code>get_control_guidance(self)</code>","text":"<p>Get control guidance node.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def get_control_guidance(self) -&gt; Optional[ControlMarkdownNode]:\n\"\"\"Get control guidance node.\"\"\"\n    return self.get_node_for_key('## Control Guidance')\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlMarkdownNode.get_control_objective","title":"<code>get_control_objective(self)</code>","text":"<p>Get control objective node.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def get_control_objective(self) -&gt; Optional[ControlMarkdownNode]:\n\"\"\"Get control objective node.\"\"\"\n    return self.get_node_for_key(const.CONTROL_OBJECTIVE_HEADER)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlMarkdownNode.get_control_statement","title":"<code>get_control_statement(self)</code>","text":"<p>Get control statement node.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def get_control_statement(self) -&gt; Optional[ControlMarkdownNode]:\n\"\"\"Get control statement node.\"\"\"\n    return self.get_node_for_key('## Control Statement')\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlMarkdownNode.get_editable_parts_and_subparts","title":"<code>get_editable_parts_and_subparts(self)</code>","text":"<p>Get editable parts and subparts if exist.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def get_editable_parts_and_subparts(self) -&gt; Optional[List[common.Part]]:\n\"\"\"Get editable parts and subparts if exist.\"\"\"\n    by_id_parts = self.get_by_id_parts()\n    exclude_parts_id = list(by_id_parts.keys())\n    editable_node = self.get_node_for_key(f'# {const.EDITABLE_CONTENT}')\n    parts = self._get_subparts(editable_node, exclude_parts_id)\n    return parts\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlMarkdownNode.get_other_control_parts","title":"<code>get_other_control_parts(self)</code>","text":"<p>Get all other control parts that are not statement, guidance or objective.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def get_other_control_parts(self) -&gt; List[Optional[ControlMarkdownNode]]:\n\"\"\"Get all other control parts that are not statement, guidance or objective.\"\"\"\n    all_other_nodes = []\n    all_control_sections = self.get_all_headers_for_key(const.CONTROL_HEADER, False)\n    control_statement = self.get_control_statement()\n    control_objective = self.get_control_objective()\n    control_guidance = self.get_control_guidance()\n    control_statement_heading = control_statement.key if control_statement else ''\n    control_objective_heading = control_objective.key if control_objective else ''\n    control_guidance_heading = control_guidance.key if control_guidance else ''\n    for heading_key in all_control_sections:\n        if heading_key not in {control_statement_heading, control_objective_heading, control_guidance_heading}:\n            section_node = self.get_node_for_key(heading_key)\n            all_other_nodes.append(section_node)\n\n    return all_other_nodes\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionContent","title":"<code> ControlSectionContent            (BaseSectionContent)         </code>","text":"<p>A content of the node.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>class ControlSectionContent(BaseSectionContent):\n\"\"\"A content of the node.\"\"\"\n\n    def __init__(self):\n\"\"\"Initialize section content.\n\n        Attributes:\n            part: A part that is found in markdown. A part is defined in markdown by two or more # symbols\n            by_id_name: Required for parts defined as ## Part a in a markdown\n        \"\"\"\n        super(ControlSectionContent, self).__init__()\n        self.part = None\n        self.by_id_name = ''\n\n    def union(self, node: ControlMarkdownNode) -&gt; None:\n\"\"\"Unites contents together.\"\"\"\n        super().union(node)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionContent-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionContent.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize section content.</p> <p>Attributes:</p> Name Type Description <code>part</code> <p>A part that is found in markdown. A part is defined in markdown by two or more # symbols</p> <code>by_id_name</code> <p>Required for parts defined as ## Part a in a markdown</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def __init__(self):\n\"\"\"Initialize section content.\n\n    Attributes:\n        part: A part that is found in markdown. A part is defined in markdown by two or more # symbols\n        by_id_name: Required for parts defined as ## Part a in a markdown\n    \"\"\"\n    super(ControlSectionContent, self).__init__()\n    self.part = None\n    self.by_id_name = ''\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionContent.union","title":"<code>union(self, node)</code>","text":"<p>Unites contents together.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def union(self, node: ControlMarkdownNode) -&gt; None:\n\"\"\"Unites contents together.\"\"\"\n    super().union(node)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionType","title":"<code> ControlSectionType            (Enum)         </code>","text":"<p>A type of the section in the markdown.</p> <p>Supported types: 1 - Control Statement 2 - Control Objective 3 - Control Guidance 4 - ## Part foo 5 - Control foo 6 - ### foo 7 - # Editable content</p> <p>Matching is case-insensitive.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>class ControlSectionType(Enum):\n\"\"\"A type of the section in the markdown.\n\n    Supported types:\n    1 - Control Statement\n    2 - Control Objective\n    3 - Control Guidance\n    4 - ## Part foo\n    5 - Control foo\n    6 - ### foo\n    7 - # Editable content\n\n    Matching is case-insensitive.\n    \"\"\"\n\n    STATEMENT = 1\n    OBJECTIVE = 2\n    GUIDANCE = 3\n    EDITABLE_BY_ID_PART = 4\n    GENERIC_CONTROL_PART = 5\n    GENERIC_SUBPART = 6\n    EDITABLE_CONTENT = 7\n    UNDEFINED = 8\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionType.EDITABLE_BY_ID_PART","title":"<code>EDITABLE_BY_ID_PART</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionType.EDITABLE_CONTENT","title":"<code>EDITABLE_CONTENT</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionType.GENERIC_CONTROL_PART","title":"<code>GENERIC_CONTROL_PART</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionType.GENERIC_SUBPART","title":"<code>GENERIC_SUBPART</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionType.GUIDANCE","title":"<code>GUIDANCE</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionType.OBJECTIVE","title":"<code>OBJECTIVE</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionType.STATEMENT","title":"<code>STATEMENT</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.ControlSectionType.UNDEFINED","title":"<code>UNDEFINED</code>","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.TreeContext","title":"<code> TreeContext        </code>","text":"<p>A shared singleton tree context.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>class TreeContext:\n\"\"\"A shared singleton tree context.\"\"\"\n\n    def __init__(self):\n\"\"\"Initialize tree context.\"\"\"\n        self.control_id = ''\n        self.control_group = ''\n        self.control_title = ''\n        self.part_label_to_id_map = None\n        self.section_to_part_name_map = None\n\n    def reset(self):\n\"\"\"Reset global control tree context.\"\"\"\n        self.control_id = ''\n        self.control_group = ''\n        self.control_title = ''\n        self.part_label_to_id_map = None\n        self.section_to_part_name_map = None\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.TreeContext-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.TreeContext.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize tree context.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def __init__(self):\n\"\"\"Initialize tree context.\"\"\"\n    self.control_id = ''\n    self.control_group = ''\n    self.control_title = ''\n    self.part_label_to_id_map = None\n    self.section_to_part_name_map = None\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.control_markdown_node/#trestle.core.markdown.control_markdown_node.TreeContext.reset","title":"<code>reset(self)</code>","text":"<p>Reset global control tree context.</p> Source code in <code>trestle/core/markdown/control_markdown_node.py</code> <pre><code>def reset(self):\n\"\"\"Reset global control tree context.\"\"\"\n    self.control_id = ''\n    self.control_group = ''\n    self.control_title = ''\n    self.part_label_to_id_map = None\n    self.section_to_part_name_map = None\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/","title":"docs_markdown_node","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node","title":"<code>trestle.core.markdown.docs_markdown_node</code>","text":"<p>A docs markdown node.</p>"},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node.DocsMarkdownNode","title":"<code> DocsMarkdownNode            (BaseMarkdownNode)         </code>","text":"<p>Markdown will be read to the tree.</p> Source code in <code>trestle/core/markdown/docs_markdown_node.py</code> <pre><code>class DocsMarkdownNode(BaseMarkdownNode):\n\"\"\"Markdown will be read to the tree.\"\"\"\n\n    def __init__(self, key: str, content: DocsSectionContent, starting_line: int):\n\"\"\"Initialize markdown node.\"\"\"\n        super(DocsMarkdownNode, self).__init__(key, content, starting_line)\n        self.content: DocsSectionContent = content\n\n    @classmethod\n    def build_tree_from_markdown(cls, lines: List[str], governed_header: Optional[str] = None):\n\"\"\"Construct a tree out of the given markdown.\"\"\"\n        ob = cls.__new__(cls)\n        start_level = ob._get_max_header_lvl(lines)\n        ob, _ = ob._build_tree(lines, 'root', 0, start_level, governed_header)\n        return ob\n\n    def _build_tree(\n        self,\n        lines: List[str],\n        root_key: str,\n        starting_line: int,\n        level: int,\n        governed_header: Optional[str] = None\n    ) -&gt; Tuple[DocsMarkdownNode, int]:\n\"\"\"\n        Build a tree from the markdown recursively.\n\n        The tree is contructed with valid headers as node's keys\n        and node's content contains everything that is under that header.\n        The subsections are placed into node's children with the same structure.\n\n        A header is valid iff the line starts with # and it is not:\n          1. Inside of the html blocks\n          2. Inside single lined in the &lt;&gt; tags\n          3. Inside the html comment\n          4. Inside any table, code block or blockquotes\n        \"\"\"\n        content = DocsSectionContent()\n        node_children = []\n        i = starting_line\n\n        while True:\n            if i &gt;= len(lines):\n                break\n            line = lines[i].strip(' ')\n            header_lvl = self._get_header_level_if_valid(line)\n\n            if header_lvl is not None:\n                if header_lvl &gt;= level + 1:\n                    # build subtree\n                    subtree, i = self._build_tree(lines, line, i + 1, level + 1, governed_header)\n                    node_children.append(subtree)\n                    content.union(subtree)\n                else:\n                    break  # level of the header is above or equal to the current level, subtree is over\n            elif self._does_start_with(line, md_const.CODEBLOCK_DEF):\n                code_lines, i = self._read_code_lines(lines, line, i + 1)\n                content.code_lines.extend(code_lines)\n            elif self._does_start_with(line, md_const.HTML_COMMENT_START):\n                html_lines, i = self._read_html_block(lines, line, i + 1, md_const.HTML_COMMENT_END_REGEX)\n                content.html_lines.extend(html_lines)\n            elif self._does_contain(line, md_const.HTML_TAG_REGEX_START):\n                html_lines, i = self._read_html_block(lines, line, i + 1, md_const.HTML_TAG_REGEX_END)\n                content.html_lines.extend(html_lines)\n            elif self._does_start_with(line, md_const.TABLE_SYMBOL):\n                table_block, i = self._read_table_block(lines, line, i + 1)\n                content.tables.extend(table_block)\n            elif self._does_start_with(line, md_const.BLOCKQUOTE_CHAR):\n                content.blockquotes.append(line)\n                i += 1\n            elif governed_header is not None and self._does_contain(\n                    root_key, fr'^[#]+ {governed_header}$') and self._does_contain(line, md_const.GOVERNED_DOC_REGEX):\n                regexp = re.compile(md_const.GOVERNED_DOC_REGEX)\n                match = regexp.search(line)\n                header = match.group(0).strip('*').strip(':')\n                content.governed_document.append(header)\n                i += 1\n            else:\n                content.text.append(line)\n                i += 1\n\n        first_line_to_grab = starting_line - 1 if starting_line else 0\n        content.raw_text = '\\n'.join(lines[first_line_to_grab:i])\n        md_node = DocsMarkdownNode(key=root_key, content=content, starting_line=first_line_to_grab)\n        md_node.subnodes = node_children\n        return md_node, i\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node.DocsMarkdownNode-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node.DocsMarkdownNode.__init__","title":"<code>__init__(self, key, content, starting_line)</code>  <code>special</code>","text":"Source code in <code>trestle/core/markdown/docs_markdown_node.py</code> <pre><code>def __init__(self, key: str, content: DocsSectionContent, starting_line: int):\n\"\"\"Initialize markdown node.\"\"\"\n    super(DocsMarkdownNode, self).__init__(key, content, starting_line)\n    self.content: DocsSectionContent = content\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node.DocsMarkdownNode.build_tree_from_markdown","title":"<code>build_tree_from_markdown(lines, governed_header=None)</code>  <code>classmethod</code>","text":"<p>Construct a tree out of the given markdown.</p> Source code in <code>trestle/core/markdown/docs_markdown_node.py</code> <pre><code>@classmethod\ndef build_tree_from_markdown(cls, lines: List[str], governed_header: Optional[str] = None):\n\"\"\"Construct a tree out of the given markdown.\"\"\"\n    ob = cls.__new__(cls)\n    start_level = ob._get_max_header_lvl(lines)\n    ob, _ = ob._build_tree(lines, 'root', 0, start_level, governed_header)\n    return ob\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node.DocsSectionContent","title":"<code> DocsSectionContent            (BaseSectionContent)         </code>","text":"<p>A content of the node.</p> Source code in <code>trestle/core/markdown/docs_markdown_node.py</code> <pre><code>class DocsSectionContent(BaseSectionContent):\n\"\"\"A content of the node.\"\"\"\n\n    def __init__(self):\n\"\"\"Initialize section content.\"\"\"\n        super(DocsSectionContent, self).__init__()\n        self.tables = []\n        self.text = []\n        self.code_lines = []\n        self.html_lines = []\n        self.blockquotes = []\n        self.governed_document = []\n\n    def union(self, node: DocsMarkdownNode) -&gt; None:\n\"\"\"Unites contents together.\"\"\"\n        super().union(node)\n        self.code_lines.extend(node.content.code_lines)\n        self.html_lines.extend(node.content.html_lines)\n        self.tables.extend(node.content.tables)\n        self.blockquotes.extend(node.content.blockquotes)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node.DocsSectionContent-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node.DocsSectionContent.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"Source code in <code>trestle/core/markdown/docs_markdown_node.py</code> <pre><code>def __init__(self):\n\"\"\"Initialize section content.\"\"\"\n    super(DocsSectionContent, self).__init__()\n    self.tables = []\n    self.text = []\n    self.code_lines = []\n    self.html_lines = []\n    self.blockquotes = []\n    self.governed_document = []\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.docs_markdown_node/#trestle.core.markdown.docs_markdown_node.DocsSectionContent.union","title":"<code>union(self, node)</code>","text":"<p>Unites contents together.</p> Source code in <code>trestle/core/markdown/docs_markdown_node.py</code> <pre><code>def union(self, node: DocsMarkdownNode) -&gt; None:\n\"\"\"Unites contents together.\"\"\"\n    super().union(node)\n    self.code_lines.extend(node.content.code_lines)\n    self.html_lines.extend(node.content.html_lines)\n    self.tables.extend(node.content.tables)\n    self.blockquotes.extend(node.content.blockquotes)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_api/","title":"markdown_api","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.markdown.markdown_api/#trestle.core.markdown.markdown_api","title":"<code>trestle.core.markdown.markdown_api</code>","text":"<p>A markdown API.</p>"},{"location":"api_reference/trestle.core.markdown.markdown_api/#trestle.core.markdown.markdown_api.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_api/#trestle.core.markdown.markdown_api-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.markdown.markdown_api/#trestle.core.markdown.markdown_api.MarkdownAPI","title":"<code> MarkdownAPI        </code>","text":"<p>A common API that wraps around the existing markdown functionality.</p> Source code in <code>trestle/core/markdown/markdown_api.py</code> <pre><code>class MarkdownAPI:\n\"\"\"A common API that wraps around the existing markdown functionality.\"\"\"\n\n    def __init__(self):\n\"\"\"Initialize markdown API.\"\"\"\n        self.processor = MarkdownProcessor()\n        self.validator = None\n\n    def load_validator_with_template(\n        self,\n        md_template_path: pathlib.Path,\n        validate_yaml_header: bool,\n        validate_md_body: bool,\n        governed_section: Optional[str] = None,\n        validate_template: bool = False\n    ) -&gt; None:\n\"\"\"Load and initialize markdown validator.\"\"\"\n        try:\n            self.processor.governed_header = governed_section\n            if validate_template:\n                template_header, template_tree = self.processor.process_markdown(md_template_path, validate_yaml_header,\n                                                                                 validate_md_body or governed_section is\n                                                                                 not None)\n            else:\n                template_header, template_tree = self.processor.process_markdown(md_template_path)\n\n            if not template_header and validate_yaml_header:\n                raise TrestleError(f'Expected yaml header for markdown template where none exists {md_template_path}')\n\n            self.validator = MarkdownValidator(\n                md_template_path,\n                template_header,\n                template_tree,\n                validate_yaml_header,\n                validate_md_body,\n                governed_section\n            )\n        except TrestleError as e:\n            raise TrestleError(f'Error while loading markdown template {md_template_path}: {e}.')\n\n    def validate_instance(self, md_instance_path: pathlib.Path) -&gt; bool:\n\"\"\"Validate a given markdown instance against a template.\"\"\"\n        if self.validator is None:\n            raise TrestleError('Markdown validator is not initialized, load template first.')\n        instance_header, instance_tree = self.processor.process_markdown(md_instance_path)\n        return self.validator.is_valid_against_template(md_instance_path, instance_header, instance_tree)\n\n    def write_markdown_with_header(self, path: pathlib.Path, header: Dict[str, str], md_body: str) -&gt; None:\n\"\"\"Write markdown with the YAML header.\"\"\"\n        try:\n            # use encoding to handle character sets as well as possible\n            with open(path, 'w', encoding=const.FILE_ENCODING, errors='replace') as md_file:\n                md_file.write('---\\n')\n                yaml.safe_dump(header, md_file, sort_keys=False)\n                md_file.write('---\\n\\n')\n                md_file.write(md_body)\n        except IOError as e:\n            raise TrestleError(f'Error while writing markdown file: {e}')\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_api/#trestle.core.markdown.markdown_api.MarkdownAPI-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.markdown_api/#trestle.core.markdown.markdown_api.MarkdownAPI.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize markdown API.</p> Source code in <code>trestle/core/markdown/markdown_api.py</code> <pre><code>def __init__(self):\n\"\"\"Initialize markdown API.\"\"\"\n    self.processor = MarkdownProcessor()\n    self.validator = None\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_api/#trestle.core.markdown.markdown_api.MarkdownAPI.load_validator_with_template","title":"<code>load_validator_with_template(self, md_template_path, validate_yaml_header, validate_md_body, governed_section=None, validate_template=False)</code>","text":"<p>Load and initialize markdown validator.</p> Source code in <code>trestle/core/markdown/markdown_api.py</code> <pre><code>def load_validator_with_template(\n    self,\n    md_template_path: pathlib.Path,\n    validate_yaml_header: bool,\n    validate_md_body: bool,\n    governed_section: Optional[str] = None,\n    validate_template: bool = False\n) -&gt; None:\n\"\"\"Load and initialize markdown validator.\"\"\"\n    try:\n        self.processor.governed_header = governed_section\n        if validate_template:\n            template_header, template_tree = self.processor.process_markdown(md_template_path, validate_yaml_header,\n                                                                             validate_md_body or governed_section is\n                                                                             not None)\n        else:\n            template_header, template_tree = self.processor.process_markdown(md_template_path)\n\n        if not template_header and validate_yaml_header:\n            raise TrestleError(f'Expected yaml header for markdown template where none exists {md_template_path}')\n\n        self.validator = MarkdownValidator(\n            md_template_path,\n            template_header,\n            template_tree,\n            validate_yaml_header,\n            validate_md_body,\n            governed_section\n        )\n    except TrestleError as e:\n        raise TrestleError(f'Error while loading markdown template {md_template_path}: {e}.')\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_api/#trestle.core.markdown.markdown_api.MarkdownAPI.validate_instance","title":"<code>validate_instance(self, md_instance_path)</code>","text":"<p>Validate a given markdown instance against a template.</p> Source code in <code>trestle/core/markdown/markdown_api.py</code> <pre><code>def validate_instance(self, md_instance_path: pathlib.Path) -&gt; bool:\n\"\"\"Validate a given markdown instance against a template.\"\"\"\n    if self.validator is None:\n        raise TrestleError('Markdown validator is not initialized, load template first.')\n    instance_header, instance_tree = self.processor.process_markdown(md_instance_path)\n    return self.validator.is_valid_against_template(md_instance_path, instance_header, instance_tree)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_api/#trestle.core.markdown.markdown_api.MarkdownAPI.write_markdown_with_header","title":"<code>write_markdown_with_header(self, path, header, md_body)</code>","text":"<p>Write markdown with the YAML header.</p> Source code in <code>trestle/core/markdown/markdown_api.py</code> <pre><code>def write_markdown_with_header(self, path: pathlib.Path, header: Dict[str, str], md_body: str) -&gt; None:\n\"\"\"Write markdown with the YAML header.\"\"\"\n    try:\n        # use encoding to handle character sets as well as possible\n        with open(path, 'w', encoding=const.FILE_ENCODING, errors='replace') as md_file:\n            md_file.write('---\\n')\n            yaml.safe_dump(header, md_file, sort_keys=False)\n            md_file.write('---\\n\\n')\n            md_file.write(md_body)\n    except IOError as e:\n        raise TrestleError(f'Error while writing markdown file: {e}')\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_const/","title":"markdown_const","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const","title":"<code>trestle.core.markdown.markdown_const</code>","text":"<p>Markdown specific constants.</p>"},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.BLOCKQUOTE_CHAR","title":"<code>BLOCKQUOTE_CHAR</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.CODEBLOCK_DEF","title":"<code>CODEBLOCK_DEF</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.GOVERNED_DOC_REGEX","title":"<code>GOVERNED_DOC_REGEX</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.HEADER_REGEX","title":"<code>HEADER_REGEX</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.HTML_COMMENT_END_REGEX","title":"<code>HTML_COMMENT_END_REGEX</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.HTML_COMMENT_START","title":"<code>HTML_COMMENT_START</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.HTML_TAG_REGEX_END","title":"<code>HTML_TAG_REGEX_END</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.HTML_TAG_REGEX_START","title":"<code>HTML_TAG_REGEX_START</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.INLINE_CODE_CHAR","title":"<code>INLINE_CODE_CHAR</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.JINJA_DATESTAMP_FORMAT","title":"<code>JINJA_DATESTAMP_FORMAT</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.LIST_CHAR","title":"<code>LIST_CHAR</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.SUBSTITUTION_REGEX","title":"<code>SUBSTITUTION_REGEX</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.TABLE_REGEX","title":"<code>TABLE_REGEX</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_const/#trestle.core.markdown.markdown_const.TABLE_SYMBOL","title":"<code>TABLE_SYMBOL</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_processor/","title":"markdown_processor","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor","title":"<code>trestle.core.markdown.markdown_processor</code>","text":"<p>A markdown processor.</p>"},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor.MarkdownProcessor","title":"<code> MarkdownProcessor        </code>","text":"<p>A markdown processor.</p> Source code in <code>trestle/core/markdown/markdown_processor.py</code> <pre><code>class MarkdownProcessor:\n\"\"\"A markdown processor.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize markdown processor.\"\"\"\n        self.governed_header = None\n\n    def render_gfm_to_html(self, markdown_text: str) -&gt; str:\n\"\"\"Render given Github Flavored Markdown to HTML.\"\"\"\n        try:\n            html = cmarkgfm.github_flavored_markdown_to_html(markdown_text)\n            return html\n        except ValueError as e:\n            raise TrestleError(f'Not a valid Github Flavored markdown: {e}.')\n\n    def process_markdown(self,\n                         md_path: pathlib.Path,\n                         read_header: bool = True,\n                         read_body: bool = True) -&gt; Tuple[Dict, DocsMarkdownNode]:\n\"\"\"Parse the markdown and builds the tree to operate over it.\"\"\"\n        header, markdown_wo_header = self.read_markdown_wo_processing(md_path, read_header, read_body)\n\n        _ = self.render_gfm_to_html(markdown_wo_header)\n\n        lines = markdown_wo_header.split('\\n')\n        tree = DocsMarkdownNode.build_tree_from_markdown(lines, self.governed_header)\n        return header, tree\n\n    def process_control_markdown(\n        self,\n        md_path: pathlib.Path,\n        cli_section_dict: Dict[str, str] = None,\n        part_label_to_id_map: Dict[str, str] = None\n    ) -&gt; Tuple[Dict, ControlMarkdownNode]:\n\"\"\"Parse control markdown and build tree with identified OSCAL components.\"\"\"\n        try:\n            header, markdown_wo_header = self.read_markdown_wo_processing(md_path, read_header=True, read_body=True)\n\n            section_to_part_name_map = {}\n            if cli_section_dict is not None:\n                # Read x-trestle-sections to the dictionary and merge it with CLI provided dictionary\n                yaml_header_sections_dict = header.get(const.SECTIONS_TAG, {})\n                merged_dict = merge_dicts(yaml_header_sections_dict, cli_section_dict)\n                section_to_part_name_map = {v: k for k, v in merged_dict.items()}\n            _ = self.render_gfm_to_html(markdown_wo_header)\n\n            lines = markdown_wo_header.split('\\n')\n            tree_context.section_to_part_name_map = section_to_part_name_map\n            tree_context.part_label_to_id_map = part_label_to_id_map\n            tree = ControlMarkdownNode.build_tree_from_markdown(lines)\n            tree_context.reset()\n            return header, tree\n        except TrestleError as e:\n            logger.error(f'Error while reading control markdown: {md_path}: {e}')\n            raise e\n\n    def read_markdown_wo_processing(self,\n                                    md_path: pathlib.Path,\n                                    read_header: bool = True,\n                                    read_body: bool = True) -&gt; Tuple[Dict, str]:\n\"\"\"Read markdown header to dictionary and body to string.\"\"\"\n        try:\n            contents = frontmatter.loads(md_path.open('r', encoding=const.FILE_ENCODING).read())\n            header = {}\n            markdown_wo_header = ''\n            if read_header:\n                header = contents.metadata\n            if read_body:\n                markdown_wo_header = contents.content\n\n            return header, markdown_wo_header\n        except UnicodeDecodeError as e:\n            logger.debug(traceback.format_exc())\n            raise TrestleError(f'Markdown cannot be decoded into {const.FILE_ENCODING}, error: {e}')\n        except ScannerError as e:\n            logger.debug(traceback.format_exc())\n            raise TrestleError(f'Header is not in a valid YAML format: {e}')\n        except FileNotFoundError as e:\n            logger.debug(traceback.format_exc())\n            raise TrestleError(f'Markdown with path {md_path}, not found: {e}')\n\n    def fetch_value_from_header(self, md_path: pathlib.Path, key: str) -&gt; Optional[str]:\n\"\"\"Fetch value for the given key from the markdown header if exists.\"\"\"\n        header, _ = self.read_markdown_wo_processing(md_path)\n        value = None\n\n        if key in header.keys():\n            value = header[key]\n\n        return value\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor.MarkdownProcessor-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor.MarkdownProcessor.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize markdown processor.</p> Source code in <code>trestle/core/markdown/markdown_processor.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize markdown processor.\"\"\"\n    self.governed_header = None\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor.MarkdownProcessor.fetch_value_from_header","title":"<code>fetch_value_from_header(self, md_path, key)</code>","text":"<p>Fetch value for the given key from the markdown header if exists.</p> Source code in <code>trestle/core/markdown/markdown_processor.py</code> <pre><code>def fetch_value_from_header(self, md_path: pathlib.Path, key: str) -&gt; Optional[str]:\n\"\"\"Fetch value for the given key from the markdown header if exists.\"\"\"\n    header, _ = self.read_markdown_wo_processing(md_path)\n    value = None\n\n    if key in header.keys():\n        value = header[key]\n\n    return value\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor.MarkdownProcessor.process_control_markdown","title":"<code>process_control_markdown(self, md_path, cli_section_dict=None, part_label_to_id_map=None)</code>","text":"<p>Parse control markdown and build tree with identified OSCAL components.</p> Source code in <code>trestle/core/markdown/markdown_processor.py</code> <pre><code>def process_control_markdown(\n    self,\n    md_path: pathlib.Path,\n    cli_section_dict: Dict[str, str] = None,\n    part_label_to_id_map: Dict[str, str] = None\n) -&gt; Tuple[Dict, ControlMarkdownNode]:\n\"\"\"Parse control markdown and build tree with identified OSCAL components.\"\"\"\n    try:\n        header, markdown_wo_header = self.read_markdown_wo_processing(md_path, read_header=True, read_body=True)\n\n        section_to_part_name_map = {}\n        if cli_section_dict is not None:\n            # Read x-trestle-sections to the dictionary and merge it with CLI provided dictionary\n            yaml_header_sections_dict = header.get(const.SECTIONS_TAG, {})\n            merged_dict = merge_dicts(yaml_header_sections_dict, cli_section_dict)\n            section_to_part_name_map = {v: k for k, v in merged_dict.items()}\n        _ = self.render_gfm_to_html(markdown_wo_header)\n\n        lines = markdown_wo_header.split('\\n')\n        tree_context.section_to_part_name_map = section_to_part_name_map\n        tree_context.part_label_to_id_map = part_label_to_id_map\n        tree = ControlMarkdownNode.build_tree_from_markdown(lines)\n        tree_context.reset()\n        return header, tree\n    except TrestleError as e:\n        logger.error(f'Error while reading control markdown: {md_path}: {e}')\n        raise e\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor.MarkdownProcessor.process_markdown","title":"<code>process_markdown(self, md_path, read_header=True, read_body=True)</code>","text":"<p>Parse the markdown and builds the tree to operate over it.</p> Source code in <code>trestle/core/markdown/markdown_processor.py</code> <pre><code>def process_markdown(self,\n                     md_path: pathlib.Path,\n                     read_header: bool = True,\n                     read_body: bool = True) -&gt; Tuple[Dict, DocsMarkdownNode]:\n\"\"\"Parse the markdown and builds the tree to operate over it.\"\"\"\n    header, markdown_wo_header = self.read_markdown_wo_processing(md_path, read_header, read_body)\n\n    _ = self.render_gfm_to_html(markdown_wo_header)\n\n    lines = markdown_wo_header.split('\\n')\n    tree = DocsMarkdownNode.build_tree_from_markdown(lines, self.governed_header)\n    return header, tree\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor.MarkdownProcessor.read_markdown_wo_processing","title":"<code>read_markdown_wo_processing(self, md_path, read_header=True, read_body=True)</code>","text":"<p>Read markdown header to dictionary and body to string.</p> Source code in <code>trestle/core/markdown/markdown_processor.py</code> <pre><code>def read_markdown_wo_processing(self,\n                                md_path: pathlib.Path,\n                                read_header: bool = True,\n                                read_body: bool = True) -&gt; Tuple[Dict, str]:\n\"\"\"Read markdown header to dictionary and body to string.\"\"\"\n    try:\n        contents = frontmatter.loads(md_path.open('r', encoding=const.FILE_ENCODING).read())\n        header = {}\n        markdown_wo_header = ''\n        if read_header:\n            header = contents.metadata\n        if read_body:\n            markdown_wo_header = contents.content\n\n        return header, markdown_wo_header\n    except UnicodeDecodeError as e:\n        logger.debug(traceback.format_exc())\n        raise TrestleError(f'Markdown cannot be decoded into {const.FILE_ENCODING}, error: {e}')\n    except ScannerError as e:\n        logger.debug(traceback.format_exc())\n        raise TrestleError(f'Header is not in a valid YAML format: {e}')\n    except FileNotFoundError as e:\n        logger.debug(traceback.format_exc())\n        raise TrestleError(f'Markdown with path {md_path}, not found: {e}')\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_processor/#trestle.core.markdown.markdown_processor.MarkdownProcessor.render_gfm_to_html","title":"<code>render_gfm_to_html(self, markdown_text)</code>","text":"<p>Render given Github Flavored Markdown to HTML.</p> Source code in <code>trestle/core/markdown/markdown_processor.py</code> <pre><code>def render_gfm_to_html(self, markdown_text: str) -&gt; str:\n\"\"\"Render given Github Flavored Markdown to HTML.\"\"\"\n    try:\n        html = cmarkgfm.github_flavored_markdown_to_html(markdown_text)\n        return html\n    except ValueError as e:\n        raise TrestleError(f'Not a valid Github Flavored markdown: {e}.')\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_validator/","title":"markdown_validator","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.markdown.markdown_validator/#trestle.core.markdown.markdown_validator","title":"<code>trestle.core.markdown.markdown_validator</code>","text":"<p>Markdown Validator.</p>"},{"location":"api_reference/trestle.core.markdown.markdown_validator/#trestle.core.markdown.markdown_validator.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.markdown.markdown_validator/#trestle.core.markdown.markdown_validator-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.markdown.markdown_validator/#trestle.core.markdown.markdown_validator.MarkdownValidator","title":"<code> MarkdownValidator        </code>","text":"<p>A markdown validator. Validates markdown instance against given template.</p> Source code in <code>trestle/core/markdown/markdown_validator.py</code> <pre><code>class MarkdownValidator:\n\"\"\"A markdown validator. Validates markdown instance against given template.\"\"\"\n\n    def __init__(\n        self,\n        tmp_path: pathlib.Path,\n        template_header: Dict,\n        template_tree: DocsMarkdownNode,\n        validate_yaml_header: bool,\n        validate_md_body: bool,\n        governed_section: Optional[str] = None\n    ):\n\"\"\"Initialize markdown validator.\"\"\"\n        self._validate_yaml_header = validate_yaml_header\n        self._validate_md_body = validate_md_body\n        self.governed_section = governed_section.strip(' ') if governed_section is not None else None\n        self.template_header = template_header\n        self.template_tree = template_tree\n        self.template_path = tmp_path\n        self.template_version = self.extract_template_version(self.template_header)\n\n        if self.template_version not in str(self.template_path):\n            raise TrestleError(\n                f'Version of the template {self.template_version} does not match the path {self.template_path}.'\n                + f'Move the template to the folder {self.template_version}'\n            )\n        if 'Version' in self.template_header.keys() and self.template_header['Version'] != self.template_version:\n            raise TrestleError(f'Version does not match template-version in template: {self.template_path}.')\n        self._ignore_headers = []\n        for key in self.template_header.keys():\n            if key.lower().startswith('x-trestle-'):\n                self._ignore_headers.append(key.lower())\n                if key.lower() == 'x-trestle-ignore':\n                    for key2 in template_header['x-trestle-ignore']:\n                        self._ignore_headers.append(key2.lower())\n\n    def is_valid_against_template(\n        self, instance: pathlib.Path, instance_header: Dict, instance_tree: DocsMarkdownNode\n    ) -&gt; bool:\n\"\"\"\n        Validate instance markdown against template.\n\n        Instance is correct against a template iff:\n            1. For YAML header keys:\n                a. All keys from the template are present and not modified\n                b. Template version in the template and instance match\n            2. On the Markdown w/o YAML header:\n                a. No additional headers of the level 1 were added\n                b. Headers were not reordered\n                c. Headers in the instance should be a superset of the template headers\n                d. Headers must be in heirarchical order (i.e. # then ### then ## is not allowed)\n            3. If Governed Header is given then:\n                a. Governed Header is not modified\n                b. All keys (i.e. key: something) inside the section are present\n\n        Args:\n            instance: a path to the markdown instance that should be validated\n            instance_header: a YAML header extracted from the markdown\n            instance_tree: a tree structure representing markdown contents\n        Returns:\n            Whether or not the the candidate is valid against the template.\n        \"\"\"\n        if self._validate_yaml_header:\n            headers_match = self.compare_keys(self.template_header, instance_header, self._ignore_headers)\n\n            if not headers_match:\n                logger.info(f'YAML header mismatch between template {self.template_path} and instance {instance}')\n                return False\n            elif headers_match and not self._validate_md_body:\n                return True\n\n        if self.governed_section is not None:\n            instance_gov_nodes = instance_tree.get_all_nodes_for_keys([self.governed_section], False)\n            template_gov_nodes = self.template_tree.get_all_nodes_for_keys([self.governed_section], False)\n\n            if not instance_gov_nodes:\n                logger.info(f'Governed section {self.governed_section} not found in instance: {instance}')\n                return False\n\n            if not template_gov_nodes:\n                logger.info(f'Governed section {self.governed_section} not found in template: {self.template_path}')\n                return False\n\n            if [node.key for node in instance_gov_nodes] != [node.key for node in template_gov_nodes]:\n                logger.info(\n                    f'Governed sections were changed, '\n                    f'template expects: {[node.key for node in template_gov_nodes]},'\n                    f'but found {[node.key for node in instance_gov_nodes]}.'\n                )\n                return False\n\n            for instance_gov_node, template_gov_node in zip(instance_gov_nodes, template_gov_nodes):\n                instance_keys = instance_gov_node.content.governed_document\n                template_keys = template_gov_node.content.governed_document\n\n                is_valid = self._validate_headings(instance, template_keys, instance_keys)\n                if not is_valid:\n                    return False\n\n        if self._validate_md_body:\n            instance_keys = instance_tree.content.subnodes_keys\n            template_keys = self.template_tree.content.subnodes_keys\n            if len(template_keys) &gt; len(instance_keys):\n                logger.info(f'Headings in the instance: {instance} were removed.')\n                return False\n\n            instance_lvl1_keys = list(instance_tree.get_all_headers_for_level(1))\n            template_lvl1_keys = list(self.template_tree.get_all_headers_for_level(1))\n            if len(template_lvl1_keys) &lt; len(instance_lvl1_keys):\n                logger.info(f'New headers of level 1 were added to the markdown instance: {instance}. ')\n                return False\n\n            is_valid = self._validate_headings(instance, template_keys, instance_keys)\n            if not is_valid:\n                return False\n\n        return True\n\n    @classmethod\n    def compare_keys(\n        cls,\n        template: Dict[str, Any],\n        candidate: Dict[str, Any],\n        ignore_fields: Optional[Dict[str, Any]] = None\n    ) -&gt; bool:\n\"\"\"\n        Compare a template dictionary against a candidate as to whether key structure is maintained.\n\n        Args:\n            template: Template dict which is used as a model of key-value pairs\n            candidate: Candidate dictionary to be measured\n        Returns:\n            Whether or not the the candidate matches the template keys.\n        \"\"\"\n        if ignore_fields is None:\n            ignore_fields = []\n        for key in list(candidate.keys()):\n            if key.lower() in ignore_fields:\n                candidate.pop(key)\n        for key in list(template.keys()):\n            if key.lower() in ignore_fields:\n                template.pop(key)\n        template_version = cls.extract_template_version(template)\n        candidate_version = cls.extract_template_version(candidate)\n        if template_version != candidate_version:\n            logger.info(f'Versions of the template {template_version} and instance {candidate_version} are different')\n            return False\n\n        if len(template.keys()) != len(candidate.keys()):\n            logger.info(f'Number of keys does not match in template {template} and instance {candidate}')\n            return False\n        for key in template.keys():\n            if key in candidate.keys():\n                if type(template[key]) == dict:\n                    if type(candidate[key]) == dict:\n                        status = cls.compare_keys(template[key], candidate[key], ignore_fields)\n                        if not status:\n                            return status\n                    else:\n                        logger.info(f'Value under {key} must be dictionary in candidate {candidate}')\n                        return False\n            else:\n                logger.info(f'Key {key} is not in candidate {candidate}')\n                return False\n        return True\n\n    def _validate_headings(self, instance: pathlib.Path, template_keys: List[str], instance_keys: List[str]) -&gt; bool:\n\"\"\"Validate instance headings against template.\"\"\"\n        if len(template_keys) &gt; len(instance_keys):\n            logger.info(\n                f'Headings in the instance: {instance} were removed.'\n                f'Expected {len(template_keys)} headings, but found only {len(instance_keys)}.'\n            )\n            return False\n        template_header_pointer = 0\n        for key in instance_keys:\n            if template_header_pointer &gt;= len(template_keys):\n                break\n            if key in template_keys and key != template_keys[template_header_pointer]:\n                logger.warning(\n                    f'Headings in the instance: {instance} were shuffled or modified. '\n                    f'\\nInstance does not have required template heading '\n                    f'\\\"{template_keys[template_header_pointer]}\\\". '\n                    f'Check if this heading was modified/present in the instance.'\n                    f'\\nPlease note that no changes to template headings are allowed, '\n                    f'including extra spaces.'\n                )\n                return False\n            elif key in template_keys and key == template_keys[template_header_pointer]:\n                template_header_pointer += 1\n            elif re.search(md_const.SUBSTITUTION_REGEX, template_keys[template_header_pointer]) is not None:\n                template_header_pointer += 1  # skip headers with substitutions\n        if template_header_pointer != len(template_keys):\n            logger.info(\n                f'Headings in the instance: {instance} were removed. '\n                f'Expected {len(template_keys)} headings, but found only {template_header_pointer}.'\n            )\n            return False\n\n        return True\n\n    @classmethod\n    def extract_template_version(cls, header: Dict[str, Any]) -&gt; Optional[str]:\n\"\"\"\n        Extract the template version from the header.\n\n        If no header is found then starting version(0.0.1) will be used by default\n        \"\"\"\n        if TEMPLATE_VERSION_HEADER not in header.keys():\n            return START_TEMPLATE_VERSION\n\n        return header[TEMPLATE_VERSION_HEADER]\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_validator/#trestle.core.markdown.markdown_validator.MarkdownValidator-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.markdown_validator/#trestle.core.markdown.markdown_validator.MarkdownValidator.__init__","title":"<code>__init__(self, tmp_path, template_header, template_tree, validate_yaml_header, validate_md_body, governed_section=None)</code>  <code>special</code>","text":"<p>Initialize markdown validator.</p> Source code in <code>trestle/core/markdown/markdown_validator.py</code> <pre><code>def __init__(\n    self,\n    tmp_path: pathlib.Path,\n    template_header: Dict,\n    template_tree: DocsMarkdownNode,\n    validate_yaml_header: bool,\n    validate_md_body: bool,\n    governed_section: Optional[str] = None\n):\n\"\"\"Initialize markdown validator.\"\"\"\n    self._validate_yaml_header = validate_yaml_header\n    self._validate_md_body = validate_md_body\n    self.governed_section = governed_section.strip(' ') if governed_section is not None else None\n    self.template_header = template_header\n    self.template_tree = template_tree\n    self.template_path = tmp_path\n    self.template_version = self.extract_template_version(self.template_header)\n\n    if self.template_version not in str(self.template_path):\n        raise TrestleError(\n            f'Version of the template {self.template_version} does not match the path {self.template_path}.'\n            + f'Move the template to the folder {self.template_version}'\n        )\n    if 'Version' in self.template_header.keys() and self.template_header['Version'] != self.template_version:\n        raise TrestleError(f'Version does not match template-version in template: {self.template_path}.')\n    self._ignore_headers = []\n    for key in self.template_header.keys():\n        if key.lower().startswith('x-trestle-'):\n            self._ignore_headers.append(key.lower())\n            if key.lower() == 'x-trestle-ignore':\n                for key2 in template_header['x-trestle-ignore']:\n                    self._ignore_headers.append(key2.lower())\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_validator/#trestle.core.markdown.markdown_validator.MarkdownValidator.compare_keys","title":"<code>compare_keys(template, candidate, ignore_fields=None)</code>  <code>classmethod</code>","text":"<p>Compare a template dictionary against a candidate as to whether key structure is maintained.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>Dict[str, Any]</code> <p>Template dict which is used as a model of key-value pairs</p> required <code>candidate</code> <code>Dict[str, Any]</code> <p>Candidate dictionary to be measured</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the the candidate matches the template keys.</p> Source code in <code>trestle/core/markdown/markdown_validator.py</code> <pre><code>@classmethod\ndef compare_keys(\n    cls,\n    template: Dict[str, Any],\n    candidate: Dict[str, Any],\n    ignore_fields: Optional[Dict[str, Any]] = None\n) -&gt; bool:\n\"\"\"\n    Compare a template dictionary against a candidate as to whether key structure is maintained.\n\n    Args:\n        template: Template dict which is used as a model of key-value pairs\n        candidate: Candidate dictionary to be measured\n    Returns:\n        Whether or not the the candidate matches the template keys.\n    \"\"\"\n    if ignore_fields is None:\n        ignore_fields = []\n    for key in list(candidate.keys()):\n        if key.lower() in ignore_fields:\n            candidate.pop(key)\n    for key in list(template.keys()):\n        if key.lower() in ignore_fields:\n            template.pop(key)\n    template_version = cls.extract_template_version(template)\n    candidate_version = cls.extract_template_version(candidate)\n    if template_version != candidate_version:\n        logger.info(f'Versions of the template {template_version} and instance {candidate_version} are different')\n        return False\n\n    if len(template.keys()) != len(candidate.keys()):\n        logger.info(f'Number of keys does not match in template {template} and instance {candidate}')\n        return False\n    for key in template.keys():\n        if key in candidate.keys():\n            if type(template[key]) == dict:\n                if type(candidate[key]) == dict:\n                    status = cls.compare_keys(template[key], candidate[key], ignore_fields)\n                    if not status:\n                        return status\n                else:\n                    logger.info(f'Value under {key} must be dictionary in candidate {candidate}')\n                    return False\n        else:\n            logger.info(f'Key {key} is not in candidate {candidate}')\n            return False\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_validator/#trestle.core.markdown.markdown_validator.MarkdownValidator.extract_template_version","title":"<code>extract_template_version(header)</code>  <code>classmethod</code>","text":"<p>Extract the template version from the header.</p> <p>If no header is found then starting version(0.0.1) will be used by default</p> Source code in <code>trestle/core/markdown/markdown_validator.py</code> <pre><code>@classmethod\ndef extract_template_version(cls, header: Dict[str, Any]) -&gt; Optional[str]:\n\"\"\"\n    Extract the template version from the header.\n\n    If no header is found then starting version(0.0.1) will be used by default\n    \"\"\"\n    if TEMPLATE_VERSION_HEADER not in header.keys():\n        return START_TEMPLATE_VERSION\n\n    return header[TEMPLATE_VERSION_HEADER]\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.markdown_validator/#trestle.core.markdown.markdown_validator.MarkdownValidator.is_valid_against_template","title":"<code>is_valid_against_template(self, instance, instance_header, instance_tree)</code>","text":"<p>Validate instance markdown against template.</p> <p>Instance is correct against a template iff:     1. For YAML header keys:         a. All keys from the template are present and not modified         b. Template version in the template and instance match     2. On the Markdown w/o YAML header:         a. No additional headers of the level 1 were added         b. Headers were not reordered         c. Headers in the instance should be a superset of the template headers         d. Headers must be in heirarchical order (i.e. # then ### then ## is not allowed)     3. If Governed Header is given then:         a. Governed Header is not modified         b. All keys (i.e. key: something) inside the section are present</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Path</code> <p>a path to the markdown instance that should be validated</p> required <code>instance_header</code> <code>Dict</code> <p>a YAML header extracted from the markdown</p> required <code>instance_tree</code> <code>DocsMarkdownNode</code> <p>a tree structure representing markdown contents</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the the candidate is valid against the template.</p> Source code in <code>trestle/core/markdown/markdown_validator.py</code> <pre><code>def is_valid_against_template(\n    self, instance: pathlib.Path, instance_header: Dict, instance_tree: DocsMarkdownNode\n) -&gt; bool:\n\"\"\"\n    Validate instance markdown against template.\n\n    Instance is correct against a template iff:\n        1. For YAML header keys:\n            a. All keys from the template are present and not modified\n            b. Template version in the template and instance match\n        2. On the Markdown w/o YAML header:\n            a. No additional headers of the level 1 were added\n            b. Headers were not reordered\n            c. Headers in the instance should be a superset of the template headers\n            d. Headers must be in heirarchical order (i.e. # then ### then ## is not allowed)\n        3. If Governed Header is given then:\n            a. Governed Header is not modified\n            b. All keys (i.e. key: something) inside the section are present\n\n    Args:\n        instance: a path to the markdown instance that should be validated\n        instance_header: a YAML header extracted from the markdown\n        instance_tree: a tree structure representing markdown contents\n    Returns:\n        Whether or not the the candidate is valid against the template.\n    \"\"\"\n    if self._validate_yaml_header:\n        headers_match = self.compare_keys(self.template_header, instance_header, self._ignore_headers)\n\n        if not headers_match:\n            logger.info(f'YAML header mismatch between template {self.template_path} and instance {instance}')\n            return False\n        elif headers_match and not self._validate_md_body:\n            return True\n\n    if self.governed_section is not None:\n        instance_gov_nodes = instance_tree.get_all_nodes_for_keys([self.governed_section], False)\n        template_gov_nodes = self.template_tree.get_all_nodes_for_keys([self.governed_section], False)\n\n        if not instance_gov_nodes:\n            logger.info(f'Governed section {self.governed_section} not found in instance: {instance}')\n            return False\n\n        if not template_gov_nodes:\n            logger.info(f'Governed section {self.governed_section} not found in template: {self.template_path}')\n            return False\n\n        if [node.key for node in instance_gov_nodes] != [node.key for node in template_gov_nodes]:\n            logger.info(\n                f'Governed sections were changed, '\n                f'template expects: {[node.key for node in template_gov_nodes]},'\n                f'but found {[node.key for node in instance_gov_nodes]}.'\n            )\n            return False\n\n        for instance_gov_node, template_gov_node in zip(instance_gov_nodes, template_gov_nodes):\n            instance_keys = instance_gov_node.content.governed_document\n            template_keys = template_gov_node.content.governed_document\n\n            is_valid = self._validate_headings(instance, template_keys, instance_keys)\n            if not is_valid:\n                return False\n\n    if self._validate_md_body:\n        instance_keys = instance_tree.content.subnodes_keys\n        template_keys = self.template_tree.content.subnodes_keys\n        if len(template_keys) &gt; len(instance_keys):\n            logger.info(f'Headings in the instance: {instance} were removed.')\n            return False\n\n        instance_lvl1_keys = list(instance_tree.get_all_headers_for_level(1))\n        template_lvl1_keys = list(self.template_tree.get_all_headers_for_level(1))\n        if len(template_lvl1_keys) &lt; len(instance_lvl1_keys):\n            logger.info(f'New headers of level 1 were added to the markdown instance: {instance}. ')\n            return False\n\n        is_valid = self._validate_headings(instance, template_keys, instance_keys)\n        if not is_valid:\n            return False\n\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/","title":"md_writer","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer","title":"<code>trestle.core.markdown.md_writer</code>","text":"<p>Create formatted markdown files with optional yaml header.</p>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter","title":"<code> MDWriter        </code>","text":"<p>Simple class to create markdown files.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>class MDWriter():\n\"\"\"Simple class to create markdown files.\"\"\"\n\n    def __init__(self, file_path: pathlib.Path, header_comments_dict: Optional[Dict[str, str]] = None):\n\"\"\"Initialize the class.\"\"\"\n        self._file_path = file_path\n        self._lines = []\n        self._indent_level = 0\n        self._indent_size = 2\n        self._yaml_header = None\n        self._header_comments_dict = header_comments_dict\n\n    def _current_indent_space(self):\n        if self._indent_level &lt;= 0:\n            return ''\n        return ' ' * (self._indent_level * self._indent_size)\n\n    def _add_line_raw(self, line: str) -&gt; None:\n        out_line = '' if self._is_blank(line) else line\n        self._lines.append(out_line)\n\n    def _add_indent_level(self, delta: int) -&gt; None:\n        self._indent_level += delta\n\n    def exists(self) -&gt; bool:\n\"\"\"Check if the file already exists.\"\"\"\n        return self._file_path.exists()\n\n    def add_yaml_header(self, header: dict) -&gt; None:\n\"\"\"Add the yaml header.\"\"\"\n        self._yaml_header = header\n\n    def set_indent_level(self, level: int) -&gt; None:\n\"\"\"Set the current indent level.\"\"\"\n        self._indent_level = level\n\n    def set_indent_step_size(self, size: int) -&gt; None:\n\"\"\"Set the indent step size in spaces.\"\"\"\n        self._indent_size = size\n\n    def _is_blank(self, line: str) -&gt; bool:\n        return line.strip() == ''\n\n    def _prev_blank_line(self) -&gt; bool:\n        return len(self._lines) &gt; 0 and self._is_blank(self._lines[-1])\n\n    def new_line(self, line: str) -&gt; None:\n\"\"\"Add a line of text to the output.\"\"\"\n        # prevent double empty lines\n        out_line = '' if self._is_blank(line) else self._current_indent_space() + line\n        if self._prev_blank_line() and out_line == '':\n            return\n        self._add_line_raw(out_line)\n\n    def new_paraline(self, line: str) -&gt; None:\n\"\"\"Add a paragraph and a line to output.\"\"\"\n        self.new_paragraph()\n        self.new_line(line)\n\n    def new_paragraph(self):\n\"\"\"Start a new paragraph.\"\"\"\n        self.new_line('')\n\n    def new_header(self, level: int, title: str, add_new_line_after_header: bool = True) -&gt; None:\n\"\"\"Add new header.\"\"\"\n        # headers might be separated by blank lines\n        self.new_paragraph()\n        self.new_line('#' * level + ' ' + title)\n        if add_new_line_after_header:\n            self.new_paragraph()\n\n    def new_hr(self) -&gt; None:\n\"\"\"Add horizontal rule.\"\"\"\n        self.new_paragraph()\n        self.new_line(const.SSP_MD_HRULE_LINE)\n        self.new_paragraph()\n\n    def new_list(self, list_: List[Any]) -&gt; None:\n\"\"\"Add a list to the markdown.\"\"\"\n        # in general this is a list of lists\n        # if string just write it out\n        if isinstance(list_, str):\n            if self._is_blank(list_):\n                self.new_paragraph()\n            else:\n                self.new_line('- ' + list_)\n        # else it is a sublist so indent\n        else:\n            self._add_indent_level(1)\n            self.new_paragraph()\n            for item in list_:\n                if self._indent_level &lt;= 0:\n                    self.new_paragraph()\n                self.new_list(item)\n            self._add_indent_level(-1)\n\n    def new_table(self, table_list: List[List[str]], header: List[str]):\n\"\"\"Add table to the markdown. All rows must be of equal length.\"\"\"\n        header_str = '| ' + ' | '.join(header) + ' |'\n        sep_str = '|---' * len(header) + '|'\n        self.new_line(header_str)\n        self.new_line(sep_str)\n        for row in table_list:\n            row_str = '| ' + ' | '.join(row) + ' |'\n            self.new_line(row_str)\n\n    def _check_header(self) -&gt; None:\n        while len(self._lines) &gt; 0 and self._lines[0] == '':\n            self._lines = self._lines[1:]\n\n    def write_out(self) -&gt; None:\n\"\"\"Write out the markdown file.\"\"\"\n        self._check_header()\n        try:\n            self._file_path.parent.mkdir(exist_ok=True, parents=True)\n            with open(self._file_path, 'w', encoding=const.FILE_ENCODING) as f:\n                # Make sure yaml header is written first\n                if self._yaml_header:\n                    f.write('---\\n')\n                    yaml = YAML()\n                    yaml.indent(mapping=2, sequence=4, offset=2)\n                    yaml.dump(self._yaml_header, f)\n                    f.write('---\\n\\n')\n\n                f.write('\\n'.join(self._lines))\n                # if last line has text it will need an extra \\n at end\n                if self._lines and self._lines[-1]:\n                    f.write('\\n')\n            # insert helpful comments into the header happens after header is written out\n            for tag, comment in as_dict(self._header_comments_dict).items():\n                if tag in as_dict(self._yaml_header):\n                    file_utils.insert_text_in_file(self._file_path, tag, comment)\n        except IOError as e:\n            logger.debug(f'md_writer error attempting to write out md file {self._file_path} {e}')\n            raise TrestleError(f'Error attempting to write out md file {self._file_path} {e}')\n\n    def get_lines(self) -&gt; List[str]:\n\"\"\"Return the current lines in the file.\"\"\"\n        return self._lines\n\n    def get_text(self) -&gt; str:\n\"\"\"Get the text as currently written.\"\"\"\n        return '\\n'.join(self._lines)\n\n    def cull_headings(self, md_in: pathlib.Path, cull_list: List[str], strict_match: bool = False) -&gt; None:\n\"\"\"\n        Cull headers from the lines of input markdown file with optional strict string match.\n\n        Args:\n            md_in: the path of the markdown file being edited\n            cull_list: the list of strings in headers that are to be culled\n            strict_match: whether to require an exact string match on header key or just a substring\n\n        Returns None and creates new markdown at the path specified during MDWriter construction\n        It is allowed to overwrite the original file\n        \"\"\"\n        markdown_api = MarkdownAPI()\n        header, content = markdown_api.processor.process_markdown(md_in)\n        self._yaml_header = header\n        self._lines = content.delete_nodes_text(cull_list, strict_match)\n        self.write_out()\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.__init__","title":"<code>__init__(self, file_path, header_comments_dict=None)</code>  <code>special</code>","text":"<p>Initialize the class.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def __init__(self, file_path: pathlib.Path, header_comments_dict: Optional[Dict[str, str]] = None):\n\"\"\"Initialize the class.\"\"\"\n    self._file_path = file_path\n    self._lines = []\n    self._indent_level = 0\n    self._indent_size = 2\n    self._yaml_header = None\n    self._header_comments_dict = header_comments_dict\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.add_yaml_header","title":"<code>add_yaml_header(self, header)</code>","text":"<p>Add the yaml header.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def add_yaml_header(self, header: dict) -&gt; None:\n\"\"\"Add the yaml header.\"\"\"\n    self._yaml_header = header\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.cull_headings","title":"<code>cull_headings(self, md_in, cull_list, strict_match=False)</code>","text":"<p>Cull headers from the lines of input markdown file with optional strict string match.</p> <p>Parameters:</p> Name Type Description Default <code>md_in</code> <code>Path</code> <p>the path of the markdown file being edited</p> required <code>cull_list</code> <code>List[str]</code> <p>the list of strings in headers that are to be culled</p> required <code>strict_match</code> <code>bool</code> <p>whether to require an exact string match on header key or just a substring</p> <code>False</code> <p>Returns None and creates new markdown at the path specified during MDWriter construction It is allowed to overwrite the original file</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def cull_headings(self, md_in: pathlib.Path, cull_list: List[str], strict_match: bool = False) -&gt; None:\n\"\"\"\n    Cull headers from the lines of input markdown file with optional strict string match.\n\n    Args:\n        md_in: the path of the markdown file being edited\n        cull_list: the list of strings in headers that are to be culled\n        strict_match: whether to require an exact string match on header key or just a substring\n\n    Returns None and creates new markdown at the path specified during MDWriter construction\n    It is allowed to overwrite the original file\n    \"\"\"\n    markdown_api = MarkdownAPI()\n    header, content = markdown_api.processor.process_markdown(md_in)\n    self._yaml_header = header\n    self._lines = content.delete_nodes_text(cull_list, strict_match)\n    self.write_out()\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.exists","title":"<code>exists(self)</code>","text":"<p>Check if the file already exists.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def exists(self) -&gt; bool:\n\"\"\"Check if the file already exists.\"\"\"\n    return self._file_path.exists()\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.get_lines","title":"<code>get_lines(self)</code>","text":"<p>Return the current lines in the file.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def get_lines(self) -&gt; List[str]:\n\"\"\"Return the current lines in the file.\"\"\"\n    return self._lines\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.get_text","title":"<code>get_text(self)</code>","text":"<p>Get the text as currently written.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def get_text(self) -&gt; str:\n\"\"\"Get the text as currently written.\"\"\"\n    return '\\n'.join(self._lines)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.new_header","title":"<code>new_header(self, level, title, add_new_line_after_header=True)</code>","text":"<p>Add new header.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def new_header(self, level: int, title: str, add_new_line_after_header: bool = True) -&gt; None:\n\"\"\"Add new header.\"\"\"\n    # headers might be separated by blank lines\n    self.new_paragraph()\n    self.new_line('#' * level + ' ' + title)\n    if add_new_line_after_header:\n        self.new_paragraph()\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.new_hr","title":"<code>new_hr(self)</code>","text":"<p>Add horizontal rule.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def new_hr(self) -&gt; None:\n\"\"\"Add horizontal rule.\"\"\"\n    self.new_paragraph()\n    self.new_line(const.SSP_MD_HRULE_LINE)\n    self.new_paragraph()\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.new_line","title":"<code>new_line(self, line)</code>","text":"<p>Add a line of text to the output.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def new_line(self, line: str) -&gt; None:\n\"\"\"Add a line of text to the output.\"\"\"\n    # prevent double empty lines\n    out_line = '' if self._is_blank(line) else self._current_indent_space() + line\n    if self._prev_blank_line() and out_line == '':\n        return\n    self._add_line_raw(out_line)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.new_list","title":"<code>new_list(self, list_)</code>","text":"<p>Add a list to the markdown.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def new_list(self, list_: List[Any]) -&gt; None:\n\"\"\"Add a list to the markdown.\"\"\"\n    # in general this is a list of lists\n    # if string just write it out\n    if isinstance(list_, str):\n        if self._is_blank(list_):\n            self.new_paragraph()\n        else:\n            self.new_line('- ' + list_)\n    # else it is a sublist so indent\n    else:\n        self._add_indent_level(1)\n        self.new_paragraph()\n        for item in list_:\n            if self._indent_level &lt;= 0:\n                self.new_paragraph()\n            self.new_list(item)\n        self._add_indent_level(-1)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.new_paragraph","title":"<code>new_paragraph(self)</code>","text":"<p>Start a new paragraph.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def new_paragraph(self):\n\"\"\"Start a new paragraph.\"\"\"\n    self.new_line('')\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.new_paraline","title":"<code>new_paraline(self, line)</code>","text":"<p>Add a paragraph and a line to output.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def new_paraline(self, line: str) -&gt; None:\n\"\"\"Add a paragraph and a line to output.\"\"\"\n    self.new_paragraph()\n    self.new_line(line)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.new_table","title":"<code>new_table(self, table_list, header)</code>","text":"<p>Add table to the markdown. All rows must be of equal length.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def new_table(self, table_list: List[List[str]], header: List[str]):\n\"\"\"Add table to the markdown. All rows must be of equal length.\"\"\"\n    header_str = '| ' + ' | '.join(header) + ' |'\n    sep_str = '|---' * len(header) + '|'\n    self.new_line(header_str)\n    self.new_line(sep_str)\n    for row in table_list:\n        row_str = '| ' + ' | '.join(row) + ' |'\n        self.new_line(row_str)\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.set_indent_level","title":"<code>set_indent_level(self, level)</code>","text":"<p>Set the current indent level.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def set_indent_level(self, level: int) -&gt; None:\n\"\"\"Set the current indent level.\"\"\"\n    self._indent_level = level\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.set_indent_step_size","title":"<code>set_indent_step_size(self, size)</code>","text":"<p>Set the indent step size in spaces.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def set_indent_step_size(self, size: int) -&gt; None:\n\"\"\"Set the indent step size in spaces.\"\"\"\n    self._indent_size = size\n</code></pre>"},{"location":"api_reference/trestle.core.markdown.md_writer/#trestle.core.markdown.md_writer.MDWriter.write_out","title":"<code>write_out(self)</code>","text":"<p>Write out the markdown file.</p> Source code in <code>trestle/core/markdown/md_writer.py</code> <pre><code>def write_out(self) -&gt; None:\n\"\"\"Write out the markdown file.\"\"\"\n    self._check_header()\n    try:\n        self._file_path.parent.mkdir(exist_ok=True, parents=True)\n        with open(self._file_path, 'w', encoding=const.FILE_ENCODING) as f:\n            # Make sure yaml header is written first\n            if self._yaml_header:\n                f.write('---\\n')\n                yaml = YAML()\n                yaml.indent(mapping=2, sequence=4, offset=2)\n                yaml.dump(self._yaml_header, f)\n                f.write('---\\n\\n')\n\n            f.write('\\n'.join(self._lines))\n            # if last line has text it will need an extra \\n at end\n            if self._lines and self._lines[-1]:\n                f.write('\\n')\n        # insert helpful comments into the header happens after header is written out\n        for tag, comment in as_dict(self._header_comments_dict).items():\n            if tag in as_dict(self._yaml_header):\n                file_utils.insert_text_in_file(self._file_path, tag, comment)\n    except IOError as e:\n        logger.debug(f'md_writer error attempting to write out md file {self._file_path} {e}')\n        raise TrestleError(f'Error attempting to write out md file {self._file_path} {e}')\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/","title":"actions","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions","title":"<code>trestle.core.models.actions</code>","text":"<p>Action wrapper of a command.</p>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action","title":"<code> Action            (ABC)         </code>","text":"<p>Action wrapper of a command.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>class Action(ABC):\n\"\"\"Action wrapper of a command.\"\"\"\n\n    def __init__(self, action_type: ActionType, has_rollback: bool) -&gt; None:\n\"\"\"Initialize an base action.\"\"\"\n        self._type: ActionType = action_type\n        self._has_rollback: bool = has_rollback\n\n        # child class must set this flag once it executes\n        self._has_executed = False\n\n    def to_string(self) -&gt; str:\n\"\"\"Return a string representation.\"\"\"\n        return self.__str__()\n\n    def get_type(self) -&gt; ActionType:\n\"\"\"Return the action type.\"\"\"\n        return self._type\n\n    def _mark_executed(self) -&gt; None:\n\"\"\"Set flag that the action has been executed.\"\"\"\n        self._has_executed = True\n\n    def has_executed(self) -&gt; bool:\n\"\"\"Return if the action has been executed.\"\"\"\n        return self._has_executed\n\n    def _mark_rollback(self) -&gt; None:\n\"\"\"Set flag that the action has been rollbacked.\"\"\"\n        self._has_executed = False\n\n    def has_rollback(self) -&gt; bool:\n\"\"\"Return if rollback of the action is possible.\"\"\"\n        return self._has_rollback\n\n    def __eq__(self, other: object) -&gt; bool:\n\"\"\"Check that two actions are equal.\"\"\"\n        if not isinstance(other, Action):\n            return False\n        if self.get_type() is not other.get_type():\n            return False\n        is_eq = self.__dict__ == other.__dict__\n        return is_eq\n\n    @abstractmethod\n    def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n\n    @abstractmethod\n    def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action.__eq__","title":"<code>__eq__(self, other)</code>  <code>special</code>","text":"<p>Check that two actions are equal.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Check that two actions are equal.\"\"\"\n    if not isinstance(other, Action):\n        return False\n    if self.get_type() is not other.get_type():\n        return False\n    is_eq = self.__dict__ == other.__dict__\n    return is_eq\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action.__init__","title":"<code>__init__(self, action_type, has_rollback)</code>  <code>special</code>","text":"<p>Initialize an base action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __init__(self, action_type: ActionType, has_rollback: bool) -&gt; None:\n\"\"\"Initialize an base action.\"\"\"\n    self._type: ActionType = action_type\n    self._has_rollback: bool = has_rollback\n\n    # child class must set this flag once it executes\n    self._has_executed = False\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action.execute","title":"<code>execute(self)</code>","text":"<p>Execute the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>@abstractmethod\ndef execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action.get_type","title":"<code>get_type(self)</code>","text":"<p>Return the action type.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def get_type(self) -&gt; ActionType:\n\"\"\"Return the action type.\"\"\"\n    return self._type\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action.has_executed","title":"<code>has_executed(self)</code>","text":"<p>Return if the action has been executed.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def has_executed(self) -&gt; bool:\n\"\"\"Return if the action has been executed.\"\"\"\n    return self._has_executed\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action.has_rollback","title":"<code>has_rollback(self)</code>","text":"<p>Return if rollback of the action is possible.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def has_rollback(self) -&gt; bool:\n\"\"\"Return if rollback of the action is possible.\"\"\"\n    return self._has_rollback\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action.rollback","title":"<code>rollback(self)</code>","text":"<p>Rollback the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>@abstractmethod\ndef rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.Action.to_string","title":"<code>to_string(self)</code>","text":"<p>Return a string representation.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def to_string(self) -&gt; str:\n\"\"\"Return a string representation.\"\"\"\n    return self.__str__()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.ActionType","title":"<code> ActionType            (Enum)         </code>","text":"<p>Action type enum for different action type.</p> <p>File system related actions have code like 1 Model processing related actions have code like 2</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>class ActionType(Enum):\n\"\"\"Action type enum for different action type.\n\n    File system related actions have code like 1*\n    Model processing related actions have code like 2*\n    \"\"\"\n\n    # create a file or directory path\n    CREATE_PATH = 10\n\n    # remove a file or directory path\n    REMOVE_PATH = 12\n\n    # write element to a destination file or stream\n    WRITE = 11\n\n    # update or add the element at the path\n    UPDATE = 20\n\n    # remove the element at the path\n    REMOVE = 21\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.ActionType.CREATE_PATH","title":"<code>CREATE_PATH</code>","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.ActionType.REMOVE","title":"<code>REMOVE</code>","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.ActionType.REMOVE_PATH","title":"<code>REMOVE_PATH</code>","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.ActionType.UPDATE","title":"<code>UPDATE</code>","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.ActionType.WRITE","title":"<code>WRITE</code>","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.CreatePathAction","title":"<code> CreatePathAction            (Action)         </code>","text":"<p>Create a file or directory path.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>class CreatePathAction(Action):\n\"\"\"Create a file or directory path.\"\"\"\n\n    def __init__(self, sub_path: pathlib.Path, clear_content: bool = False) -&gt; None:\n\"\"\"Initialize a create path action.\n\n        It creates all the missing directories in the path.\n        If it is a file, then it also creates an empty file with the name provided\n\n        Arguments:\n            sub_path: this is the desired file or directory path that needs to be created under the project root\n        \"\"\"\n        sub_path = sub_path.resolve()\n\n        self._trestle_project_root = file_utils.extract_trestle_project_root(sub_path)\n        if self._trestle_project_root is None:\n            raise TrestleError(f'Sub path \"{sub_path}\" should be child of a valid trestle project')\n\n        self._sub_path = sub_path\n        self._created_paths: List[pathlib.Path] = []\n\n        # variables for handling with file content\n        self._clear_content = clear_content\n        self._old_file_content = None\n\n        super().__init__(ActionType.CREATE_PATH, True)\n\n    def get_trestle_project_root(self) -&gt; pathlib.Path:\n\"\"\"Return the trestle workspace root path.\"\"\"\n        return self._trestle_project_root\n\n    def get_created_paths(self) -&gt; List[pathlib.Path]:\n\"\"\"Get the list of paths that were created after being executed.\"\"\"\n        return self._created_paths\n\n    def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n        # find the start of the sub_path relative to trestle project root\n        cur_index = len(self._trestle_project_root.parts)\n\n        # loop through the sub_path parts and create as necessary\n        cur_path = self._trestle_project_root\n        while cur_index &lt; len(self._sub_path.parts):\n            part = self._sub_path.parts[cur_index]\n\n            # create a path relative to the current\n            # it starts with the project root, so we shall always create\n            # sub directories or files relative to the project root\n            cur_path = cur_path / part\n\n            # create the sub_path file or directory if it does not exists already\n            if cur_path.suffix != '':  # suffix will denote a file\n                if not cur_path.exists():\n                    # create file\n                    cur_path.touch()\n\n                    # add in the list for rollback\n                    self._created_paths.append(cur_path)\n                elif self._clear_content:\n                    # read file content for rollback\n                    with open(cur_path, 'r+', encoding=const.FILE_ENCODING) as fp:\n                        # read all content\n                        self._old_file_content = fp.read()\n\n                        # clear file content\n                        fp.truncate(0)\n            else:\n                if not cur_path.exists():\n                    # create directory\n                    cur_path.mkdir()\n\n                    # add in the list for rollback\n                    self._created_paths.append(cur_path)\n\n            # move to the next part of the sub_path parts\n            cur_index = cur_index + 1\n\n        self._mark_executed()\n\n    def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n        if self.has_executed():\n            if len(self._created_paths) &gt; 0:\n                for cur_path in reversed(self._created_paths):\n                    if cur_path.exists():\n                        if cur_path.is_file():\n                            cur_path.unlink()\n                        elif cur_path.is_dir():\n                            cur_path.rmdir()\n\n                self._created_paths.clear()\n\n            # rollback the content of a file if required\n            # we should be here only if there were no path created and the sub_part already existed\n            elif self._sub_path.is_file() and self._sub_path.exists() and self._clear_content is True:\n                if self._old_file_content is not None:\n                    with open(self._sub_path, 'w', encoding=const.FILE_ENCODING) as fp:\n                        fp.write(self._old_file_content)\n\n        self._mark_rollback()\n\n    def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n        return f'{self._type} {self._sub_path}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.CreatePathAction-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.CreatePathAction.__init__","title":"<code>__init__(self, sub_path, clear_content=False)</code>  <code>special</code>","text":"<p>Initialize a create path action.</p> <p>It creates all the missing directories in the path. If it is a file, then it also creates an empty file with the name provided</p> <p>Parameters:</p> Name Type Description Default <code>sub_path</code> <code>Path</code> <p>this is the desired file or directory path that needs to be created under the project root</p> required Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __init__(self, sub_path: pathlib.Path, clear_content: bool = False) -&gt; None:\n\"\"\"Initialize a create path action.\n\n    It creates all the missing directories in the path.\n    If it is a file, then it also creates an empty file with the name provided\n\n    Arguments:\n        sub_path: this is the desired file or directory path that needs to be created under the project root\n    \"\"\"\n    sub_path = sub_path.resolve()\n\n    self._trestle_project_root = file_utils.extract_trestle_project_root(sub_path)\n    if self._trestle_project_root is None:\n        raise TrestleError(f'Sub path \"{sub_path}\" should be child of a valid trestle project')\n\n    self._sub_path = sub_path\n    self._created_paths: List[pathlib.Path] = []\n\n    # variables for handling with file content\n    self._clear_content = clear_content\n    self._old_file_content = None\n\n    super().__init__(ActionType.CREATE_PATH, True)\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.CreatePathAction.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Return string representation.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n    return f'{self._type} {self._sub_path}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.CreatePathAction.execute","title":"<code>execute(self)</code>","text":"<p>Execute the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n    # find the start of the sub_path relative to trestle project root\n    cur_index = len(self._trestle_project_root.parts)\n\n    # loop through the sub_path parts and create as necessary\n    cur_path = self._trestle_project_root\n    while cur_index &lt; len(self._sub_path.parts):\n        part = self._sub_path.parts[cur_index]\n\n        # create a path relative to the current\n        # it starts with the project root, so we shall always create\n        # sub directories or files relative to the project root\n        cur_path = cur_path / part\n\n        # create the sub_path file or directory if it does not exists already\n        if cur_path.suffix != '':  # suffix will denote a file\n            if not cur_path.exists():\n                # create file\n                cur_path.touch()\n\n                # add in the list for rollback\n                self._created_paths.append(cur_path)\n            elif self._clear_content:\n                # read file content for rollback\n                with open(cur_path, 'r+', encoding=const.FILE_ENCODING) as fp:\n                    # read all content\n                    self._old_file_content = fp.read()\n\n                    # clear file content\n                    fp.truncate(0)\n        else:\n            if not cur_path.exists():\n                # create directory\n                cur_path.mkdir()\n\n                # add in the list for rollback\n                self._created_paths.append(cur_path)\n\n        # move to the next part of the sub_path parts\n        cur_index = cur_index + 1\n\n    self._mark_executed()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.CreatePathAction.get_created_paths","title":"<code>get_created_paths(self)</code>","text":"<p>Get the list of paths that were created after being executed.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def get_created_paths(self) -&gt; List[pathlib.Path]:\n\"\"\"Get the list of paths that were created after being executed.\"\"\"\n    return self._created_paths\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.CreatePathAction.get_trestle_project_root","title":"<code>get_trestle_project_root(self)</code>","text":"<p>Return the trestle workspace root path.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def get_trestle_project_root(self) -&gt; pathlib.Path:\n\"\"\"Return the trestle workspace root path.\"\"\"\n    return self._trestle_project_root\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.CreatePathAction.rollback","title":"<code>rollback(self)</code>","text":"<p>Rollback the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n    if self.has_executed():\n        if len(self._created_paths) &gt; 0:\n            for cur_path in reversed(self._created_paths):\n                if cur_path.exists():\n                    if cur_path.is_file():\n                        cur_path.unlink()\n                    elif cur_path.is_dir():\n                        cur_path.rmdir()\n\n            self._created_paths.clear()\n\n        # rollback the content of a file if required\n        # we should be here only if there were no path created and the sub_part already existed\n        elif self._sub_path.is_file() and self._sub_path.exists() and self._clear_content is True:\n            if self._old_file_content is not None:\n                with open(self._sub_path, 'w', encoding=const.FILE_ENCODING) as fp:\n                    fp.write(self._old_file_content)\n\n    self._mark_rollback()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemoveAction","title":"<code> RemoveAction            (Action)         </code>","text":"<p>Remove sub element at the element path in the source element.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>class RemoveAction(Action):\n\"\"\"Remove sub element at the element path in the source element.\"\"\"\n\n    def __init__(self, src_element: Element, sub_element_path: ElementPath) -&gt; None:\n\"\"\"Initialize a remove element action.\"\"\"\n        super().__init__(ActionType.REMOVE, True)\n\n        self._src_element: Element = src_element\n        self._sub_element_path: ElementPath = sub_element_path\n        self._prev_sub_element = None\n\n    def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n        self._prev_sub_element = self._src_element.get_at(self._sub_element_path)\n        self._src_element.set_at(self._sub_element_path, None)\n        self._mark_executed()\n\n    def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n        if self.has_executed():\n            self._src_element.set_at(self._sub_element_path, self._prev_sub_element)\n        self._mark_rollback()\n\n    def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n        return f'{self._type} element at {self._sub_element_path} from {self._src_element}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemoveAction-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemoveAction.__init__","title":"<code>__init__(self, src_element, sub_element_path)</code>  <code>special</code>","text":"<p>Initialize a remove element action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __init__(self, src_element: Element, sub_element_path: ElementPath) -&gt; None:\n\"\"\"Initialize a remove element action.\"\"\"\n    super().__init__(ActionType.REMOVE, True)\n\n    self._src_element: Element = src_element\n    self._sub_element_path: ElementPath = sub_element_path\n    self._prev_sub_element = None\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemoveAction.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Return string representation.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n    return f'{self._type} element at {self._sub_element_path} from {self._src_element}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemoveAction.execute","title":"<code>execute(self)</code>","text":"<p>Execute the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n    self._prev_sub_element = self._src_element.get_at(self._sub_element_path)\n    self._src_element.set_at(self._sub_element_path, None)\n    self._mark_executed()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemoveAction.rollback","title":"<code>rollback(self)</code>","text":"<p>Rollback the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n    if self.has_executed():\n        self._src_element.set_at(self._sub_element_path, self._prev_sub_element)\n    self._mark_rollback()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemovePathAction","title":"<code> RemovePathAction            (Action)         </code>","text":"<p>Remove a file or directory path.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>class RemovePathAction(Action):\n\"\"\"Remove a file or directory path.\"\"\"\n\n    def __init__(self, sub_path: pathlib.Path) -&gt; None:\n\"\"\"Initialize a remove path action.\n\n        It removes the file or directory recursively into trash.\n\n        Arguments:\n            sub_path: this is the desired file or directory path that needs to be removed under the project root\n        \"\"\"\n        if not isinstance(sub_path, pathlib.Path):\n            raise TrestleError('Sub path must be of type pathlib.Path')\n\n        self._trestle_project_root = file_utils.extract_trestle_project_root(sub_path)\n        if self._trestle_project_root is None:\n            raise TrestleError(f'Sub path \"{sub_path}\" should be child of a valid trestle project.')\n\n        self._sub_path = sub_path\n\n        super().__init__(ActionType.REMOVE_PATH, True)\n\n    def get_trestle_project_root(self) -&gt; Optional[pathlib.Path]:\n\"\"\"Return the trestle workspace root path.\"\"\"\n        return self._trestle_project_root\n\n    def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n        if not self._sub_path.exists():\n            logger.debug(f'path {self._sub_path} does not exist in remove path action - ignoring.')\n\n        trash.store(self._sub_path, True)\n\n        # check if parent folder is empty and if so delete\n        parent_dir = pathlib.Path(os.path.dirname(self._sub_path))\n        files = list(parent_dir.iterdir())\n        if not files:\n            trash.store(parent_dir, True)\n        self._mark_executed()\n\n    def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n        if self.has_executed():\n            trash_path = trash.to_trash_path(self._sub_path)\n            if trash_path is None or trash_path.exists() is False:\n                # FIXME suppress file contents not found message til trash/rollback behavior is fixed.  # issue 412\n                return\n            trash.recover(self._sub_path, True)\n\n        self._mark_rollback()\n\n    def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n        return f'{self._type} {self._sub_path}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemovePathAction-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemovePathAction.__init__","title":"<code>__init__(self, sub_path)</code>  <code>special</code>","text":"<p>Initialize a remove path action.</p> <p>It removes the file or directory recursively into trash.</p> <p>Parameters:</p> Name Type Description Default <code>sub_path</code> <code>Path</code> <p>this is the desired file or directory path that needs to be removed under the project root</p> required Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __init__(self, sub_path: pathlib.Path) -&gt; None:\n\"\"\"Initialize a remove path action.\n\n    It removes the file or directory recursively into trash.\n\n    Arguments:\n        sub_path: this is the desired file or directory path that needs to be removed under the project root\n    \"\"\"\n    if not isinstance(sub_path, pathlib.Path):\n        raise TrestleError('Sub path must be of type pathlib.Path')\n\n    self._trestle_project_root = file_utils.extract_trestle_project_root(sub_path)\n    if self._trestle_project_root is None:\n        raise TrestleError(f'Sub path \"{sub_path}\" should be child of a valid trestle project.')\n\n    self._sub_path = sub_path\n\n    super().__init__(ActionType.REMOVE_PATH, True)\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemovePathAction.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Return string representation.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n    return f'{self._type} {self._sub_path}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemovePathAction.execute","title":"<code>execute(self)</code>","text":"<p>Execute the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n    if not self._sub_path.exists():\n        logger.debug(f'path {self._sub_path} does not exist in remove path action - ignoring.')\n\n    trash.store(self._sub_path, True)\n\n    # check if parent folder is empty and if so delete\n    parent_dir = pathlib.Path(os.path.dirname(self._sub_path))\n    files = list(parent_dir.iterdir())\n    if not files:\n        trash.store(parent_dir, True)\n    self._mark_executed()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemovePathAction.get_trestle_project_root","title":"<code>get_trestle_project_root(self)</code>","text":"<p>Return the trestle workspace root path.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def get_trestle_project_root(self) -&gt; Optional[pathlib.Path]:\n\"\"\"Return the trestle workspace root path.\"\"\"\n    return self._trestle_project_root\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.RemovePathAction.rollback","title":"<code>rollback(self)</code>","text":"<p>Rollback the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n    if self.has_executed():\n        trash_path = trash.to_trash_path(self._sub_path)\n        if trash_path is None or trash_path.exists() is False:\n            # FIXME suppress file contents not found message til trash/rollback behavior is fixed.  # issue 412\n            return\n        trash.recover(self._sub_path, True)\n\n    self._mark_rollback()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.UpdateAction","title":"<code> UpdateAction            (Action)         </code>","text":"<p>Update element at the element path in the destination element with the source element.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>class UpdateAction(Action):\n\"\"\"Update element at the element path in the destination element with the source element.\"\"\"\n\n    def __init__(self, sub_element, dest_element: Element, sub_element_path: ElementPath) -&gt; None:\n\"\"\"Initialize an add element action.\n\n        Sub element can be OscalBaseModel, Element, list or None\n        \"\"\"\n        super().__init__(ActionType.UPDATE, True)\n\n        if not Element.is_allowed_sub_element_type(sub_element):\n            allowed_types = Element.get_allowed_sub_element_types()\n            raise TrestleError(\n                f'Sub element \"{sub_element.__class__} is not a allowed sub element types in \"{allowed_types}\"'\n            )\n\n        self._sub_element = sub_element\n        self._dest_element: Element = dest_element\n        self._sub_element_path: ElementPath = sub_element_path\n        self._prev_sub_element = None\n\n    def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n        self._prev_sub_element = self._dest_element.get_at(self._sub_element_path)\n        self._dest_element.set_at(self._sub_element_path, self._sub_element)\n        self._mark_executed()\n\n    def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n        if self.has_executed():\n            self._dest_element.set_at(self._sub_element_path, self._prev_sub_element)\n        self._mark_rollback()\n\n    def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n        return f'{self._type} {self._model_obj.__class__} to {self._dest_element} at {self._sub_element_path}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.UpdateAction-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.UpdateAction.__init__","title":"<code>__init__(self, sub_element, dest_element, sub_element_path)</code>  <code>special</code>","text":"<p>Initialize an add element action.</p> <p>Sub element can be OscalBaseModel, Element, list or None</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __init__(self, sub_element, dest_element: Element, sub_element_path: ElementPath) -&gt; None:\n\"\"\"Initialize an add element action.\n\n    Sub element can be OscalBaseModel, Element, list or None\n    \"\"\"\n    super().__init__(ActionType.UPDATE, True)\n\n    if not Element.is_allowed_sub_element_type(sub_element):\n        allowed_types = Element.get_allowed_sub_element_types()\n        raise TrestleError(\n            f'Sub element \"{sub_element.__class__} is not a allowed sub element types in \"{allowed_types}\"'\n        )\n\n    self._sub_element = sub_element\n    self._dest_element: Element = dest_element\n    self._sub_element_path: ElementPath = sub_element_path\n    self._prev_sub_element = None\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.UpdateAction.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Return string representation.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n    return f'{self._type} {self._model_obj.__class__} to {self._dest_element} at {self._sub_element_path}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.UpdateAction.execute","title":"<code>execute(self)</code>","text":"<p>Execute the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n    self._prev_sub_element = self._dest_element.get_at(self._sub_element_path)\n    self._dest_element.set_at(self._sub_element_path, self._sub_element)\n    self._mark_executed()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.UpdateAction.rollback","title":"<code>rollback(self)</code>","text":"<p>Rollback the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n    if self.has_executed():\n        self._dest_element.set_at(self._sub_element_path, self._prev_sub_element)\n    self._mark_rollback()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteAction","title":"<code> WriteAction            (Action)         </code>","text":"<p>Write the element to a destination stream.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>class WriteAction(Action):\n\"\"\"Write the element to a destination stream.\"\"\"\n\n    def __init__(self, writer: Optional[io.TextIOWrapper], element: Element, content_type: FileContentType) -&gt; None:\n\"\"\"Initialize an write file action.\"\"\"\n        super().__init__(ActionType.WRITE, True)\n\n        if writer is not None and not issubclass(io.TextIOWrapper, writer.__class__):\n            raise TrestleError(f'Writer must be of io.TextIOWrapper, given f{writer.__class__}')\n\n        self._writer: Optional[io.TextIOWrapper] = writer\n        self._element: Element = element\n        self._content_type: FileContentType = content_type\n        self._lastStreamPos = -1\n        if self._writer is not None:\n            self._lastStreamPos = self._writer.tell()\n\n    def _is_writer_valid(self) -&gt; bool:\n        if self._writer is not None and isinstance(self._writer, io.TextIOWrapper) and not self._writer.closed:\n            return True\n\n        return False\n\n    def _encode(self) -&gt; str:\n\"\"\"Encode the element to appropriate content type.\"\"\"\n        if self._content_type == FileContentType.YAML:\n            return self._element.to_yaml()\n        if self._content_type == FileContentType.JSON:\n            return self._element.to_json()\n\n        raise TrestleError(f'Invalid content type {self._content_type}')\n\n    def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n        if self._element is None:\n            raise TrestleError('Element is empty and cannot write')\n\n        if not self._is_writer_valid():\n            raise TrestleError('Writer is not provided or closed')\n\n        self._writer.write(self._encode())\n        self._writer.flush()\n        self._mark_executed()\n\n    def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n        if not self._is_writer_valid():\n            raise TrestleError('Writer is not provided or closed')\n\n        if self._lastStreamPos &lt; 0:\n            raise TrestleError('Last stream position is not available to rollback to')\n\n        if self.has_executed():\n            self._writer.seek(self._lastStreamPos)\n            self._writer.truncate()\n\n        self._mark_rollback()\n\n    def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n        return f'{self.get_type()} {self._element}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteAction-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteAction.__init__","title":"<code>__init__(self, writer, element, content_type)</code>  <code>special</code>","text":"<p>Initialize an write file action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __init__(self, writer: Optional[io.TextIOWrapper], element: Element, content_type: FileContentType) -&gt; None:\n\"\"\"Initialize an write file action.\"\"\"\n    super().__init__(ActionType.WRITE, True)\n\n    if writer is not None and not issubclass(io.TextIOWrapper, writer.__class__):\n        raise TrestleError(f'Writer must be of io.TextIOWrapper, given f{writer.__class__}')\n\n    self._writer: Optional[io.TextIOWrapper] = writer\n    self._element: Element = element\n    self._content_type: FileContentType = content_type\n    self._lastStreamPos = -1\n    if self._writer is not None:\n        self._lastStreamPos = self._writer.tell()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteAction.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Return string representation.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n    return f'{self.get_type()} {self._element}'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteAction.execute","title":"<code>execute(self)</code>","text":"<p>Execute the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n    if self._element is None:\n        raise TrestleError('Element is empty and cannot write')\n\n    if not self._is_writer_valid():\n        raise TrestleError('Writer is not provided or closed')\n\n    self._writer.write(self._encode())\n    self._writer.flush()\n    self._mark_executed()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteAction.rollback","title":"<code>rollback(self)</code>","text":"<p>Rollback the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def rollback(self) -&gt; None:\n\"\"\"Rollback the action.\"\"\"\n    if not self._is_writer_valid():\n        raise TrestleError('Writer is not provided or closed')\n\n    if self._lastStreamPos &lt; 0:\n        raise TrestleError('Last stream position is not available to rollback to')\n\n    if self.has_executed():\n        self._writer.seek(self._lastStreamPos)\n        self._writer.truncate()\n\n    self._mark_rollback()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteFileAction","title":"<code> WriteFileAction            (WriteAction)         </code>","text":"<p>Write the element to a destination file.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>class WriteFileAction(WriteAction):\n\"\"\"Write the element to a destination file.\"\"\"\n\n    def __init__(self, file_path: pathlib.Path, element: Element, content_type: FileContentType) -&gt; None:\n\"\"\"Initialize a write file action.\n\n        It opens the file in append mode. Therefore the file needs to exist even if it is a new file.\n        \"\"\"\n        if not isinstance(file_path, pathlib.Path):\n            raise TrestleError('file_path should be of type pathlib.Path')\n\n        inferred_content_type = FileContentType.to_content_type(file_path.suffix)\n        if inferred_content_type != content_type:\n            raise TrestleError(f'Mismatch between stated content type {content_type.name} and file path {file_path}')\n\n        self._file_path = file_path\n\n        # initialize super without writer for now\n        # Note, execute and rollback sets the writer as appropriate\n        super().__init__(None, element, content_type)\n\n    def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n        if not self._file_path.exists():\n            raise TrestleError(f'File at {self._file_path} does not exist')\n\n        with open(self._file_path, 'a+', encoding=const.FILE_ENCODING) as writer:\n            if self._lastStreamPos &lt; 0:\n                self._lastStreamPos = writer.tell()\n            else:\n                writer.seek(self._lastStreamPos)\n\n            self._writer = writer\n            super().execute()\n\n    def rollback(self) -&gt; None:\n\"\"\"Execute the rollback action.\"\"\"\n        if not self._file_path.exists():\n            raise TrestleError(f'File at {self._file_path} does not exist')\n\n        with open(self._file_path, 'a+', encoding=const.FILE_ENCODING) as writer:\n            self._writer = writer\n            super().rollback()\n\n    def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n        return f'{self._type} {self._element} to \"{self._file_path}\"'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteFileAction-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteFileAction.__init__","title":"<code>__init__(self, file_path, element, content_type)</code>  <code>special</code>","text":"<p>Initialize a write file action.</p> <p>It opens the file in append mode. Therefore the file needs to exist even if it is a new file.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __init__(self, file_path: pathlib.Path, element: Element, content_type: FileContentType) -&gt; None:\n\"\"\"Initialize a write file action.\n\n    It opens the file in append mode. Therefore the file needs to exist even if it is a new file.\n    \"\"\"\n    if not isinstance(file_path, pathlib.Path):\n        raise TrestleError('file_path should be of type pathlib.Path')\n\n    inferred_content_type = FileContentType.to_content_type(file_path.suffix)\n    if inferred_content_type != content_type:\n        raise TrestleError(f'Mismatch between stated content type {content_type.name} and file path {file_path}')\n\n    self._file_path = file_path\n\n    # initialize super without writer for now\n    # Note, execute and rollback sets the writer as appropriate\n    super().__init__(None, element, content_type)\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteFileAction.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"Source code in <code>trestle/core/models/actions.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return string representation.\"\"\"\n    return f'{self._type} {self._element} to \"{self._file_path}\"'\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteFileAction.execute","title":"<code>execute(self)</code>","text":"<p>Execute the action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def execute(self) -&gt; None:\n\"\"\"Execute the action.\"\"\"\n    if not self._file_path.exists():\n        raise TrestleError(f'File at {self._file_path} does not exist')\n\n    with open(self._file_path, 'a+', encoding=const.FILE_ENCODING) as writer:\n        if self._lastStreamPos &lt; 0:\n            self._lastStreamPos = writer.tell()\n        else:\n            writer.seek(self._lastStreamPos)\n\n        self._writer = writer\n        super().execute()\n</code></pre>"},{"location":"api_reference/trestle.core.models.actions/#trestle.core.models.actions.WriteFileAction.rollback","title":"<code>rollback(self)</code>","text":"<p>Execute the rollback action.</p> Source code in <code>trestle/core/models/actions.py</code> <pre><code>def rollback(self) -&gt; None:\n\"\"\"Execute the rollback action.\"\"\"\n    if not self._file_path.exists():\n        raise TrestleError(f'File at {self._file_path} does not exist')\n\n    with open(self._file_path, 'a+', encoding=const.FILE_ENCODING) as writer:\n        self._writer = writer\n        super().rollback()\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/","title":"elements","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements","title":"<code>trestle.core.models.elements</code>","text":"<p>Element wrapper of an OSCAL model element.</p>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element","title":"<code> Element        </code>","text":"<p>Element wrapper of an OSCAL model.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>class Element:\n\"\"\"Element wrapper of an OSCAL model.\"\"\"\n\n    IGNORE_WRAPPER_ALIAS = '__'\n\n    _allowed_sub_element_types: List[str] = ['Element', 'OscalBaseModel', 'list', 'None', 'dict']\n\n    def __init__(self, elem: OscalBaseModel, wrapper_alias: str = ''):\n\"\"\"Initialize an element wrapper.\n\n        wrapper_alias is the OSCAL alias for the given elem object and used for seriazation in to_json() method.\n\n        For example,\n         - List[Catalog.Group] element should have wrapper alias 'groups'\n         - Catalog element should have wrapper alias 'catalog'\n\n        wrapper_alias is deduced for collection type object\n\n        if wrapper_alias = IGNORE_WRAPPER_ALIAS, then it is ignored and assumed to be json-serializable during to_json()\n        \"\"\"\n        # FIXME: There are instances where elem is a list.\n        self._elem: OscalBaseModel = elem\n\n        if wrapper_alias == '' and wrapper_alias != self.IGNORE_WRAPPER_ALIAS:\n            class_name = elem.__class__.__name__\n            if utils.is_collection_field_type(elem):\n                class_name = self._get_singular_classname()\n                if class_name is None:\n                    raise TrestleError(\n                        f'wrapper_alias not found for a collection type object: {elem.__class__.__name__}'\n                    )\n            wrapper_alias = str_utils.classname_to_alias(class_name, AliasMode.JSON)\n\n        self._wrapper_alias: str = wrapper_alias\n\n    def _get_singular_classname(self) -&gt; str:\n\"\"\"Get the inner class name for list or dict objects.\"\"\"\n        # this assumes all items in list and all values in dict are same type\n        class_name = None\n        root = getattr(self._elem, '__root__', None)\n        if root is not None:\n            type_str = root.__class__.__name__\n            if type_str == 'list':\n                class_name = self._elem.__root__[0].__class__.__name__\n            elif type_str == 'dict':\n                class_name = list(self._elem.__root__.values())[0].__class__.__name__\n        return class_name\n\n    def get(self) -&gt; OscalBaseModel:\n\"\"\"Return the model object.\"\"\"\n        return self._elem\n\n    def _split_element_path(self, element_path: ElementPath):\n\"\"\"Split the element path into root_model and remaing attr names.\"\"\"\n        path_parts = element_path.get()\n        root_model = path_parts[0]\n        path_parts = path_parts[1:]\n\n        return root_model, path_parts\n\n    def get_at(self,\n               element_path: ElementPath = None,\n               check_parent: bool = True) -&gt; Union[OscalBaseModel, List[OscalBaseModel]]:\n\"\"\"Get the element at the specified element path.\n\n        it will return the sub-model object at the path. Sub-model object\n        can be of type OscalBaseModel or List\n        \"\"\"\n        if element_path is None:\n            return self._elem\n\n        # find the root-model and element path parts\n        _, path_parts = self._split_element_path(element_path)\n\n        # TODO validate that self._elem is of same type as root_model\n\n        # initialize the starting element for search\n        elm = self._elem\n        if hasattr(elm, '__root__') and (isinstance(elm.__root__, dict) or isinstance(elm.__root__, list)):\n            elm = elm.__root__\n\n        # if parent exists and does not end with wildcard, use the parent as the starting element for search\n        if check_parent and element_path.get_parent(\n        ) is not None and element_path.get_parent().get_last() != ElementPath.WILDCARD:\n            elm_at = self.get_at(element_path.get_parent())\n            if elm_at is None:\n                raise TrestleNotFoundError(f'Invalid parent path {element_path.get_parent()}')\n            elm = elm_at\n\n        # return the sub-element at the specified path\n        for attr in path_parts:\n            if elm is None:\n                break\n\n            # process for wildcard and array indexes\n\n            if attr == ElementPath.WILDCARD:\n                break\n            elif attr.isnumeric():\n                if isinstance(elm, list):\n                    elm = elm[int(attr)]\n                else:\n                    # index to a non list type should return None\n                    return None\n            else:\n                elm = elm.get_field_value_by_alias(attr)\n\n        return elm\n\n    def get_preceding_element(self, element_path: ElementPath) -&gt; Optional[OscalBaseModel]:\n\"\"\"Get the preceding element in the path.\"\"\"\n        preceding_path = element_path.get_preceding_path()\n        preceding_elm: Optional[OscalBaseModel] = self.get_at(preceding_path)\n        return preceding_elm\n\n    def _get_sub_element_obj(self, sub_element):\n\"\"\"Convert sub element into allowed model obj.\"\"\"\n        if not self.is_allowed_sub_element_type(sub_element):\n            raise TrestleError(\n                f'Sub element must be one of \"{self.get_allowed_sub_element_types()}\", found \"{sub_element.__class__}\"'\n            )\n\n        model_obj = sub_element\n        if isinstance(sub_element, Element):\n            model_obj = sub_element.get()\n\n        return model_obj\n\n    def set_at(self, element_path: ElementPath, sub_element: OscalBaseModel) -&gt; 'Element':\n\"\"\"Set a sub_element at the path in the current element.\n\n        Sub element can be Element, OscalBaseModel, list or None type\n        It returns the element itself so that chaining operation can be done such as\n            `element.set_at(path, sub-element).get()`.\n        \"\"\"\n        # convert the element_path to ElementPath if needed\n        if isinstance(element_path, str):\n            element_path = ElementPath(element_path)\n\n        # convert sub-element to OscalBaseModel if needed\n        model_obj = self._get_sub_element_obj(sub_element)\n\n        # find the root-model and element path parts\n        _, path_parts = self._split_element_path(element_path)\n\n        # TODO validate that self._elem is of same type as root_model\n\n        # If wildcard is present, check the input type and determine the preceding element\n        if element_path.get_last() == ElementPath.WILDCARD:\n            # validate the type is either list or OscalBaseModel\n            if not isinstance(model_obj, list) and not isinstance(model_obj, OscalBaseModel):\n                raise TrestleError(\n                    f'The model object needs to be a List or OscalBaseModel for path with \"{ElementPath.WILDCARD}\"'\n                )\n\n            # since wildcard * is there, we need to go one level up for preceding element in the path\n            preceding_elm = self.get_preceding_element(element_path.get_preceding_path())\n        else:\n            # get the preceding element in the path\n            preceding_elm = self.get_preceding_element(element_path)\n\n        if preceding_elm is None:\n            raise TrestleError(f'Invalid sub element path {element_path} with no valid preceding element')\n\n        # check if it can be a valid sub_element of the parent\n        sub_element_name = element_path.get_element_name().replace('-', '_')\n        if hasattr(preceding_elm, sub_element_name) is False:\n            raise TrestleError(\n                f'Element \"{preceding_elm.__class__}\" does not have the attribute \"{sub_element_name}\" '\n                f'of type \"{model_obj.__class__}\"'\n            )\n\n        # set the sub-element\n        try:\n            setattr(preceding_elm, sub_element_name, model_obj)\n        except ValidationError:\n            sub_element_class = self.get_sub_element_class(preceding_elm, sub_element_name)\n            raise TrestleError(\n                f'Validation error: {sub_element_name} is expected to be \"{sub_element_class}\", '\n                f'but found \"{model_obj.__class__}\"'\n            )\n\n        # returning self will allow to do 'chaining' of commands after set\n        return self\n\n    def to_yaml(self) -&gt; str:\n\"\"\"Convert into YAML string.\"\"\"\n        yaml = YAML(typ='safe')\n        yaml.default_flow_style = False\n        from io import StringIO\n        string_stream = StringIO()\n        yaml.dump(yaml.load(self.to_json(pretty=False)), string_stream)\n        yaml_data = string_stream.getvalue()\n        string_stream.close()\n\n        return yaml_data\n\n    def to_json(self, pretty: bool = True) -&gt; str:\n\"\"\"Convert into JSON string.\"\"\"\n        if self._wrapper_alias == self.IGNORE_WRAPPER_ALIAS:\n            json_data = self._elem.oscal_serialize_json(pretty=pretty, wrapped=False)\n\n        else:\n            # Note before trying to edit this\n            # This transient model allows self._elem not be an OscalBaseModel (e.g. a DICT or LIST)\n            # typing need to be clarified.\n            if isinstance(self._elem, OscalBaseModel):\n                json_data = self._elem.oscal_serialize_json(pretty=pretty)\n            else:\n                dynamic_passer = {}\n                dynamic_passer['TransientField'] = (self._elem.__class__, Field(self, alias=self._wrapper_alias))\n                wrapper_model = create_model(\n                    'TransientModel', __base__=OscalBaseModel, **dynamic_passer\n                )  # type: ignore\n                wrapped_model = wrapper_model.construct(**{self._wrapper_alias: self._elem})\n                json_data = wrapped_model.oscal_serialize_json(pretty=pretty, wrapped=False)\n        return json_data\n\n    @classmethod\n    def get_sub_element_class(cls, parent_elm: OscalBaseModel, sub_element_name: str):\n\"\"\"Get the class of the sub-element.\"\"\"\n        sub_element_class = parent_elm.__fields__[sub_element_name].outer_type_\n        return sub_element_class\n\n    @classmethod\n    def get_allowed_sub_element_types(cls) -&gt; List[str]:\n\"\"\"Get the list of allowed sub element types.\"\"\"\n        return cls._allowed_sub_element_types\n\n    @classmethod\n    def is_allowed_sub_element_type(cls, elm) -&gt; bool:\n\"\"\"Check if is of allowed sub element type.\"\"\"\n        # FIXME: The following logic does not use the _allowed_sub_element_types being defined for the class\n        if (isinstance(elm, Element) or isinstance(elm, OscalBaseModel) or isinstance(elm, list)\n                or isinstance(elm, dict) or elm is None):\n            return True\n\n        return False\n\n    def __str__(self) -&gt; str:\n\"\"\"Return string representation of element.\"\"\"\n        return type(self._elem).__name__\n\n    def __eq__(self, other: object) -&gt; bool:\n\"\"\"Check that two elements are equal.\"\"\"\n        if not isinstance(other, Element):\n            return False\n\n        return self.get() == other.get()\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.IGNORE_WRAPPER_ALIAS","title":"<code>IGNORE_WRAPPER_ALIAS</code>","text":""},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.__eq__","title":"<code>__eq__(self, other)</code>  <code>special</code>","text":"<p>Check that two elements are equal.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Check that two elements are equal.\"\"\"\n    if not isinstance(other, Element):\n        return False\n\n    return self.get() == other.get()\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.__init__","title":"<code>__init__(self, elem, wrapper_alias='')</code>  <code>special</code>","text":"<p>Initialize an element wrapper.</p> <p>wrapper_alias is the OSCAL alias for the given elem object and used for seriazation in to_json() method.</p> <p>For example,  - List[Catalog.Group] element should have wrapper alias 'groups'  - Catalog element should have wrapper alias 'catalog'</p> <p>wrapper_alias is deduced for collection type object</p> <p>if wrapper_alias = IGNORE_WRAPPER_ALIAS, then it is ignored and assumed to be json-serializable during to_json()</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def __init__(self, elem: OscalBaseModel, wrapper_alias: str = ''):\n\"\"\"Initialize an element wrapper.\n\n    wrapper_alias is the OSCAL alias for the given elem object and used for seriazation in to_json() method.\n\n    For example,\n     - List[Catalog.Group] element should have wrapper alias 'groups'\n     - Catalog element should have wrapper alias 'catalog'\n\n    wrapper_alias is deduced for collection type object\n\n    if wrapper_alias = IGNORE_WRAPPER_ALIAS, then it is ignored and assumed to be json-serializable during to_json()\n    \"\"\"\n    # FIXME: There are instances where elem is a list.\n    self._elem: OscalBaseModel = elem\n\n    if wrapper_alias == '' and wrapper_alias != self.IGNORE_WRAPPER_ALIAS:\n        class_name = elem.__class__.__name__\n        if utils.is_collection_field_type(elem):\n            class_name = self._get_singular_classname()\n            if class_name is None:\n                raise TrestleError(\n                    f'wrapper_alias not found for a collection type object: {elem.__class__.__name__}'\n                )\n        wrapper_alias = str_utils.classname_to_alias(class_name, AliasMode.JSON)\n\n    self._wrapper_alias: str = wrapper_alias\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Return string representation of element.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return string representation of element.\"\"\"\n    return type(self._elem).__name__\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.get","title":"<code>get(self)</code>","text":"<p>Return the model object.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get(self) -&gt; OscalBaseModel:\n\"\"\"Return the model object.\"\"\"\n    return self._elem\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.get_allowed_sub_element_types","title":"<code>get_allowed_sub_element_types()</code>  <code>classmethod</code>","text":"<p>Get the list of allowed sub element types.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>@classmethod\ndef get_allowed_sub_element_types(cls) -&gt; List[str]:\n\"\"\"Get the list of allowed sub element types.\"\"\"\n    return cls._allowed_sub_element_types\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.get_at","title":"<code>get_at(self, element_path=None, check_parent=True)</code>","text":"<p>Get the element at the specified element path.</p> <p>it will return the sub-model object at the path. Sub-model object can be of type OscalBaseModel or List</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_at(self,\n           element_path: ElementPath = None,\n           check_parent: bool = True) -&gt; Union[OscalBaseModel, List[OscalBaseModel]]:\n\"\"\"Get the element at the specified element path.\n\n    it will return the sub-model object at the path. Sub-model object\n    can be of type OscalBaseModel or List\n    \"\"\"\n    if element_path is None:\n        return self._elem\n\n    # find the root-model and element path parts\n    _, path_parts = self._split_element_path(element_path)\n\n    # TODO validate that self._elem is of same type as root_model\n\n    # initialize the starting element for search\n    elm = self._elem\n    if hasattr(elm, '__root__') and (isinstance(elm.__root__, dict) or isinstance(elm.__root__, list)):\n        elm = elm.__root__\n\n    # if parent exists and does not end with wildcard, use the parent as the starting element for search\n    if check_parent and element_path.get_parent(\n    ) is not None and element_path.get_parent().get_last() != ElementPath.WILDCARD:\n        elm_at = self.get_at(element_path.get_parent())\n        if elm_at is None:\n            raise TrestleNotFoundError(f'Invalid parent path {element_path.get_parent()}')\n        elm = elm_at\n\n    # return the sub-element at the specified path\n    for attr in path_parts:\n        if elm is None:\n            break\n\n        # process for wildcard and array indexes\n\n        if attr == ElementPath.WILDCARD:\n            break\n        elif attr.isnumeric():\n            if isinstance(elm, list):\n                elm = elm[int(attr)]\n            else:\n                # index to a non list type should return None\n                return None\n        else:\n            elm = elm.get_field_value_by_alias(attr)\n\n    return elm\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.get_preceding_element","title":"<code>get_preceding_element(self, element_path)</code>","text":"<p>Get the preceding element in the path.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_preceding_element(self, element_path: ElementPath) -&gt; Optional[OscalBaseModel]:\n\"\"\"Get the preceding element in the path.\"\"\"\n    preceding_path = element_path.get_preceding_path()\n    preceding_elm: Optional[OscalBaseModel] = self.get_at(preceding_path)\n    return preceding_elm\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.get_sub_element_class","title":"<code>get_sub_element_class(parent_elm, sub_element_name)</code>  <code>classmethod</code>","text":"<p>Get the class of the sub-element.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>@classmethod\ndef get_sub_element_class(cls, parent_elm: OscalBaseModel, sub_element_name: str):\n\"\"\"Get the class of the sub-element.\"\"\"\n    sub_element_class = parent_elm.__fields__[sub_element_name].outer_type_\n    return sub_element_class\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.is_allowed_sub_element_type","title":"<code>is_allowed_sub_element_type(elm)</code>  <code>classmethod</code>","text":"<p>Check if is of allowed sub element type.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>@classmethod\ndef is_allowed_sub_element_type(cls, elm) -&gt; bool:\n\"\"\"Check if is of allowed sub element type.\"\"\"\n    # FIXME: The following logic does not use the _allowed_sub_element_types being defined for the class\n    if (isinstance(elm, Element) or isinstance(elm, OscalBaseModel) or isinstance(elm, list)\n            or isinstance(elm, dict) or elm is None):\n        return True\n\n    return False\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.set_at","title":"<code>set_at(self, element_path, sub_element)</code>","text":"<p>Set a sub_element at the path in the current element.</p> <p>Sub element can be Element, OscalBaseModel, list or None type It returns the element itself so that chaining operation can be done such as     <code>element.set_at(path, sub-element).get()</code>.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def set_at(self, element_path: ElementPath, sub_element: OscalBaseModel) -&gt; 'Element':\n\"\"\"Set a sub_element at the path in the current element.\n\n    Sub element can be Element, OscalBaseModel, list or None type\n    It returns the element itself so that chaining operation can be done such as\n        `element.set_at(path, sub-element).get()`.\n    \"\"\"\n    # convert the element_path to ElementPath if needed\n    if isinstance(element_path, str):\n        element_path = ElementPath(element_path)\n\n    # convert sub-element to OscalBaseModel if needed\n    model_obj = self._get_sub_element_obj(sub_element)\n\n    # find the root-model and element path parts\n    _, path_parts = self._split_element_path(element_path)\n\n    # TODO validate that self._elem is of same type as root_model\n\n    # If wildcard is present, check the input type and determine the preceding element\n    if element_path.get_last() == ElementPath.WILDCARD:\n        # validate the type is either list or OscalBaseModel\n        if not isinstance(model_obj, list) and not isinstance(model_obj, OscalBaseModel):\n            raise TrestleError(\n                f'The model object needs to be a List or OscalBaseModel for path with \"{ElementPath.WILDCARD}\"'\n            )\n\n        # since wildcard * is there, we need to go one level up for preceding element in the path\n        preceding_elm = self.get_preceding_element(element_path.get_preceding_path())\n    else:\n        # get the preceding element in the path\n        preceding_elm = self.get_preceding_element(element_path)\n\n    if preceding_elm is None:\n        raise TrestleError(f'Invalid sub element path {element_path} with no valid preceding element')\n\n    # check if it can be a valid sub_element of the parent\n    sub_element_name = element_path.get_element_name().replace('-', '_')\n    if hasattr(preceding_elm, sub_element_name) is False:\n        raise TrestleError(\n            f'Element \"{preceding_elm.__class__}\" does not have the attribute \"{sub_element_name}\" '\n            f'of type \"{model_obj.__class__}\"'\n        )\n\n    # set the sub-element\n    try:\n        setattr(preceding_elm, sub_element_name, model_obj)\n    except ValidationError:\n        sub_element_class = self.get_sub_element_class(preceding_elm, sub_element_name)\n        raise TrestleError(\n            f'Validation error: {sub_element_name} is expected to be \"{sub_element_class}\", '\n            f'but found \"{model_obj.__class__}\"'\n        )\n\n    # returning self will allow to do 'chaining' of commands after set\n    return self\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.to_json","title":"<code>to_json(self, pretty=True)</code>","text":"<p>Convert into JSON string.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def to_json(self, pretty: bool = True) -&gt; str:\n\"\"\"Convert into JSON string.\"\"\"\n    if self._wrapper_alias == self.IGNORE_WRAPPER_ALIAS:\n        json_data = self._elem.oscal_serialize_json(pretty=pretty, wrapped=False)\n\n    else:\n        # Note before trying to edit this\n        # This transient model allows self._elem not be an OscalBaseModel (e.g. a DICT or LIST)\n        # typing need to be clarified.\n        if isinstance(self._elem, OscalBaseModel):\n            json_data = self._elem.oscal_serialize_json(pretty=pretty)\n        else:\n            dynamic_passer = {}\n            dynamic_passer['TransientField'] = (self._elem.__class__, Field(self, alias=self._wrapper_alias))\n            wrapper_model = create_model(\n                'TransientModel', __base__=OscalBaseModel, **dynamic_passer\n            )  # type: ignore\n            wrapped_model = wrapper_model.construct(**{self._wrapper_alias: self._elem})\n            json_data = wrapped_model.oscal_serialize_json(pretty=pretty, wrapped=False)\n    return json_data\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.Element.to_yaml","title":"<code>to_yaml(self)</code>","text":"<p>Convert into YAML string.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def to_yaml(self) -&gt; str:\n\"\"\"Convert into YAML string.\"\"\"\n    yaml = YAML(typ='safe')\n    yaml.default_flow_style = False\n    from io import StringIO\n    string_stream = StringIO()\n    yaml.dump(yaml.load(self.to_json(pretty=False)), string_stream)\n    yaml_data = string_stream.getvalue()\n    string_stream.close()\n\n    return yaml_data\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath","title":"<code> ElementPath        </code>","text":"<p>Element path wrapper of an element.</p> <p>This only allows a single wildcard '*' at the end to denote elements of an array or dict</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>class ElementPath:\n\"\"\"Element path wrapper of an element.\n\n    This only allows a single wildcard '*' at the end to denote elements of an array or dict\n    \"\"\"\n\n    PATH_SEPARATOR: str = const.ALIAS_PATH_SEPARATOR\n\n    WILDCARD: str = '*'\n\n    def __init__(self, element_path: str, parent_path: Optional['ElementPath'] = None) -&gt; None:\n\"\"\"Initialize an element wrapper.\n\n        It assumes the element path contains oscal field alias with hyphens only\n        \"\"\"\n        self._parent_path = parent_path\n\n        self._path: List[str] = self._parse(element_path)\n\n        # Initialize private variables for lazy processing and caching\n        self._element_name: Optional[str] = None\n        self._preceding_path: Optional['ElementPath'] = None\n\n    def _parse(self, element_path: str) -&gt; List[str]:\n\"\"\"Parse the element path and validate.\"\"\"\n        parts: List[str] = element_path.split(self.PATH_SEPARATOR)\n\n        for part in parts:\n            if part == '':\n                raise TrestleError(\n                    f'Invalid path \"{element_path}\" because there are empty path parts between \"{self.PATH_SEPARATOR}\" '\n                    'or in the beginning'\n                )\n\n        if parts[0] == self.WILDCARD:\n            raise TrestleError(f'Invalid path {element_path} with wildcard.')\n        return parts\n\n    def get(self) -&gt; List[str]:\n\"\"\"Return the path parts as a list.\"\"\"\n        return self._path\n\n    def get_type(self, root_model: Optional[Type[Any]] = None, use_parent: bool = False) -&gt; Type[Any]:\n\"\"\"Get the type of an element.\n\n        If possible the model type will be derived from one of the top level models,\n        otherwise a 'root model' can be passed for situations where this is not possible.\n\n        This type path should *NOT* have wild cards in it. It *may* have* indices.\n        Valid Examples:\n            catalog.metadata\n            catalog.groups\n            catalog.groups.group\n            catalog\n            catalog.groups.0\n\n        Args:\n            root_model: An OscalBaseModel Type from which to base the approach on.\n            use_parent: Whether or not to normalise the full path across parent ElementPaths, default to not.\n\n        Returns:\n            The type of the model whether or not it is an OscalBaseModel or not.\n        \"\"\"\n        effective_path: List[str]\n        if use_parent:\n            effective_path = self.get_full_path_parts()\n        else:\n            effective_path = self._path\n\n        if not root_model:\n            # lookup root model from top level oscal models or fail\n            prev_model = self._top_level_type_lookup(effective_path[0])\n        else:\n            prev_model = root_model\n        if len(effective_path) == 1:\n            return prev_model\n        # variables\n        # for current_element_str in effective_path[1:]:\n        for current_element_str in effective_path[1:]:\n            # Determine if the parent model is a collection.\n            if utils.is_collection_field_type(prev_model):\n                inner_model = utils.get_inner_type(prev_model)\n                inner_class_name = classname_to_alias(inner_model.__name__, AliasMode.JSON)\n                # Assert that the current name fits an expected form.\n                # Valid choices here are *, integer (for arrays) and the inner model alias\n                if (inner_class_name == current_element_str or current_element_str == self.WILDCARD\n                        or current_element_str.isnumeric()):\n                    prev_model = inner_model\n\n                else:\n                    raise TrestleError('Unexpected key in element path when finding type.')\n\n            else:\n                # Indices, * are not allowed on non-collection types\n                if current_element_str == self.WILDCARD:\n                    raise TrestleError(\n                        'Wild card in unexpected position when trying to find class type.'\n                        + ' Element path type lookup can only occur where a single type can be identified.'\n                    )\n                prev_model = prev_model.alias_to_field_map()[current_element_str].outer_type_\n        return prev_model\n\n    def get_obm_wrapped_type(self,\n                             root_model: Optional[Type[Any]] = None,\n                             use_parent: bool = False) -&gt; Type[OscalBaseModel]:\n\"\"\"Get the type of the element. Wraps the collection type in an OscalBaseModel as a __root__ element.\n\n        This should principally be used for validating content.\n\n        Args:\n            root_model: An OscalBaseModel Type from which to base the approach on.\n            use_parent: Whether or not to normalise the full path across parent ElementPaths, default to not.\n\n        Returns:\n            The type of the model whether wrapped or not as an OscalBaseModel.\n        \"\"\"\n        base_type = self.get_type(root_model, use_parent)\n        # Get an outer model type.\n        origin_type = utils.get_origin(base_type)\n\n        if origin_type in [list, dict]:\n            # OSCAL does not support collections of collections directly. We should not hit this scenario\n            collection_name = self.get_last()\n            if collection_name == self.WILDCARD:\n                logger.critical('Unexpected error in type system when inferring type from element path.')\n                logger.critical('Please report this issue.')\n                raise TrestleError('Unknown error inferring type from element path.')\n            # Final path must be the alias\n\n            new_base_type = create_model(\n                str_utils.alias_to_classname(collection_name, AliasMode.JSON),\n                __base__=OscalBaseModel,\n                __root__=(base_type, ...)\n            )\n            return new_base_type\n        return base_type\n\n    def _top_level_type_lookup(self, element_str: str) -&gt; Type[common_types.TopLevelOscalModel]:\n\"\"\"From an individual element tag, induce the type of the model.\n\n        Args:\n            element_str: individual element as text such as 'catalog' or 'profile'\n\n        Returns:\n            Top level object model such as catalog, profile etc.\n        \"\"\"\n        # Even though awkward use chain of models.\n        if element_str not in const.MODEL_TYPE_LIST:\n            raise TrestleError(f'{element_str} is not a top level model (e.g. catalog, profile)')\n        model_package = const.MODEL_TYPE_TO_MODEL_MODULE[element_str]\n        object_type, _ = ModelUtils.get_root_model(model_package)\n        object_type = cast(Type[common_types.TopLevelOscalModel], object_type)\n        return object_type\n\n    def is_multipart(self) -&gt; bool:\n\"\"\"Assert whether or not an element path is multiple parts.\n\n        Originally element paths had to have multiple paths.\n        This provides a check for higher level code that still has that requirement.\n\n        Single part:\n            catalog\n            control\n            assessment-results\n\n        Multipart:\n            catalog.metadata\n            catalog.controls.control\n        \"\"\"\n        return len(self._path) &gt; 1\n\n    def to_string(self) -&gt; str:\n\"\"\"Return the path parts as a dot-separated string.\"\"\"\n        return self.PATH_SEPARATOR.join(self.get())\n\n    def get_parent(self) -&gt; 'ElementPath':\n\"\"\"Return the parent path.\n\n        It can be None or a valid ElementPath\n        \"\"\"\n        return self._parent_path\n\n    def get_first(self) -&gt; str:\n\"\"\"Return the first part of the path.\"\"\"\n        return self._path[0]\n\n    def get_last(self) -&gt; str:\n\"\"\"Return the last part of the path.\"\"\"\n        return self._path[-1]\n\n    def get_full(self) -&gt; str:\n\"\"\"Return the full path including parent path parts as a dot separated str.\"\"\"\n        all_parts = self.get_full_path_parts()\n        return self.PATH_SEPARATOR.join(all_parts)\n\n    def get_element_name(self) -&gt; str:\n\"\"\"Return the element alias name from the path.\n\n        Essentailly this the last part of the element path\n        \"\"\"\n        # if it is available then return otherwise compute\n        if self._element_name is None:\n            element_name = self.get_last()\n            if element_name == self.WILDCARD:\n                element_name = self._path[-2]\n\n            self._element_name = element_name\n\n        return self._element_name\n\n    def get_full_path_parts(self) -&gt; List[str]:\n\"\"\"Get full path parts to the element including parent path parts as a list.\"\"\"\n        path_parts = []\n        if self.get_parent() is not None:\n            parent_path_parts = self.get_parent().get_full_path_parts()\n            path_parts.extend(parent_path_parts)\n            path_parts.extend(self.get()[1:])  # don't use the first part\n        else:\n            path_parts.extend(self.get())\n\n        return path_parts\n\n    def get_preceding_path(self) -&gt; 'ElementPath':\n\"\"\"Return the element path to the preceding element in the path.\"\"\"\n        # if it is available then return otherwise compute\n        if self._preceding_path is None:\n            path_parts = self.get_full_path_parts()\n\n            if len(path_parts) &gt; 1:\n                prec_path_parts = path_parts[:-1]\n                self._preceding_path = ElementPath(self.PATH_SEPARATOR.join(prec_path_parts))\n\n        return self._preceding_path\n\n    def find_last_file_in_path(self, content_type: FileContentType, model_dir: pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Find the last (nearest) existing file in the element path leading to this element.\"\"\"\n        # model dir is the top level dir for this model, e.g. catalogs/mycat\n        path = model_dir\n        extension = FileContentType.to_file_extension(content_type)\n        good_model: pathlib.Path = None\n        for element in self._path:\n            if element == '*':\n                break\n            model_file = (path / element).with_suffix(extension)\n            if not model_file.exists():\n                break\n            path = path / element\n            good_model = model_file\n        return good_model\n\n    def make_absolute(self, model_dir: pathlib.Path, reference_dir: pathlib.Path):\n\"\"\"Make the parts absolute from the top model dir.\"\"\"\n        # Match the current relative element path to the model directory and reference directory\n        # If the element path is partial and doesn't connect to the top of the model,\n        # need to deduce absolute element path from the model_dir and the reference directory\n        # that corresponds to the root of the element path\n\n        # if first element is a model type it is already absolute\n        if self._path[0] not in const.MODEL_TYPE_LIST:\n            rel_path = list(reference_dir.relative_to(model_dir).parts)\n            rel_path.extend(self._path)\n            self._path = rel_path\n\n    def make_relative(self, model_relative_path: pathlib.Path) -&gt; int:\n\"\"\"Make the parts relative to the model path.\"\"\"\n        # The element path should currently be absolute\n        # The model relative path should be relative to the top leve of the model\n        # Change the element path to be relative to the model being loaded\n        # Returns 0 on success and 1 on failur\n        rel_path_parts = model_relative_path.parts[:-1]\n        n_rel_parts = len(rel_path_parts)\n        # the element path can't start above the model path\n        if n_rel_parts &gt;= len(self._path):\n            return 1\n        # confirm the leading parts match\n        for ii in range(n_rel_parts):\n            if rel_path_parts[ii] != self._path[ii]:\n                return 1\n        # chop off the leading parts of the absolute element path\n        self._path = self._path[n_rel_parts:]\n        return 0\n\n    def to_file_path(self, content_type: FileContentType = None, root_dir: str = '') -&gt; pathlib.Path:\n\"\"\"Convert to a file or directory path for the element path.\n\n        if content_type is not passed, it will return a path for directory\n        \"\"\"\n        path_parts = self.get()\n\n        # skip wildcard\n        if path_parts[-1] == ElementPath.WILDCARD:\n            path_parts = path_parts[:-1]\n\n        if root_dir != '':\n            path_parts[0] = root_dir\n\n        path_str = '/'.join(path_parts)\n\n        # add file extension if required\n        # this will be omitted if it is a dir path\n        if content_type is not None:\n            file_extension = FileContentType.to_file_extension(content_type)\n            path_str = path_str + file_extension\n\n        # prepare the path\n        file_path: pathlib.Path = pathlib.Path(f'./{path_str}')\n\n        return file_path\n\n    def to_root_path(self, content_type: FileContentType = None) -&gt; pathlib.Path:\n\"\"\"Convert to a file path for the element root.\"\"\"\n        path_str = f'./{self.get_first()}'\n        if content_type is not None:\n            file_extension = FileContentType.to_file_extension(content_type)\n            path_str = path_str + file_extension\n\n        file_path: pathlib.Path = pathlib.Path(path_str)\n        return file_path\n\n    def __str__(self) -&gt; str:\n\"\"\"Return string representation of element path.\"\"\"\n        return self.to_string()\n\n    def __eq__(self, other) -&gt; bool:\n\"\"\"Override equality method.\"\"\"\n        if not isinstance(other, ElementPath):\n            return False\n\n        return self.get() == other.get()\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.PATH_SEPARATOR","title":"<code>PATH_SEPARATOR: str</code>","text":""},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.WILDCARD","title":"<code>WILDCARD: str</code>","text":""},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.__eq__","title":"<code>__eq__(self, other)</code>  <code>special</code>","text":"<p>Override equality method.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n\"\"\"Override equality method.\"\"\"\n    if not isinstance(other, ElementPath):\n        return False\n\n    return self.get() == other.get()\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.__init__","title":"<code>__init__(self, element_path, parent_path=None)</code>  <code>special</code>","text":"<p>Initialize an element wrapper.</p> <p>It assumes the element path contains oscal field alias with hyphens only</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def __init__(self, element_path: str, parent_path: Optional['ElementPath'] = None) -&gt; None:\n\"\"\"Initialize an element wrapper.\n\n    It assumes the element path contains oscal field alias with hyphens only\n    \"\"\"\n    self._parent_path = parent_path\n\n    self._path: List[str] = self._parse(element_path)\n\n    # Initialize private variables for lazy processing and caching\n    self._element_name: Optional[str] = None\n    self._preceding_path: Optional['ElementPath'] = None\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Return string representation of element path.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return string representation of element path.\"\"\"\n    return self.to_string()\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.find_last_file_in_path","title":"<code>find_last_file_in_path(self, content_type, model_dir)</code>","text":"<p>Find the last (nearest) existing file in the element path leading to this element.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def find_last_file_in_path(self, content_type: FileContentType, model_dir: pathlib.Path) -&gt; pathlib.Path:\n\"\"\"Find the last (nearest) existing file in the element path leading to this element.\"\"\"\n    # model dir is the top level dir for this model, e.g. catalogs/mycat\n    path = model_dir\n    extension = FileContentType.to_file_extension(content_type)\n    good_model: pathlib.Path = None\n    for element in self._path:\n        if element == '*':\n            break\n        model_file = (path / element).with_suffix(extension)\n        if not model_file.exists():\n            break\n        path = path / element\n        good_model = model_file\n    return good_model\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get","title":"<code>get(self)</code>","text":"<p>Return the path parts as a list.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get(self) -&gt; List[str]:\n\"\"\"Return the path parts as a list.\"\"\"\n    return self._path\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get_element_name","title":"<code>get_element_name(self)</code>","text":"<p>Return the element alias name from the path.</p> <p>Essentailly this the last part of the element path</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_element_name(self) -&gt; str:\n\"\"\"Return the element alias name from the path.\n\n    Essentailly this the last part of the element path\n    \"\"\"\n    # if it is available then return otherwise compute\n    if self._element_name is None:\n        element_name = self.get_last()\n        if element_name == self.WILDCARD:\n            element_name = self._path[-2]\n\n        self._element_name = element_name\n\n    return self._element_name\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get_first","title":"<code>get_first(self)</code>","text":"<p>Return the first part of the path.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_first(self) -&gt; str:\n\"\"\"Return the first part of the path.\"\"\"\n    return self._path[0]\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get_full","title":"<code>get_full(self)</code>","text":"<p>Return the full path including parent path parts as a dot separated str.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_full(self) -&gt; str:\n\"\"\"Return the full path including parent path parts as a dot separated str.\"\"\"\n    all_parts = self.get_full_path_parts()\n    return self.PATH_SEPARATOR.join(all_parts)\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get_full_path_parts","title":"<code>get_full_path_parts(self)</code>","text":"<p>Get full path parts to the element including parent path parts as a list.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_full_path_parts(self) -&gt; List[str]:\n\"\"\"Get full path parts to the element including parent path parts as a list.\"\"\"\n    path_parts = []\n    if self.get_parent() is not None:\n        parent_path_parts = self.get_parent().get_full_path_parts()\n        path_parts.extend(parent_path_parts)\n        path_parts.extend(self.get()[1:])  # don't use the first part\n    else:\n        path_parts.extend(self.get())\n\n    return path_parts\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get_last","title":"<code>get_last(self)</code>","text":"<p>Return the last part of the path.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_last(self) -&gt; str:\n\"\"\"Return the last part of the path.\"\"\"\n    return self._path[-1]\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get_obm_wrapped_type","title":"<code>get_obm_wrapped_type(self, root_model=None, use_parent=False)</code>","text":"<p>Get the type of the element. Wraps the collection type in an OscalBaseModel as a root element.</p> <p>This should principally be used for validating content.</p> <p>Parameters:</p> Name Type Description Default <code>root_model</code> <code>Optional[Type[Any]]</code> <p>An OscalBaseModel Type from which to base the approach on.</p> <code>None</code> <code>use_parent</code> <code>bool</code> <p>Whether or not to normalise the full path across parent ElementPaths, default to not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Type[trestle.core.base_model.OscalBaseModel]</code> <p>The type of the model whether wrapped or not as an OscalBaseModel.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_obm_wrapped_type(self,\n                         root_model: Optional[Type[Any]] = None,\n                         use_parent: bool = False) -&gt; Type[OscalBaseModel]:\n\"\"\"Get the type of the element. Wraps the collection type in an OscalBaseModel as a __root__ element.\n\n    This should principally be used for validating content.\n\n    Args:\n        root_model: An OscalBaseModel Type from which to base the approach on.\n        use_parent: Whether or not to normalise the full path across parent ElementPaths, default to not.\n\n    Returns:\n        The type of the model whether wrapped or not as an OscalBaseModel.\n    \"\"\"\n    base_type = self.get_type(root_model, use_parent)\n    # Get an outer model type.\n    origin_type = utils.get_origin(base_type)\n\n    if origin_type in [list, dict]:\n        # OSCAL does not support collections of collections directly. We should not hit this scenario\n        collection_name = self.get_last()\n        if collection_name == self.WILDCARD:\n            logger.critical('Unexpected error in type system when inferring type from element path.')\n            logger.critical('Please report this issue.')\n            raise TrestleError('Unknown error inferring type from element path.')\n        # Final path must be the alias\n\n        new_base_type = create_model(\n            str_utils.alias_to_classname(collection_name, AliasMode.JSON),\n            __base__=OscalBaseModel,\n            __root__=(base_type, ...)\n        )\n        return new_base_type\n    return base_type\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get_parent","title":"<code>get_parent(self)</code>","text":"<p>Return the parent path.</p> <p>It can be None or a valid ElementPath</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_parent(self) -&gt; 'ElementPath':\n\"\"\"Return the parent path.\n\n    It can be None or a valid ElementPath\n    \"\"\"\n    return self._parent_path\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get_preceding_path","title":"<code>get_preceding_path(self)</code>","text":"<p>Return the element path to the preceding element in the path.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_preceding_path(self) -&gt; 'ElementPath':\n\"\"\"Return the element path to the preceding element in the path.\"\"\"\n    # if it is available then return otherwise compute\n    if self._preceding_path is None:\n        path_parts = self.get_full_path_parts()\n\n        if len(path_parts) &gt; 1:\n            prec_path_parts = path_parts[:-1]\n            self._preceding_path = ElementPath(self.PATH_SEPARATOR.join(prec_path_parts))\n\n    return self._preceding_path\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.get_type","title":"<code>get_type(self, root_model=None, use_parent=False)</code>","text":"<p>Get the type of an element.</p> <p>If possible the model type will be derived from one of the top level models, otherwise a 'root model' can be passed for situations where this is not possible.</p> <p>This type path should NOT have wild cards in it. It may have* indices. Valid Examples:     catalog.metadata     catalog.groups     catalog.groups.group     catalog     catalog.groups.0</p> <p>Parameters:</p> Name Type Description Default <code>root_model</code> <code>Optional[Type[Any]]</code> <p>An OscalBaseModel Type from which to base the approach on.</p> <code>None</code> <code>use_parent</code> <code>bool</code> <p>Whether or not to normalise the full path across parent ElementPaths, default to not.</p> <code>False</code> <p>Returns:</p> Type Description <code>Type[Any]</code> <p>The type of the model whether or not it is an OscalBaseModel or not.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def get_type(self, root_model: Optional[Type[Any]] = None, use_parent: bool = False) -&gt; Type[Any]:\n\"\"\"Get the type of an element.\n\n    If possible the model type will be derived from one of the top level models,\n    otherwise a 'root model' can be passed for situations where this is not possible.\n\n    This type path should *NOT* have wild cards in it. It *may* have* indices.\n    Valid Examples:\n        catalog.metadata\n        catalog.groups\n        catalog.groups.group\n        catalog\n        catalog.groups.0\n\n    Args:\n        root_model: An OscalBaseModel Type from which to base the approach on.\n        use_parent: Whether or not to normalise the full path across parent ElementPaths, default to not.\n\n    Returns:\n        The type of the model whether or not it is an OscalBaseModel or not.\n    \"\"\"\n    effective_path: List[str]\n    if use_parent:\n        effective_path = self.get_full_path_parts()\n    else:\n        effective_path = self._path\n\n    if not root_model:\n        # lookup root model from top level oscal models or fail\n        prev_model = self._top_level_type_lookup(effective_path[0])\n    else:\n        prev_model = root_model\n    if len(effective_path) == 1:\n        return prev_model\n    # variables\n    # for current_element_str in effective_path[1:]:\n    for current_element_str in effective_path[1:]:\n        # Determine if the parent model is a collection.\n        if utils.is_collection_field_type(prev_model):\n            inner_model = utils.get_inner_type(prev_model)\n            inner_class_name = classname_to_alias(inner_model.__name__, AliasMode.JSON)\n            # Assert that the current name fits an expected form.\n            # Valid choices here are *, integer (for arrays) and the inner model alias\n            if (inner_class_name == current_element_str or current_element_str == self.WILDCARD\n                    or current_element_str.isnumeric()):\n                prev_model = inner_model\n\n            else:\n                raise TrestleError('Unexpected key in element path when finding type.')\n\n        else:\n            # Indices, * are not allowed on non-collection types\n            if current_element_str == self.WILDCARD:\n                raise TrestleError(\n                    'Wild card in unexpected position when trying to find class type.'\n                    + ' Element path type lookup can only occur where a single type can be identified.'\n                )\n            prev_model = prev_model.alias_to_field_map()[current_element_str].outer_type_\n    return prev_model\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.is_multipart","title":"<code>is_multipart(self)</code>","text":"<p>Assert whether or not an element path is multiple parts.</p> <p>Originally element paths had to have multiple paths. This provides a check for higher level code that still has that requirement.</p> <p>Single part:     catalog     control     assessment-results</p> <p>Multipart</p> <p>catalog.metadata catalog.controls.control</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def is_multipart(self) -&gt; bool:\n\"\"\"Assert whether or not an element path is multiple parts.\n\n    Originally element paths had to have multiple paths.\n    This provides a check for higher level code that still has that requirement.\n\n    Single part:\n        catalog\n        control\n        assessment-results\n\n    Multipart:\n        catalog.metadata\n        catalog.controls.control\n    \"\"\"\n    return len(self._path) &gt; 1\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.make_absolute","title":"<code>make_absolute(self, model_dir, reference_dir)</code>","text":"<p>Make the parts absolute from the top model dir.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def make_absolute(self, model_dir: pathlib.Path, reference_dir: pathlib.Path):\n\"\"\"Make the parts absolute from the top model dir.\"\"\"\n    # Match the current relative element path to the model directory and reference directory\n    # If the element path is partial and doesn't connect to the top of the model,\n    # need to deduce absolute element path from the model_dir and the reference directory\n    # that corresponds to the root of the element path\n\n    # if first element is a model type it is already absolute\n    if self._path[0] not in const.MODEL_TYPE_LIST:\n        rel_path = list(reference_dir.relative_to(model_dir).parts)\n        rel_path.extend(self._path)\n        self._path = rel_path\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.make_relative","title":"<code>make_relative(self, model_relative_path)</code>","text":"<p>Make the parts relative to the model path.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def make_relative(self, model_relative_path: pathlib.Path) -&gt; int:\n\"\"\"Make the parts relative to the model path.\"\"\"\n    # The element path should currently be absolute\n    # The model relative path should be relative to the top leve of the model\n    # Change the element path to be relative to the model being loaded\n    # Returns 0 on success and 1 on failur\n    rel_path_parts = model_relative_path.parts[:-1]\n    n_rel_parts = len(rel_path_parts)\n    # the element path can't start above the model path\n    if n_rel_parts &gt;= len(self._path):\n        return 1\n    # confirm the leading parts match\n    for ii in range(n_rel_parts):\n        if rel_path_parts[ii] != self._path[ii]:\n            return 1\n    # chop off the leading parts of the absolute element path\n    self._path = self._path[n_rel_parts:]\n    return 0\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.to_file_path","title":"<code>to_file_path(self, content_type=None, root_dir='')</code>","text":"<p>Convert to a file or directory path for the element path.</p> <p>if content_type is not passed, it will return a path for directory</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def to_file_path(self, content_type: FileContentType = None, root_dir: str = '') -&gt; pathlib.Path:\n\"\"\"Convert to a file or directory path for the element path.\n\n    if content_type is not passed, it will return a path for directory\n    \"\"\"\n    path_parts = self.get()\n\n    # skip wildcard\n    if path_parts[-1] == ElementPath.WILDCARD:\n        path_parts = path_parts[:-1]\n\n    if root_dir != '':\n        path_parts[0] = root_dir\n\n    path_str = '/'.join(path_parts)\n\n    # add file extension if required\n    # this will be omitted if it is a dir path\n    if content_type is not None:\n        file_extension = FileContentType.to_file_extension(content_type)\n        path_str = path_str + file_extension\n\n    # prepare the path\n    file_path: pathlib.Path = pathlib.Path(f'./{path_str}')\n\n    return file_path\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.to_root_path","title":"<code>to_root_path(self, content_type=None)</code>","text":"<p>Convert to a file path for the element root.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def to_root_path(self, content_type: FileContentType = None) -&gt; pathlib.Path:\n\"\"\"Convert to a file path for the element root.\"\"\"\n    path_str = f'./{self.get_first()}'\n    if content_type is not None:\n        file_extension = FileContentType.to_file_extension(content_type)\n        path_str = path_str + file_extension\n\n    file_path: pathlib.Path = pathlib.Path(path_str)\n    return file_path\n</code></pre>"},{"location":"api_reference/trestle.core.models.elements/#trestle.core.models.elements.ElementPath.to_string","title":"<code>to_string(self)</code>","text":"<p>Return the path parts as a dot-separated string.</p> Source code in <code>trestle/core/models/elements.py</code> <pre><code>def to_string(self) -&gt; str:\n\"\"\"Return the path parts as a dot-separated string.\"\"\"\n    return self.PATH_SEPARATOR.join(self.get())\n</code></pre>"},{"location":"api_reference/trestle.core.models.file_content_type/","title":"file_content_type","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.models.file_content_type/#trestle.core.models.file_content_type","title":"<code>trestle.core.models.file_content_type</code>","text":"<p>Action wrapper of a command.</p>"},{"location":"api_reference/trestle.core.models.file_content_type/#trestle.core.models.file_content_type-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.models.file_content_type/#trestle.core.models.file_content_type.FileContentType","title":"<code> FileContentType            (Enum)         </code>","text":"<p>File Content type for read/write.</p> Source code in <code>trestle/core/models/file_content_type.py</code> <pre><code>class FileContentType(Enum):\n\"\"\"File Content type for read/write.\"\"\"\n\n    # JSON formatted content\n    JSON = 1\n\n    # YAML formatted content\n    YAML = 2\n\n    # No extension and possibly a DIR\n    DIRLIKE = 3\n\n    # Type could not be determined\n    UNKNOWN = 4\n\n    @classmethod\n    def to_file_extension(cls, content_type: 'FileContentType') -&gt; str:\n\"\"\"Get file extension for the type, including the dot.\"\"\"\n        if content_type == FileContentType.YAML:\n            return '.yaml'\n        if content_type == FileContentType.JSON:\n            return '.json'\n        raise TrestleError(f'Invalid file content type {content_type}')\n\n    @classmethod\n    def to_content_type(cls, file_extension: str) -&gt; 'FileContentType':\n\"\"\"Get content type form file extension, including the dot.\"\"\"\n        if file_extension == '.json':\n            return FileContentType.JSON\n        if file_extension == '.yaml' or file_extension == '.yml':\n            return FileContentType.YAML\n        if not file_extension:\n            return FileContentType.DIRLIKE\n\n        raise TrestleError(f'Unsupported file extension {file_extension}')\n\n    @classmethod\n    def path_to_content_type(cls, file_path: Path) -&gt; 'FileContentType':\n\"\"\"Get content type from file path looking for extension.\"\"\"\n        if file_path.with_suffix('.json').exists():\n            return FileContentType.JSON\n        if file_path.with_suffix('.yaml').exists():\n            return FileContentType.YAML\n        if file_path.with_suffix('.yml').exists():\n            return FileContentType.YAML\n        return FileContentType.UNKNOWN\n\n    @classmethod\n    def dir_to_content_type(cls, dir_path: Path) -&gt; 'FileContentType':\n\"\"\"Get content type by looking for json or yaml files in dir.\"\"\"\n        files = dir_path.glob('*')\n        for file in files:\n            if file.is_file():\n                suffix = file.suffix\n                if suffix == '.json':\n                    return FileContentType.JSON\n                if suffix in ['.yaml', '.yml']:\n                    return FileContentType.YAML\n        return FileContentType.UNKNOWN\n\n    @classmethod\n    def path_to_file_extension(cls, file_path: Path) -&gt; str:\n\"\"\"Get extension from file path looking for extension.\"\"\"\n        if file_path.with_suffix('.json').exists():\n            return '.json'\n        if file_path.with_suffix('.yaml').exists():\n            return '.yaml'\n        if file_path.with_suffix('.yml').exists():\n            return '.yml'\n        return ''\n\n    @classmethod\n    def is_readable_file(cls, content_type: 'FileContentType') -&gt; bool:\n\"\"\"Is the file a type that can be read directly.\"\"\"\n        return content_type == FileContentType.JSON or content_type == FileContentType.YAML\n</code></pre>"},{"location":"api_reference/trestle.core.models.file_content_type/#trestle.core.models.file_content_type.FileContentType.DIRLIKE","title":"<code>DIRLIKE</code>","text":""},{"location":"api_reference/trestle.core.models.file_content_type/#trestle.core.models.file_content_type.FileContentType.JSON","title":"<code>JSON</code>","text":""},{"location":"api_reference/trestle.core.models.file_content_type/#trestle.core.models.file_content_type.FileContentType.UNKNOWN","title":"<code>UNKNOWN</code>","text":""},{"location":"api_reference/trestle.core.models.file_content_type/#trestle.core.models.file_content_type.FileContentType.YAML","title":"<code>YAML</code>","text":""},{"location":"api_reference/trestle.core.models.interfaces/","title":"interfaces","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces","title":"<code>trestle.core.models.interfaces</code>","text":"<p>Interfaces for use within other trestle functions defined as pydantic data models.</p>"},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly","title":"<code> OSCALAssembly            (TrestleBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Data model to represent an assembled set of OSCAL objects.</p> <p>Here the assembly represents the constraints as expected by the current OSCAL schema. At this point in time a 'flat' model has been chosen rather than an tree.</p> Source code in <code>trestle/core/models/interfaces.py</code> <pre><code>class OSCALAssembly(TrestleBaseModel):\n\"\"\"Data model to represent an assembled set of OSCAL objects.\n\n    Here the assembly represents the constraints as expected by the current OSCAL\n    schema. At this point in time a 'flat' model has been chosen rather than an tree.\n    \"\"\"\n\n    poam: Optional[o_poam.PlanOfActionAndMilestones] = None\n    sar: Optional[o_ar.AssessmentResults] = None\n    sap: Optional[o_ap.AssessmentPlan] = None\n    ssp: Optional[o_ssp.SystemSecurityPlan] = None\n    profiles: Optional[Dict[str, o_profile.Profile]] = None\n    catalogs: Optional[Dict[str, o_catalog.Catalog]] = None\n    components: Optional[Dict[str, o_component.ComponentDefinition]] = None\n\n    class Config:\n\"\"\"Pydantic config overrides.\"\"\"\n\n        allow_population_by_field_name = True\n        # Enforce strict schema\n        extra = Extra.forbid\n        # Validate on assignment of variables to ensure no escapes\n        validate_assignment = True\n</code></pre>"},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly.catalogs","title":"<code>catalogs: Dict[str, trestle.oscal.catalog.Catalog]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly.components","title":"<code>components: Dict[str, trestle.oscal.component.ComponentDefinition]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly.poam","title":"<code>poam: PlanOfActionAndMilestones</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly.profiles","title":"<code>profiles: Dict[str, trestle.oscal.profile.Profile]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly.sap","title":"<code>sap: AssessmentPlan</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly.sar","title":"<code>sar: AssessmentResults</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly.ssp","title":"<code>ssp: SystemSecurityPlan</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.models.interfaces/#trestle.core.models.interfaces.OSCALAssembly.Config","title":"<code> Config        </code>","text":"<p>Pydantic config overrides.</p> Source code in <code>trestle/core/models/interfaces.py</code> <pre><code>class Config:\n\"\"\"Pydantic config overrides.\"\"\"\n\n    allow_population_by_field_name = True\n    # Enforce strict schema\n    extra = Extra.forbid\n    # Validate on assignment of variables to ensure no escapes\n    validate_assignment = True\n</code></pre> <code>allow_population_by_field_name</code> \u00a4 <code>extra</code> \u00a4 <code>validate_assignment</code> \u00a4"},{"location":"api_reference/trestle.core.models.plans/","title":"plans","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans","title":"<code>trestle.core.models.plans</code>","text":"<p>Plan of action of a command.</p>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan","title":"<code> Plan        </code>","text":"<p>Plan of action of a command.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>class Plan:\n\"\"\"Plan of action of a command.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize a plan.\"\"\"\n        self._actions: List[Action] = []\n\n    def _action_key(self, action: Action) -&gt; int:\n        return hash(action)\n\n    def __str__(self) -&gt; str:\n\"\"\"Print the plan.\"\"\"\n        list_actions = []\n        index = 1\n        for action in self._actions:\n            list_actions.append(f'{index}. {action}')\n            index = index + 1\n\n        list_str = '\\n'.join(list_actions)\n        return list_str\n\n    def get_actions(self) -&gt; List[Action]:\n\"\"\"Get all actions.\"\"\"\n        return self._actions\n\n    def add_action(self, action: Action) -&gt; None:\n\"\"\"Add a new action.\"\"\"\n        self._actions.append(action)\n\n    def add_actions(self, actions: List[Action]) -&gt; None:\n\"\"\"Add actions in order.\"\"\"\n        self._actions.extend(actions)\n\n    def clear_actions(self) -&gt; None:\n\"\"\"Clear all actions.\"\"\"\n        self._actions = []\n\n    def execute(self) -&gt; None:\n\"\"\"Execute the actions in the plan.\"\"\"\n        for action in self._actions:\n            try:\n                action.execute()\n            except Exception as e:\n                logger.error(f'Failed to execute action {action} for the plan: {e}. Rolling back.')\n                self.rollback()\n                raise e\n\n    def rollback(self) -&gt; None:\n\"\"\"Rollback the actions in the plan.\"\"\"\n        # execute in reverse order\n        for action in reversed(self._actions):\n            if action.has_rollback() is False:\n                raise UnsupportedOperation(f'{action.get_type()} does not support rollback')\n            action.rollback()\n\n    def __eq__(self, other: object) -&gt; bool:\n\"\"\"Check that two plans are equal.\"\"\"\n        if not isinstance(other, Plan):\n            return False\n\n        return self.get_actions() == other.get_actions()\n</code></pre>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan.__eq__","title":"<code>__eq__(self, other)</code>  <code>special</code>","text":"<p>Check that two plans are equal.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"Check that two plans are equal.\"\"\"\n    if not isinstance(other, Plan):\n        return False\n\n    return self.get_actions() == other.get_actions()\n</code></pre>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize a plan.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize a plan.\"\"\"\n    self._actions: List[Action] = []\n</code></pre>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Print the plan.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Print the plan.\"\"\"\n    list_actions = []\n    index = 1\n    for action in self._actions:\n        list_actions.append(f'{index}. {action}')\n        index = index + 1\n\n    list_str = '\\n'.join(list_actions)\n    return list_str\n</code></pre>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan.add_action","title":"<code>add_action(self, action)</code>","text":"<p>Add a new action.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>def add_action(self, action: Action) -&gt; None:\n\"\"\"Add a new action.\"\"\"\n    self._actions.append(action)\n</code></pre>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan.add_actions","title":"<code>add_actions(self, actions)</code>","text":"<p>Add actions in order.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>def add_actions(self, actions: List[Action]) -&gt; None:\n\"\"\"Add actions in order.\"\"\"\n    self._actions.extend(actions)\n</code></pre>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan.clear_actions","title":"<code>clear_actions(self)</code>","text":"<p>Clear all actions.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>def clear_actions(self) -&gt; None:\n\"\"\"Clear all actions.\"\"\"\n    self._actions = []\n</code></pre>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan.execute","title":"<code>execute(self)</code>","text":"<p>Execute the actions in the plan.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>def execute(self) -&gt; None:\n\"\"\"Execute the actions in the plan.\"\"\"\n    for action in self._actions:\n        try:\n            action.execute()\n        except Exception as e:\n            logger.error(f'Failed to execute action {action} for the plan: {e}. Rolling back.')\n            self.rollback()\n            raise e\n</code></pre>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan.get_actions","title":"<code>get_actions(self)</code>","text":"<p>Get all actions.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>def get_actions(self) -&gt; List[Action]:\n\"\"\"Get all actions.\"\"\"\n    return self._actions\n</code></pre>"},{"location":"api_reference/trestle.core.models.plans/#trestle.core.models.plans.Plan.rollback","title":"<code>rollback(self)</code>","text":"<p>Rollback the actions in the plan.</p> Source code in <code>trestle/core/models/plans.py</code> <pre><code>def rollback(self) -&gt; None:\n\"\"\"Rollback the actions in the plan.\"\"\"\n    # execute in reverse order\n    for action in reversed(self._actions):\n        if action.has_rollback() is False:\n            raise UnsupportedOperation(f'{action.get_type()} does not support rollback')\n        action.rollback()\n</code></pre>"},{"location":"api_reference/trestle.core.object_factory/","title":"object_factory","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.object_factory/#trestle.core.object_factory","title":"<code>trestle.core.object_factory</code>","text":"<p>Generic object factory.</p>"},{"location":"api_reference/trestle.core.object_factory/#trestle.core.object_factory-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.object_factory/#trestle.core.object_factory.ObjectFactory","title":"<code> ObjectFactory        </code>","text":"<p>Allow registration and creation of factory objects.</p> Source code in <code>trestle/core/object_factory.py</code> <pre><code>class ObjectFactory:\n\"\"\"Allow registration and creation of factory objects.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize the objects dictionary as empty.\"\"\"\n        self._objects: Dict[str, Any] = {}\n\n    def register_object(self, mode: str, obj: Any) -&gt; None:\n\"\"\"Register an object to the object factory.\n\n        Args:\n            mode: Descriptive key for the mode / type of object to be retrieved.\n            obj: The object type to be registered.\n        \"\"\"\n        self._objects[mode] = obj\n\n    def get(self, args: argparse.Namespace) -&gt; Any:\n\"\"\"Create the object from the args.\"\"\"\n        return self._objects.get(args.mode)\n\n    def get_all(self) -&gt; ValuesView[Any]:\n\"\"\"Get all registered objects.\"\"\"\n        return self._objects.values()\n</code></pre>"},{"location":"api_reference/trestle.core.object_factory/#trestle.core.object_factory.ObjectFactory-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.object_factory/#trestle.core.object_factory.ObjectFactory.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize the objects dictionary as empty.</p> Source code in <code>trestle/core/object_factory.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the objects dictionary as empty.\"\"\"\n    self._objects: Dict[str, Any] = {}\n</code></pre>"},{"location":"api_reference/trestle.core.object_factory/#trestle.core.object_factory.ObjectFactory.get","title":"<code>get(self, args)</code>","text":"<p>Create the object from the args.</p> Source code in <code>trestle/core/object_factory.py</code> <pre><code>def get(self, args: argparse.Namespace) -&gt; Any:\n\"\"\"Create the object from the args.\"\"\"\n    return self._objects.get(args.mode)\n</code></pre>"},{"location":"api_reference/trestle.core.object_factory/#trestle.core.object_factory.ObjectFactory.get_all","title":"<code>get_all(self)</code>","text":"<p>Get all registered objects.</p> Source code in <code>trestle/core/object_factory.py</code> <pre><code>def get_all(self) -&gt; ValuesView[Any]:\n\"\"\"Get all registered objects.\"\"\"\n    return self._objects.values()\n</code></pre>"},{"location":"api_reference/trestle.core.object_factory/#trestle.core.object_factory.ObjectFactory.register_object","title":"<code>register_object(self, mode, obj)</code>","text":"<p>Register an object to the object factory.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Descriptive key for the mode / type of object to be retrieved.</p> required <code>obj</code> <code>Any</code> <p>The object type to be registered.</p> required Source code in <code>trestle/core/object_factory.py</code> <pre><code>def register_object(self, mode: str, obj: Any) -&gt; None:\n\"\"\"Register an object to the object factory.\n\n    Args:\n        mode: Descriptive key for the mode / type of object to be retrieved.\n        obj: The object type to be registered.\n    \"\"\"\n    self._objects[mode] = obj\n</code></pre>"},{"location":"api_reference/trestle.core.parser/","title":"parser","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.parser/#trestle.core.parser","title":"<code>trestle.core.parser</code>","text":"<p>Model parsing for use when models themselves must be inferred and are not known.</p> <p>Under most use cases trestle.core.base_model.OscalBaseModel provides functionality for loading Oscal models from files. However, under some circumstances the model internals are unknown.  Use of this module should be avoided unless the BaseModel functionality is inadequate.</p>"},{"location":"api_reference/trestle.core.parser/#trestle.core.parser.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.parser/#trestle.core.parser-functions","title":"Functions","text":""},{"location":"api_reference/trestle.core.parser/#trestle.core.parser.parse_dict","title":"<code>parse_dict(data, model_name)</code>","text":"<p>Load a model from the data dict.</p> <p>This functionality is provided for situations when the OSCAL data type is not known ahead of time. Here the model has been loaded into memory using json loads or similar and passed as a dict.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Oscal data loaded into memory as a dictionary with the <code>root key</code> removed.</p> required <code>model_name</code> <code>str</code> <p>should be of the form 'module.class' from trestle.oscal.* modules</p> required <p>Returns:</p> Type Description <code>OscalBaseModel</code> <p>The oscal model of the desired model.</p> Source code in <code>trestle/core/parser.py</code> <pre><code>def parse_dict(data: Dict[str, Any], model_name: str) -&gt; OscalBaseModel:\n\"\"\"Load a model from the data dict.\n\n    This functionality is provided for situations when the OSCAL data type is not known ahead of time. Here the model\n    has been loaded into memory using json loads or similar and passed as a dict.\n\n    Args:\n        data: Oscal data loaded into memory as a dictionary with the `root key` removed.\n        model_name: should be of the form 'module.class' from trestle.oscal.* modules\n\n    Returns:\n        The oscal model of the desired model.\n    \"\"\"\n    if data is None:\n        raise TrestleError('data name is required')\n\n    if model_name is None:\n        raise TrestleError('model_name is required')\n\n    parts = model_name.split('.')\n    class_name = parts.pop()\n    module_name = '.'.join(parts)\n\n    logger.debug(f'Loading class \"{class_name}\" from \"{module_name}\"')\n    module = importlib.import_module(module_name)\n    mclass: OscalBaseModel = getattr(module, class_name)\n    if mclass is None:\n        raise TrestleError(f'class \"{class_name}\" could not be found in \"{module_name}\"')\n\n    instance = mclass.parse_obj(data)\n    return instance\n</code></pre>"},{"location":"api_reference/trestle.core.parser/#trestle.core.parser.root_key","title":"<code>root_key(data)</code>","text":"<p>Find root model name in the data.</p> Source code in <code>trestle/core/parser.py</code> <pre><code>def root_key(data: Dict[str, Any]) -&gt; str:\n\"\"\"Find root model name in the data.\"\"\"\n    if len(data.items()) == 1:\n        return next(iter(data))\n\n    raise TrestleError('data does not contain a root key')\n</code></pre>"},{"location":"api_reference/trestle.core.parser/#trestle.core.parser.to_full_model_name","title":"<code>to_full_model_name(root_key)</code>","text":"<p>Find model name from the root_key in the file.</p> <p>Parameters:</p> Name Type Description Default <code>root_key</code> <code>str</code> <p>root key such as 'system-security-plan' from a top level OSCAL model.</p> required Source code in <code>trestle/core/parser.py</code> <pre><code>def to_full_model_name(root_key: str) -&gt; str:\n\"\"\"\n    Find model name from the root_key in the file.\n\n    Args:\n        root_key: root key such as 'system-security-plan' from a top level OSCAL model.\n    \"\"\"\n    if root_key not in const.MODEL_TYPE_LIST:\n        raise TrestleError(f'{root_key} is not a top level model name.')\n\n    module = const.MODEL_TYPE_TO_MODEL_MODULE[root_key]\n    class_name = alias_to_classname(root_key, AliasMode.JSON)\n    return f'{module}.{class_name}'\n</code></pre>"},{"location":"api_reference/trestle.core.pipeline/","title":"pipeline","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.pipeline/#trestle.core.pipeline","title":"<code>trestle.core.pipeline</code>","text":"<p>Abstract base class for pipelines and filters.</p>"},{"location":"api_reference/trestle.core.pipeline/#trestle.core.pipeline-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.pipeline/#trestle.core.pipeline.Pipeline","title":"<code> Pipeline        </code>","text":"<p>Pipeline base class.</p> Source code in <code>trestle/core/pipeline.py</code> <pre><code>class Pipeline():\n\"\"\"Pipeline base class.\"\"\"\n\n    class Filter(ABC):\n\"\"\"Filter class used by pipeline.\"\"\"\n\n        @abstractclassmethod\n        def process(self, input_: Any) -&gt; Any:\n\"\"\"Process the input to output.\"\"\"\n            return input_\n\n    def __init__(self, filters: List[Filter]) -&gt; None:\n\"\"\"Initialize the class.\"\"\"\n        self._filters = filters\n\n    def process(self, input_: Any) -&gt; Any:\n\"\"\"Process the filter pipeline.\"\"\"\n        for filter_ in self._filters:\n            input_ = filter_.process(input_)\n        return input_\n</code></pre>"},{"location":"api_reference/trestle.core.pipeline/#trestle.core.pipeline.Pipeline-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.pipeline/#trestle.core.pipeline.Pipeline.Filter","title":"<code> Filter            (ABC)         </code>","text":"<p>Filter class used by pipeline.</p> Source code in <code>trestle/core/pipeline.py</code> <pre><code>class Filter(ABC):\n\"\"\"Filter class used by pipeline.\"\"\"\n\n    @abstractclassmethod\n    def process(self, input_: Any) -&gt; Any:\n\"\"\"Process the input to output.\"\"\"\n        return input_\n</code></pre> Methods\u00a4 <code>process(input_)</code> <code>classmethod</code> \u00a4 <p>Process the input to output.</p> Source code in <code>trestle/core/pipeline.py</code> <pre><code>@abstractclassmethod\ndef process(self, input_: Any) -&gt; Any:\n\"\"\"Process the input to output.\"\"\"\n    return input_\n</code></pre>"},{"location":"api_reference/trestle.core.pipeline/#trestle.core.pipeline.Pipeline-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.pipeline/#trestle.core.pipeline.Pipeline.__init__","title":"<code>__init__(self, filters)</code>  <code>special</code>","text":"<p>Initialize the class.</p> Source code in <code>trestle/core/pipeline.py</code> <pre><code>def __init__(self, filters: List[Filter]) -&gt; None:\n\"\"\"Initialize the class.\"\"\"\n    self._filters = filters\n</code></pre>"},{"location":"api_reference/trestle.core.pipeline/#trestle.core.pipeline.Pipeline.process","title":"<code>process(self, input_)</code>","text":"<p>Process the filter pipeline.</p> Source code in <code>trestle/core/pipeline.py</code> <pre><code>def process(self, input_: Any) -&gt; Any:\n\"\"\"Process the filter pipeline.\"\"\"\n    for filter_ in self._filters:\n        input_ = filter_.process(input_)\n    return input_\n</code></pre>"},{"location":"api_reference/trestle.core.profile_resolver/","title":"profile_resolver","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.profile_resolver/#trestle.core.profile_resolver","title":"<code>trestle.core.profile_resolver</code>","text":"<p>Create resolved catalog from profile.</p>"},{"location":"api_reference/trestle.core.profile_resolver/#trestle.core.profile_resolver.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.profile_resolver/#trestle.core.profile_resolver-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.profile_resolver/#trestle.core.profile_resolver.ProfileResolver","title":"<code> ProfileResolver        </code>","text":"<p>Class to resolve a catalog given a profile.</p> Source code in <code>trestle/core/profile_resolver.py</code> <pre><code>class ProfileResolver():\n\"\"\"Class to resolve a catalog given a profile.\"\"\"\n\n    @staticmethod\n    def _extract_inherited_props(res_cat: cat.Catalog) -&gt; Tuple[cat.Catalog, Dict[str, Any]]:\n\"\"\"\n        Build the control dict of inherited props.\n\n        Args:\n            The resolved profile catalog with a possible temporary part in each control\n\n        Returns:\n            The temporary parts are removed from each control and a Dict of added props per control_id is returned\n\n        Notes:\n        If an upstream profile adds props to the control they are tracked in a special temporary part in the control\n        called const.TRESTLE_INHERITED_PROPS_TRACKER.  If that part is present in a control its contents should be added\n        to the dict entry for that control, and the part removed from the control.\n        \"\"\"\n        prop_dict: Dict[str, Any] = {}\n        cat_interface = CatalogInterface(res_cat)\n        for control in cat_interface.get_all_controls_from_dict():\n            part: com.Part = pop_item_from_list(control.parts, TRESTLE_INHERITED_PROPS_TRACKER, lambda p: p.name)\n            if part:\n                props_list: List[Dict[str, Any]] = []\n                for prop in as_list(part.props):\n                    props_list.append({'name': prop.name, 'value': prop.value})\n                for sub_part in as_list(part.parts):\n                    for prop in as_list(sub_part.props):\n                        props_list.append({'name': prop.name, 'value': prop.value, 'part_name': sub_part.title})\n                prop_dict[control.id] = props_list\n        cat_interface.update_catalog_controls()\n        clean_res_cat = cat_interface.get_catalog()\n        return clean_res_cat, prop_dict\n\n    @staticmethod\n    def get_resolved_profile_catalog_and_inherited_props(\n        trestle_root: pathlib.Path,\n        profile_path: str,\n        block_adds: bool = False,\n        block_params: bool = False,\n        params_format: Optional[str] = None,\n        param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n        show_value_warnings: bool = False,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; Tuple[cat.Catalog, Optional[Dict[str, Any]]]:\n\"\"\"\n        Create the resolved profile catalog given a profile path along with inherited props.\n\n        Args:\n            trestle_root: root directory of the trestle workspace\n            profile_path: string path or uri of the profile being resolved\n            block_adds: prevent the application of adds in the final profile\n            block_params: prevent the application of setparams in the final profile\n            params_format: optional pattern with dot to wrap the param string, where dot represents the param string\n            param_rep: desired way to convert params to strings\n            show_value_warnings: warn if prose references a value that has not been set\n            value_assigned_prefix: Prefix placed in front of param string if a value was assigned\n            value_not_assigned_prefix: Prefix placed in front of param string if a value was *not* assigned\n\n        Returns:\n            The resolved profile catalog and a control dict of inherited props\n        \"\"\"\n        logger.debug(f'get resolved profile catalog and inherited props for {profile_path} via generated Import.')\n        import_ = prof.Import(href=str(profile_path), include_all={})\n        # The final Import has change_prose=True to force parameter substitution in the prose only at the last stage.\n        import_filter = Import(\n            trestle_root,\n            import_, [],\n            True,\n            block_adds,\n            block_params,\n            params_format,\n            param_rep,\n            None,\n            show_value_warnings,\n            value_assigned_prefix,\n            value_not_assigned_prefix\n        )\n        logger.debug('launch pipeline')\n        resolved_profile_catalog = next(import_filter.process())\n        resolved_profile_catalog, inherited_props = ProfileResolver._extract_inherited_props(resolved_profile_catalog)\n        return resolved_profile_catalog, inherited_props\n\n    @staticmethod\n    def get_resolved_profile_catalog(\n        trestle_root: pathlib.Path,\n        profile_path: str,\n        block_adds: bool = False,\n        block_params: bool = False,\n        params_format: Optional[str] = None,\n        param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n        show_value_warnings: bool = False,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; cat.Catalog:\n\"\"\"\n        Create the resolved profile catalog given a profile path.\n\n        Args:\n            trestle_root: root directory of the trestle workspace\n            profile_path: string path or uri of the profile being resolved\n            block_adds: prevent the application of adds in the final profile\n            block_params: prevent the application of setparams in the final profile\n            params_format: optional pattern with dot to wrap the param string, where dot represents the param string\n            param_rep: desired way to convert params to strings\n            show_value_warnings: warn if prose references a value that has not been set\n            value_assigned_prefix: Prefix placed in front of param string if a value was assigned\n            value_not_assigned_prefix: Prefix placed in front of param string if a value was *not* assigned\n\n        Returns:\n            The resolved profile catalog\n        \"\"\"\n        logger.debug(f'get resolved profile catalog for {profile_path} via generated Import.')\n        resolved_profile_catalog, _ = ProfileResolver.get_resolved_profile_catalog_and_inherited_props(\n            trestle_root,\n            profile_path,\n            block_adds,\n            block_params,\n            params_format,\n            param_rep,\n            show_value_warnings,\n            value_assigned_prefix,\n            value_not_assigned_prefix\n        )\n        return resolved_profile_catalog\n</code></pre>"},{"location":"api_reference/trestle.core.profile_resolver/#trestle.core.profile_resolver.ProfileResolver-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.profile_resolver/#trestle.core.profile_resolver.ProfileResolver.get_resolved_profile_catalog","title":"<code>get_resolved_profile_catalog(trestle_root, profile_path, block_adds=False, block_params=False, params_format=None, param_rep=&lt;ParameterRep.VALUE_OR_LABEL_OR_CHOICES: 3&gt;, show_value_warnings=False, value_assigned_prefix=None, value_not_assigned_prefix=None)</code>  <code>staticmethod</code>","text":"<p>Create the resolved profile catalog given a profile path.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>root directory of the trestle workspace</p> required <code>profile_path</code> <code>str</code> <p>string path or uri of the profile being resolved</p> required <code>block_adds</code> <code>bool</code> <p>prevent the application of adds in the final profile</p> <code>False</code> <code>block_params</code> <code>bool</code> <p>prevent the application of setparams in the final profile</p> <code>False</code> <code>params_format</code> <code>Optional[str]</code> <p>optional pattern with dot to wrap the param string, where dot represents the param string</p> <code>None</code> <code>param_rep</code> <code>ParameterRep</code> <p>desired way to convert params to strings</p> <code>&lt;ParameterRep.VALUE_OR_LABEL_OR_CHOICES: 3&gt;</code> <code>show_value_warnings</code> <code>bool</code> <p>warn if prose references a value that has not been set</p> <code>False</code> <code>value_assigned_prefix</code> <code>Optional[str]</code> <p>Prefix placed in front of param string if a value was assigned</p> <code>None</code> <code>value_not_assigned_prefix</code> <code>Optional[str]</code> <p>Prefix placed in front of param string if a value was not assigned</p> <code>None</code> <p>Returns:</p> Type Description <code>Catalog</code> <p>The resolved profile catalog</p> Source code in <code>trestle/core/profile_resolver.py</code> <pre><code>@staticmethod\ndef get_resolved_profile_catalog(\n    trestle_root: pathlib.Path,\n    profile_path: str,\n    block_adds: bool = False,\n    block_params: bool = False,\n    params_format: Optional[str] = None,\n    param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n    show_value_warnings: bool = False,\n    value_assigned_prefix: Optional[str] = None,\n    value_not_assigned_prefix: Optional[str] = None\n) -&gt; cat.Catalog:\n\"\"\"\n    Create the resolved profile catalog given a profile path.\n\n    Args:\n        trestle_root: root directory of the trestle workspace\n        profile_path: string path or uri of the profile being resolved\n        block_adds: prevent the application of adds in the final profile\n        block_params: prevent the application of setparams in the final profile\n        params_format: optional pattern with dot to wrap the param string, where dot represents the param string\n        param_rep: desired way to convert params to strings\n        show_value_warnings: warn if prose references a value that has not been set\n        value_assigned_prefix: Prefix placed in front of param string if a value was assigned\n        value_not_assigned_prefix: Prefix placed in front of param string if a value was *not* assigned\n\n    Returns:\n        The resolved profile catalog\n    \"\"\"\n    logger.debug(f'get resolved profile catalog for {profile_path} via generated Import.')\n    resolved_profile_catalog, _ = ProfileResolver.get_resolved_profile_catalog_and_inherited_props(\n        trestle_root,\n        profile_path,\n        block_adds,\n        block_params,\n        params_format,\n        param_rep,\n        show_value_warnings,\n        value_assigned_prefix,\n        value_not_assigned_prefix\n    )\n    return resolved_profile_catalog\n</code></pre>"},{"location":"api_reference/trestle.core.profile_resolver/#trestle.core.profile_resolver.ProfileResolver.get_resolved_profile_catalog_and_inherited_props","title":"<code>get_resolved_profile_catalog_and_inherited_props(trestle_root, profile_path, block_adds=False, block_params=False, params_format=None, param_rep=&lt;ParameterRep.VALUE_OR_LABEL_OR_CHOICES: 3&gt;, show_value_warnings=False, value_assigned_prefix=None, value_not_assigned_prefix=None)</code>  <code>staticmethod</code>","text":"<p>Create the resolved profile catalog given a profile path along with inherited props.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>root directory of the trestle workspace</p> required <code>profile_path</code> <code>str</code> <p>string path or uri of the profile being resolved</p> required <code>block_adds</code> <code>bool</code> <p>prevent the application of adds in the final profile</p> <code>False</code> <code>block_params</code> <code>bool</code> <p>prevent the application of setparams in the final profile</p> <code>False</code> <code>params_format</code> <code>Optional[str]</code> <p>optional pattern with dot to wrap the param string, where dot represents the param string</p> <code>None</code> <code>param_rep</code> <code>ParameterRep</code> <p>desired way to convert params to strings</p> <code>&lt;ParameterRep.VALUE_OR_LABEL_OR_CHOICES: 3&gt;</code> <code>show_value_warnings</code> <code>bool</code> <p>warn if prose references a value that has not been set</p> <code>False</code> <code>value_assigned_prefix</code> <code>Optional[str]</code> <p>Prefix placed in front of param string if a value was assigned</p> <code>None</code> <code>value_not_assigned_prefix</code> <code>Optional[str]</code> <p>Prefix placed in front of param string if a value was not assigned</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[trestle.oscal.catalog.Catalog, Optional[Dict[str, Any]]]</code> <p>The resolved profile catalog and a control dict of inherited props</p> Source code in <code>trestle/core/profile_resolver.py</code> <pre><code>@staticmethod\ndef get_resolved_profile_catalog_and_inherited_props(\n    trestle_root: pathlib.Path,\n    profile_path: str,\n    block_adds: bool = False,\n    block_params: bool = False,\n    params_format: Optional[str] = None,\n    param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n    show_value_warnings: bool = False,\n    value_assigned_prefix: Optional[str] = None,\n    value_not_assigned_prefix: Optional[str] = None\n) -&gt; Tuple[cat.Catalog, Optional[Dict[str, Any]]]:\n\"\"\"\n    Create the resolved profile catalog given a profile path along with inherited props.\n\n    Args:\n        trestle_root: root directory of the trestle workspace\n        profile_path: string path or uri of the profile being resolved\n        block_adds: prevent the application of adds in the final profile\n        block_params: prevent the application of setparams in the final profile\n        params_format: optional pattern with dot to wrap the param string, where dot represents the param string\n        param_rep: desired way to convert params to strings\n        show_value_warnings: warn if prose references a value that has not been set\n        value_assigned_prefix: Prefix placed in front of param string if a value was assigned\n        value_not_assigned_prefix: Prefix placed in front of param string if a value was *not* assigned\n\n    Returns:\n        The resolved profile catalog and a control dict of inherited props\n    \"\"\"\n    logger.debug(f'get resolved profile catalog and inherited props for {profile_path} via generated Import.')\n    import_ = prof.Import(href=str(profile_path), include_all={})\n    # The final Import has change_prose=True to force parameter substitution in the prose only at the last stage.\n    import_filter = Import(\n        trestle_root,\n        import_, [],\n        True,\n        block_adds,\n        block_params,\n        params_format,\n        param_rep,\n        None,\n        show_value_warnings,\n        value_assigned_prefix,\n        value_not_assigned_prefix\n    )\n    logger.debug('launch pipeline')\n    resolved_profile_catalog = next(import_filter.process())\n    resolved_profile_catalog, inherited_props = ProfileResolver._extract_inherited_props(resolved_profile_catalog)\n    return resolved_profile_catalog, inherited_props\n</code></pre>"},{"location":"api_reference/trestle.core.refs_validator/","title":"refs_validator","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.refs_validator/#trestle.core.refs_validator","title":"<code>trestle.core.refs_validator</code>","text":"<p>Validate by confirming all refs have corresponding id.</p>"},{"location":"api_reference/trestle.core.refs_validator/#trestle.core.refs_validator-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.refs_validator/#trestle.core.refs_validator.RefsValidator","title":"<code> RefsValidator            (Validator)         </code>","text":"<p>Validator to confirm all references in responsible parties are found in roles.</p> Source code in <code>trestle/core/refs_validator.py</code> <pre><code>class RefsValidator(Validator):\n\"\"\"Validator to confirm all references in responsible parties are found in roles.\"\"\"\n\n    def model_is_valid(\n        self, model: TopLevelOscalModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None\n    ) -&gt; bool:\n\"\"\"\n        Test if the model is valid.\n\n        args:\n            model: A top level OSCAL model.\n            quiet: Don't report msgs unless invalid.\n\n        returns:\n            True (valid) if the model's responsible parties match those found in roles.\n        \"\"\"\n        roles = as_list(model.metadata.roles)\n        role_ids = [role.id for role in roles]\n        responsible_parties = as_list(model.metadata.responsible_parties)\n        if not responsible_parties:\n            return True\n        party_roles = [party.role_id for party in responsible_parties]\n        # return true if all party roles are in the roles list\n        return all(item in role_ids for item in party_roles)\n</code></pre>"},{"location":"api_reference/trestle.core.refs_validator/#trestle.core.refs_validator.RefsValidator-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.refs_validator/#trestle.core.refs_validator.RefsValidator.model_is_valid","title":"<code>model_is_valid(self, model, quiet, trestle_root=None)</code>","text":"<p>Test if the model is valid.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>~TopLevelOscalModel</code> <p>A top level OSCAL model.</p> required <code>quiet</code> <code>bool</code> <p>Don't report msgs unless invalid.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True (valid) if the model's responsible parties match those found in roles.</p> Source code in <code>trestle/core/refs_validator.py</code> <pre><code>def model_is_valid(\n    self, model: TopLevelOscalModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None\n) -&gt; bool:\n\"\"\"\n    Test if the model is valid.\n\n    args:\n        model: A top level OSCAL model.\n        quiet: Don't report msgs unless invalid.\n\n    returns:\n        True (valid) if the model's responsible parties match those found in roles.\n    \"\"\"\n    roles = as_list(model.metadata.roles)\n    role_ids = [role.id for role in roles]\n    responsible_parties = as_list(model.metadata.responsible_parties)\n    if not responsible_parties:\n        return True\n    party_roles = [party.role_id for party in responsible_parties]\n    # return true if all party roles are in the roles list\n    return all(item in role_ids for item in party_roles)\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/","title":"cache","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache","title":"<code>trestle.core.remote.cache</code>","text":"<p>Trestle cache operations library.</p> <p>Allows for using URI's to reference external directories and then expand.</p>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherBase","title":"<code> FetcherBase            (ABC)         </code>","text":"<p>FetcherBase - base class for caching and fetching remote oscal objects.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>class FetcherBase(ABC):\n\"\"\"FetcherBase - base class for caching and fetching remote oscal objects.\"\"\"\n\n    def __init__(self, trestle_root: pathlib.Path, uri: str) -&gt; None:\n\"\"\"Intialize fetcher base.\n\n        Args:\n            trestle_root: Path of the trestle workspace, i.e., within which .trestle is to be found.\n            uri: Reference to the source object to cache.\n        \"\"\"\n        logger.debug('Initializing FetcherBase')\n        self._cached_object_path: pathlib.Path\n        self._uri = uri\n        self._trestle_root = trestle_root.resolve()\n        self._trestle_cache_path: pathlib.Path = self._trestle_root / const.TRESTLE_CACHE_DIR\n        # ensure trestle cache directory exists.\n        self._trestle_cache_path.mkdir(exist_ok=True)\n        self._expiration_seconds = const.DAY_SECONDS\n\n    @staticmethod\n    def _time_since_modification(file_path: pathlib.Path) -&gt; datetime.timedelta:\n\"\"\"Get time since last modification.\"\"\"\n        last_modification = datetime.datetime.fromtimestamp(file_path.stat().st_mtime)\n        return datetime.datetime.now() - last_modification\n\n    @abstractmethod\n    def _do_fetch(self) -&gt; None:\n\"\"\"Fetch the object from a remote source.\"\"\"\n        pass\n\n    def _in_cache(self) -&gt; bool:\n\"\"\"Return whether object is present in the cache or not.\"\"\"\n        return self._cached_object_path.exists()\n\n    def _is_stale(self) -&gt; bool:\n        # Either cache empty or cached item is too old\n        if not self._in_cache():\n            return True\n        return FetcherBase._time_since_modification(self._cached_object_path\n                                                    ) &gt; datetime.timedelta(seconds=self._expiration_seconds)\n\n    def _update_cache(self, force_update: bool = False) -&gt; bool:\n\"\"\"Update the cache by fetching the target remote object, if stale or forced.\n\n        Args:\n            force_update: force the fetch regardless of staleness.\n\n        Returns:\n            True if update occurred\n        \"\"\"\n        if self._is_stale() or force_update:\n            try:\n                self._do_fetch()\n                return True\n            except Exception as e:\n                raise TrestleError(\n                    f'Cache update failure for {self._uri}.  Please confirm the file is json and not html: {e}.'\n                ) from e  # noqa E501\n        return False\n\n    def get_raw(self, force_update=False) -&gt; Dict[str, Any]:\n\"\"\"Retrieve the raw dictionary representing the underlying object.\"\"\"\n        self._update_cache(force_update)\n        # Return results in the cache, whether yaml or json, or whatever is supported by fs.load_file().\n        try:\n            raw_data = file_utils.load_file(self._cached_object_path)\n        except Exception:\n            try:\n                raw_data = file_utils.load_file(self._cached_object_path)\n            except Exception as e:\n                raise TrestleError(f'Cache get failure for {self._uri}: {e}.') from e\n        return raw_data\n\n    def get_oscal_with_model_type(self, model_type: Type[OscalBaseModel], force_update=False) -&gt; OscalBaseModel:\n\"\"\"Retrieve the cached file as a particular OSCAL model.\n\n        Arguments:\n            model_type: Type[OscalBaseModel] Specifies the OSCAL model type of the fetched object.\n        \"\"\"\n        self._update_cache(force_update)\n        cache_file = self._cached_object_path\n        if not cache_file.exists():\n            raise TrestleError(f'get_oscal failure for {self._uri}')\n\n        try:\n            return model_type.oscal_read(cache_file)\n        except Exception as e:\n            logger.debug(f'get_oscal failed, error loading cache file for {self._uri} as {model_type}')\n            raise TrestleError(f'get_oscal failure for {self._uri}: {e}.') from e\n\n    def get_oscal(self, force_update=False) -&gt; Tuple[OscalBaseModel, str]:\n\"\"\"Retrieve the cached file and model name without knowing its model type.\"\"\"\n        model_dict = self.get_raw(force_update)\n        root_key = parser.root_key(model_dict)\n        model_name = parser.to_full_model_name(root_key)\n        if model_name is None:\n            raise TrestleError(f'Failed cache read of non top level model with root_key {root_key}')\n        return parser.parse_dict(model_dict[root_key], model_name), root_key\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherBase-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherBase.__init__","title":"<code>__init__(self, trestle_root, uri)</code>  <code>special</code>","text":"<p>Intialize fetcher base.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>Path of the trestle workspace, i.e., within which .trestle is to be found.</p> required <code>uri</code> <code>str</code> <p>Reference to the source object to cache.</p> required Source code in <code>trestle/core/remote/cache.py</code> <pre><code>def __init__(self, trestle_root: pathlib.Path, uri: str) -&gt; None:\n\"\"\"Intialize fetcher base.\n\n    Args:\n        trestle_root: Path of the trestle workspace, i.e., within which .trestle is to be found.\n        uri: Reference to the source object to cache.\n    \"\"\"\n    logger.debug('Initializing FetcherBase')\n    self._cached_object_path: pathlib.Path\n    self._uri = uri\n    self._trestle_root = trestle_root.resolve()\n    self._trestle_cache_path: pathlib.Path = self._trestle_root / const.TRESTLE_CACHE_DIR\n    # ensure trestle cache directory exists.\n    self._trestle_cache_path.mkdir(exist_ok=True)\n    self._expiration_seconds = const.DAY_SECONDS\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherBase.get_oscal","title":"<code>get_oscal(self, force_update=False)</code>","text":"<p>Retrieve the cached file and model name without knowing its model type.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>def get_oscal(self, force_update=False) -&gt; Tuple[OscalBaseModel, str]:\n\"\"\"Retrieve the cached file and model name without knowing its model type.\"\"\"\n    model_dict = self.get_raw(force_update)\n    root_key = parser.root_key(model_dict)\n    model_name = parser.to_full_model_name(root_key)\n    if model_name is None:\n        raise TrestleError(f'Failed cache read of non top level model with root_key {root_key}')\n    return parser.parse_dict(model_dict[root_key], model_name), root_key\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherBase.get_oscal_with_model_type","title":"<code>get_oscal_with_model_type(self, model_type, force_update=False)</code>","text":"<p>Retrieve the cached file as a particular OSCAL model.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[trestle.core.base_model.OscalBaseModel]</code> <p>Type[OscalBaseModel] Specifies the OSCAL model type of the fetched object.</p> required Source code in <code>trestle/core/remote/cache.py</code> <pre><code>def get_oscal_with_model_type(self, model_type: Type[OscalBaseModel], force_update=False) -&gt; OscalBaseModel:\n\"\"\"Retrieve the cached file as a particular OSCAL model.\n\n    Arguments:\n        model_type: Type[OscalBaseModel] Specifies the OSCAL model type of the fetched object.\n    \"\"\"\n    self._update_cache(force_update)\n    cache_file = self._cached_object_path\n    if not cache_file.exists():\n        raise TrestleError(f'get_oscal failure for {self._uri}')\n\n    try:\n        return model_type.oscal_read(cache_file)\n    except Exception as e:\n        logger.debug(f'get_oscal failed, error loading cache file for {self._uri} as {model_type}')\n        raise TrestleError(f'get_oscal failure for {self._uri}: {e}.') from e\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherBase.get_raw","title":"<code>get_raw(self, force_update=False)</code>","text":"<p>Retrieve the raw dictionary representing the underlying object.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>def get_raw(self, force_update=False) -&gt; Dict[str, Any]:\n\"\"\"Retrieve the raw dictionary representing the underlying object.\"\"\"\n    self._update_cache(force_update)\n    # Return results in the cache, whether yaml or json, or whatever is supported by fs.load_file().\n    try:\n        raw_data = file_utils.load_file(self._cached_object_path)\n    except Exception:\n        try:\n            raw_data = file_utils.load_file(self._cached_object_path)\n        except Exception as e:\n            raise TrestleError(f'Cache get failure for {self._uri}: {e}.') from e\n    return raw_data\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherFactory","title":"<code> FetcherFactory        </code>","text":"<p>Factory method for creating a fetcher.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>class FetcherFactory:\n\"\"\"Factory method for creating a fetcher.\"\"\"\n\n    class UriType(Enum):\n\"\"\"Specify types of URI.\"\"\"\n\n        LOCAL_FILE = 1\n\n        SFTP = 2\n\n        HTTPS = 3\n\n        TRESTLE = 4\n\n    @staticmethod\n    def uri_type_is_not_local(uri_type: UriType) -&gt; bool:\n\"\"\"Determine if the uri type is not local.\"\"\"\n        return uri_type in [FetcherFactory.UriType.SFTP, FetcherFactory.UriType.HTTPS]\n\n    @staticmethod\n    def get_uri_type(uri: str) -&gt; UriType:\n\"\"\"Determine the type of uri.\"\"\"\n        if uri.startswith(const.SFTP_URI):\n            return FetcherFactory.UriType.SFTP\n        if uri.startswith(const.HTTPS_URI):\n            return FetcherFactory.UriType.HTTPS\n        if uri.startswith(const.TRESTLE_HREF_HEADING):\n            return FetcherFactory.UriType.TRESTLE\n        # if we land here, assume it is a local file and may have relative path\n        # but it at least needs a filename with suffix\n        # the most minimal allowed uri is of the form a.yml\n        uri_clean = uri.strip()\n        if uri_clean.startswith('ftp:'):\n            raise TrestleError(f'Invalid uri {uri}  ftp is not supported.  Use sftp instead.')\n        uri_len = len(uri_clean)\n        # at least 5 chars and ending with dot followed by at least 3 chars\n        if uri_len &gt; 4 and 0 &lt; uri_clean.rfind('.') &lt; uri_len - 3:\n            return FetcherFactory.UriType.LOCAL_FILE\n        raise TrestleError(f'Invalid uri not recognized as a readable file path with extension: {uri}')\n\n    @staticmethod\n    def in_trestle_directory(trestle_root: pathlib.Path, uri: str) -&gt; bool:\n\"\"\"Check if in trestle directory when uri may not be a file path.\"\"\"\n        uri_type = FetcherFactory.get_uri_type(uri)\n        if uri_type == FetcherFactory.UriType.TRESTLE:\n            return True\n        if uri_type != FetcherFactory.UriType.LOCAL_FILE:\n            return False\n        try:\n            pathlib.Path(uri).resolve().relative_to(str(trestle_root.resolve()))\n        except Exception:\n            return False\n        return True\n\n    @classmethod\n    def get_fetcher(cls, trestle_root: pathlib.Path, uri: str) -&gt; FetcherBase:\n\"\"\"Return an instantiated fetcher object based on the type of URI.\n\n        Args:\n            trestle_root: Path of the trestle workspace, i.e., within which .trestle is to be found.\n            uri: Reference to the remote object to cache.\n\n        Returns:\n            fetcher object for the given URI.\n        \"\"\"\n        fetcher_dict = {\n            FetcherFactory.UriType.LOCAL_FILE: LocalFetcher,\n            FetcherFactory.UriType.SFTP: SFTPFetcher,\n            FetcherFactory.UriType.HTTPS: HTTPSFetcher,\n            FetcherFactory.UriType.TRESTLE: LocalFetcher,\n        }\n        uri_type = cls.get_uri_type(uri)\n        return fetcher_dict[uri_type](trestle_root, uri)\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherFactory-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherFactory.UriType","title":"<code> UriType            (Enum)         </code>","text":"<p>Specify types of URI.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>class UriType(Enum):\n\"\"\"Specify types of URI.\"\"\"\n\n    LOCAL_FILE = 1\n\n    SFTP = 2\n\n    HTTPS = 3\n\n    TRESTLE = 4\n</code></pre> <code>HTTPS</code> \u00a4 <code>LOCAL_FILE</code> \u00a4 <code>SFTP</code> \u00a4 <code>TRESTLE</code> \u00a4"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherFactory-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherFactory.get_fetcher","title":"<code>get_fetcher(trestle_root, uri)</code>  <code>classmethod</code>","text":"<p>Return an instantiated fetcher object based on the type of URI.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>Path of the trestle workspace, i.e., within which .trestle is to be found.</p> required <code>uri</code> <code>str</code> <p>Reference to the remote object to cache.</p> required <p>Returns:</p> Type Description <code>FetcherBase</code> <p>fetcher object for the given URI.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>@classmethod\ndef get_fetcher(cls, trestle_root: pathlib.Path, uri: str) -&gt; FetcherBase:\n\"\"\"Return an instantiated fetcher object based on the type of URI.\n\n    Args:\n        trestle_root: Path of the trestle workspace, i.e., within which .trestle is to be found.\n        uri: Reference to the remote object to cache.\n\n    Returns:\n        fetcher object for the given URI.\n    \"\"\"\n    fetcher_dict = {\n        FetcherFactory.UriType.LOCAL_FILE: LocalFetcher,\n        FetcherFactory.UriType.SFTP: SFTPFetcher,\n        FetcherFactory.UriType.HTTPS: HTTPSFetcher,\n        FetcherFactory.UriType.TRESTLE: LocalFetcher,\n    }\n    uri_type = cls.get_uri_type(uri)\n    return fetcher_dict[uri_type](trestle_root, uri)\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherFactory.get_uri_type","title":"<code>get_uri_type(uri)</code>  <code>staticmethod</code>","text":"<p>Determine the type of uri.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>@staticmethod\ndef get_uri_type(uri: str) -&gt; UriType:\n\"\"\"Determine the type of uri.\"\"\"\n    if uri.startswith(const.SFTP_URI):\n        return FetcherFactory.UriType.SFTP\n    if uri.startswith(const.HTTPS_URI):\n        return FetcherFactory.UriType.HTTPS\n    if uri.startswith(const.TRESTLE_HREF_HEADING):\n        return FetcherFactory.UriType.TRESTLE\n    # if we land here, assume it is a local file and may have relative path\n    # but it at least needs a filename with suffix\n    # the most minimal allowed uri is of the form a.yml\n    uri_clean = uri.strip()\n    if uri_clean.startswith('ftp:'):\n        raise TrestleError(f'Invalid uri {uri}  ftp is not supported.  Use sftp instead.')\n    uri_len = len(uri_clean)\n    # at least 5 chars and ending with dot followed by at least 3 chars\n    if uri_len &gt; 4 and 0 &lt; uri_clean.rfind('.') &lt; uri_len - 3:\n        return FetcherFactory.UriType.LOCAL_FILE\n    raise TrestleError(f'Invalid uri not recognized as a readable file path with extension: {uri}')\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherFactory.in_trestle_directory","title":"<code>in_trestle_directory(trestle_root, uri)</code>  <code>staticmethod</code>","text":"<p>Check if in trestle directory when uri may not be a file path.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>@staticmethod\ndef in_trestle_directory(trestle_root: pathlib.Path, uri: str) -&gt; bool:\n\"\"\"Check if in trestle directory when uri may not be a file path.\"\"\"\n    uri_type = FetcherFactory.get_uri_type(uri)\n    if uri_type == FetcherFactory.UriType.TRESTLE:\n        return True\n    if uri_type != FetcherFactory.UriType.LOCAL_FILE:\n        return False\n    try:\n        pathlib.Path(uri).resolve().relative_to(str(trestle_root.resolve()))\n    except Exception:\n        return False\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.FetcherFactory.uri_type_is_not_local","title":"<code>uri_type_is_not_local(uri_type)</code>  <code>staticmethod</code>","text":"<p>Determine if the uri type is not local.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>@staticmethod\ndef uri_type_is_not_local(uri_type: UriType) -&gt; bool:\n\"\"\"Determine if the uri type is not local.\"\"\"\n    return uri_type in [FetcherFactory.UriType.SFTP, FetcherFactory.UriType.HTTPS]\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.HTTPSFetcher","title":"<code> HTTPSFetcher            (FetcherBase)         </code>","text":"<p>Fetcher for https content.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>class HTTPSFetcher(FetcherBase):\n\"\"\"Fetcher for https content.\"\"\"\n\n    # Use request: https://requests.readthedocs.io/en/master/\n    def __init__(self, trestle_root: pathlib.Path, uri: str) -&gt; None:\n\"\"\"Initialize HTTPS fetcher.\"\"\"\n        logger.debug('Initializing HTTPSFetcher')\n        super().__init__(trestle_root, uri)\n        self._username = None\n        self._password = None\n        u = parse.urlparse(self._uri)\n        self._url = uri\n        # If the either the username or password is omitted in the URI, then the other becomes ''\n        # so we test for either None or ''.\n        if u.username != '' and u.username is not None:\n            # This also checks for invalid environment variable name (IEEE 1003.1)\n            if not re.match('{{[a-zA-Z_][a-zA-Z0-9_]*}}', u.username) or u.username == '{{_}}':\n                raise TrestleError(\n                    'Cache request for invalid input URI: '\n                    f'username must refer to an environment variable using moustache {self._uri}'\n                )\n            username_var = u.username[2:-2]\n            if username_var not in os.environ:\n                raise TrestleError(\n                    f'Cache request for invalid input URI: username not found in the environment {self._uri}'\n                )\n            self._username = os.environ[username_var]\n        if u.password != '' and u.password is not None:  # noqa S105\n            if not re.match('{{[a-zA-Z_][a-zA-Z0-9_]*}}', u.password) or u.password == '{{_}}':  # noqa S105\n                raise TrestleError(\n                    'Cache request for invalid input URI: '\n                    f'password must refer to an environment variable using moustache {self._uri}'\n                )\n            password_var = u.password[2:-2]\n            if password_var not in os.environ:\n                raise TrestleError(\n                    'Cache request for invalid input URI: '\n                    f'password not found in the environment {self._uri}'\n                )\n            self._password = os.environ[password_var]\n        if self._username and (self._password == '' or self._password is None):  # noqa S105\n            raise TrestleError(\n                f'Cache request for invalid input URI: username found '\n                f'but password not found via environment variable {self._uri}'\n            )\n        if self._password and not self._username:\n            raise TrestleError(\n                f'Cache request for invalid input URI: password found '\n                f'but username not found via environment variable {self._uri}'\n            )\n        https_cached_dir = self._trestle_cache_path / u.hostname\n        # Skip any number of back- or forward slashes preceding the URI path (u.path)\n        path_parent = pathlib.Path(u.path[re.search('[^/\\\\\\\\]', u.path).span()[0]:]).parent\n        https_cached_dir = https_cached_dir / path_parent\n        https_cached_dir.mkdir(parents=True, exist_ok=True)\n        self._cached_object_path = https_cached_dir / pathlib.Path(pathlib.Path(u.path).name)\n\n    def _do_fetch(self) -&gt; None:\n        auth = None\n        verify = None\n        # This order reflects requests library behavior: REQUESTS_CA_BUNDLE comes first.\n        for env_var_name in ['REQUESTS_CA_BUNDLE', 'CURL_CA_BUNDLE']:\n            if env_var_name in os.environ:\n                if pathlib.Path(os.environ[env_var_name]).exists():\n                    verify = os.environ[env_var_name]\n                    break\n                else:\n                    err_str = f'Env var ${env_var_name} found but path does not exist: {os.environ[env_var_name]}'\n                    logger.warning(err_str)\n                    raise TrestleError(f'Cache update failure with bad inputenv var: {err_str}')\n        if self._username is not None and self._password is not None:\n            auth = HTTPBasicAuth(self._username, self._password)\n\n        try:\n            response = requests.get(self._url, auth=auth, verify=verify, timeout=10)\n        except Exception as e:\n            raise TrestleError(f'Cache update failure to connect via HTTPS: {self._url} ({e})')\n\n        if response.status_code == 200:\n            try:\n                result = response.text\n            except Exception as err:\n                raise TrestleError(f'Cache update failure reading response via HTTPS: {self._url} ({err})')\n            else:\n                self._cached_object_path.write_text(result, encoding=const.FILE_ENCODING)\n        else:\n            raise TrestleError(f'GET returned code {response.status_code}: {self._uri}')\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.HTTPSFetcher-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.HTTPSFetcher.__init__","title":"<code>__init__(self, trestle_root, uri)</code>  <code>special</code>","text":"<p>Initialize HTTPS fetcher.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>def __init__(self, trestle_root: pathlib.Path, uri: str) -&gt; None:\n\"\"\"Initialize HTTPS fetcher.\"\"\"\n    logger.debug('Initializing HTTPSFetcher')\n    super().__init__(trestle_root, uri)\n    self._username = None\n    self._password = None\n    u = parse.urlparse(self._uri)\n    self._url = uri\n    # If the either the username or password is omitted in the URI, then the other becomes ''\n    # so we test for either None or ''.\n    if u.username != '' and u.username is not None:\n        # This also checks for invalid environment variable name (IEEE 1003.1)\n        if not re.match('{{[a-zA-Z_][a-zA-Z0-9_]*}}', u.username) or u.username == '{{_}}':\n            raise TrestleError(\n                'Cache request for invalid input URI: '\n                f'username must refer to an environment variable using moustache {self._uri}'\n            )\n        username_var = u.username[2:-2]\n        if username_var not in os.environ:\n            raise TrestleError(\n                f'Cache request for invalid input URI: username not found in the environment {self._uri}'\n            )\n        self._username = os.environ[username_var]\n    if u.password != '' and u.password is not None:  # noqa S105\n        if not re.match('{{[a-zA-Z_][a-zA-Z0-9_]*}}', u.password) or u.password == '{{_}}':  # noqa S105\n            raise TrestleError(\n                'Cache request for invalid input URI: '\n                f'password must refer to an environment variable using moustache {self._uri}'\n            )\n        password_var = u.password[2:-2]\n        if password_var not in os.environ:\n            raise TrestleError(\n                'Cache request for invalid input URI: '\n                f'password not found in the environment {self._uri}'\n            )\n        self._password = os.environ[password_var]\n    if self._username and (self._password == '' or self._password is None):  # noqa S105\n        raise TrestleError(\n            f'Cache request for invalid input URI: username found '\n            f'but password not found via environment variable {self._uri}'\n        )\n    if self._password and not self._username:\n        raise TrestleError(\n            f'Cache request for invalid input URI: password found '\n            f'but username not found via environment variable {self._uri}'\n        )\n    https_cached_dir = self._trestle_cache_path / u.hostname\n    # Skip any number of back- or forward slashes preceding the URI path (u.path)\n    path_parent = pathlib.Path(u.path[re.search('[^/\\\\\\\\]', u.path).span()[0]:]).parent\n    https_cached_dir = https_cached_dir / path_parent\n    https_cached_dir.mkdir(parents=True, exist_ok=True)\n    self._cached_object_path = https_cached_dir / pathlib.Path(pathlib.Path(u.path).name)\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.LocalFetcher","title":"<code> LocalFetcher            (FetcherBase)         </code>","text":"<p>Fetcher for local content.</p> <p>Used for both file:/// and C:\\ or C:/ type paths, but the path must be absolute. Also used for trestle:// files present in the current trestle root.</p> <p>If file:/// is used on a Windows system, it must be followed by C:/ or other drive letter to be sure it is an absolute path, e.g. file:///C:/Users/Default/Documents/profile.json. The drive letter may be lowercase. LocalFetcher does not do any caching and assumes the file is quickly accessible.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>class LocalFetcher(FetcherBase):\nr\"\"\"Fetcher for local content.\n\n    Used for both file:/// and C:\\\\ or C:/ type paths, but the path must be absolute.\n    Also used for trestle:// files present in the current trestle root.\n\n    If file:/// is used on a Windows system, it must be followed by C:/ or other drive letter\n    to be sure it is an absolute path, e.g. file:///C:/Users/Default/Documents/profile.json.\n    The drive letter may be lowercase.\n    LocalFetcher does not do any caching and assumes the file is quickly accessible.\n    \"\"\"\n\n    def __init__(self, trestle_root: pathlib.Path, uri: str) -&gt; None:\n\"\"\"Initialize local fetcher.\n\n        Args:\n            trestle_root: trestle root path\n            uri: Reference to the file in the local filesystem to cache, which must be outside trestle_root.\n        \"\"\"\n        super().__init__(trestle_root, uri)\n\n        # Handle as file:/// form\n        if uri.startswith(const.FILE_URI):\n            # strip off entire header including /\n            uri = uri[len(const.FILE_URI):]\n\n            # if it has a drive letter don't add / to front\n            uri = uri if re.match(const.WINDOWS_DRIVE_LETTER_REGEX, uri) else '/' + uri\n        elif uri.startswith(const.TRESTLE_HREF_HEADING):\n            uri = str(trestle_root / uri[len(const.TRESTLE_HREF_HEADING):])\n            self._abs_path = pathlib.Path(uri).resolve()\n            self._cached_object_path = self._abs_path\n            return\n\n        # now the URI should be either unix / style or windows C:/ style.  It may be relative.\n\n        if ':' in uri and platform.system() != const.WINDOWS_PLATFORM_STR:\n            raise TrestleError(f'Cannot have : in uri on non-Windows system unless ftps, https or trestle: {uri}')\n\n        # if it has a drive letter but no / after it, it is not absolute\n        if re.match(const.WINDOWS_DRIVE_LETTER_REGEX, uri):\n            if platform.system() != const.WINDOWS_PLATFORM_STR:\n                raise TrestleError(f'Cannot cache Windows paths on non-Windows system. {uri}')\n\n        # store the abs path to the file for fetching\n        # if this is a windows file it will have a drive letter at start after resolve\n        try:\n            self._abs_path = pathlib.Path(uri).resolve()\n        except Exception:\n            raise TrestleError(f'The uri provided is invalid or unresolvable as a file path: {uri}')\n\n        # set the cached path to be the actual file path\n        self._cached_object_path = self._abs_path\n\n    def _is_stale(self):\n        # Local file is always stale.\n        return True\n\n    def _do_fetch(self) -&gt; None:\n\"\"\"No need to fetch since using actual file path.\"\"\"\n        pass\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.LocalFetcher-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.LocalFetcher.__init__","title":"<code>__init__(self, trestle_root, uri)</code>  <code>special</code>","text":"<p>Initialize local fetcher.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>trestle root path</p> required <code>uri</code> <code>str</code> <p>Reference to the file in the local filesystem to cache, which must be outside trestle_root.</p> required Source code in <code>trestle/core/remote/cache.py</code> <pre><code>def __init__(self, trestle_root: pathlib.Path, uri: str) -&gt; None:\n\"\"\"Initialize local fetcher.\n\n    Args:\n        trestle_root: trestle root path\n        uri: Reference to the file in the local filesystem to cache, which must be outside trestle_root.\n    \"\"\"\n    super().__init__(trestle_root, uri)\n\n    # Handle as file:/// form\n    if uri.startswith(const.FILE_URI):\n        # strip off entire header including /\n        uri = uri[len(const.FILE_URI):]\n\n        # if it has a drive letter don't add / to front\n        uri = uri if re.match(const.WINDOWS_DRIVE_LETTER_REGEX, uri) else '/' + uri\n    elif uri.startswith(const.TRESTLE_HREF_HEADING):\n        uri = str(trestle_root / uri[len(const.TRESTLE_HREF_HEADING):])\n        self._abs_path = pathlib.Path(uri).resolve()\n        self._cached_object_path = self._abs_path\n        return\n\n    # now the URI should be either unix / style or windows C:/ style.  It may be relative.\n\n    if ':' in uri and platform.system() != const.WINDOWS_PLATFORM_STR:\n        raise TrestleError(f'Cannot have : in uri on non-Windows system unless ftps, https or trestle: {uri}')\n\n    # if it has a drive letter but no / after it, it is not absolute\n    if re.match(const.WINDOWS_DRIVE_LETTER_REGEX, uri):\n        if platform.system() != const.WINDOWS_PLATFORM_STR:\n            raise TrestleError(f'Cannot cache Windows paths on non-Windows system. {uri}')\n\n    # store the abs path to the file for fetching\n    # if this is a windows file it will have a drive letter at start after resolve\n    try:\n        self._abs_path = pathlib.Path(uri).resolve()\n    except Exception:\n        raise TrestleError(f'The uri provided is invalid or unresolvable as a file path: {uri}')\n\n    # set the cached path to be the actual file path\n    self._cached_object_path = self._abs_path\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.SFTPFetcher","title":"<code> SFTPFetcher            (FetcherBase)         </code>","text":"<p>Fetcher for SFTP content.</p> Source code in <code>trestle/core/remote/cache.py</code> <pre><code>class SFTPFetcher(FetcherBase):\n\"\"\"Fetcher for SFTP content.\"\"\"\n\n    def __init__(self, trestle_root: pathlib.Path, uri: str) -&gt; None:\n\"\"\"Initialize SFTP fetcher. Update the expected cache path as per caching specs.\n\n        Args:\n            trestle_root: Path of the trestle workspace, i.e., within which .trestle is to be found.\n            uri: Reference to the remote file to cache that can be fetched using the sftp:// scheme.\n        \"\"\"\n        logger.debug(f'initialize SFTPFetcher for uri {uri}')\n        super().__init__(trestle_root, uri)\n        # Is this a valid URI, however? Username and password are optional, of course.\n        try:\n            u = parse.urlparse(self._uri)\n        except Exception as e:\n            logger.warning(f'SFTP fetcher unable to parse uri {self._uri} error {e}')\n            raise TrestleError(f'Unable to parse malformed url {self._uri} error {e}')\n        logger.debug(f'SFTP fetcher with parsed uri {u}')\n        if not u.hostname:\n            logger.debug('SFTP fetcher uri missing hostname')\n            logger.warning(f'Malformed URI, cannot parse hostname in URL {self._uri}')\n            raise TrestleError(f'Cache request for invalid input URI: missing hostname {self._uri}')\n        if not u.path:\n            logger.debug('SFTP fetcher uri missing path')\n            logger.warning(f'Malformed URI, cannot parse path in URL {self._uri}')\n            raise TrestleError(f'Cache request for invalid input URI: missing file path {self._uri}')\n\n        sftp_cached_dir = self._trestle_cache_path / u.hostname\n        # Skip any number of back- or forward slashes preceding the URL path (u.path)\n        path_parent = pathlib.Path(u.path[re.search('[^/\\\\\\\\]', u.path).span()[0]:]).parent\n        sftp_cached_dir = sftp_cached_dir / path_parent\n        sftp_cached_dir.mkdir(parents=True, exist_ok=True)\n        self._cached_object_path = sftp_cached_dir / pathlib.Path(pathlib.Path(u.path).name)\n\n    def _do_fetch(self) -&gt; None:\n\"\"\"Fetch remote object and update the cache if appropriate and possible to do so.\n\n        Authentication relies on the user's private key being either active via ssh-agent or\n        supplied via environment variable SSH_KEY. In the latter case, it must not require a passphrase prompt.\n        \"\"\"\n        u = parse.urlparse(self._uri)\n        client = paramiko.SSHClient()\n        # Must pick up host keys from the default known_hosts on this environment:\n        try:\n            client.load_system_host_keys()\n        except Exception as e:\n            raise TrestleError(f'Cache update failure for {self._uri}: {e}.')\n        # Use the supplied private key file if given, or look for keys in default path.\n        if 'SSH_KEY' in os.environ:\n            pkey = paramiko.RSAKey.from_private_key(StringIO(os.environ['SSH_KEY']))\n            look_for_keys = False\n        else:\n            pkey = None\n            look_for_keys = True\n\n        username = getpass.getuser() if not u.username else u.username\n        try:\n            client.connect(\n                u.hostname,\n                username=username,\n                password=u.password,\n                pkey=pkey,\n                look_for_keys=look_for_keys,\n                port=22 if not u.port else u.port,\n            )\n        except Exception as e:\n            raise TrestleError(f'Cache update failure to connect via SSH: {u.hostname}: {e}.')\n\n        try:\n            sftp_client = client.open_sftp()\n        except Exception as e:\n            raise TrestleError(f'Cache update failure to open sftp for {u.hostname}: {e}.')\n\n        localpath = self._cached_object_path\n        try:\n            sftp_client.get(remotepath=u.path[1:], localpath=(localpath.__str__()))\n        except Exception as e:\n            raise TrestleError(f'Error getting remote resource {self._uri} into cache {localpath}: {e}')\n</code></pre>"},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.SFTPFetcher-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.remote.cache/#trestle.core.remote.cache.SFTPFetcher.__init__","title":"<code>__init__(self, trestle_root, uri)</code>  <code>special</code>","text":"<p>Initialize SFTP fetcher. Update the expected cache path as per caching specs.</p> <p>Parameters:</p> Name Type Description Default <code>trestle_root</code> <code>Path</code> <p>Path of the trestle workspace, i.e., within which .trestle is to be found.</p> required <code>uri</code> <code>str</code> <p>Reference to the remote file to cache that can be fetched using the sftp:// scheme.</p> required Source code in <code>trestle/core/remote/cache.py</code> <pre><code>def __init__(self, trestle_root: pathlib.Path, uri: str) -&gt; None:\n\"\"\"Initialize SFTP fetcher. Update the expected cache path as per caching specs.\n\n    Args:\n        trestle_root: Path of the trestle workspace, i.e., within which .trestle is to be found.\n        uri: Reference to the remote file to cache that can be fetched using the sftp:// scheme.\n    \"\"\"\n    logger.debug(f'initialize SFTPFetcher for uri {uri}')\n    super().__init__(trestle_root, uri)\n    # Is this a valid URI, however? Username and password are optional, of course.\n    try:\n        u = parse.urlparse(self._uri)\n    except Exception as e:\n        logger.warning(f'SFTP fetcher unable to parse uri {self._uri} error {e}')\n        raise TrestleError(f'Unable to parse malformed url {self._uri} error {e}')\n    logger.debug(f'SFTP fetcher with parsed uri {u}')\n    if not u.hostname:\n        logger.debug('SFTP fetcher uri missing hostname')\n        logger.warning(f'Malformed URI, cannot parse hostname in URL {self._uri}')\n        raise TrestleError(f'Cache request for invalid input URI: missing hostname {self._uri}')\n    if not u.path:\n        logger.debug('SFTP fetcher uri missing path')\n        logger.warning(f'Malformed URI, cannot parse path in URL {self._uri}')\n        raise TrestleError(f'Cache request for invalid input URI: missing file path {self._uri}')\n\n    sftp_cached_dir = self._trestle_cache_path / u.hostname\n    # Skip any number of back- or forward slashes preceding the URL path (u.path)\n    path_parent = pathlib.Path(u.path[re.search('[^/\\\\\\\\]', u.path).span()[0]:]).parent\n    sftp_cached_dir = sftp_cached_dir / path_parent\n    sftp_cached_dir.mkdir(parents=True, exist_ok=True)\n    self._cached_object_path = sftp_cached_dir / pathlib.Path(pathlib.Path(u.path).name)\n</code></pre>"},{"location":"api_reference/trestle.core.repository/","title":"repository","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository","title":"<code>trestle.core.repository</code>","text":"<p>Trestle Repository APIs.</p>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.repository/#trestle.core.repository-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.ManagedOSCAL","title":"<code> ManagedOSCAL        </code>","text":"<p>Object representing OSCAL models in repository for programmatic manipulation.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>class ManagedOSCAL:\n\"\"\"Object representing OSCAL models in repository for programmatic manipulation.\"\"\"\n\n    def __init__(self, root_dir: pathlib.Path, model_type: Type[OscalBaseModel], name: str) -&gt; None:\n\"\"\"Initialize repository OSCAL model object.\"\"\"\n        if not file_utils.is_valid_project_root(root_dir):\n            raise TrestleError(f'Provided root directory {str(root_dir)} is not a valid Trestle root directory.')\n        self.root_dir = root_dir\n        self.model_type = model_type\n        self.model_name = name\n\n        # set model alais and dir\n        self.model_alias = classname_to_alias(self.model_type.__name__, AliasMode.JSON)\n        if parser.to_full_model_name(self.model_alias) is None:\n            raise TrestleError(f'Given model {self.model_alias} is not a top level model.')\n\n        plural_path = ModelUtils.model_type_to_model_dir(self.model_alias)\n        self.model_dir = self.root_dir / plural_path / self.model_name\n\n        if not self.model_dir.exists() or not self.model_dir.is_dir():\n            raise TrestleError(f'Model dir {self.model_name} does not exist.')\n\n        file_content_type = FileContentType.path_to_content_type(self.model_dir / self.model_alias)\n        if file_content_type == FileContentType.UNKNOWN:\n            raise TrestleError(f'Model file for model {self.model_name} does not exist.')\n        self.file_content_type = file_content_type\n\n        filepath = pathlib.Path(\n            self.model_dir,\n            self.model_alias + FileContentType.path_to_file_extension(self.model_dir / self.model_alias)\n        )\n\n        self.filepath = filepath\n\n    def read(self) -&gt; OscalBaseModel:\n\"\"\"Read OSCAL model from repository.\"\"\"\n        logger.debug(f'Reading model {self.model_name}.')\n        model = load_validate_model_path(self.root_dir, self.filepath)\n        return model\n\n    def write(self, model: OscalBaseModel) -&gt; bool:\n\"\"\"Write OSCAL model to repository.\"\"\"\n        logger.debug(f'Writing model {self.model_name}.')\n        model_alias = classname_to_alias(model.__class__.__name__, AliasMode.JSON)\n        if parser.to_full_model_name(model_alias) is None:\n            raise TrestleError(f'Given model {model_alias} is not a top level model.')\n\n        # split directory if the model was split\n        split_dir = pathlib.Path(self.model_dir, self.model_alias)\n\n        # Prepare actions; delete split model dir if any, recreate model file, and write to filepath\n        top_element = Element(model)\n        remove_action = RemovePathAction(split_dir)\n        create_action = CreatePathAction(self.filepath, True)\n        write_action = WriteFileAction(self.filepath, top_element, self.file_content_type)\n\n        # create a plan to create the directory and imported file.\n        import_plan = Plan()\n        import_plan.add_action(remove_action)\n        import_plan.add_action(create_action)\n        import_plan.add_action(write_action)\n\n        import_plan.execute()\n\n        logger.debug(f'Model {self.model_name} written to repository')\n        return True\n\n    def split(self, model_file: pathlib.Path, elements: List[str]) -&gt; bool:\n\"\"\"Split the given OSCAL model file in repository.\n\n        Model file path should be relative to the main model directory, e.g., model dir is $TRESTLE_ROOT/catalogs/NIST\n        then model file path can be 'catalog/metadata.json' if metadata is to be split.\n\n        Elements should be specified relative to model file, e.g., 'metadata.props.*'\n        \"\"\"\n        logger.debug(f'Splitting model {self.model_name}, file {model_file}.')\n        # input model_file should be relative to the model dir\n        model_file_path = self.model_dir / model_file\n        model_file_path = model_file_path.resolve()\n        file_parent = model_file_path.parent\n        filename = model_file_path.name\n\n        elems = ''\n        first = True\n        for elem in elements:\n            if first:\n                elems = elem\n                first = False\n            else:\n                elems = elems + ',' + elem\n\n        success = False\n        try:\n            ret = splitcmd.SplitCmd().perform_split(file_parent, filename, elems, self.root_dir)\n            if ret == 0:\n                success = True\n        except Exception as e:\n            raise TrestleError(f'Error in splitting model: {e}')\n\n        logger.debug(f'Model {self.model_name}, file {model_file} splitted successfully.')\n        return success\n\n    def merge(self, elements: List[str], parent_model_dir: Optional[pathlib.Path] = None) -&gt; bool:\n\"\"\"Merge OSCAL elements in repository.\n\n        The parent_model_dir specifies the parent model direcotry in which to merge relative to main model dir.\n        For example, if we have to merge 'metadata.*' into 'metadata' then parent_model_dir should be the 'catalog'\n        dir that contains the 'metadata.json' file or the 'metadata' directory\n        \"\"\"\n        logger.debug(f'Merging model {self.model_name}, parent dir {parent_model_dir}.')\n        if parent_model_dir is None:\n            effective_cwd = self.model_dir\n        else:\n            effective_cwd = self.model_dir / parent_model_dir\n\n        success = True\n        try:\n            for elem in elements:\n                plan = mergecmd.MergeCmd.merge(effective_cwd, ElementPath(elem), self.root_dir)\n                plan.execute()\n\n        except Exception as e:\n            raise TrestleError(f'Error in merging model: {e}')\n\n        logger.debug(f'Model {self.model_name} merged successfully.')\n        return success\n\n    def validate(self) -&gt; bool:\n\"\"\"Validate OSCAL model in repository.\"\"\"\n        logger.debug(f'Validating model {self.model_name}.')\n        repo = Repository(self.root_dir)\n        success = repo.validate_model(self.model_type, self.model_name)\n        return success\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.ManagedOSCAL-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.ManagedOSCAL.__init__","title":"<code>__init__(self, root_dir, model_type, name)</code>  <code>special</code>","text":"<p>Initialize repository OSCAL model object.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def __init__(self, root_dir: pathlib.Path, model_type: Type[OscalBaseModel], name: str) -&gt; None:\n\"\"\"Initialize repository OSCAL model object.\"\"\"\n    if not file_utils.is_valid_project_root(root_dir):\n        raise TrestleError(f'Provided root directory {str(root_dir)} is not a valid Trestle root directory.')\n    self.root_dir = root_dir\n    self.model_type = model_type\n    self.model_name = name\n\n    # set model alais and dir\n    self.model_alias = classname_to_alias(self.model_type.__name__, AliasMode.JSON)\n    if parser.to_full_model_name(self.model_alias) is None:\n        raise TrestleError(f'Given model {self.model_alias} is not a top level model.')\n\n    plural_path = ModelUtils.model_type_to_model_dir(self.model_alias)\n    self.model_dir = self.root_dir / plural_path / self.model_name\n\n    if not self.model_dir.exists() or not self.model_dir.is_dir():\n        raise TrestleError(f'Model dir {self.model_name} does not exist.')\n\n    file_content_type = FileContentType.path_to_content_type(self.model_dir / self.model_alias)\n    if file_content_type == FileContentType.UNKNOWN:\n        raise TrestleError(f'Model file for model {self.model_name} does not exist.')\n    self.file_content_type = file_content_type\n\n    filepath = pathlib.Path(\n        self.model_dir,\n        self.model_alias + FileContentType.path_to_file_extension(self.model_dir / self.model_alias)\n    )\n\n    self.filepath = filepath\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.ManagedOSCAL.merge","title":"<code>merge(self, elements, parent_model_dir=None)</code>","text":"<p>Merge OSCAL elements in repository.</p> <p>The parent_model_dir specifies the parent model direcotry in which to merge relative to main model dir. For example, if we have to merge 'metadata.*' into 'metadata' then parent_model_dir should be the 'catalog' dir that contains the 'metadata.json' file or the 'metadata' directory</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def merge(self, elements: List[str], parent_model_dir: Optional[pathlib.Path] = None) -&gt; bool:\n\"\"\"Merge OSCAL elements in repository.\n\n    The parent_model_dir specifies the parent model direcotry in which to merge relative to main model dir.\n    For example, if we have to merge 'metadata.*' into 'metadata' then parent_model_dir should be the 'catalog'\n    dir that contains the 'metadata.json' file or the 'metadata' directory\n    \"\"\"\n    logger.debug(f'Merging model {self.model_name}, parent dir {parent_model_dir}.')\n    if parent_model_dir is None:\n        effective_cwd = self.model_dir\n    else:\n        effective_cwd = self.model_dir / parent_model_dir\n\n    success = True\n    try:\n        for elem in elements:\n            plan = mergecmd.MergeCmd.merge(effective_cwd, ElementPath(elem), self.root_dir)\n            plan.execute()\n\n    except Exception as e:\n        raise TrestleError(f'Error in merging model: {e}')\n\n    logger.debug(f'Model {self.model_name} merged successfully.')\n    return success\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.ManagedOSCAL.read","title":"<code>read(self)</code>","text":"<p>Read OSCAL model from repository.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def read(self) -&gt; OscalBaseModel:\n\"\"\"Read OSCAL model from repository.\"\"\"\n    logger.debug(f'Reading model {self.model_name}.')\n    model = load_validate_model_path(self.root_dir, self.filepath)\n    return model\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.ManagedOSCAL.split","title":"<code>split(self, model_file, elements)</code>","text":"<p>Split the given OSCAL model file in repository.</p> <p>Model file path should be relative to the main model directory, e.g., model dir is $TRESTLE_ROOT/catalogs/NIST then model file path can be 'catalog/metadata.json' if metadata is to be split.</p> <p>Elements should be specified relative to model file, e.g., 'metadata.props.*'</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def split(self, model_file: pathlib.Path, elements: List[str]) -&gt; bool:\n\"\"\"Split the given OSCAL model file in repository.\n\n    Model file path should be relative to the main model directory, e.g., model dir is $TRESTLE_ROOT/catalogs/NIST\n    then model file path can be 'catalog/metadata.json' if metadata is to be split.\n\n    Elements should be specified relative to model file, e.g., 'metadata.props.*'\n    \"\"\"\n    logger.debug(f'Splitting model {self.model_name}, file {model_file}.')\n    # input model_file should be relative to the model dir\n    model_file_path = self.model_dir / model_file\n    model_file_path = model_file_path.resolve()\n    file_parent = model_file_path.parent\n    filename = model_file_path.name\n\n    elems = ''\n    first = True\n    for elem in elements:\n        if first:\n            elems = elem\n            first = False\n        else:\n            elems = elems + ',' + elem\n\n    success = False\n    try:\n        ret = splitcmd.SplitCmd().perform_split(file_parent, filename, elems, self.root_dir)\n        if ret == 0:\n            success = True\n    except Exception as e:\n        raise TrestleError(f'Error in splitting model: {e}')\n\n    logger.debug(f'Model {self.model_name}, file {model_file} splitted successfully.')\n    return success\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.ManagedOSCAL.validate","title":"<code>validate(self)</code>","text":"<p>Validate OSCAL model in repository.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def validate(self) -&gt; bool:\n\"\"\"Validate OSCAL model in repository.\"\"\"\n    logger.debug(f'Validating model {self.model_name}.')\n    repo = Repository(self.root_dir)\n    success = repo.validate_model(self.model_type, self.model_name)\n    return success\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.ManagedOSCAL.write","title":"<code>write(self, model)</code>","text":"<p>Write OSCAL model to repository.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def write(self, model: OscalBaseModel) -&gt; bool:\n\"\"\"Write OSCAL model to repository.\"\"\"\n    logger.debug(f'Writing model {self.model_name}.')\n    model_alias = classname_to_alias(model.__class__.__name__, AliasMode.JSON)\n    if parser.to_full_model_name(model_alias) is None:\n        raise TrestleError(f'Given model {model_alias} is not a top level model.')\n\n    # split directory if the model was split\n    split_dir = pathlib.Path(self.model_dir, self.model_alias)\n\n    # Prepare actions; delete split model dir if any, recreate model file, and write to filepath\n    top_element = Element(model)\n    remove_action = RemovePathAction(split_dir)\n    create_action = CreatePathAction(self.filepath, True)\n    write_action = WriteFileAction(self.filepath, top_element, self.file_content_type)\n\n    # create a plan to create the directory and imported file.\n    import_plan = Plan()\n    import_plan.add_action(remove_action)\n    import_plan.add_action(create_action)\n    import_plan.add_action(write_action)\n\n    import_plan.execute()\n\n    logger.debug(f'Model {self.model_name} written to repository')\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository","title":"<code> Repository        </code>","text":"<p>Repository class for performing operations on Trestle repository.</p> <p>This class provides a set of APIs to perform operations on trestle repository programmatically rather than using the command line. It takes the trestle root directory as input while creating an instance of this object. Operations such as import and get model return a ManagedOSCAL object representing the specific model that can be used to perform operations on the specific models.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>class Repository:\n\"\"\"Repository class for performing operations on Trestle repository.\n\n    This class provides a set of APIs to perform operations on trestle repository programmatically\n    rather than using the command line. It takes the trestle root directory as input while creating\n    an instance of this object. Operations such as import and get model return a ManagedOSCAL object\n    representing the specific model that can be used to perform operations on the specific models.\n\n    \"\"\"\n\n    def __init__(self, root_dir: pathlib.Path) -&gt; None:\n\"\"\"Initialize trestle repository object.\"\"\"\n        if not file_utils.is_valid_project_root(root_dir):\n            raise TrestleError(f'Provided root directory {root_dir} is not a valid Trestle root directory.')\n        self.root_dir = root_dir\n\n    def import_model(self, model: OscalBaseModel, name: str, content_type='json') -&gt; ManagedOSCAL:\n\"\"\"Import OSCAL object into trestle repository.\"\"\"\n        logger.debug(f'Importing model {name} of type {model.__class__.__name__}.')\n        model_alias = classname_to_alias(model.__class__.__name__, AliasMode.JSON)\n        if parser.to_full_model_name(model_alias) is None:\n            raise TrestleError(f'Given model {model_alias} is not a top level model.')\n\n        # Work out output directory and file\n        plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n\n        desired_model_dir = self.root_dir / plural_path\n        desired_model_path = desired_model_dir / name / (model_alias + '.' + content_type)\n        desired_model_path = desired_model_path.resolve()\n\n        if desired_model_path.exists():\n            raise TrestleError(f'OSCAL file to be created here: {desired_model_path} exists.')\n\n        content_type = FileContentType.to_content_type(pathlib.Path(desired_model_path).suffix)\n\n        # Prepare actions\n        top_element = Element(model)\n        create_action = CreatePathAction(desired_model_path, True)\n        write_action = WriteFileAction(desired_model_path, top_element, content_type)\n\n        # create a plan to create the directory and imported file.\n        import_plan = Plan()\n        import_plan.add_action(create_action)\n        import_plan.add_action(write_action)\n        import_plan.execute()\n\n        # Validate the imported file, rollback if unsuccessful\n        success = False\n        errmsg = ''\n        try:\n            success = self.validate_model(model.__class__, name)\n            if not success:\n                errmsg = f'Validation of model {name} did not pass'\n                logger.error(errmsg)\n        except Exception as err:\n            logger.error(errmsg)\n            errmsg = f'Import of model {name} failed. Validation failed with error: {err}'\n\n        if not success:\n            # rollback in case of validation error or failure\n            logger.debug(f'Rolling back import of model {name} to {desired_model_path}')\n            try:\n                import_plan.rollback()\n            except TrestleError as err:\n                logger.error(f'Failed to rollback: {err}. Remove {desired_model_path} to resolve state.')\n            else:\n                logger.debug(f'Successful rollback of import to {desired_model_path}')\n\n            # raise trestle error\n            raise TrestleError(errmsg)\n\n        # all well; model was imported and validated successfully\n        logger.debug(f'Model {name} of type {model.__class__.__name__} imported successfully.')\n        return ManagedOSCAL(self.root_dir, model.__class__, name)\n\n    def load_and_import_model(self, model_path: pathlib.Path, name: str, content_type='json') -&gt; ManagedOSCAL:\n\"\"\"Load the model at the specified path into trestle with the specified name.\"\"\"\n        fetcher = cache.FetcherFactory.get_fetcher(self.root_dir, str(model_path))\n        model, _ = fetcher.get_oscal(True)\n\n        return self.import_model(model, name, content_type)\n\n    def list_models(self, model_type: Type[OscalBaseModel]) -&gt; List[str]:\n\"\"\"List models of a given type in trestle repository.\"\"\"\n        logger.debug(f'Listing models of type {model_type.__name__}.')\n        model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n        if parser.to_full_model_name(model_alias) is None:\n            raise TrestleError(f'Given model {model_alias} is not a top level model.')\n        models = ModelUtils.get_models_of_type(model_alias, self.root_dir)\n\n        return models\n\n    def get_model(self, model_type: Type[OscalBaseModel], name: str) -&gt; ManagedOSCAL:\n\"\"\"Get a specific OSCAL model from repository.\"\"\"\n        logger.debug(f'Getting model {name} of type {model_type.__name__}.')\n        model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n        if parser.to_full_model_name(model_alias) is None:\n            raise TrestleError(f'Given model {model_alias} is not a top level model.')\n        plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n        desired_model_dir = self.root_dir / plural_path / name\n\n        if not desired_model_dir.exists() or not desired_model_dir.is_dir():\n            raise TrestleError(f'Model {name} does not exist.')\n\n        return ManagedOSCAL(self.root_dir, model_type, name)\n\n    def delete_model(self, model_type: Type[OscalBaseModel], name: str) -&gt; bool:\n\"\"\"Delete an OSCAL model from repository.\"\"\"\n        logger.debug(f'Deleting model {name} of type {model_type.__name__}.')\n        model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n        if parser.to_full_model_name(model_alias) is None:\n            raise TrestleError(f'Given model {model_alias} is not a top level model.')\n        plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n        desired_model_dir = self.root_dir / plural_path / name\n\n        if not desired_model_dir.exists() or not desired_model_dir.is_dir():\n            raise TrestleError(f'Model {name} does not exist.')\n        shutil.rmtree(desired_model_dir)\n\n        # remove model from dist directory if it exists\n        dist_model_dir = self.root_dir / const.TRESTLE_DIST_DIR / plural_path\n        file_content_type = FileContentType.path_to_content_type(dist_model_dir / name)\n        if file_content_type != FileContentType.UNKNOWN:\n            file_path = pathlib.Path(\n                dist_model_dir, name + FileContentType.path_to_file_extension(dist_model_dir / name)\n            )\n            logger.debug(f'Deleting model {name} from dist directory.')\n            os.remove(file_path)\n\n        logger.debug(f'Model {name} deleted successfully.')\n        return True\n\n    def assemble_model(self, model_type: Type[OscalBaseModel], name: str, extension='json') -&gt; bool:\n\"\"\"Assemble an OSCAL model in repository and publish it to 'dist' directory.\"\"\"\n        logger.debug(f'Assembling model {name} of type {model_type.__name__}.')\n        success = False\n\n        model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n        if parser.to_full_model_name(model_alias) is None:\n            raise TrestleError(f'Given model {model_alias} is not a top level model.')\n\n        verbose = log.get_current_verbosity_level(logger)\n        args = argparse.Namespace(\n            type=model_alias, name=name, extension=extension, trestle_root=self.root_dir, verbose=verbose\n        )\n\n        try:\n            ret = assemblecmd.AssembleCmd().assemble_model(model_alias, args)\n            if ret == 0:\n                success = True\n        except Exception as e:\n            raise TrestleError(f'Error in assembling model: {e}')\n\n        logger.debug(f'Model {name} assembled successfully.')\n        return success\n\n    def validate_model(self, model_type: Type[OscalBaseModel], name: str) -&gt; bool:\n\"\"\"Validate an OSCAL model in repository.\"\"\"\n        logger.debug(f'Validating model {name} of type {model_type.__name__}.')\n        success = False\n\n        model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n        if parser.to_full_model_name(model_alias) is None:\n            raise TrestleError(f'Given model {model_alias} is not a top level model.')\n\n        verbose = log.get_current_verbosity_level(logger)\n        args = argparse.Namespace(type=model_alias, name=name, trestle_root=self.root_dir, verbose=verbose, quiet=False)\n\n        try:\n            ret = validatecmd.ValidateCmd()._run(args)\n            if ret == 0:\n                success = True\n        except Exception as e:\n            raise TrestleError(f'Error in validating model: {e}')\n\n        logger.debug(f'Model {name} validated successfully.')\n        return success\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository.__init__","title":"<code>__init__(self, root_dir)</code>  <code>special</code>","text":"<p>Initialize trestle repository object.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def __init__(self, root_dir: pathlib.Path) -&gt; None:\n\"\"\"Initialize trestle repository object.\"\"\"\n    if not file_utils.is_valid_project_root(root_dir):\n        raise TrestleError(f'Provided root directory {root_dir} is not a valid Trestle root directory.')\n    self.root_dir = root_dir\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository.assemble_model","title":"<code>assemble_model(self, model_type, name, extension='json')</code>","text":"<p>Assemble an OSCAL model in repository and publish it to 'dist' directory.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def assemble_model(self, model_type: Type[OscalBaseModel], name: str, extension='json') -&gt; bool:\n\"\"\"Assemble an OSCAL model in repository and publish it to 'dist' directory.\"\"\"\n    logger.debug(f'Assembling model {name} of type {model_type.__name__}.')\n    success = False\n\n    model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n    if parser.to_full_model_name(model_alias) is None:\n        raise TrestleError(f'Given model {model_alias} is not a top level model.')\n\n    verbose = log.get_current_verbosity_level(logger)\n    args = argparse.Namespace(\n        type=model_alias, name=name, extension=extension, trestle_root=self.root_dir, verbose=verbose\n    )\n\n    try:\n        ret = assemblecmd.AssembleCmd().assemble_model(model_alias, args)\n        if ret == 0:\n            success = True\n    except Exception as e:\n        raise TrestleError(f'Error in assembling model: {e}')\n\n    logger.debug(f'Model {name} assembled successfully.')\n    return success\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository.delete_model","title":"<code>delete_model(self, model_type, name)</code>","text":"<p>Delete an OSCAL model from repository.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def delete_model(self, model_type: Type[OscalBaseModel], name: str) -&gt; bool:\n\"\"\"Delete an OSCAL model from repository.\"\"\"\n    logger.debug(f'Deleting model {name} of type {model_type.__name__}.')\n    model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n    if parser.to_full_model_name(model_alias) is None:\n        raise TrestleError(f'Given model {model_alias} is not a top level model.')\n    plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n    desired_model_dir = self.root_dir / plural_path / name\n\n    if not desired_model_dir.exists() or not desired_model_dir.is_dir():\n        raise TrestleError(f'Model {name} does not exist.')\n    shutil.rmtree(desired_model_dir)\n\n    # remove model from dist directory if it exists\n    dist_model_dir = self.root_dir / const.TRESTLE_DIST_DIR / plural_path\n    file_content_type = FileContentType.path_to_content_type(dist_model_dir / name)\n    if file_content_type != FileContentType.UNKNOWN:\n        file_path = pathlib.Path(\n            dist_model_dir, name + FileContentType.path_to_file_extension(dist_model_dir / name)\n        )\n        logger.debug(f'Deleting model {name} from dist directory.')\n        os.remove(file_path)\n\n    logger.debug(f'Model {name} deleted successfully.')\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository.get_model","title":"<code>get_model(self, model_type, name)</code>","text":"<p>Get a specific OSCAL model from repository.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def get_model(self, model_type: Type[OscalBaseModel], name: str) -&gt; ManagedOSCAL:\n\"\"\"Get a specific OSCAL model from repository.\"\"\"\n    logger.debug(f'Getting model {name} of type {model_type.__name__}.')\n    model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n    if parser.to_full_model_name(model_alias) is None:\n        raise TrestleError(f'Given model {model_alias} is not a top level model.')\n    plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n    desired_model_dir = self.root_dir / plural_path / name\n\n    if not desired_model_dir.exists() or not desired_model_dir.is_dir():\n        raise TrestleError(f'Model {name} does not exist.')\n\n    return ManagedOSCAL(self.root_dir, model_type, name)\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository.import_model","title":"<code>import_model(self, model, name, content_type='json')</code>","text":"<p>Import OSCAL object into trestle repository.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def import_model(self, model: OscalBaseModel, name: str, content_type='json') -&gt; ManagedOSCAL:\n\"\"\"Import OSCAL object into trestle repository.\"\"\"\n    logger.debug(f'Importing model {name} of type {model.__class__.__name__}.')\n    model_alias = classname_to_alias(model.__class__.__name__, AliasMode.JSON)\n    if parser.to_full_model_name(model_alias) is None:\n        raise TrestleError(f'Given model {model_alias} is not a top level model.')\n\n    # Work out output directory and file\n    plural_path = ModelUtils.model_type_to_model_dir(model_alias)\n\n    desired_model_dir = self.root_dir / plural_path\n    desired_model_path = desired_model_dir / name / (model_alias + '.' + content_type)\n    desired_model_path = desired_model_path.resolve()\n\n    if desired_model_path.exists():\n        raise TrestleError(f'OSCAL file to be created here: {desired_model_path} exists.')\n\n    content_type = FileContentType.to_content_type(pathlib.Path(desired_model_path).suffix)\n\n    # Prepare actions\n    top_element = Element(model)\n    create_action = CreatePathAction(desired_model_path, True)\n    write_action = WriteFileAction(desired_model_path, top_element, content_type)\n\n    # create a plan to create the directory and imported file.\n    import_plan = Plan()\n    import_plan.add_action(create_action)\n    import_plan.add_action(write_action)\n    import_plan.execute()\n\n    # Validate the imported file, rollback if unsuccessful\n    success = False\n    errmsg = ''\n    try:\n        success = self.validate_model(model.__class__, name)\n        if not success:\n            errmsg = f'Validation of model {name} did not pass'\n            logger.error(errmsg)\n    except Exception as err:\n        logger.error(errmsg)\n        errmsg = f'Import of model {name} failed. Validation failed with error: {err}'\n\n    if not success:\n        # rollback in case of validation error or failure\n        logger.debug(f'Rolling back import of model {name} to {desired_model_path}')\n        try:\n            import_plan.rollback()\n        except TrestleError as err:\n            logger.error(f'Failed to rollback: {err}. Remove {desired_model_path} to resolve state.')\n        else:\n            logger.debug(f'Successful rollback of import to {desired_model_path}')\n\n        # raise trestle error\n        raise TrestleError(errmsg)\n\n    # all well; model was imported and validated successfully\n    logger.debug(f'Model {name} of type {model.__class__.__name__} imported successfully.')\n    return ManagedOSCAL(self.root_dir, model.__class__, name)\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository.list_models","title":"<code>list_models(self, model_type)</code>","text":"<p>List models of a given type in trestle repository.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def list_models(self, model_type: Type[OscalBaseModel]) -&gt; List[str]:\n\"\"\"List models of a given type in trestle repository.\"\"\"\n    logger.debug(f'Listing models of type {model_type.__name__}.')\n    model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n    if parser.to_full_model_name(model_alias) is None:\n        raise TrestleError(f'Given model {model_alias} is not a top level model.')\n    models = ModelUtils.get_models_of_type(model_alias, self.root_dir)\n\n    return models\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository.load_and_import_model","title":"<code>load_and_import_model(self, model_path, name, content_type='json')</code>","text":"<p>Load the model at the specified path into trestle with the specified name.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def load_and_import_model(self, model_path: pathlib.Path, name: str, content_type='json') -&gt; ManagedOSCAL:\n\"\"\"Load the model at the specified path into trestle with the specified name.\"\"\"\n    fetcher = cache.FetcherFactory.get_fetcher(self.root_dir, str(model_path))\n    model, _ = fetcher.get_oscal(True)\n\n    return self.import_model(model, name, content_type)\n</code></pre>"},{"location":"api_reference/trestle.core.repository/#trestle.core.repository.Repository.validate_model","title":"<code>validate_model(self, model_type, name)</code>","text":"<p>Validate an OSCAL model in repository.</p> Source code in <code>trestle/core/repository.py</code> <pre><code>def validate_model(self, model_type: Type[OscalBaseModel], name: str) -&gt; bool:\n\"\"\"Validate an OSCAL model in repository.\"\"\"\n    logger.debug(f'Validating model {name} of type {model_type.__name__}.')\n    success = False\n\n    model_alias = classname_to_alias(model_type.__name__, AliasMode.JSON)\n    if parser.to_full_model_name(model_alias) is None:\n        raise TrestleError(f'Given model {model_alias} is not a top level model.')\n\n    verbose = log.get_current_verbosity_level(logger)\n    args = argparse.Namespace(type=model_alias, name=name, trestle_root=self.root_dir, verbose=verbose, quiet=False)\n\n    try:\n        ret = validatecmd.ValidateCmd()._run(args)\n        if ret == 0:\n            success = True\n    except Exception as e:\n        raise TrestleError(f'Error in validating model: {e}')\n\n    logger.debug(f'Model {name} validated successfully.')\n    return success\n</code></pre>"},{"location":"api_reference/trestle.core.resolver.merge/","title":"merge","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge","title":"<code>trestle.core.resolver.merge</code>","text":"<p>Create resolved catalog from profile.</p>"},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.CATALOG_EXCLUDE","title":"<code>CATALOG_EXCLUDE</code>","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.CONTROL_EXCLUDE","title":"<code>CONTROL_EXCLUDE</code>","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.ID","title":"<code>ID</code>","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.ITEM_EXCLUDE_MAP","title":"<code>ITEM_EXCLUDE_MAP</code>","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.NAME","title":"<code>NAME</code>","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.PARAMETER_EXCLUDE","title":"<code>PARAMETER_EXCLUDE</code>","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.PART_EXCLUDE","title":"<code>PART_EXCLUDE</code>","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.PROPERTY_EXCLUDE","title":"<code>PROPERTY_EXCLUDE</code>","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.Merge","title":"<code> Merge            (Filter)         </code>","text":"<p>Merge the incoming catalogs according to rules in the profile.</p> <p>The incoming catalogs have already been pruned based on the import. Now the controls must be gathered, merged, and grouped based on the merge settings.</p> Source code in <code>trestle/core/resolver/merge.py</code> <pre><code>class Merge(Pipeline.Filter):\n\"\"\"\n    Merge the incoming catalogs according to rules in the profile.\n\n    The incoming catalogs have already been pruned based on the import.\n    Now the controls must be gathered, merged, and grouped based on the merge settings.\n    \"\"\"\n\n    def __init__(self, profile: prof.Profile) -&gt; None:\n\"\"\"Initialize the class with the profile.\"\"\"\n        logger.debug('merge filter initialize')\n        self._profile = profile\n\n    def _get_id(self, item: OBT) -&gt; Optional[str]:\n        id_ = getattr(item, ID, None)\n        if id_ is None:\n            id_ = getattr(item, NAME, None)\n        return id_\n\n    def _merge_lists(self, dest: List[OBT], src: List[OBT], merge_method: Optional[prof.Method]) -&gt; None:\n        added_items = []\n        if merge_method == prof.Method.keep:\n            dest.extend(src)\n            return\n        for item in src:\n            # if there is an exact copy of this in dest then ignore it\n            if item not in dest:\n                merged = False\n                item_id = self._get_id(item)\n                if item_id is not None:\n                    for other in dest:\n                        other_id = self._get_id(other)\n                        if other_id == item_id:\n                            if merge_method == prof.Method.merge:\n                                self._merge_items(other, item, merge_method)\n                            merged = True\n                            break\n                # it isn't already in dest and no match was found for merge, so append\n                if not merged:\n                    added_items.append(item)\n        dest.extend(added_items)\n\n    def _merge_attrs(\n        self, dest: Union[OBT, List[OBT]], src: Union[OBT, List[OBT]], attr: str, merge_method: Optional[prof.Method]\n    ) -&gt; None:\n\"\"\"Merge this attr of src into the attr of dest.\"\"\"\n        src_attr = getattr(src, attr, None)\n        if src_attr is None:\n            return\n        item_type = type(src).__name__\n        if attr in ITEM_EXCLUDE_MAP.get(item_type, []):\n            return\n        dest_attr = getattr(dest, attr, None)\n        if dest_attr and isinstance(dest_attr, list):\n            self._merge_lists(dest_attr, src_attr, merge_method)\n            setattr(dest, attr, dest_attr)\n            return\n        if dest_attr and merge_method == prof.Method.use_first:\n            return\n        if dest_attr == src_attr and merge_method not in [None, prof.Method.keep]:\n            return\n        setattr(dest, attr, src_attr)\n\n    def _merge_items(self, dest: OBT, src: OBT, merge_method: Optional[prof.Method]) -&gt; None:\n\"\"\"Merge two items recursively.\"\"\"\n        for field in src.__fields_set__:\n            self._merge_attrs(dest, src, field, merge_method)\n\n    def _group_contents(self, group: cat.Group) -&gt; Tuple[List[cat.Control], List[com.Parameter]]:\n\"\"\"Get flattened content of group and its groups recursively.\"\"\"\n        controls = []\n        params = []\n        controls.extend(as_list(group.controls))\n        params.extend(as_list(group.params))\n        if group.groups is not None:\n            for sub_group in group.groups:\n                new_controls, new_params = self._group_contents(sub_group)\n                controls.extend(new_controls)\n                params.extend(new_params)\n        return controls, params\n\n    def _flatten_catalog(self, catalog: cat.Catalog, as_is: bool) -&gt; cat.Catalog:\n\"\"\"Flatten the groups of the catalog if as_is is False.\"\"\"\n        if as_is or catalog.groups is None:\n            return catalog\n\n        # as_is is False so flatten the controls into a single list\n        catalog.controls = as_list(catalog.controls)\n        catalog.params = as_list(catalog.params)\n        for group in catalog.groups:\n            new_controls, new_params = self._group_contents(group)\n            catalog.controls.extend(new_controls)\n            catalog.params.extend(new_params)\n        catalog.controls = none_if_empty(catalog.controls)\n        catalog.params = none_if_empty(catalog.params)\n        catalog.groups = None\n        return catalog\n\n    def _merge_two_catalogs(\n        self, dest: cat.Catalog, src: cat.Catalog, merge_method: Optional[prof.Method], as_is: bool\n    ) -&gt; cat.Catalog:\n        # merge_method is use_first, merge, keep\n        # no combine or merge_method equates to merge_method=keep\n        # if as_is is false, the result is flattened\n\n        dest = self._flatten_catalog(dest, as_is)\n        src = self._flatten_catalog(src, as_is)\n\n        self._merge_items(dest, src, merge_method)\n\n        return dest\n\n    def _merge_catalog(self, merged: Optional[cat.Catalog], catalog: cat.Catalog) -&gt; cat.Catalog:\n\"\"\"Merge the controls in the catalog into merged catalog.\"\"\"\n        # no merge means keep, including dups\n        # same for merge with no combine\n        # groups are merged only if separate directive such as as-is is given\n        # use-first is a merge combination rule\n        # merge is a merge combination rule for controls.  groups are not merged by this rule\n        # merge/as-is and merge/custom are used for merging groups\n        # if neither as-is nor custom is specified - just get single list of controls\n        # unstructured controls should appear after any loose params\n\n        # make copies to avoid changing input objects\n        local_cat = catalog.copy(deep=True)\n        local_merged = merged.copy(deep=True) if merged else None\n\n        merge_method = prof.Method.keep\n        as_is = False\n        if self._profile.merge is not None:\n            if self._profile.merge.custom is not None:\n                raise TrestleError('Profile with custom merge is not supported.')\n            if self._profile.merge.as_is is not None:\n                as_is = self._profile.merge.as_is\n            if self._profile.merge.combine is None:\n                logger.debug('Profile has merge but no combine so defaulting to combine/merge.')\n                merge_method = prof.Method.merge\n            else:\n                merge_combine = self._profile.merge.combine\n                if merge_combine.method is None:\n                    logger.debug('Profile has merge combine but no method.  Defaulting to merge.')\n                    merge_method = prof.Method.merge\n                else:\n                    merge_method = merge_combine.method\n\n        if local_merged is None:\n            return self._flatten_catalog(local_cat, as_is)\n\n        # merge the incoming catalog with merged based on merge_method and as_is\n        return self._merge_two_catalogs(local_merged, local_cat, merge_method, as_is)\n\n    def process(self, pipelines: List[Pipeline]) -&gt; Iterator[cat.Catalog]:\n\"\"\"\n        Merge the incoming catalogs.\n\n        This pulls from import and iterates over the incoming catalogs.\n        The way groups, lists of controls, and controls themselves get merged is specified by the profile.\n        \"\"\"\n        merged: Optional[cat.Catalog] = None\n        logger.debug(f'merge entering process with {len(pipelines)} pipelines')\n        for pipeline in pipelines:\n            catalog = next(pipeline.process(None))\n            merged = self._merge_catalog(merged, catalog)\n        yield merged\n</code></pre>"},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.Merge-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.Merge.__init__","title":"<code>__init__(self, profile)</code>  <code>special</code>","text":"<p>Initialize the class with the profile.</p> Source code in <code>trestle/core/resolver/merge.py</code> <pre><code>def __init__(self, profile: prof.Profile) -&gt; None:\n\"\"\"Initialize the class with the profile.\"\"\"\n    logger.debug('merge filter initialize')\n    self._profile = profile\n</code></pre>"},{"location":"api_reference/trestle.core.resolver.merge/#trestle.core.resolver.merge.Merge.process","title":"<code>process(self, pipelines)</code>","text":"<p>Merge the incoming catalogs.</p> <p>This pulls from import and iterates over the incoming catalogs. The way groups, lists of controls, and controls themselves get merged is specified by the profile.</p> Source code in <code>trestle/core/resolver/merge.py</code> <pre><code>def process(self, pipelines: List[Pipeline]) -&gt; Iterator[cat.Catalog]:\n\"\"\"\n    Merge the incoming catalogs.\n\n    This pulls from import and iterates over the incoming catalogs.\n    The way groups, lists of controls, and controls themselves get merged is specified by the profile.\n    \"\"\"\n    merged: Optional[cat.Catalog] = None\n    logger.debug(f'merge entering process with {len(pipelines)} pipelines')\n    for pipeline in pipelines:\n        catalog = next(pipeline.process(None))\n        merged = self._merge_catalog(merged, catalog)\n    yield merged\n</code></pre>"},{"location":"api_reference/trestle.core.resolver.modify/","title":"modify","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.resolver.modify/#trestle.core.resolver.modify","title":"<code>trestle.core.resolver.modify</code>","text":"<p>Create resolved catalog from profile.</p>"},{"location":"api_reference/trestle.core.resolver.modify/#trestle.core.resolver.modify.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.resolver.modify/#trestle.core.resolver.modify-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.resolver.modify/#trestle.core.resolver.modify.Modify","title":"<code> Modify            (Filter)         </code>","text":"<p>Modify the controls based on the profile.</p> Source code in <code>trestle/core/resolver/modify.py</code> <pre><code>class Modify(Pipeline.Filter):\n\"\"\"Modify the controls based on the profile.\"\"\"\n\n    def __init__(\n        self,\n        profile: prof.Profile,\n        change_prose: bool = False,\n        block_adds: bool = False,\n        block_params: bool = False,\n        params_format: str = None,\n        param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n        show_value_warnings: bool = False,\n        value_assigned_prefix: Optional[str] = None,\n        value_not_assigned_prefix: Optional[str] = None\n    ) -&gt; None:\n\"\"\"Initialize the filter.\"\"\"\n        self._profile = profile\n        self._catalog_interface: Optional[CatalogInterface] = None\n        self._block_adds = block_adds\n        self._block_params = block_params\n        self._change_prose = change_prose\n        self._params_format = params_format\n        self._param_rep = param_rep\n        self.show_value_warnings = show_value_warnings\n        self._value_assigned_prefix = value_assigned_prefix\n        self._value_not_assigned_prefix = value_not_assigned_prefix\n        logger.debug(f'modify initialize filter with profile {profile.metadata.title}')\n\n    @staticmethod\n    def _add_adds_to_part(part: common.Part, add: prof.Add, added_parts=False) -&gt; None:\n        for attr in ['params', 'props', 'parts', 'links']:\n            # don't add parts if already added earlier\n            if added_parts and attr == 'parts':\n                continue\n            add_list = getattr(add, attr, None)\n            if add_list:\n                Modify._add_attr_to_part(part, add_list[:], attr, add.position)\n\n    @staticmethod\n    def _add_to_list(parts_list: List[common.Part], add: prof.Add) -&gt; bool:\n\"\"\"Add the contents of the add according to its by_id and position.\n\n        Return True on success or False if id needed and not found.\n\n        This is only called when by_id is not None.\n        The add will be inserted if the id is found, or return False if not.\n        This allows a separate recursive routine to search sub-lists for the id.\n        Position before/after will put the item adjacent to the target in the same list as target\n        Position starting/ending will put the item within the target itself\n        \"\"\"\n        # Test here for matched by_id attribute.\n        added_parts = False\n        for index in range(len(parts_list)):\n            # find the matching part\n            if parts_list[index].id == add.by_id:\n                if add.position == prof.Position.after:\n                    for offset, new_item in enumerate(as_list(add.parts)):\n                        parts_list.insert(index + 1 + offset, new_item)\n                    added_parts = True\n                elif add.position == prof.Position.before:\n                    for offset, new_item in enumerate(as_list(add.parts)):\n                        parts_list.insert(index + offset, new_item)\n                    added_parts = True\n                # if starting or ending or None, the adds go directly into this part according to type\n                Modify._add_adds_to_part(parts_list[index], add, added_parts)\n                return True\n        return False\n\n    @staticmethod\n    def _add_to_parts(parts: List[common.Part], add: prof.Add) -&gt; bool:\n\"\"\"\n        Add the add to the parts.\n\n        This is only called if add.by_id is not None.\n        \"\"\"\n        if Modify._add_to_list(parts, add):\n            return True\n        for part in parts:\n            if part.parts is not None and Modify._add_to_parts(part.parts, add):\n                return True\n        return False\n\n    @staticmethod\n    def _add_attr_to_part(part: common.Part, items: List[OBT], attr: str, position: Optional[prof.Position]) -&gt; None:\n        attr_list = as_list(getattr(part, attr, None))\n        # position may be None and if so will go at end\n        if position in [prof.Position.starting, prof.Position.before]:\n            items.extend(attr_list)\n            attr_list = items\n        else:\n            attr_list.extend(items)\n        setattr(part, attr, attr_list)\n\n    @staticmethod\n    def _add_attr_to_control(\n        control: cat.Control, items: List[OBT], attr: str, position: Optional[prof.Position]\n    ) -&gt; None:\n        attr_list = as_list(getattr(control, attr, None))\n        # if position is None it will add to end\n        if position in [prof.Position.starting, prof.Position.before]:\n            items.extend(attr_list)\n            attr_list = items\n        else:\n            attr_list.extend(items)\n        setattr(control, attr, attr_list)\n\n    @staticmethod\n    def _add_to_trestle_props(control: cat.Control, add: prof.Add) -&gt; None:\n\"\"\"Add props to special trestle part that keeps track of inherited props.\"\"\"\n        if add.props:\n            trestle_part = get_item_from_list(control.parts, TRESTLE_INHERITED_PROPS_TRACKER, lambda p: p.name)\n            if trestle_part is None:\n                trestle_part = common.Part(\n                    id=TRESTLE_INHERITED_PROPS_TRACKER, name=TRESTLE_INHERITED_PROPS_TRACKER, props=[], parts=[]\n                )\n                control.parts = as_list(control.parts)\n                control.parts.append(trestle_part)\n                trestle_part = control.parts[-1]\n            if add.by_id is None or add.by_id == control.id:\n                trestle_part.props.extend(add.props)\n            else:\n                by_id_part = get_item_from_list(trestle_part.parts, add.by_id, lambda p: p.title)\n                if by_id_part is None:\n                    trestle_part.parts.append(\n                        common.Part(name=TRESTLE_INHERITED_PROPS_TRACKER + '_' + add.by_id, title=add.by_id, props=[])\n                    )\n                    by_id_part = trestle_part.parts[-1]\n                by_id_part.props.extend(add.props)\n\n    @staticmethod\n    def _add_to_control(control: cat.Control, add: prof.Add) -&gt; None:\n\"\"\"First step in applying Add to control.\"\"\"\n        control.parts = as_list(control.parts)\n        if add.by_id is None or add.by_id == control.id:\n            # add contents will be added to the control directly and with no recursion\n            for attr in ['params', 'props', 'parts', 'links']:\n                add_list = getattr(add, attr, None)\n                if add_list:\n                    Modify._add_attr_to_control(control, add_list[:], attr, add.position)\n        else:\n            # this is only called if by_id is not None\n            if not Modify._add_to_parts(control.parts, add):\n                logger.warning(f'Could not find id for add in control {control.id}: {add.by_id}')\n        Modify._add_to_trestle_props(control, add)\n        control.parts = none_if_empty(control.parts)\n\n    @staticmethod\n    def _set_overwrite_items(param: common.Parameter, set_param: prof.SetParameter) -&gt; None:\n        # these overwrite\n        if set_param.class_:\n            param.class_ = set_param.class_\n        if set_param.depends_on:\n            param.depends_on = set_param.depends_on\n        if set_param.label:\n            param.label = set_param.label\n        if set_param.usage:\n            param.usage = set_param.usage\n        if set_param.values:\n            param.values = set_param.values\n        if set_param.select:\n            param.select = set_param.select\n\n    @staticmethod\n    def _set_appended_items(param: common.Parameter, set_param: prof.SetParameter) -&gt; None:\n        # these append\n        if set_param.constraints:\n            if not param.constraints:\n                param.constraints = []\n            param.constraints.extend(set_param.constraints)\n        if set_param.guidelines:\n            if not param.guidelines:\n                param.guidelines = []\n            param.guidelines.extend(set_param.guidelines)\n\n    @staticmethod\n    def _set_replaced_or_appended_items(param: common.Parameter, set_param: prof.SetParameter) -&gt; None:\n        # these replace or append\n        if set_param.props:\n            new_props = as_list(param.props)\n            names = [prop.name for prop in new_props]\n            for prop in set_param.props:\n                if prop.name in names:\n                    new_props[names.index(prop.name)] = prop\n                else:\n                    new_props.append(prop)\n            param.props = new_props\n        if set_param.links:\n            new_links = as_list(param.links)\n            hrefs = [link.href for link in new_links]\n            for link in set_param.links:\n                if link.href in hrefs:\n                    new_links[hrefs.index(link.href)] = link\n                else:\n                    new_links.append(link)\n            param.links = new_links\n\n    def _set_parameter_in_control_or_loose(self, set_param: prof.SetParameter) -&gt; None:\n\"\"\"\n        Find the control with the param_id in it and set the parameter contents.\n\n        It modifies controls in the control_dict not the catalog.\n        Parameters are either bound to a control or are 'loose' and bound to the catalog itself.\n        \"\"\"\n        # find the target param in control or the catalog's loose ones, i.e. catalog.params\n        control = self._catalog_interface.get_control_by_param_id(set_param.param_id)\n        loose_param = False\n        if control:\n            control.params = as_list(control.params)\n            param_ids = [param.id for param in control.params]\n            if set_param.param_id not in param_ids:\n                raise TrestleNotFoundError(f'Param id {set_param.param_id} not found in control {control.id}')\n            index = param_ids.index(set_param.param_id)\n            param = control.params[index]\n        else:\n            param = self._catalog_interface.loose_param_dict.get(set_param.param_id, None)\n            if param:\n                loose_param = True\n            else:\n                logger.warning(f'SetParameter for param_id {set_param.param_id} not found in catalog')\n                return\n\n        # rules here follow https://pages.nist.gov/OSCAL/concepts/processing/profile-resolution/\n        # see 'Modify Phase' and Setting Parameters\n\n        Modify._set_overwrite_items(param, set_param)\n        Modify._set_appended_items(param, set_param)\n        Modify._set_replaced_or_appended_items(param, set_param)\n\n        if loose_param:\n            self._catalog_interface.loose_param_dict[set_param.param_id] = param\n        else:\n            control.params[index] = param\n            self._catalog_interface.replace_control(control)\n\n    def _modify_controls(self, catalog: cat.Catalog) -&gt; cat.Catalog:\n\"\"\"Modify the controls based on the profile.\"\"\"\n        logger.debug(f'modify specify catalog {catalog.metadata.title} for profile {self._profile.metadata.title}')\n        self._catalog_interface = CatalogInterface(catalog)\n        alters: Optional[List[prof.Alter]] = None\n        # find the modify and alters\n        if self._profile.modify:\n            # change all parameter values\n            if self._profile.modify.set_parameters and not self._block_params:\n                set_param_list = self._profile.modify.set_parameters\n                for set_param in set_param_list:\n                    self._set_parameter_in_control_or_loose(set_param)\n            alters = self._profile.modify.alters\n\n        # an add with no by-id applies to the control\n        # if position is starting it should appear immediately after title\n        # if position is ending it should appear at end\n        # if not specified it defaults to ending\n        # if no by-id then before is treated as starting and after is treated as ending\n        if alters is not None:\n            title = self._profile.metadata.title\n            for alter in alters:\n                if alter.control_id is None:\n                    logger.warning(f'Alter must have control id specified in profile {title}.')\n                    continue\n                id_ = alter.control_id\n                if alter.removes is not None:\n                    logger.warning(f'Alter not supported for removes in profile {title} control {id_}')\n                    continue\n                # we want a warning about adds even if adds are blocked, as in profile generate\n                if alter.adds is None:\n                    logger.warning(f'Alter has no adds in profile {title} control {id_}')\n                    continue\n                if not self._block_adds:\n                    for add in alter.adds:\n                        control = self._catalog_interface.get_control(id_)\n                        if control is None:\n                            logger.warning(\n                                f'Alter/Add refers to control {id_} but it is not found in the import '\n                                + f'for profile {self._profile.metadata.title}'\n                            )\n                        else:\n                            self._add_to_control(control, add)\n                            self._catalog_interface.replace_control(control)\n\n        if self._change_prose:\n            # go through all controls and fix the prose based on param values\n            self._catalog_interface._change_prose_with_param_values(\n                self._params_format,\n                self._param_rep,\n                self.show_value_warnings,\n                self._value_assigned_prefix,\n                self._value_not_assigned_prefix\n            )\n\n        catalog = self._catalog_interface.get_catalog()\n\n        # update the original profile metadata with new contents\n        # roles and responsible-parties will be pulled in with new uuid's\n        # the title simply becomes the title of the current profile - and will get overwritten\n        # by any other profiles downstream so that only the final profile title is used\n        new_metadata = self._profile.metadata\n        new_metadata.title = self._profile.metadata.title\n        new_metadata.oscal_version = OSCAL_VERSION\n\n        links: List[common.Link] = []\n        for import_ in self._profile.imports:\n            links.append(common.Link(**{'href': import_.href, 'rel': RESOLUTION_SOURCE}))\n        new_metadata.links = links\n\n        # move catalog controls from dummy group '' into the catalog\n        for group in as_list(catalog.groups):\n            if not group.id:\n                catalog.controls = group.controls\n                catalog.groups.remove(group)\n                break\n\n        catalog.metadata = new_metadata\n\n        return catalog\n\n    def process(self, catalog_iter: Iterator[cat.Catalog]) -&gt; Iterator[cat.Catalog]:\n\"\"\"Make the modifications to the controls based on the profile.\"\"\"\n        catalog = next(catalog_iter)\n        logger.debug(\n            f'modify process with catalog {catalog.metadata.title} using profile {self._profile.metadata.title}'\n        )\n        yield self._modify_controls(catalog)\n</code></pre>"},{"location":"api_reference/trestle.core.resolver.modify/#trestle.core.resolver.modify.Modify-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.resolver.modify/#trestle.core.resolver.modify.Modify.__init__","title":"<code>__init__(self, profile, change_prose=False, block_adds=False, block_params=False, params_format=None, param_rep=&lt;ParameterRep.VALUE_OR_LABEL_OR_CHOICES: 3&gt;, show_value_warnings=False, value_assigned_prefix=None, value_not_assigned_prefix=None)</code>  <code>special</code>","text":"<p>Initialize the filter.</p> Source code in <code>trestle/core/resolver/modify.py</code> <pre><code>def __init__(\n    self,\n    profile: prof.Profile,\n    change_prose: bool = False,\n    block_adds: bool = False,\n    block_params: bool = False,\n    params_format: str = None,\n    param_rep: ParameterRep = ParameterRep.VALUE_OR_LABEL_OR_CHOICES,\n    show_value_warnings: bool = False,\n    value_assigned_prefix: Optional[str] = None,\n    value_not_assigned_prefix: Optional[str] = None\n) -&gt; None:\n\"\"\"Initialize the filter.\"\"\"\n    self._profile = profile\n    self._catalog_interface: Optional[CatalogInterface] = None\n    self._block_adds = block_adds\n    self._block_params = block_params\n    self._change_prose = change_prose\n    self._params_format = params_format\n    self._param_rep = param_rep\n    self.show_value_warnings = show_value_warnings\n    self._value_assigned_prefix = value_assigned_prefix\n    self._value_not_assigned_prefix = value_not_assigned_prefix\n    logger.debug(f'modify initialize filter with profile {profile.metadata.title}')\n</code></pre>"},{"location":"api_reference/trestle.core.resolver.modify/#trestle.core.resolver.modify.Modify.process","title":"<code>process(self, catalog_iter)</code>","text":"<p>Make the modifications to the controls based on the profile.</p> Source code in <code>trestle/core/resolver/modify.py</code> <pre><code>def process(self, catalog_iter: Iterator[cat.Catalog]) -&gt; Iterator[cat.Catalog]:\n\"\"\"Make the modifications to the controls based on the profile.\"\"\"\n    catalog = next(catalog_iter)\n    logger.debug(\n        f'modify process with catalog {catalog.metadata.title} using profile {self._profile.metadata.title}'\n    )\n    yield self._modify_controls(catalog)\n</code></pre>"},{"location":"api_reference/trestle.core.resolver.prune/","title":"prune","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.resolver.prune/#trestle.core.resolver.prune","title":"<code>trestle.core.resolver.prune</code>","text":"<p>Create resolved catalog from profile.</p>"},{"location":"api_reference/trestle.core.resolver.prune/#trestle.core.resolver.prune.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.resolver.prune/#trestle.core.resolver.prune-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.resolver.prune/#trestle.core.resolver.prune.Prune","title":"<code> Prune            (Filter)         </code>","text":"<p>Prune the catalog based on the import include rule.</p> Source code in <code>trestle/core/resolver/prune.py</code> <pre><code>class Prune(Pipeline.Filter):\n\"\"\"Prune the catalog based on the import include rule.\"\"\"\n\n    def __init__(self, import_: prof.Import, profile: prof.Profile) -&gt; None:\n\"\"\"\n        Inject the import.\n\n        This needs to be created prior to knowing the catalog.\n        The profile itself is only needed for debug messages.\n        The import is one possibly several imports in that profile.\n        \"\"\"\n        self._import = import_\n        self._profile = profile\n        self._catalog_interface: Optional[CatalogInterface] = None\n        self._catalog: Optional[cat.Catalog] = None\n\n    def _set_catalog(self, catalog: cat.Catalog) -&gt; None:\n\"\"\"Set the catalog used by the catalog interface.\"\"\"\n        self._catalog_interface = CatalogInterface(catalog)\n        self._catalog = catalog\n\n    def _controls_selected(self, select_list: Optional[List[prof.SelectControlById]]) -&gt; List[str]:\n        control_ids: List[str] = []\n        if select_list is not None:\n            for select_control in select_list:\n                if select_control.matching is not None:\n                    raise TrestleError('Profiles with SelectControlById based on matching are not supported.')\n                include_children = select_control.with_child_controls == 'yes'\n                if select_control.with_ids:\n                    new_ids = select_control.with_ids\n                    for id_ in new_ids:\n                        control_ids.append(id_)\n                        if include_children:\n                            control_ids.extend(self._catalog_interface.get_dependent_control_ids(id_))\n        return [control_id.__root__ for control_id in control_ids]\n\n    def _find_needed_control_ids(self) -&gt; List[str]:\n\"\"\"Get list of control_ids needed by profile and corresponding groups.\"\"\"\n        if self._import.include_controls is not None:\n            include_ids = self._controls_selected(self._import.include_controls)\n        else:\n            if self._import.include_all is None:\n                logger.warning('Profile does not specify include-controls, so including all.')\n            include_ids = self._catalog_interface.get_control_ids()\n\n        exclude_ids = self._controls_selected(self._import.exclude_controls)\n\n        if not set(include_ids).issuperset(set(exclude_ids)):\n            logger.debug(f'include_ids is not a superset of exclude_ids in import {self._import.href}')\n        return sorted([id_ for id_ in include_ids if id_ not in exclude_ids])\n\n    def _prune_control(self, needed_ids: List[str], control: cat.Control, exclude_ids: List[str]) -&gt; cat.Control:\n\"\"\"\n        Prune the control based on the Import requirements.\n\n        This is only called if the control is needed\n        Some or all of its sub_controls may not be needed\n        This always returns the original control, possibly with fewer subcontrols\n        \"\"\"\n        if control.controls is None:\n            return control\n        controls = []\n        for sub_control in control.controls:\n            if sub_control.id in needed_ids and sub_control.id not in exclude_ids:\n                controls.append(self._prune_control(needed_ids, sub_control, exclude_ids))\n                exclude_ids.append(sub_control.id)\n        control.controls = none_if_empty(controls)\n        return control\n\n    def _prune_controls(self, needed_ids: List[str]) -&gt; List[str]:\n        loaded_ids = []\n        final_ids: List[str] = []\n        for control_id in needed_ids:\n            if control_id not in loaded_ids:\n                control = self._catalog_interface.get_control(control_id)\n                if control is None:\n                    msg = (\n                        f'Profile titled \"{self._profile.metadata.title}\" references control {control_id} '\n                        f'but it is not in catalog titled \"{self._catalog.metadata.title}\"'\n                    )\n                    raise TrestleError(msg)\n                control = self._prune_control(needed_ids, control, loaded_ids)\n                self._catalog_interface.replace_control(control)\n                loaded_ids.append(control_id)\n                final_ids.append(control_id)\n        return final_ids\n\n    def _re_insert_child_controls(self, control: cat.Control) -&gt; cat.Control:\n\"\"\"Re insert this control and its children recursively.\"\"\"\n        new_controls = []\n        for sub_control in as_list(control.controls):\n            new_control = self._re_insert_child_controls(sub_control)\n            new_controls.append(new_control)\n        control.controls = none_if_empty(new_controls)\n        return control\n\n    def _re_insert_children(self) -&gt; None:\n\"\"\"Go through all controls in control dict and load child controls from control dict.\"\"\"\n        for control in self._catalog_interface.get_all_controls_from_dict():\n            _ = self._re_insert_child_controls(control)\n\n    def _prune_catalog(self) -&gt; cat.Catalog:\n\"\"\"Prune the controls in the current catalog.\"\"\"\n        if self._import is None:\n            return self._catalog\n\n        needed_ids = self._find_needed_control_ids()\n\n        # if a control includes controls - only include those that we know are needed\n        final_control_ids = self._prune_controls(needed_ids)\n\n        self._re_insert_children()\n\n        cat_controls = []\n\n        # build the needed groups of controls\n        group_dict: Dict[str, cat.Group] = {}\n        for control_id in final_control_ids:\n            control = self._catalog_interface.get_control(control_id)\n            group_id, group_title, group_class = self._catalog_interface.get_group_info_by_control(control_id)\n            if not group_id:\n                cat_controls.append(control)\n                continue\n            group = group_dict.get(group_id)\n            if group is None:\n                group = cat.Group(id=group_id, title=group_title, class_=group_class, controls=[control])\n                group_dict[group_id] = group\n            else:\n                group_dict[group_id].controls.append(control)\n\n        new_groups: Optional[List[cat.Group]] = list(group_dict.values())\n\n        # should avoid empty lists so set to None if empty\n        new_groups = none_if_empty(new_groups)\n        cat_controls = none_if_empty(cat_controls)\n        new_params = self._catalog.params\n\n        new_cat = cat.Catalog(\n            uuid=str(uuid4()),\n            metadata=self._catalog.metadata,\n            back_matter=common.BackMatter(),\n            controls=cat_controls,\n            groups=new_groups,\n            params=new_params\n        )\n\n        # find all referenced uuids - they should be 1:1 with those in backmatter\n        needed_uuid_refs = ModelUtils.find_uuid_refs(new_cat)\n\n        # prune the list of resources to only those that are needed\n        new_resources: Optional[List[common.Resource]] = []\n        if self._catalog.back_matter and self._catalog.back_matter.resources:\n            new_resources = [res for res in self._catalog.back_matter.resources if res.uuid in needed_uuid_refs]\n        new_resources = none_if_empty(new_resources)\n        new_cat.back_matter.resources = new_resources\n\n        return new_cat\n\n    def process(self, catalog_iter: Iterator[cat.Catalog]) -&gt; Iterator[cat.Catalog]:\n\"\"\"\n        Prune the catalog based on the include rule in the import_.\n\n        This only processes the one catalog yielded by the one import in this pipeline.\n        It must yield in order to have the merge filter loop over available imported catalogs.\n        \"\"\"\n        self._set_catalog(next(catalog_iter))\n        logger.debug(f'prune yielding catalog {self._catalog.metadata.title} with import {self._import.href}')\n        yield self._prune_catalog()\n</code></pre>"},{"location":"api_reference/trestle.core.resolver.prune/#trestle.core.resolver.prune.Prune-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.resolver.prune/#trestle.core.resolver.prune.Prune.__init__","title":"<code>__init__(self, import_, profile)</code>  <code>special</code>","text":"<p>Inject the import.</p> <p>This needs to be created prior to knowing the catalog. The profile itself is only needed for debug messages. The import is one possibly several imports in that profile.</p> Source code in <code>trestle/core/resolver/prune.py</code> <pre><code>def __init__(self, import_: prof.Import, profile: prof.Profile) -&gt; None:\n\"\"\"\n    Inject the import.\n\n    This needs to be created prior to knowing the catalog.\n    The profile itself is only needed for debug messages.\n    The import is one possibly several imports in that profile.\n    \"\"\"\n    self._import = import_\n    self._profile = profile\n    self._catalog_interface: Optional[CatalogInterface] = None\n    self._catalog: Optional[cat.Catalog] = None\n</code></pre>"},{"location":"api_reference/trestle.core.resolver.prune/#trestle.core.resolver.prune.Prune.process","title":"<code>process(self, catalog_iter)</code>","text":"<p>Prune the catalog based on the include rule in the import_.</p> <p>This only processes the one catalog yielded by the one import in this pipeline. It must yield in order to have the merge filter loop over available imported catalogs.</p> Source code in <code>trestle/core/resolver/prune.py</code> <pre><code>def process(self, catalog_iter: Iterator[cat.Catalog]) -&gt; Iterator[cat.Catalog]:\n\"\"\"\n    Prune the catalog based on the include rule in the import_.\n\n    This only processes the one catalog yielded by the one import in this pipeline.\n    It must yield in order to have the merge filter loop over available imported catalogs.\n    \"\"\"\n    self._set_catalog(next(catalog_iter))\n    logger.debug(f'prune yielding catalog {self._catalog.metadata.title} with import {self._import.href}')\n    yield self._prune_catalog()\n</code></pre>"},{"location":"api_reference/trestle.core.rule_parameters_validator/","title":"rule_parameters_validator","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.rule_parameters_validator/#trestle.core.rule_parameters_validator","title":"<code>trestle.core.rule_parameters_validator</code>","text":"<p>Validate by confirming rule parameter values are consistent.</p>"},{"location":"api_reference/trestle.core.rule_parameters_validator/#trestle.core.rule_parameters_validator.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.rule_parameters_validator/#trestle.core.rule_parameters_validator-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.rule_parameters_validator/#trestle.core.rule_parameters_validator.RuleParametersValidator","title":"<code> RuleParametersValidator            (Validator)         </code>","text":"<p>Validator to confirm all rule parameter values are consistent.</p> Source code in <code>trestle/core/rule_parameters_validator.py</code> <pre><code>class RuleParametersValidator(Validator):\n\"\"\"Validator to confirm all rule parameter values are consistent.\"\"\"\n\n    def __init__(self):\n\"\"\"Initialize rule param values dictionary.\"\"\"\n        self._rule_param_values_dict = {}\n\n    def _add_imp_req_rule_params_to_dict(\n        self,\n        imp_requirement: ImplementedRequirement,\n        cat_int: CatalogInterface,\n    ) -&gt; None:\n\"\"\"\n        Iterate all by components in an object and add the rule shared parameter values to list.\n\n        args:\n            imp_requirement: Current implemented requirement.\n            cat_int: Instance of catalog interface with controls catalog loaded.\n        \"\"\"\n        for by_component in as_list(imp_requirement.by_components):\n            # adds rule param values present in set parameters for current imp req\n            self._add_rule_params(imp_requirement, imp_requirement.control_id, cat_int, by_component.component_uuid)\n            # adds rule param values present in set parameters for current by_component in by_components list\n            # in the current implemented requirement\n            self._add_rule_params(by_component, imp_requirement.control_id, cat_int, by_component.component_uuid)\n            for statement in as_list(imp_requirement.statements):\n                # iterates by each by component inclded at each statemtent set for current imp req\n                for by_comp in as_list(statement.by_components):\n                    # adds rule param values present in set parameters for current by_component in by_components list\n                    # of current statement in current implemented requirement\n                    self._add_rule_params(by_comp, imp_requirement.control_id, cat_int, by_comp.component_uuid)\n\n    def _add_rule_params(\n        self, item: TypeWithSetParams, control_id: str, cat_int: CatalogInterface, comp_uuid: str = ''\n    ) -&gt; None:\n\"\"\"\n        Add a rule shared parameter to the rule shared parameters list.\n\n        args:\n            item: Generic item to iterate over parameters.\n            control_id: Current control id.\n            cat_int: Instance of catalog interface with controls catalog loaded.\n            comp_uuid: Component uuid to save.\n        \"\"\"\n        for set_param in as_list(item.set_parameters):\n            # validates if current param_id is or not associated with a control so we can assume it\u00b4s a rule param\n            control = cat_int.get_control_by_param_id(set_param.param_id)\n            if not control:\n                deep_set(self._rule_param_values_dict, [set_param.param_id, comp_uuid, control_id], set_param.values)\n\n    def model_is_valid(\n        self, model: TopLevelOscalModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None\n    ) -&gt; bool:\n\"\"\"\n        Test if the model is valid.\n\n        args:\n            model: A top level OSCAL model.\n            quiet: Don't report msgs unless invalid.\n            trestle_root: Trestle root path.\n\n        returns:\n            True (valid) if the model's rule parameter values are the same across controls.\n        \"\"\"\n        # verify if model type is either an SSP of a Component Definition\n        if not isinstance(model, SystemSecurityPlan):\n            return True\n\n        if not model.import_profile.href:\n            logger.info(f'INVALID: Model {model.metadata.title} has no referenced profile')\n            return False\n        profile_catalog = ProfileResolver().get_resolved_profile_catalog(trestle_root, model.import_profile.href)\n        catalog_interface = CatalogInterface(profile_catalog)\n        # iterate by each implemented requirement defined\n        for imp_req in model.control_implementation.implemented_requirements:\n            # adds rule param values to dict by implemented requirement basis\n            self._add_imp_req_rule_params_to_dict(imp_req, catalog_interface)\n        if self._rule_param_values_dict:\n            # compare all values in shared paramerets by component basis\n            for shared_param, values_dict in self._rule_param_values_dict.items():\n                for comp_name, value_dict in values_dict.items():\n                    expected_value = next(iter(value_dict.values()))\n                    if not all(value == expected_value for value in value_dict.values()):\n                        logger.error(\n                            f'Rule parameter values for param: {shared_param} in '\n                            f' {comp_name} are not consistent with '\n                            'other values provided across controls. Invalid model'\n                        )\n                        return False\n        return True\n</code></pre>"},{"location":"api_reference/trestle.core.rule_parameters_validator/#trestle.core.rule_parameters_validator.RuleParametersValidator-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.rule_parameters_validator/#trestle.core.rule_parameters_validator.RuleParametersValidator.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize rule param values dictionary.</p> Source code in <code>trestle/core/rule_parameters_validator.py</code> <pre><code>def __init__(self):\n\"\"\"Initialize rule param values dictionary.\"\"\"\n    self._rule_param_values_dict = {}\n</code></pre>"},{"location":"api_reference/trestle.core.rule_parameters_validator/#trestle.core.rule_parameters_validator.RuleParametersValidator.model_is_valid","title":"<code>model_is_valid(self, model, quiet, trestle_root=None)</code>","text":"<p>Test if the model is valid.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>~TopLevelOscalModel</code> <p>A top level OSCAL model.</p> required <code>quiet</code> <code>bool</code> <p>Don't report msgs unless invalid.</p> required <code>trestle_root</code> <code>Optional[pathlib.Path]</code> <p>Trestle root path.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True (valid) if the model's rule parameter values are the same across controls.</p> Source code in <code>trestle/core/rule_parameters_validator.py</code> <pre><code>def model_is_valid(\n    self, model: TopLevelOscalModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None\n) -&gt; bool:\n\"\"\"\n    Test if the model is valid.\n\n    args:\n        model: A top level OSCAL model.\n        quiet: Don't report msgs unless invalid.\n        trestle_root: Trestle root path.\n\n    returns:\n        True (valid) if the model's rule parameter values are the same across controls.\n    \"\"\"\n    # verify if model type is either an SSP of a Component Definition\n    if not isinstance(model, SystemSecurityPlan):\n        return True\n\n    if not model.import_profile.href:\n        logger.info(f'INVALID: Model {model.metadata.title} has no referenced profile')\n        return False\n    profile_catalog = ProfileResolver().get_resolved_profile_catalog(trestle_root, model.import_profile.href)\n    catalog_interface = CatalogInterface(profile_catalog)\n    # iterate by each implemented requirement defined\n    for imp_req in model.control_implementation.implemented_requirements:\n        # adds rule param values to dict by implemented requirement basis\n        self._add_imp_req_rule_params_to_dict(imp_req, catalog_interface)\n    if self._rule_param_values_dict:\n        # compare all values in shared paramerets by component basis\n        for shared_param, values_dict in self._rule_param_values_dict.items():\n            for comp_name, value_dict in values_dict.items():\n                expected_value = next(iter(value_dict.values()))\n                if not all(value == expected_value for value in value_dict.values()):\n                    logger.error(\n                        f'Rule parameter values for param: {shared_param} in '\n                        f' {comp_name} are not consistent with '\n                        'other values provided across controls. Invalid model'\n                    )\n                    return False\n    return True\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/","title":"ssp_io","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io","title":"<code>trestle.core.ssp_io</code>","text":"<p>Handle direct IO for writing SSP responses as markdown.</p>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter","title":"<code> SSPMarkdownWriter        </code>","text":"<p>Class to write control responses as markdown.</p> <p>Functions in this class are mainly used by jinja and not by the trestle code itself.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>class SSPMarkdownWriter():\n\"\"\"\n    Class to write control responses as markdown.\n\n    Functions in this class are mainly used by jinja and not by the trestle code itself.\n    \"\"\"\n\n    def __init__(self, trestle_root: pathlib.Path) -&gt; None:\n\"\"\"Initialize the class.\"\"\"\n        self._trestle_root = trestle_root\n        self._ssp: ssp.SystemSecurityPlan = None\n        self._resolved_catalog: Catalog = None\n        self._catalog_interface: CatalogInterface = None\n\n    def set_ssp(self, ssp: ssp.SystemSecurityPlan) -&gt; None:\n\"\"\"Set ssp.\"\"\"\n        self._ssp = ssp\n\n    def set_catalog(self, resolved_catalog: Catalog) -&gt; None:\n\"\"\"Set catalog.\"\"\"\n        self._resolved_catalog = resolved_catalog\n        self._catalog_interface = catalog_interface.CatalogInterface(self._resolved_catalog)\n\n    def get_control_statement(self, control_id: str, level: int) -&gt; str:\n\"\"\"\n        Get the control statement for an ssp - to be printed in markdown as a structured list.\n\n        Args:\n            control_id: The control_id to use.\n\n        Returns:\n            A markdown blob as a string.\n        \"\"\"\n        if not self._resolved_catalog:\n            raise TrestleError('Cannot get control statement, set resolved catalog first.')\n\n        writer = DocsControlWriter()\n        control = self._catalog_interface.get_control(control_id)\n        if not control:\n            return ''\n\n        control_lines = writer.get_control_statement_ssp(control)\n\n        return self._build_tree_and_adjust(control_lines, level)\n\n    def get_control_part(self, control_id: str, part_name: str, level: int) -&gt; str:\n\"\"\"Get control part with given name.\"\"\"\n        control_part = self._catalog_interface.get_control_part_prose(control_id, part_name)\n\n        md_list = self._write_str_with_header(\n            f'Control Part: {part_name} for control: {control_id}', control_part, level\n        )\n        return self._build_tree_and_adjust(md_list.split('\\n'), level)\n\n    def get_fedramp_control_tables(self, control_id: str, level: int, label_column=False) -&gt; str:\n\"\"\"Get the fedramp metadata as markdown tables, with optional third label column for params.\n\n        The fedramp metadata has the following elements:\n        - Responsible roles field\n        - Parameter values table\n        - Implementation status field\n        - Control origination field\n\n        Returns:\n            tables as one coherent markdown blob.\n        \"\"\"\n        resp_roles_table = self.get_responsible_roles_table(control_id, level)\n        params_values = self._parameter_table(control_id, level, label_column)\n        impl_status = self.get_fedramp_implementation_status(control_id, level)\n        control_orig = self.get_fedramp_control_origination(control_id, level)\n\n        final_output = ''\n        if resp_roles_table:\n            final_output += resp_roles_table\n        if params_values:\n            final_output += '\\n' + params_values\n        if impl_status:\n            final_output += '\\n' + impl_status\n        if control_orig:\n            final_output += '\\n' + control_orig\n        return final_output\n\n    def get_responsible_roles_table(self, control_id: str, level: int) -&gt; str:\n\"\"\"\n        For each role id - if the role exists in metadata use the title as what gets printed in the roles table.\n\n        If not (for now) warn and use the role-id as the printed text.\n        \"\"\"\n        if self._ssp is None:\n            raise TrestleError('Cannot get responsible roles, SSP is not set.')\n\n        for impl_requirement in self._ssp.control_implementation.implemented_requirements:\n            if impl_requirement.control_id == control_id:\n                if impl_requirement.responsible_roles:\n                    resp_roles = as_list(impl_requirement.responsible_roles)\n                    role_ids = [role.role_id.replace('_', ' ') for role in resp_roles]\n\n                    # now check if this role exists in the metadata\n                    role_titles = dict(zip(role_ids, role_ids))\n                    roles = as_list(self._ssp.metadata.roles)\n                    for role in roles:\n                        if role.id in role_ids:\n                            role_titles[role.id] = role.title\n\n                    # dictionary to md table\n                    md_list = self._write_table_with_header(\n                        'Responsible Roles.', [[key, role_titles[key]] for key in role_titles.keys()],\n                        ['Role ID', 'Title'],\n                        level\n                    )\n                    return md_list\n                else:\n                    logger.warning(\n                        f'No responsible roles were found for the control with id: {control_id} in given SSP.'\n                    )\n                    return ''\n\n        return ''\n\n    def _parameter_table(self, control_id: str, level: int, label_column=False) -&gt; str:\n\"\"\"Print Param_id | ValueOrLabelOrChoices | Optional Label Column.\"\"\"\n        if not self._ssp:\n            raise TrestleError('Cannot get parameter table, set SSP first.')\n\n        writer = DocsControlWriter()\n        control = self._catalog_interface.get_control(control_id)\n        if not control:\n            return ''\n        params_lines = writer.get_param_table(control, label_column)\n        # need to make sure no params still have moustaches.  convert to brackets to avoid jinja complaints\n        clean_lines = []\n        for line in params_lines:\n            clean_lines.append(line.replace('{{', '[[').replace('}}', ']]'))\n\n        tree = DocsMarkdownNode.build_tree_from_markdown(clean_lines)\n        tree.change_header_level_by(level)\n        return tree.content.raw_text\n\n    def get_fedramp_implementation_status(self, control_id: str, level: int) -&gt; str:\n\"\"\"\n        Print implementation status as a list of items, only showing those that are applicable for the control.\n\n        This is unlike the word document FedRAMP which uses checkboxes on standard set of options.\n        Using a LUT to map between structured data fields, defined by FedRAMP and historical text.\n        \"\"\"\n        if not self._ssp:\n            raise TrestleError('Cannot get Fedramp implementation status, set SSP first.')\n\n        implementation_statuses: List[str] = []\n        control_impl_req = self._control_implemented_req(control_id)\n        if control_impl_req and control_impl_req.props:\n            for prop in control_impl_req.props:\n                if prop.name == IMPLEMENTATION_STATUS:\n                    implementation_statuses.append(prop.value)\n\n        md_list = self._write_list_with_header('FedRamp Implementation Status.', implementation_statuses, level)\n        return md_list\n\n    def get_fedramp_control_origination(self, control_id: str, level: int) -&gt; str:\n\"\"\"\n        Print control origination, as a list of items, only showing those that are applicable for the control.\n\n        Using a LUT to map between structured data fields, defined by FedRAMP and historical text.\n        \"\"\"\n        if not self._ssp:\n            raise TrestleError('Cannot get FedRamp control origination, set SSP first.')\n\n        control_origination = []\n        control_impl_req = self._control_implemented_req(control_id)\n\n        if control_impl_req and control_impl_req.props:\n            for prop in control_impl_req.props:\n                if prop.name == CONTROL_ORIGINATION:\n                    control_origination.append(prop.value)\n\n        md_list = self._write_list_with_header('FedRamp Control Origination.', control_origination, level)\n        return md_list\n\n    def get_control_response(self, control_id: str, level: int, write_empty_responses=False, show_comp=True) -&gt; str:\n\"\"\"\n        Get the full control implemented requirements, broken down based on the available control responses.\n\n        Args:\n            control_id: id of the control\n            level: level of indentation\n            write_empty_responses: write response even if empty\n            show_comp: show the component name in the response\n\n        Notes:\n            For components the following structure is assumed:\n            'This System' is the default response, and other components are treated as sub-headings per response item.\n        \"\"\"\n        if not self._resolved_catalog:\n            raise TrestleError('Cannot get control response, set resolved catalog first.')\n\n        control = self._catalog_interface.get_control(control_id)\n        control_impl_req = self._control_implemented_req(control_id)\n        if not control_impl_req:\n            logger.info(f'No implemented requirements found for the control {control_id}')\n            return ''\n\n        md_writer = MDWriter(None)\n        # if a control has no statement sub-parts then get the response bycomps from the imp_req itself\n        # otherwise get them from the statements in the imp_req\n        # an imp_req and a statement are both things that can have bycomps\n        has_bycomps = control_impl_req.statements if control_impl_req.statements else [control_impl_req]\n        for has_bycomp in has_bycomps:\n            statement_id = getattr(has_bycomp, 'statement_id', f'{control_id}_smt')\n            label = statement_id\n            part_name = None\n\n            # look up label for this statement\n            if control.parts:\n                found_label, part = self._catalog_interface.get_statement_label_if_exists(control_id, statement_id)\n                if found_label:\n                    label = found_label\n                    part_name = part.name\n\n            response_per_component = self._get_responses_by_components(has_bycomp, write_empty_responses)\n\n            if response_per_component or (not response_per_component and write_empty_responses):\n                if part_name and part_name == 'item':\n                    # print part header only if subitem\n                    header = f'Implementation for part {label}'\n                    md_writer.new_header(level=1, title=header)\n                for idx, component_key in enumerate(response_per_component):\n                    if component_key == SSP_MAIN_COMP_NAME and idx == 0:\n                        # special case ignore header but print contents\n                        md_writer.new_paragraph()\n                    elif show_comp:\n                        md_writer.new_header(level=2, title=component_key)\n                    md_writer.set_indent_level(-1)\n                    md_writer.new_line(response_per_component[component_key])\n                    md_writer.set_indent_level(-1)\n\n        lines = md_writer.get_lines()\n\n        tree = DocsMarkdownNode.build_tree_from_markdown(lines)\n        tree.change_header_level_by(level)\n\n        return tree.content.raw_text\n\n    def _get_responses_by_components(self, has_bycomps: TypeWithByComps, write_empty_responses: bool) -&gt; Dict[str, str]:\n\"\"\"Get response per component, substitute component id with title if possible.\"\"\"\n        response_per_component = {}\n        for component in as_list(has_bycomps.by_components):\n            # look up component title\n            subheader = component.component_uuid\n            response = ''\n            if self._ssp.system_implementation.components:\n                for comp in self._ssp.system_implementation.components:\n                    if comp.uuid == component.component_uuid:\n                        title = comp.title\n                        if title:\n                            subheader = title\n            if component.description:\n                response = component.description\n\n            if response or (not response and write_empty_responses):\n                if subheader:\n                    response_per_component[subheader] = response\n\n        return response_per_component\n\n    def _control_implemented_req(self, control_id: str) -&gt; Optional[ssp.ImplementedRequirement]:\n\"\"\"Retrieve control implemented requirement by control-id.\"\"\"\n        requirements = self._ssp.control_implementation.implemented_requirements\n        for requirement in requirements:\n            if requirement.control_id == control_id:\n                return requirement\n        logger.debug(f'No implemented requirement found for control {control_id}')\n        return None\n\n    def _write_list_with_header(self, header: str, lines: List[str], level: int) -&gt; str:\n        if lines:\n            md_writer = MDWriter(None)\n            md_writer.new_paragraph()\n            md_writer.new_header(level=1, title=header)\n            md_writer.set_indent_level(-1)\n            md_writer.new_list(lines)\n            md_writer.set_indent_level(-1)\n\n            return self._build_tree_and_adjust(md_writer.get_lines(), level)\n\n        return ''\n\n    def _write_table_with_header(\n        self, header: str, values: List[List[str]], table_header: List[str], level: int\n    ) -&gt; str:\n        if values and values[0]:\n            md_writer = MDWriter(None)\n            md_writer.new_paragraph()\n            md_writer.new_header(level=1, title=header)\n            md_writer.set_indent_level(-1)\n            md_writer.new_table(values, table_header)\n            md_writer.set_indent_level(-1)\n\n            return self._build_tree_and_adjust(md_writer.get_lines(), level)\n        return ''\n\n    def _write_str_with_header(self, header: str, text: str, level: int) -&gt; str:\n        if text:\n            md_writer = MDWriter(None)\n            md_writer.new_paragraph()\n            md_writer.new_header(level=1, title=header)\n            md_writer.set_indent_level(-1)\n            md_writer.new_line(text)\n            md_writer.set_indent_level(-1)\n\n            return self._build_tree_and_adjust(md_writer.get_lines(), level)\n        return ''\n\n    def _build_tree_and_adjust(self, lines: List[str], level: int) -&gt; str:\n        tree = DocsMarkdownNode.build_tree_from_markdown(lines)\n        tree.change_header_level_by(level)\n\n        return tree.content.raw_text\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.__init__","title":"<code>__init__(self, trestle_root)</code>  <code>special</code>","text":"<p>Initialize the class.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def __init__(self, trestle_root: pathlib.Path) -&gt; None:\n\"\"\"Initialize the class.\"\"\"\n    self._trestle_root = trestle_root\n    self._ssp: ssp.SystemSecurityPlan = None\n    self._resolved_catalog: Catalog = None\n    self._catalog_interface: CatalogInterface = None\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.get_control_part","title":"<code>get_control_part(self, control_id, part_name, level)</code>","text":"<p>Get control part with given name.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def get_control_part(self, control_id: str, part_name: str, level: int) -&gt; str:\n\"\"\"Get control part with given name.\"\"\"\n    control_part = self._catalog_interface.get_control_part_prose(control_id, part_name)\n\n    md_list = self._write_str_with_header(\n        f'Control Part: {part_name} for control: {control_id}', control_part, level\n    )\n    return self._build_tree_and_adjust(md_list.split('\\n'), level)\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.get_control_response","title":"<code>get_control_response(self, control_id, level, write_empty_responses=False, show_comp=True)</code>","text":"<p>Get the full control implemented requirements, broken down based on the available control responses.</p> <p>Parameters:</p> Name Type Description Default <code>control_id</code> <code>str</code> <p>id of the control</p> required <code>level</code> <code>int</code> <p>level of indentation</p> required <code>write_empty_responses</code> <p>write response even if empty</p> <code>False</code> <code>show_comp</code> <p>show the component name in the response</p> <code>True</code> <p>Notes</p> <p>For components the following structure is assumed: 'This System' is the default response, and other components are treated as sub-headings per response item.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def get_control_response(self, control_id: str, level: int, write_empty_responses=False, show_comp=True) -&gt; str:\n\"\"\"\n    Get the full control implemented requirements, broken down based on the available control responses.\n\n    Args:\n        control_id: id of the control\n        level: level of indentation\n        write_empty_responses: write response even if empty\n        show_comp: show the component name in the response\n\n    Notes:\n        For components the following structure is assumed:\n        'This System' is the default response, and other components are treated as sub-headings per response item.\n    \"\"\"\n    if not self._resolved_catalog:\n        raise TrestleError('Cannot get control response, set resolved catalog first.')\n\n    control = self._catalog_interface.get_control(control_id)\n    control_impl_req = self._control_implemented_req(control_id)\n    if not control_impl_req:\n        logger.info(f'No implemented requirements found for the control {control_id}')\n        return ''\n\n    md_writer = MDWriter(None)\n    # if a control has no statement sub-parts then get the response bycomps from the imp_req itself\n    # otherwise get them from the statements in the imp_req\n    # an imp_req and a statement are both things that can have bycomps\n    has_bycomps = control_impl_req.statements if control_impl_req.statements else [control_impl_req]\n    for has_bycomp in has_bycomps:\n        statement_id = getattr(has_bycomp, 'statement_id', f'{control_id}_smt')\n        label = statement_id\n        part_name = None\n\n        # look up label for this statement\n        if control.parts:\n            found_label, part = self._catalog_interface.get_statement_label_if_exists(control_id, statement_id)\n            if found_label:\n                label = found_label\n                part_name = part.name\n\n        response_per_component = self._get_responses_by_components(has_bycomp, write_empty_responses)\n\n        if response_per_component or (not response_per_component and write_empty_responses):\n            if part_name and part_name == 'item':\n                # print part header only if subitem\n                header = f'Implementation for part {label}'\n                md_writer.new_header(level=1, title=header)\n            for idx, component_key in enumerate(response_per_component):\n                if component_key == SSP_MAIN_COMP_NAME and idx == 0:\n                    # special case ignore header but print contents\n                    md_writer.new_paragraph()\n                elif show_comp:\n                    md_writer.new_header(level=2, title=component_key)\n                md_writer.set_indent_level(-1)\n                md_writer.new_line(response_per_component[component_key])\n                md_writer.set_indent_level(-1)\n\n    lines = md_writer.get_lines()\n\n    tree = DocsMarkdownNode.build_tree_from_markdown(lines)\n    tree.change_header_level_by(level)\n\n    return tree.content.raw_text\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.get_control_statement","title":"<code>get_control_statement(self, control_id, level)</code>","text":"<p>Get the control statement for an ssp - to be printed in markdown as a structured list.</p> <p>Parameters:</p> Name Type Description Default <code>control_id</code> <code>str</code> <p>The control_id to use.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A markdown blob as a string.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def get_control_statement(self, control_id: str, level: int) -&gt; str:\n\"\"\"\n    Get the control statement for an ssp - to be printed in markdown as a structured list.\n\n    Args:\n        control_id: The control_id to use.\n\n    Returns:\n        A markdown blob as a string.\n    \"\"\"\n    if not self._resolved_catalog:\n        raise TrestleError('Cannot get control statement, set resolved catalog first.')\n\n    writer = DocsControlWriter()\n    control = self._catalog_interface.get_control(control_id)\n    if not control:\n        return ''\n\n    control_lines = writer.get_control_statement_ssp(control)\n\n    return self._build_tree_and_adjust(control_lines, level)\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.get_fedramp_control_origination","title":"<code>get_fedramp_control_origination(self, control_id, level)</code>","text":"<p>Print control origination, as a list of items, only showing those that are applicable for the control.</p> <p>Using a LUT to map between structured data fields, defined by FedRAMP and historical text.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def get_fedramp_control_origination(self, control_id: str, level: int) -&gt; str:\n\"\"\"\n    Print control origination, as a list of items, only showing those that are applicable for the control.\n\n    Using a LUT to map between structured data fields, defined by FedRAMP and historical text.\n    \"\"\"\n    if not self._ssp:\n        raise TrestleError('Cannot get FedRamp control origination, set SSP first.')\n\n    control_origination = []\n    control_impl_req = self._control_implemented_req(control_id)\n\n    if control_impl_req and control_impl_req.props:\n        for prop in control_impl_req.props:\n            if prop.name == CONTROL_ORIGINATION:\n                control_origination.append(prop.value)\n\n    md_list = self._write_list_with_header('FedRamp Control Origination.', control_origination, level)\n    return md_list\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.get_fedramp_control_tables","title":"<code>get_fedramp_control_tables(self, control_id, level, label_column=False)</code>","text":"<p>Get the fedramp metadata as markdown tables, with optional third label column for params.</p> <p>The fedramp metadata has the following elements: - Responsible roles field - Parameter values table - Implementation status field - Control origination field</p> <p>Returns:</p> Type Description <code>str</code> <p>tables as one coherent markdown blob.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def get_fedramp_control_tables(self, control_id: str, level: int, label_column=False) -&gt; str:\n\"\"\"Get the fedramp metadata as markdown tables, with optional third label column for params.\n\n    The fedramp metadata has the following elements:\n    - Responsible roles field\n    - Parameter values table\n    - Implementation status field\n    - Control origination field\n\n    Returns:\n        tables as one coherent markdown blob.\n    \"\"\"\n    resp_roles_table = self.get_responsible_roles_table(control_id, level)\n    params_values = self._parameter_table(control_id, level, label_column)\n    impl_status = self.get_fedramp_implementation_status(control_id, level)\n    control_orig = self.get_fedramp_control_origination(control_id, level)\n\n    final_output = ''\n    if resp_roles_table:\n        final_output += resp_roles_table\n    if params_values:\n        final_output += '\\n' + params_values\n    if impl_status:\n        final_output += '\\n' + impl_status\n    if control_orig:\n        final_output += '\\n' + control_orig\n    return final_output\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.get_fedramp_implementation_status","title":"<code>get_fedramp_implementation_status(self, control_id, level)</code>","text":"<p>Print implementation status as a list of items, only showing those that are applicable for the control.</p> <p>This is unlike the word document FedRAMP which uses checkboxes on standard set of options. Using a LUT to map between structured data fields, defined by FedRAMP and historical text.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def get_fedramp_implementation_status(self, control_id: str, level: int) -&gt; str:\n\"\"\"\n    Print implementation status as a list of items, only showing those that are applicable for the control.\n\n    This is unlike the word document FedRAMP which uses checkboxes on standard set of options.\n    Using a LUT to map between structured data fields, defined by FedRAMP and historical text.\n    \"\"\"\n    if not self._ssp:\n        raise TrestleError('Cannot get Fedramp implementation status, set SSP first.')\n\n    implementation_statuses: List[str] = []\n    control_impl_req = self._control_implemented_req(control_id)\n    if control_impl_req and control_impl_req.props:\n        for prop in control_impl_req.props:\n            if prop.name == IMPLEMENTATION_STATUS:\n                implementation_statuses.append(prop.value)\n\n    md_list = self._write_list_with_header('FedRamp Implementation Status.', implementation_statuses, level)\n    return md_list\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.get_responsible_roles_table","title":"<code>get_responsible_roles_table(self, control_id, level)</code>","text":"<p>For each role id - if the role exists in metadata use the title as what gets printed in the roles table.</p> <p>If not (for now) warn and use the role-id as the printed text.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def get_responsible_roles_table(self, control_id: str, level: int) -&gt; str:\n\"\"\"\n    For each role id - if the role exists in metadata use the title as what gets printed in the roles table.\n\n    If not (for now) warn and use the role-id as the printed text.\n    \"\"\"\n    if self._ssp is None:\n        raise TrestleError('Cannot get responsible roles, SSP is not set.')\n\n    for impl_requirement in self._ssp.control_implementation.implemented_requirements:\n        if impl_requirement.control_id == control_id:\n            if impl_requirement.responsible_roles:\n                resp_roles = as_list(impl_requirement.responsible_roles)\n                role_ids = [role.role_id.replace('_', ' ') for role in resp_roles]\n\n                # now check if this role exists in the metadata\n                role_titles = dict(zip(role_ids, role_ids))\n                roles = as_list(self._ssp.metadata.roles)\n                for role in roles:\n                    if role.id in role_ids:\n                        role_titles[role.id] = role.title\n\n                # dictionary to md table\n                md_list = self._write_table_with_header(\n                    'Responsible Roles.', [[key, role_titles[key]] for key in role_titles.keys()],\n                    ['Role ID', 'Title'],\n                    level\n                )\n                return md_list\n            else:\n                logger.warning(\n                    f'No responsible roles were found for the control with id: {control_id} in given SSP.'\n                )\n                return ''\n\n    return ''\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.set_catalog","title":"<code>set_catalog(self, resolved_catalog)</code>","text":"<p>Set catalog.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def set_catalog(self, resolved_catalog: Catalog) -&gt; None:\n\"\"\"Set catalog.\"\"\"\n    self._resolved_catalog = resolved_catalog\n    self._catalog_interface = catalog_interface.CatalogInterface(self._resolved_catalog)\n</code></pre>"},{"location":"api_reference/trestle.core.ssp_io/#trestle.core.ssp_io.SSPMarkdownWriter.set_ssp","title":"<code>set_ssp(self, ssp)</code>","text":"<p>Set ssp.</p> Source code in <code>trestle/core/ssp_io.py</code> <pre><code>def set_ssp(self, ssp: ssp.SystemSecurityPlan) -&gt; None:\n\"\"\"Set ssp.\"\"\"\n    self._ssp = ssp\n</code></pre>"},{"location":"api_reference/trestle.core.trestle_base_model/","title":"trestle_base_model","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.trestle_base_model/#trestle.core.trestle_base_model","title":"<code>trestle.core.trestle_base_model</code>","text":"<p>Trestle Base Model.</p>"},{"location":"api_reference/trestle.core.trestle_base_model/#trestle.core.trestle_base_model.Model","title":"<code>Model</code>","text":""},{"location":"api_reference/trestle.core.trestle_base_model/#trestle.core.trestle_base_model-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.trestle_base_model/#trestle.core.trestle_base_model.TrestleBaseModel","title":"<code> TrestleBaseModel            (BaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Trestle Base Model. Serves as wrapper around BaseModel for overriding methods.</p> Source code in <code>trestle/core/trestle_base_model.py</code> <pre><code>class TrestleBaseModel(BaseModel):\n\"\"\"Trestle Base Model. Serves as wrapper around BaseModel for overriding methods.\"\"\"\n\n    @classmethod\n    def parse_obj(cls: Type['Model'], obj: Any) -&gt; 'Model':\n\"\"\"Parse object to the given class.\"\"\"\n        try:\n            return super().parse_obj(obj)\n        except ValidationError as e:\n            # check if failed due to the wrong OSCAL version:\n            oscal_version_error = False\n            for err in e.errors():\n                for field in err['loc']:\n                    if field == 'oscal-version':\n                        message = err['msg']\n                        oscal_version_error = True\n                        break\n            if oscal_version_error:\n                raise TrestleError(f'{message}')\n            else:\n                raise\n</code></pre>"},{"location":"api_reference/trestle.core.trestle_base_model/#trestle.core.trestle_base_model.TrestleBaseModel-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.trestle_base_model/#trestle.core.trestle_base_model.TrestleBaseModel.parse_obj","title":"<code>parse_obj(obj)</code>  <code>classmethod</code>","text":"<p>Parse object to the given class.</p> Source code in <code>trestle/core/trestle_base_model.py</code> <pre><code>@classmethod\ndef parse_obj(cls: Type['Model'], obj: Any) -&gt; 'Model':\n\"\"\"Parse object to the given class.\"\"\"\n    try:\n        return super().parse_obj(obj)\n    except ValidationError as e:\n        # check if failed due to the wrong OSCAL version:\n        oscal_version_error = False\n        for err in e.errors():\n            for field in err['loc']:\n                if field == 'oscal-version':\n                    message = err['msg']\n                    oscal_version_error = True\n                    break\n        if oscal_version_error:\n            raise TrestleError(f'{message}')\n        else:\n            raise\n</code></pre>"},{"location":"api_reference/trestle.core.validator/","title":"validator","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.validator/#trestle.core.validator","title":"<code>trestle.core.validator</code>","text":"<p>Base class for all validators.</p>"},{"location":"api_reference/trestle.core.validator/#trestle.core.validator.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.core.validator/#trestle.core.validator-classes","title":"Classes","text":""},{"location":"api_reference/trestle.core.validator/#trestle.core.validator.Validator","title":"<code> Validator            (ABC)         </code>","text":"<p>Validator base class.</p> Source code in <code>trestle/core/validator.py</code> <pre><code>class Validator(ABC):\n\"\"\"Validator base class.\"\"\"\n\n    def error_msg(self) -&gt; str:\n\"\"\"Error message used to describe this validator.\"\"\"\n        # subclasses can override as needed\n        return self.__doc__\n\n    @abstractmethod\n    def model_is_valid(self, model: OscalBaseModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None) -&gt; bool:\n\"\"\"\n        Validate the model.\n\n        args:\n            model: An Oscal model that can be passed to the validator.\n            quiet: Don't report msgs unless invalid.\n\n        returns:\n            Whether or not the model passed this validation test.\n        \"\"\"\n\n    def validate(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Perform the validation according to user options.\"\"\"\n        trestle_root = args.trestle_root  # trestle root is set via command line in args. Default is cwd.\n\n        # validate by type - all of type or just specified by name\n        if args.type:\n            models = []\n            if args.name:\n                models = [args.name]\n            else:\n                models = ModelUtils.get_models_of_type(args.type, trestle_root)\n            models_path = trestle_root / ModelUtils.model_type_to_model_dir(args.type)\n            for m in models:\n                model_path = models_path / m\n                try:\n                    _, _, model = ModelUtils.load_distributed(model_path, trestle_root)\n                except TrestleError as e:\n                    logger.warning(f'File load error {e}')\n                    return CmdReturnCodes.OSCAL_VALIDATION_ERROR.value\n                if not self.model_is_valid(model, args.quiet, trestle_root):\n                    logger.info(f'INVALID: Model {model_path} did not pass the {self.error_msg()}')\n                    return CmdReturnCodes.OSCAL_VALIDATION_ERROR.value\n                if not args.quiet:\n                    logger.info(f'VALID: Model {model_path} passed the {self.error_msg()}')\n            return CmdReturnCodes.SUCCESS.value\n\n        # validate all\n        if args.all:\n            model_tups = ModelUtils.get_all_models(trestle_root)\n            for mt in model_tups:\n\n                model_dir = trestle_root / ModelUtils.model_type_to_model_dir(mt[0]) / mt[1]\n                extension_type = trestle.common.file_utils.get_contextual_file_type(model_dir)\n                model_path = model_dir / f'{mt[0]}{FileContentType.to_file_extension(extension_type)}'\n                _, _, model = ModelUtils.load_distributed(model_path, trestle_root)\n                if not self.model_is_valid(model, args.quiet, trestle_root):\n                    logger.info(f'INVALID: Model {model_path} did not pass the {self.error_msg()}')\n                    return CmdReturnCodes.OSCAL_VALIDATION_ERROR.value\n                if not args.quiet:\n                    logger.info(f'VALID: Model {model_path} passed the {self.error_msg()}')\n            return CmdReturnCodes.SUCCESS.value\n\n        # validate file\n        if args.file:\n            file_path = trestle_root / args.file\n            _, _, model = ModelUtils.load_distributed(file_path, trestle_root)\n            if not self.model_is_valid(model, args.quiet, trestle_root):\n                logger.info(f'INVALID: Model {file_path} did not pass the {self.error_msg()}')\n                return CmdReturnCodes.OSCAL_VALIDATION_ERROR.value\n            if not args.quiet:\n                logger.info(f'VALID: Model {file_path} passed the {self.error_msg()}')\n        return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.validator/#trestle.core.validator.Validator-methods","title":"Methods","text":""},{"location":"api_reference/trestle.core.validator/#trestle.core.validator.Validator.error_msg","title":"<code>error_msg(self)</code>","text":"<p>Error message used to describe this validator.</p> Source code in <code>trestle/core/validator.py</code> <pre><code>def error_msg(self) -&gt; str:\n\"\"\"Error message used to describe this validator.\"\"\"\n    # subclasses can override as needed\n    return self.__doc__\n</code></pre>"},{"location":"api_reference/trestle.core.validator/#trestle.core.validator.Validator.model_is_valid","title":"<code>model_is_valid(self, model, quiet, trestle_root=None)</code>","text":"<p>Validate the model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>OscalBaseModel</code> <p>An Oscal model that can be passed to the validator.</p> required <code>quiet</code> <code>bool</code> <p>Don't report msgs unless invalid.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not the model passed this validation test.</p> Source code in <code>trestle/core/validator.py</code> <pre><code>@abstractmethod\ndef model_is_valid(self, model: OscalBaseModel, quiet: bool, trestle_root: Optional[pathlib.Path] = None) -&gt; bool:\n\"\"\"\n    Validate the model.\n\n    args:\n        model: An Oscal model that can be passed to the validator.\n        quiet: Don't report msgs unless invalid.\n\n    returns:\n        Whether or not the model passed this validation test.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/trestle.core.validator/#trestle.core.validator.Validator.validate","title":"<code>validate(self, args)</code>","text":"<p>Perform the validation according to user options.</p> Source code in <code>trestle/core/validator.py</code> <pre><code>def validate(self, args: argparse.Namespace) -&gt; int:\n\"\"\"Perform the validation according to user options.\"\"\"\n    trestle_root = args.trestle_root  # trestle root is set via command line in args. Default is cwd.\n\n    # validate by type - all of type or just specified by name\n    if args.type:\n        models = []\n        if args.name:\n            models = [args.name]\n        else:\n            models = ModelUtils.get_models_of_type(args.type, trestle_root)\n        models_path = trestle_root / ModelUtils.model_type_to_model_dir(args.type)\n        for m in models:\n            model_path = models_path / m\n            try:\n                _, _, model = ModelUtils.load_distributed(model_path, trestle_root)\n            except TrestleError as e:\n                logger.warning(f'File load error {e}')\n                return CmdReturnCodes.OSCAL_VALIDATION_ERROR.value\n            if not self.model_is_valid(model, args.quiet, trestle_root):\n                logger.info(f'INVALID: Model {model_path} did not pass the {self.error_msg()}')\n                return CmdReturnCodes.OSCAL_VALIDATION_ERROR.value\n            if not args.quiet:\n                logger.info(f'VALID: Model {model_path} passed the {self.error_msg()}')\n        return CmdReturnCodes.SUCCESS.value\n\n    # validate all\n    if args.all:\n        model_tups = ModelUtils.get_all_models(trestle_root)\n        for mt in model_tups:\n\n            model_dir = trestle_root / ModelUtils.model_type_to_model_dir(mt[0]) / mt[1]\n            extension_type = trestle.common.file_utils.get_contextual_file_type(model_dir)\n            model_path = model_dir / f'{mt[0]}{FileContentType.to_file_extension(extension_type)}'\n            _, _, model = ModelUtils.load_distributed(model_path, trestle_root)\n            if not self.model_is_valid(model, args.quiet, trestle_root):\n                logger.info(f'INVALID: Model {model_path} did not pass the {self.error_msg()}')\n                return CmdReturnCodes.OSCAL_VALIDATION_ERROR.value\n            if not args.quiet:\n                logger.info(f'VALID: Model {model_path} passed the {self.error_msg()}')\n        return CmdReturnCodes.SUCCESS.value\n\n    # validate file\n    if args.file:\n        file_path = trestle_root / args.file\n        _, _, model = ModelUtils.load_distributed(file_path, trestle_root)\n        if not self.model_is_valid(model, args.quiet, trestle_root):\n            logger.info(f'INVALID: Model {file_path} did not pass the {self.error_msg()}')\n            return CmdReturnCodes.OSCAL_VALIDATION_ERROR.value\n        if not args.quiet:\n            logger.info(f'VALID: Model {file_path} passed the {self.error_msg()}')\n    return CmdReturnCodes.SUCCESS.value\n</code></pre>"},{"location":"api_reference/trestle.core.validator_factory/","title":"validator_factory","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.core.validator_factory/#trestle.core.validator_factory","title":"<code>trestle.core.validator_factory</code>","text":"<p>Register all validators here in the validator_factory.</p>"},{"location":"api_reference/trestle.core.validator_factory/#trestle.core.validator_factory.validator_factory","title":"<code>validator_factory: ObjectFactory</code>","text":""},{"location":"api_reference/trestle.core.validator_factory/#trestle.core.validator_factory-functions","title":"Functions","text":""},{"location":"api_reference/trestle.core.validator_factory/#trestle.core.validator_factory.init_arguments","title":"<code>init_arguments(cmd)</code>","text":"<p>Feed the arguments to the argument parser.</p> Source code in <code>trestle/core/validator_factory.py</code> <pre><code>def init_arguments(cmd: Command) -&gt; None:\n\"\"\"Feed the arguments to the argument parser.\"\"\"\n    group = cmd.parser.add_mutually_exclusive_group(required=True)\n    group.add_argument('-f', '--file', help='Path of file in trestle directory to validate.')\n    group.add_argument('-t', '--type', choices=const.MODEL_TYPE_LIST, help='Validate one or all models of this type.')\n    group.add_argument('-a', '--all', action='store_true', help='Validate all models in trestle directory.')\n    cmd.add_argument('-n', '--name', help='Name of single model to validate (with --type specified).', required=False)\n    quiet_help = 'Do not report messages unless validation fails.'\n    cmd.add_argument('-q', '--quiet', action='store_true', help=quiet_help, required=False)\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/","title":"assessment_plan","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan","title":"<code>trestle.oscal.assessment_plan</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan-classes","title":"Classes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity","title":"<code> Activity            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an assessment or related process that can be performed. In the assessment plan, this is an intended activity which may be associated with an assessment task. In the assessment results, this an activity that was actually performed as part of an assessment.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Activity(OscalBaseModel):\n\"\"\"\n    Identifies an assessment or related process that can be performed. In the assessment plan, this is an intended activity which may be associated with an assessment task. In the assessment results, this an activity that was actually performed as part of an assessment.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment activity elsewhere in this or other OSCAL instances. The locally defined UUID of the activity can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Assessment Activity Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='The title for this included activity.',\n        title='Included Activity Title',\n    )\n    description: str = Field(\n        ...,\n        description='A human-readable description of this included activity.',\n        title='Included Activity Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    steps: Optional[List[Step]] = Field(None)\n    related_controls: Optional[ReviewedControls] = Field(None, alias='related-controls')\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this included activity.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.related_controls","title":"<code>related_controls: ReviewedControls</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.steps","title":"<code>steps: List[trestle.oscal.assessment_plan.Step]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this included activity.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment activity elsewhere in this or other OSCAL instances. The locally defined UUID of the activity can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Activity.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentAssets","title":"<code> AssessmentAssets            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the assets used to perform this assessment, such as the assessment team, scanning tools, and assumptions.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class AssessmentAssets(OscalBaseModel):\n\"\"\"\n    Identifies the assets used to perform this assessment, such as the assessment team, scanning tools, and assumptions.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    components: Optional[List[SystemComponent]] = Field(None)\n    assessment_platforms: List[common.AssessmentPlatform] = Field(..., alias='assessment-platforms')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentAssets.assessment_platforms","title":"<code>assessment_platforms: List[trestle.oscal.common.AssessmentPlatform]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentAssets.components","title":"<code>components: List[trestle.oscal.assessment_plan.SystemComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentAssets.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan","title":"<code> AssessmentPlan            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>An assessment plan, such as those provided by a FedRAMP assessor.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class AssessmentPlan(OscalBaseModel):\n\"\"\"\n    An assessment plan, such as those provided by a FedRAMP assessor.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment plan in this or other OSCAL instances. The locally defined UUID of the assessment plan can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Assessment Plan Universally Unique Identifier',\n    )\n    metadata: common.Metadata\n    import_ssp: common.ImportSsp = Field(..., alias='import-ssp')\n    local_definitions: Optional[LocalDefinitions] = Field(\n        None,\n        alias='local-definitions',\n        description=\n        'Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.',\n        title='Local Definitions',\n    )\n    terms_and_conditions: Optional[TermsAndConditions] = Field(\n        None,\n        alias='terms-and-conditions',\n        description=\n        'Used to define various terms and conditions under which an assessment, described by the plan, can be performed. Each child part defines a different type of term or condition.',\n        title='Assessment Plan Terms and Conditions',\n    )\n    reviewed_controls: ReviewedControls = Field(..., alias='reviewed-controls')\n    assessment_subjects: Optional[List[common.AssessmentSubject]] = Field(None, alias='assessment-subjects')\n    assessment_assets: Optional[AssessmentAssets] = Field(None, alias='assessment-assets')\n    tasks: Optional[List[common.Task]] = Field(None)\n    back_matter: Optional[common.BackMatter] = Field(None, alias='back-matter')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.assessment_assets","title":"<code>assessment_assets: AssessmentAssets</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.assessment_subjects","title":"<code>assessment_subjects: List[trestle.oscal.common.AssessmentSubject]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.back_matter","title":"<code>back_matter: BackMatter</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.import_ssp","title":"<code>import_ssp: ImportSsp</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.local_definitions","title":"<code>local_definitions: LocalDefinitions</code>  <code>pydantic-field</code>","text":"<p>Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.metadata","title":"<code>metadata: Metadata</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.reviewed_controls","title":"<code>reviewed_controls: ReviewedControls</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.tasks","title":"<code>tasks: List[trestle.oscal.common.Task]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.terms_and_conditions","title":"<code>terms_and_conditions: TermsAndConditions</code>  <code>pydantic-field</code>","text":"<p>Used to define various terms and conditions under which an assessment, described by the plan, can be performed. Each child part defines a different type of term or condition.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment plan in this or other OSCAL instances. The locally defined UUID of the assessment plan can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.AssessmentPlan.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Characterization","title":"<code> Characterization            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A collection of descriptive data about the containing object from a specific origin.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Characterization(OscalBaseModel):\n\"\"\"\n    A collection of descriptive data about the containing object from a specific origin.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    origin: Origin\n    facets: List[common.Facet] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Characterization.facets","title":"<code>facets: List[trestle.oscal.common.Facet]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Characterization.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Characterization.origin","title":"<code>origin: Origin</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Characterization.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Characterization.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection","title":"<code> ControlSelection            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the controls being assessed. In the assessment plan, these are the planned controls. In the assessment results, these are the actual controls, and reflects any changes from the plan.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class ControlSelection(OscalBaseModel):\n\"\"\"\n    Identifies the controls being assessed. In the assessment plan, these are the planned controls. In the assessment results, these are the actual controls, and reflects any changes from the plan.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of in-scope controls specified for assessment.',\n        title='Assessed Controls Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    include_all: Optional[common.IncludeAll] = Field(None, alias='include-all')\n    include_controls: Optional[List[SelectControlById]] = Field(None, alias='include-controls')\n    exclude_controls: Optional[List[SelectControlById]] = Field(None, alias='exclude-controls')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of in-scope controls specified for assessment.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection.exclude_controls","title":"<code>exclude_controls: List[trestle.oscal.assessment_plan.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection.include_all","title":"<code>include_all: IncludeAll</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection.include_controls","title":"<code>include_controls: List[trestle.oscal.assessment_plan.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ControlSelection.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry","title":"<code> Entry            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an individual risk response that occurred as part of managing an identified risk.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Entry(OscalBaseModel):\n\"\"\"\n    Identifies an individual risk response that occurred as part of managing an identified risk.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk log entry elsewhere in this or other OSCAL instances. The locally defined UUID of the risk log entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Risk Log Entry Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this risk log entry.', title='Title')\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of what was done regarding the risk.',\n        title='Risk Task Description',\n    )\n    start: datetime = Field(\n        ...,\n        description='Identifies the start date and time of the event.',\n        title='Start',\n    )\n    end: Optional[datetime] = Field(\n        None,\n        description=\n        'Identifies the end date and time of the event. If the event is a point in time, the start and end will be the same date and time.',\n        title='End',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    logged_by: Optional[List[common.LoggedBy]] = Field(None, alias='logged-by')\n    status_change: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None, alias='status-change'\n    )\n    related_responses: Optional[List[common.RelatedResponse]] = Field(None, alias='related-responses')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of what was done regarding the risk.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.end","title":"<code>end: datetime</code>  <code>pydantic-field</code>","text":"<p>Identifies the end date and time of the event. If the event is a point in time, the start and end will be the same date and time.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.logged_by","title":"<code>logged_by: List[trestle.oscal.common.LoggedBy]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.related_responses","title":"<code>related_responses: List[trestle.oscal.common.RelatedResponse]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.start","title":"<code>start: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Identifies the start date and time of the event.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.status_change","title":"<code>status_change: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this risk log entry.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk log entry elsewhere in this or other OSCAL instances. The locally defined UUID of the risk log entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Entry.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.LocalDefinitions","title":"<code> LocalDefinitions            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class LocalDefinitions(OscalBaseModel):\n\"\"\"\n    Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    components: Optional[List[SystemComponent]] = Field(None)\n    inventory_items: Optional[List[common.InventoryItem]] = Field(None, alias='inventory-items')\n    users: Optional[List[common.SystemUser]] = Field(None)\n    objectives_and_methods: Optional[List[common.LocalObjective]] = Field(None, alias='objectives-and-methods')\n    activities: Optional[List[Activity]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.LocalDefinitions.activities","title":"<code>activities: List[trestle.oscal.assessment_plan.Activity]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.LocalDefinitions.components","title":"<code>components: List[trestle.oscal.assessment_plan.SystemComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.LocalDefinitions.inventory_items","title":"<code>inventory_items: List[trestle.oscal.common.InventoryItem]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.LocalDefinitions.objectives_and_methods","title":"<code>objectives_and_methods: List[trestle.oscal.common.LocalObjective]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.LocalDefinitions.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.LocalDefinitions.users","title":"<code>users: List[trestle.oscal.common.SystemUser]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.LocalDefinitions.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Method","title":"<code> Method            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Method(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='Identifies how the observation was made.',\n        title='Observation Method',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Method-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Method.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Identifies how the observation was made.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Model","title":"<code> Model            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Model(OscalBaseModel):\n    assessment_plan: AssessmentPlan = Field(..., alias='assessment-plan')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Model.assessment_plan","title":"<code>assessment_plan: AssessmentPlan</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation","title":"<code> Observation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes an individual observation.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Observation(OscalBaseModel):\n\"\"\"\n    Describes an individual observation.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this observation elsewhere in this or other OSCAL instances. The locally defined UUID of the observation can be used to reference the data item locally or globally (e.g., in an imorted OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Observation Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this observation.', title='Observation Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this assessment observation.',\n        title='Observation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    methods: List[Method] = Field(...)\n    types: Optional[List[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )]] = Field(None)\n    origins: Optional[List[Origin]] = Field(None)\n    subjects: Optional[List[common.SubjectReference]] = Field(None)\n    relevant_evidence: Optional[List[common.RelevantEvidence]] = Field(None, alias='relevant-evidence')\n    collected: datetime = Field(\n        ...,\n        description='Date/time stamp identifying when the finding information was collected.',\n        title='Collected Field',\n    )\n    expires: Optional[datetime] = Field(\n        None,\n        description=\n        'Date/time identifying when the finding information is out-of-date and no longer valid. Typically used with continuous assessment scenarios.',\n        title='Expires Field',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.collected","title":"<code>collected: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Date/time stamp identifying when the finding information was collected.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this assessment observation.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.expires","title":"<code>expires: datetime</code>  <code>pydantic-field</code>","text":"<p>Date/time identifying when the finding information is out-of-date and no longer valid. Typically used with continuous assessment scenarios.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.methods","title":"<code>methods: List[trestle.oscal.assessment_plan.Method]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.origins","title":"<code>origins: List[trestle.oscal.assessment_plan.Origin]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.relevant_evidence","title":"<code>relevant_evidence: List[trestle.oscal.common.RelevantEvidence]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.subjects","title":"<code>subjects: List[trestle.oscal.common.SubjectReference]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this observation.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.types","title":"<code>types: List[trestle.oscal.assessment_plan.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this observation elsewhere in this or other OSCAL instances. The locally defined UUID of the observation can be used to reference the data item locally or globally (e.g., in an imorted OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Observation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Origin","title":"<code> Origin            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the source of the finding, such as a tool, interviewed person, or activity.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Origin(OscalBaseModel):\n\"\"\"\n    Identifies the source of the finding, such as a tool, interviewed person, or activity.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    actors: List[common.OriginActor] = Field(...)\n    related_tasks: Optional[List[common.RelatedTask]] = Field(None, alias='related-tasks')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Origin.actors","title":"<code>actors: List[trestle.oscal.common.OriginActor]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Origin.related_tasks","title":"<code>related_tasks: List[trestle.oscal.common.RelatedTask]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Origin.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.RelatedObservation","title":"<code> RelatedObservation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Relates the finding to a set of referenced observations that were used to determine the finding.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class RelatedObservation(OscalBaseModel):\n\"\"\"\n    Relates the finding to a set of referenced observations that were used to determine the finding.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    observation_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='observation-uuid',\n        description='A machine-oriented identifier reference to an observation defined in the list of observations.',\n        title='Observation Universally Unique Identifier Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.RelatedObservation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.RelatedObservation.observation_uuid","title":"<code>observation_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to an observation defined in the list of observations.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.RelatedObservation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response","title":"<code> Response            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes either recommended or an actual plan for addressing the risk.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Response(OscalBaseModel):\n\"\"\"\n    Describes either recommended or an actual plan for addressing the risk.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this remediation elsewhere in this or other OSCAL instances. The locally defined UUID of the risk response can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Remediation Universally Unique Identifier',\n    )\n    lifecycle: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\n        'Identifies whether this is a recommendation, such as from an assessor or tool, or an actual plan accepted by the system owner.',\n        title='Remediation Intent',\n    )\n    title: str = Field(..., description='The title for this response activity.', title='Response Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this response plan.',\n        title='Response Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    origins: Optional[List[Origin]] = Field(None)\n    required_assets: Optional[List[common.RequiredAsset]] = Field(None, alias='required-assets')\n    tasks: Optional[List[common.Task]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this response plan.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.lifecycle","title":"<code>lifecycle: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Identifies whether this is a recommendation, such as from an assessor or tool, or an actual plan accepted by the system owner.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.origins","title":"<code>origins: List[trestle.oscal.assessment_plan.Origin]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.required_assets","title":"<code>required_assets: List[trestle.oscal.common.RequiredAsset]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.tasks","title":"<code>tasks: List[trestle.oscal.common.Task]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title for this response activity.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this remediation elsewhere in this or other OSCAL instances. The locally defined UUID of the risk response can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Response.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ReviewedControls","title":"<code> ReviewedControls            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the controls being assessed and their control objectives.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class ReviewedControls(OscalBaseModel):\n\"\"\"\n    Identifies the controls being assessed and their control objectives.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of control objectives.',\n        title='Control Objective Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    control_selections: List[ControlSelection] = Field(..., alias='control-selections')\n    control_objective_selections: Optional[List[common.ControlObjectiveSelection]] = Field(\n        None, alias='control-objective-selections'\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ReviewedControls-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ReviewedControls.control_objective_selections","title":"<code>control_objective_selections: List[trestle.oscal.common.ControlObjectiveSelection]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ReviewedControls.control_selections","title":"<code>control_selections: List[trestle.oscal.assessment_plan.ControlSelection]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ReviewedControls.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of control objectives.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ReviewedControls.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ReviewedControls.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ReviewedControls.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.ReviewedControls.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk","title":"<code> Risk            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>An identified risk.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Risk(OscalBaseModel):\n\"\"\"\n    An identified risk.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk elsewhere in this or other OSCAL instances. The locally defined UUID of the risk can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Risk Universally Unique Identifier',\n    )\n    title: str = Field(..., description='The title for this risk.', title='Risk Title')\n    description: str = Field(\n        ...,\n        description=\n        'A human-readable summary of the identified risk, to include a statement of how the risk impacts the system.',\n        title='Risk Description',\n    )\n    statement: str = Field(\n        ...,\n        description='An summary of impact for how the risk affects the system.',\n        title='Risk Statement',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    status: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )\n    origins: Optional[List[Origin]] = Field(None)\n    threat_ids: Optional[List[common.ThreatId]] = Field(None, alias='threat-ids')\n    characterizations: Optional[List[Characterization]] = Field(None)\n    mitigating_factors: Optional[List[common.MitigatingFactor]] = Field(None, alias='mitigating-factors')\n    deadline: Optional[datetime] = Field(\n        None,\n        description='The date/time by which the risk must be resolved.',\n        title='Risk Resolution Deadline',\n    )\n    remediations: Optional[List[Response]] = Field(None)\n    risk_log: Optional[RiskLog] = Field(\n        None,\n        alias='risk-log',\n        description='A log of all risk-related tasks taken.',\n        title='Risk Log',\n    )\n    related_observations: Optional[List[RelatedObservation]] = Field(None, alias='related-observations')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.characterizations","title":"<code>characterizations: List[trestle.oscal.assessment_plan.Characterization]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.deadline","title":"<code>deadline: datetime</code>  <code>pydantic-field</code>","text":"<p>The date/time by which the risk must be resolved.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable summary of the identified risk, to include a statement of how the risk impacts the system.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.mitigating_factors","title":"<code>mitigating_factors: List[trestle.oscal.common.MitigatingFactor]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.origins","title":"<code>origins: List[trestle.oscal.assessment_plan.Origin]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.related_observations","title":"<code>related_observations: List[trestle.oscal.assessment_plan.RelatedObservation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.remediations","title":"<code>remediations: List[trestle.oscal.assessment_plan.Response]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.risk_log","title":"<code>risk_log: RiskLog</code>  <code>pydantic-field</code>","text":"<p>A log of all risk-related tasks taken.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.statement","title":"<code>statement: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An summary of impact for how the risk affects the system.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.status","title":"<code>status: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.threat_ids","title":"<code>threat_ids: List[trestle.oscal.common.ThreatId]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title for this risk.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk elsewhere in this or other OSCAL instances. The locally defined UUID of the risk can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Risk.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.RiskLog","title":"<code> RiskLog            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A log of all risk-related tasks taken.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class RiskLog(OscalBaseModel):\n\"\"\"\n    A log of all risk-related tasks taken.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    entries: List[Entry] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.RiskLog.entries","title":"<code>entries: List[trestle.oscal.assessment_plan.Entry]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.RiskLog.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SelectControlById","title":"<code> SelectControlById            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to select a control for inclusion/exclusion based on one or more control identifiers. A set of statement identifiers can be used to target the inclusion/exclusion to only specific control statements providing more granularity over the specific statements that are within the asessment scope.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class SelectControlById(OscalBaseModel):\n\"\"\"\n    Used to select a control for inclusion/exclusion based on one or more control identifiers. A set of statement identifiers can be used to target the inclusion/exclusion to only specific control statements providing more granularity over the specific statements that are within the asessment scope.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    control_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='control-id',\n        description=\n        'A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).',\n        title='Control Identifier Reference',\n    )\n    statement_ids: Optional[List[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )]] = Field(\n        None, alias='statement-ids'\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SelectControlById-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SelectControlById.control_id","title":"<code>control_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SelectControlById.statement_ids","title":"<code>statement_ids: List[trestle.oscal.assessment_plan.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SelectControlById.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.State","title":"<code> State            (Enum)         </code>","text":"<p>An indication as to whether the objective is satisfied or not.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class State(Enum):\n\"\"\"\n    An indication as to whether the objective is satisfied or not.\n    \"\"\"\n\n    satisfied = 'satisfied'\n    not_satisfied = 'not-satisfied'\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.State.not_satisfied","title":"<code>not_satisfied</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.State.satisfied","title":"<code>satisfied</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.State1","title":"<code> State1            (Enum)         </code>","text":"<p>The operational status.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class State1(Enum):\n\"\"\"\n    The operational status.\n    \"\"\"\n\n    under_development = 'under-development'\n    operational = 'operational'\n    disposition = 'disposition'\n    other = 'other'\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.State1.disposition","title":"<code>disposition</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.State1.operational","title":"<code>operational</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.State1.other","title":"<code>other</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.State1.under_development","title":"<code>under_development</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status","title":"<code> Status            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A determination of if the objective is satisfied or not within a given system.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Status(OscalBaseModel):\n\"\"\"\n    A determination of if the objective is satisfied or not within a given system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: State = Field(\n        ...,\n        description='An indication as to whether the objective is satisfied or not.',\n        title='Objective Status State',\n    )\n    reason: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        description=\"The reason the objective was given it's status.\",\n        title='Objective Status Reason',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status.reason","title":"<code>reason: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>The reason the objective was given it's status.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status.state","title":"<code>state: State</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An indication as to whether the objective is satisfied or not.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status1","title":"<code> Status1            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes the operational status of the system component.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Status1(OscalBaseModel):\n\"\"\"\n    Describes the operational status of the system component.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: State1 = Field(..., description='The operational status.', title='State')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status1-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status1.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status1.state","title":"<code>state: State1</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The operational status.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Status1.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step","title":"<code> Step            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an individual step in a series of steps related to an activity, such as an assessment test or examination procedure.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Step(OscalBaseModel):\n\"\"\"\n    Identifies an individual step in a series of steps related to an activity, such as an assessment test or examination procedure.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this step elsewhere in this or other OSCAL instances. The locally defined UUID of the step (in a series of steps) can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Step Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this step.', title='Step Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this step.',\n        title='Step Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    reviewed_controls: Optional[ReviewedControls] = Field(None, alias='reviewed-controls')\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this step.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step.reviewed_controls","title":"<code>reviewed_controls: ReviewedControls</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this step.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this step elsewhere in this or other OSCAL instances. The locally defined UUID of the step (in a series of steps) can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.Step.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent","title":"<code> SystemComponent            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A defined component that can be part of an implemented system.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class SystemComponent(OscalBaseModel):\n\"\"\"\n    A defined component that can be part of an implemented system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Component Identifier',\n    )\n    type: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='A category describing the purpose of the component.',\n        title='Component Type',\n    )\n    title: str = Field(\n        ...,\n        description='A human readable name for the system component.',\n        title='Component Title',\n    )\n    description: str = Field(\n        ...,\n        description='A description of the component, including information about its function.',\n        title='Component Description',\n    )\n    purpose: Optional[str] = Field(\n        None,\n        description='A summary of the technological or business purpose of the component.',\n        title='Purpose',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    status: Status1 = Field(\n        ...,\n        description='Describes the operational status of the system component.',\n        title='Status',\n    )\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    protocols: Optional[List[common.Protocol]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of the component, including information about its function.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.protocols","title":"<code>protocols: List[trestle.oscal.common.Protocol]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.purpose","title":"<code>purpose: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the technological or business purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.status","title":"<code>status: Status1</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Describes the operational status of the system component.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human readable name for the system component.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A category describing the purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.SystemComponent.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.TermsAndConditions","title":"<code> TermsAndConditions            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to define various terms and conditions under which an assessment, described by the plan, can be performed. Each child part defines a different type of term or condition.</p> Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class TermsAndConditions(OscalBaseModel):\n\"\"\"\n    Used to define various terms and conditions under which an assessment, described by the plan, can be performed. Each child part defines a different type of term or condition.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    parts: Optional[List[common.AssessmentPart]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.TermsAndConditions.parts","title":"<code>parts: List[trestle.oscal.common.AssessmentPart]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_plan/#trestle.oscal.assessment_plan.TermsAndConditions.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_plan.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/","title":"assessment_results","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results","title":"<code>trestle.oscal.assessment_results</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results-classes","title":"Classes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity","title":"<code> Activity            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an assessment or related process that can be performed. In the assessment plan, this is an intended activity which may be associated with an assessment task. In the assessment results, this an activity that was actually performed as part of an assessment.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Activity(OscalBaseModel):\n\"\"\"\n    Identifies an assessment or related process that can be performed. In the assessment plan, this is an intended activity which may be associated with an assessment task. In the assessment results, this an activity that was actually performed as part of an assessment.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment activity elsewhere in this or other OSCAL instances. The locally defined UUID of the activity can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Assessment Activity Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='The title for this included activity.',\n        title='Included Activity Title',\n    )\n    description: str = Field(\n        ...,\n        description='A human-readable description of this included activity.',\n        title='Included Activity Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    steps: Optional[List[Step]] = Field(None)\n    related_controls: Optional[ReviewedControls] = Field(None, alias='related-controls')\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this included activity.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.related_controls","title":"<code>related_controls: ReviewedControls</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.steps","title":"<code>steps: List[trestle.oscal.assessment_results.Step]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this included activity.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment activity elsewhere in this or other OSCAL instances. The locally defined UUID of the activity can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Activity.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentAssets","title":"<code> AssessmentAssets            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the assets used to perform this assessment, such as the assessment team, scanning tools, and assumptions.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class AssessmentAssets(OscalBaseModel):\n\"\"\"\n    Identifies the assets used to perform this assessment, such as the assessment team, scanning tools, and assumptions.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    components: Optional[List[SystemComponent]] = Field(None)\n    assessment_platforms: List[common.AssessmentPlatform] = Field(..., alias='assessment-platforms')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentAssets.assessment_platforms","title":"<code>assessment_platforms: List[trestle.oscal.common.AssessmentPlatform]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentAssets.components","title":"<code>components: List[trestle.oscal.assessment_results.SystemComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentAssets.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentLog","title":"<code> AssessmentLog            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A log of all assessment-related actions taken.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class AssessmentLog(OscalBaseModel):\n\"\"\"\n    A log of all assessment-related actions taken.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    entries: List[Entry] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentLog.entries","title":"<code>entries: List[trestle.oscal.assessment_results.Entry]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentLog.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentResults","title":"<code> AssessmentResults            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Security assessment results, such as those provided by a FedRAMP assessor in the FedRAMP Security Assessment Report.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class AssessmentResults(OscalBaseModel):\n\"\"\"\n    Security assessment results, such as those provided by a FedRAMP assessor in the FedRAMP Security Assessment Report.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment results instance in this or other OSCAL instances. The locally defined UUID of the assessment result can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Assessment Results Universally Unique Identifier',\n    )\n    metadata: common.Metadata\n    import_ap: ImportAp = Field(..., alias='import-ap')\n    local_definitions: Optional[LocalDefinitions] = Field(\n        None,\n        alias='local-definitions',\n        description=\n        'Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.',\n        title='Local Definitions',\n    )\n    results: List[Result] = Field(...)\n    back_matter: Optional[common.BackMatter] = Field(None, alias='back-matter')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentResults-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentResults.back_matter","title":"<code>back_matter: BackMatter</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentResults.import_ap","title":"<code>import_ap: ImportAp</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentResults.local_definitions","title":"<code>local_definitions: LocalDefinitions</code>  <code>pydantic-field</code>","text":"<p>Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentResults.metadata","title":"<code>metadata: Metadata</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentResults.results","title":"<code>results: List[trestle.oscal.assessment_results.Result]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentResults.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment results instance in this or other OSCAL instances. The locally defined UUID of the assessment result can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.AssessmentResults.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Attestation","title":"<code> Attestation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A set of textual statements, typically written by the assessor.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Attestation(OscalBaseModel):\n\"\"\"\n    A set of textual statements, typically written by the assessor.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    responsible_parties: Optional[List[common.ResponsibleParty]] = Field(None, alias='responsible-parties')\n    parts: List[common.AssessmentPart] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Attestation.parts","title":"<code>parts: List[trestle.oscal.common.AssessmentPart]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Attestation.responsible_parties","title":"<code>responsible_parties: List[trestle.oscal.common.ResponsibleParty]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Attestation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Characterization","title":"<code> Characterization            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A collection of descriptive data about the containing object from a specific origin.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Characterization(OscalBaseModel):\n\"\"\"\n    A collection of descriptive data about the containing object from a specific origin.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    origin: Origin\n    facets: List[common.Facet] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Characterization.facets","title":"<code>facets: List[trestle.oscal.common.Facet]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Characterization.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Characterization.origin","title":"<code>origin: Origin</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Characterization.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Characterization.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection","title":"<code> ControlSelection            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the controls being assessed. In the assessment plan, these are the planned controls. In the assessment results, these are the actual controls, and reflects any changes from the plan.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class ControlSelection(OscalBaseModel):\n\"\"\"\n    Identifies the controls being assessed. In the assessment plan, these are the planned controls. In the assessment results, these are the actual controls, and reflects any changes from the plan.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of in-scope controls specified for assessment.',\n        title='Assessed Controls Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    include_all: Optional[common.IncludeAll] = Field(None, alias='include-all')\n    include_controls: Optional[List[SelectControlById]] = Field(None, alias='include-controls')\n    exclude_controls: Optional[List[SelectControlById]] = Field(None, alias='exclude-controls')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of in-scope controls specified for assessment.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection.exclude_controls","title":"<code>exclude_controls: List[trestle.oscal.assessment_results.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection.include_all","title":"<code>include_all: IncludeAll</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection.include_controls","title":"<code>include_controls: List[trestle.oscal.assessment_results.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ControlSelection.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry","title":"<code> Entry            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the result of an action and/or task that occurred as part of executing an assessment plan or an assessment event that occurred in producing the assessment results.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Entry(OscalBaseModel):\n\"\"\"\n    Identifies the result of an action and/or task that occurred as part of executing an assessment plan or an assessment event that occurred in producing the assessment results.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference an assessment event in this or other OSCAL instances. The locally defined UUID of the assessment log entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Assessment Log Entry Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this event.', title='Action Title')\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of this event.',\n        title='Action Description',\n    )\n    start: datetime = Field(\n        ...,\n        description='Identifies the start date and time of an event.',\n        title='Start',\n    )\n    end: Optional[datetime] = Field(\n        None,\n        description=\n        'Identifies the end date and time of an event. If the event is a point in time, the start and end will be the same date and time.',\n        title='End',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    logged_by: Optional[List[common.LoggedBy]] = Field(None, alias='logged-by')\n    related_tasks: Optional[List[common.RelatedTask]] = Field(None, alias='related-tasks')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of this event.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.end","title":"<code>end: datetime</code>  <code>pydantic-field</code>","text":"<p>Identifies the end date and time of an event. If the event is a point in time, the start and end will be the same date and time.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.logged_by","title":"<code>logged_by: List[trestle.oscal.common.LoggedBy]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.related_tasks","title":"<code>related_tasks: List[trestle.oscal.common.RelatedTask]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.start","title":"<code>start: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Identifies the start date and time of an event.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this event.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference an assessment event in this or other OSCAL instances. The locally defined UUID of the assessment log entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1","title":"<code> Entry1            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an individual risk response that occurred as part of managing an identified risk.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Entry1(OscalBaseModel):\n\"\"\"\n    Identifies an individual risk response that occurred as part of managing an identified risk.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk log entry elsewhere in this or other OSCAL instances. The locally defined UUID of the risk log entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Risk Log Entry Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this risk log entry.', title='Title')\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of what was done regarding the risk.',\n        title='Risk Task Description',\n    )\n    start: datetime = Field(\n        ...,\n        description='Identifies the start date and time of the event.',\n        title='Start',\n    )\n    end: Optional[datetime] = Field(\n        None,\n        description=\n        'Identifies the end date and time of the event. If the event is a point in time, the start and end will be the same date and time.',\n        title='End',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    logged_by: Optional[List[common.LoggedBy]] = Field(None, alias='logged-by')\n    status_change: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None, alias='status-change'\n    )\n    related_responses: Optional[List[common.RelatedResponse]] = Field(None, alias='related-responses')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of what was done regarding the risk.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.end","title":"<code>end: datetime</code>  <code>pydantic-field</code>","text":"<p>Identifies the end date and time of the event. If the event is a point in time, the start and end will be the same date and time.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.logged_by","title":"<code>logged_by: List[trestle.oscal.common.LoggedBy]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.related_responses","title":"<code>related_responses: List[trestle.oscal.common.RelatedResponse]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.start","title":"<code>start: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Identifies the start date and time of the event.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.status_change","title":"<code>status_change: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this risk log entry.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk log entry elsewhere in this or other OSCAL instances. The locally defined UUID of the risk log entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Entry1.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding","title":"<code> Finding            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes an individual finding.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Finding(OscalBaseModel):\n\"\"\"\n    Describes an individual finding.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this finding in this or other OSCAL instances. The locally defined UUID of the finding can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Finding Universally Unique Identifier',\n    )\n    title: str = Field(..., description='The title for this finding.', title='Finding Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this finding.',\n        title='Finding Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    origins: Optional[List[Origin]] = Field(None)\n    target: FindingTarget\n    implementation_statement_uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        alias='implementation-statement-uuid',\n        description=\n        'A machine-oriented identifier reference to the implementation statement in the SSP to which this finding is related.',\n        title='Implementation Statement UUID',\n    )\n    related_observations: Optional[List[RelatedObservation]] = Field(None, alias='related-observations')\n    related_risks: Optional[List[common.RelatedRisk]] = Field(None, alias='related-risks')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this finding.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.implementation_statement_uuid","title":"<code>implementation_statement_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented identifier reference to the implementation statement in the SSP to which this finding is related.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.origins","title":"<code>origins: List[trestle.oscal.assessment_results.Origin]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.related_observations","title":"<code>related_observations: List[trestle.oscal.assessment_results.RelatedObservation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.related_risks","title":"<code>related_risks: List[trestle.oscal.common.RelatedRisk]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.target","title":"<code>target: FindingTarget</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title for this finding.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this finding in this or other OSCAL instances. The locally defined UUID of the finding can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Finding.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget","title":"<code> FindingTarget            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Captures an assessor's conclusions regarding the degree to which an objective is satisfied.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class FindingTarget(OscalBaseModel):\n\"\"\"\n    Captures an assessor's conclusions regarding the degree to which an objective is satisfied.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    type: common.Type1 = Field(\n        ...,\n        description='Identifies the type of the target.',\n        title='Finding Target Type',\n    )\n    target_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='target-id',\n        description='A machine-oriented identifier reference for a specific target qualified by the type.',\n        title='Finding Target Identifier Reference',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='The title for this objective status.',\n        title='Objective Status Title',\n    )\n    description: Optional[str] = Field(\n        None,\n        description=\n        \"A human-readable description of the assessor's conclusions regarding the degree to which an objective is satisfied.\",\n        title='Objective Status Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    status: Status = Field(\n        ...,\n        description='A determination of if the objective is satisfied or not within a given system.',\n        title='Objective Status',\n    )\n    implementation_status: Optional[common.ImplementationStatus] = Field(None, alias='implementation-status')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of the assessor's conclusions regarding the degree to which an objective is satisfied.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.implementation_status","title":"<code>implementation_status: ImplementationStatus</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.status","title":"<code>status: Status</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A determination of if the objective is satisfied or not within a given system.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.target_id","title":"<code>target_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference for a specific target qualified by the type.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this objective status.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.type","title":"<code>type: Type1</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Identifies the type of the target.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.FindingTarget.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ImportAp","title":"<code> ImportAp            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used by assessment-results to import information about the original plan for assessing the system.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class ImportAp(OscalBaseModel):\n\"\"\"\n    Used by assessment-results to import information about the original plan for assessing the system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    href: str = Field(\n        ...,\n        description='A resolvable URL reference to the assessment plan governing the assessment activities.',\n        title='Assessment Plan Reference',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ImportAp-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ImportAp.href","title":"<code>href: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A resolvable URL reference to the assessment plan governing the assessment activities.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ImportAp.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ImportAp.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions","title":"<code> LocalDefinitions            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class LocalDefinitions(OscalBaseModel):\n\"\"\"\n    Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    objectives_and_methods: Optional[List[common.LocalObjective]] = Field(None, alias='objectives-and-methods')\n    activities: Optional[List[Activity]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions.activities","title":"<code>activities: List[trestle.oscal.assessment_results.Activity]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions.objectives_and_methods","title":"<code>objectives_and_methods: List[trestle.oscal.common.LocalObjective]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions1","title":"<code> LocalDefinitions1            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class LocalDefinitions1(OscalBaseModel):\n\"\"\"\n    Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    components: Optional[List[SystemComponent]] = Field(None)\n    inventory_items: Optional[List[common.InventoryItem]] = Field(None, alias='inventory-items')\n    users: Optional[List[common.SystemUser]] = Field(None)\n    assessment_assets: Optional[AssessmentAssets] = Field(None, alias='assessment-assets')\n    tasks: Optional[List[common.Task]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions1.assessment_assets","title":"<code>assessment_assets: AssessmentAssets</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions1.components","title":"<code>components: List[trestle.oscal.assessment_results.SystemComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions1.inventory_items","title":"<code>inventory_items: List[trestle.oscal.common.InventoryItem]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions1.tasks","title":"<code>tasks: List[trestle.oscal.common.Task]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions1.users","title":"<code>users: List[trestle.oscal.common.SystemUser]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.LocalDefinitions1.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Method","title":"<code> Method            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Method(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='Identifies how the observation was made.',\n        title='Observation Method',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Method-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Method.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Identifies how the observation was made.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Model","title":"<code> Model            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Model(OscalBaseModel):\n    assessment_results: AssessmentResults = Field(..., alias='assessment-results')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Model.assessment_results","title":"<code>assessment_results: AssessmentResults</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation","title":"<code> Observation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes an individual observation.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Observation(OscalBaseModel):\n\"\"\"\n    Describes an individual observation.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this observation elsewhere in this or other OSCAL instances. The locally defined UUID of the observation can be used to reference the data item locally or globally (e.g., in an imorted OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Observation Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this observation.', title='Observation Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this assessment observation.',\n        title='Observation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    methods: List[Method] = Field(...)\n    types: Optional[List[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )]] = Field(None)\n    origins: Optional[List[Origin]] = Field(None)\n    subjects: Optional[List[common.SubjectReference]] = Field(None)\n    relevant_evidence: Optional[List[common.RelevantEvidence]] = Field(None, alias='relevant-evidence')\n    collected: datetime = Field(\n        ...,\n        description='Date/time stamp identifying when the finding information was collected.',\n        title='Collected Field',\n    )\n    expires: Optional[datetime] = Field(\n        None,\n        description=\n        'Date/time identifying when the finding information is out-of-date and no longer valid. Typically used with continuous assessment scenarios.',\n        title='Expires Field',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.collected","title":"<code>collected: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Date/time stamp identifying when the finding information was collected.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this assessment observation.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.expires","title":"<code>expires: datetime</code>  <code>pydantic-field</code>","text":"<p>Date/time identifying when the finding information is out-of-date and no longer valid. Typically used with continuous assessment scenarios.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.methods","title":"<code>methods: List[trestle.oscal.assessment_results.Method]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.origins","title":"<code>origins: List[trestle.oscal.assessment_results.Origin]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.relevant_evidence","title":"<code>relevant_evidence: List[trestle.oscal.common.RelevantEvidence]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.subjects","title":"<code>subjects: List[trestle.oscal.common.SubjectReference]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this observation.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.types","title":"<code>types: List[trestle.oscal.assessment_results.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this observation elsewhere in this or other OSCAL instances. The locally defined UUID of the observation can be used to reference the data item locally or globally (e.g., in an imorted OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Observation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Origin","title":"<code> Origin            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the source of the finding, such as a tool, interviewed person, or activity.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Origin(OscalBaseModel):\n\"\"\"\n    Identifies the source of the finding, such as a tool, interviewed person, or activity.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    actors: List[common.OriginActor] = Field(...)\n    related_tasks: Optional[List[common.RelatedTask]] = Field(None, alias='related-tasks')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Origin.actors","title":"<code>actors: List[trestle.oscal.common.OriginActor]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Origin.related_tasks","title":"<code>related_tasks: List[trestle.oscal.common.RelatedTask]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Origin.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.RelatedObservation","title":"<code> RelatedObservation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Relates the finding to a set of referenced observations that were used to determine the finding.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class RelatedObservation(OscalBaseModel):\n\"\"\"\n    Relates the finding to a set of referenced observations that were used to determine the finding.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    observation_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='observation-uuid',\n        description='A machine-oriented identifier reference to an observation defined in the list of observations.',\n        title='Observation Universally Unique Identifier Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.RelatedObservation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.RelatedObservation.observation_uuid","title":"<code>observation_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to an observation defined in the list of observations.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.RelatedObservation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response","title":"<code> Response            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes either recommended or an actual plan for addressing the risk.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Response(OscalBaseModel):\n\"\"\"\n    Describes either recommended or an actual plan for addressing the risk.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this remediation elsewhere in this or other OSCAL instances. The locally defined UUID of the risk response can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Remediation Universally Unique Identifier',\n    )\n    lifecycle: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\n        'Identifies whether this is a recommendation, such as from an assessor or tool, or an actual plan accepted by the system owner.',\n        title='Remediation Intent',\n    )\n    title: str = Field(..., description='The title for this response activity.', title='Response Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this response plan.',\n        title='Response Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    origins: Optional[List[Origin]] = Field(None)\n    required_assets: Optional[List[common.RequiredAsset]] = Field(None, alias='required-assets')\n    tasks: Optional[List[common.Task]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this response plan.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.lifecycle","title":"<code>lifecycle: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Identifies whether this is a recommendation, such as from an assessor or tool, or an actual plan accepted by the system owner.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.origins","title":"<code>origins: List[trestle.oscal.assessment_results.Origin]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.required_assets","title":"<code>required_assets: List[trestle.oscal.common.RequiredAsset]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.tasks","title":"<code>tasks: List[trestle.oscal.common.Task]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title for this response activity.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this remediation elsewhere in this or other OSCAL instances. The locally defined UUID of the risk response can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Response.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result","title":"<code> Result            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used by the assessment results and POA&amp;M. In the assessment results, this identifies all of the assessment observations and findings, initial and residual risks, deviations, and disposition. In the POA&amp;M, this identifies initial and residual risks, deviations, and disposition.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Result(OscalBaseModel):\n\"\"\"\n    Used by the assessment results and POA&amp;M. In the assessment results, this identifies all of the assessment observations and findings, initial and residual risks, deviations, and disposition. In the POA&amp;M, this identifies initial and residual risks, deviations, and disposition.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this set of results in this or other OSCAL instances. The locally defined UUID of the assessment result can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Results Universally Unique Identifier',\n    )\n    title: str = Field(..., description='The title for this set of results.', title='Results Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this set of test results.',\n        title='Results Description',\n    )\n    start: datetime = Field(\n        ...,\n        description='Date/time stamp identifying the start of the evidence collection reflected in these results.',\n        title='start field',\n    )\n    end: Optional[datetime] = Field(\n        None,\n        description=\n        'Date/time stamp identifying the end of the evidence collection reflected in these results. In a continuous motoring scenario, this may contain the same value as start if appropriate.',\n        title='end field',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    local_definitions: Optional[LocalDefinitions1] = Field(\n        None,\n        alias='local-definitions',\n        description=\n        'Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.',\n        title='Local Definitions',\n    )\n    reviewed_controls: ReviewedControls = Field(..., alias='reviewed-controls')\n    attestations: Optional[List[Attestation]] = Field(None)\n    assessment_log: Optional[AssessmentLog] = Field(\n        None,\n        alias='assessment-log',\n        description='A log of all assessment-related actions taken.',\n        title='Assessment Log',\n    )\n    observations: Optional[List[Observation]] = Field(None)\n    risks: Optional[List[Risk]] = Field(None)\n    findings: Optional[List[Finding]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.assessment_log","title":"<code>assessment_log: AssessmentLog</code>  <code>pydantic-field</code>","text":"<p>A log of all assessment-related actions taken.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.attestations","title":"<code>attestations: List[trestle.oscal.assessment_results.Attestation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this set of test results.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.end","title":"<code>end: datetime</code>  <code>pydantic-field</code>","text":"<p>Date/time stamp identifying the end of the evidence collection reflected in these results. In a continuous motoring scenario, this may contain the same value as start if appropriate.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.findings","title":"<code>findings: List[trestle.oscal.assessment_results.Finding]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.local_definitions","title":"<code>local_definitions: LocalDefinitions1</code>  <code>pydantic-field</code>","text":"<p>Used to define data objects that are used in the assessment plan, that do not appear in the referenced SSP.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.observations","title":"<code>observations: List[trestle.oscal.assessment_results.Observation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.reviewed_controls","title":"<code>reviewed_controls: ReviewedControls</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.risks","title":"<code>risks: List[trestle.oscal.assessment_results.Risk]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.start","title":"<code>start: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Date/time stamp identifying the start of the evidence collection reflected in these results.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title for this set of results.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this set of results in this or other OSCAL instances. The locally defined UUID of the assessment result can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Result.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ReviewedControls","title":"<code> ReviewedControls            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the controls being assessed and their control objectives.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class ReviewedControls(OscalBaseModel):\n\"\"\"\n    Identifies the controls being assessed and their control objectives.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of control objectives.',\n        title='Control Objective Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    control_selections: List[ControlSelection] = Field(..., alias='control-selections')\n    control_objective_selections: Optional[List[common.ControlObjectiveSelection]] = Field(\n        None, alias='control-objective-selections'\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ReviewedControls-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ReviewedControls.control_objective_selections","title":"<code>control_objective_selections: List[trestle.oscal.common.ControlObjectiveSelection]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ReviewedControls.control_selections","title":"<code>control_selections: List[trestle.oscal.assessment_results.ControlSelection]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ReviewedControls.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of control objectives.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ReviewedControls.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ReviewedControls.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ReviewedControls.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.ReviewedControls.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk","title":"<code> Risk            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>An identified risk.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Risk(OscalBaseModel):\n\"\"\"\n    An identified risk.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk elsewhere in this or other OSCAL instances. The locally defined UUID of the risk can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Risk Universally Unique Identifier',\n    )\n    title: str = Field(..., description='The title for this risk.', title='Risk Title')\n    description: str = Field(\n        ...,\n        description=\n        'A human-readable summary of the identified risk, to include a statement of how the risk impacts the system.',\n        title='Risk Description',\n    )\n    statement: str = Field(\n        ...,\n        description='An summary of impact for how the risk affects the system.',\n        title='Risk Statement',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    status: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )\n    origins: Optional[List[Origin]] = Field(None)\n    threat_ids: Optional[List[common.ThreatId]] = Field(None, alias='threat-ids')\n    characterizations: Optional[List[Characterization]] = Field(None)\n    mitigating_factors: Optional[List[common.MitigatingFactor]] = Field(None, alias='mitigating-factors')\n    deadline: Optional[datetime] = Field(\n        None,\n        description='The date/time by which the risk must be resolved.',\n        title='Risk Resolution Deadline',\n    )\n    remediations: Optional[List[Response]] = Field(None)\n    risk_log: Optional[RiskLog] = Field(\n        None,\n        alias='risk-log',\n        description='A log of all risk-related tasks taken.',\n        title='Risk Log',\n    )\n    related_observations: Optional[List[RelatedObservation]] = Field(None, alias='related-observations')\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.characterizations","title":"<code>characterizations: List[trestle.oscal.assessment_results.Characterization]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.deadline","title":"<code>deadline: datetime</code>  <code>pydantic-field</code>","text":"<p>The date/time by which the risk must be resolved.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable summary of the identified risk, to include a statement of how the risk impacts the system.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.mitigating_factors","title":"<code>mitigating_factors: List[trestle.oscal.common.MitigatingFactor]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.origins","title":"<code>origins: List[trestle.oscal.assessment_results.Origin]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.related_observations","title":"<code>related_observations: List[trestle.oscal.assessment_results.RelatedObservation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.remediations","title":"<code>remediations: List[trestle.oscal.assessment_results.Response]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.risk_log","title":"<code>risk_log: RiskLog</code>  <code>pydantic-field</code>","text":"<p>A log of all risk-related tasks taken.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.statement","title":"<code>statement: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An summary of impact for how the risk affects the system.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.status","title":"<code>status: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.threat_ids","title":"<code>threat_ids: List[trestle.oscal.common.ThreatId]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title for this risk.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk elsewhere in this or other OSCAL instances. The locally defined UUID of the risk can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Risk.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.RiskLog","title":"<code> RiskLog            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A log of all risk-related tasks taken.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class RiskLog(OscalBaseModel):\n\"\"\"\n    A log of all risk-related tasks taken.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    entries: List[Entry1] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.RiskLog.entries","title":"<code>entries: List[trestle.oscal.assessment_results.Entry1]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.RiskLog.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SelectControlById","title":"<code> SelectControlById            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to select a control for inclusion/exclusion based on one or more control identifiers. A set of statement identifiers can be used to target the inclusion/exclusion to only specific control statements providing more granularity over the specific statements that are within the asessment scope.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class SelectControlById(OscalBaseModel):\n\"\"\"\n    Used to select a control for inclusion/exclusion based on one or more control identifiers. A set of statement identifiers can be used to target the inclusion/exclusion to only specific control statements providing more granularity over the specific statements that are within the asessment scope.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    control_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='control-id',\n        description=\n        'A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).',\n        title='Control Identifier Reference',\n    )\n    statement_ids: Optional[List[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )]] = Field(\n        None, alias='statement-ids'\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SelectControlById-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SelectControlById.control_id","title":"<code>control_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SelectControlById.statement_ids","title":"<code>statement_ids: List[trestle.oscal.assessment_results.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SelectControlById.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.State","title":"<code> State            (Enum)         </code>","text":"<p>An indication as to whether the objective is satisfied or not.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class State(Enum):\n\"\"\"\n    An indication as to whether the objective is satisfied or not.\n    \"\"\"\n\n    satisfied = 'satisfied'\n    not_satisfied = 'not-satisfied'\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.State.not_satisfied","title":"<code>not_satisfied</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.State.satisfied","title":"<code>satisfied</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.State1","title":"<code> State1            (Enum)         </code>","text":"<p>The operational status.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class State1(Enum):\n\"\"\"\n    The operational status.\n    \"\"\"\n\n    under_development = 'under-development'\n    operational = 'operational'\n    disposition = 'disposition'\n    other = 'other'\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.State1.disposition","title":"<code>disposition</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.State1.operational","title":"<code>operational</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.State1.other","title":"<code>other</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.State1.under_development","title":"<code>under_development</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status","title":"<code> Status            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A determination of if the objective is satisfied or not within a given system.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Status(OscalBaseModel):\n\"\"\"\n    A determination of if the objective is satisfied or not within a given system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: State = Field(\n        ...,\n        description='An indication as to whether the objective is satisfied or not.',\n        title='Objective Status State',\n    )\n    reason: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        description=\"The reason the objective was given it's status.\",\n        title='Objective Status Reason',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status.reason","title":"<code>reason: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>The reason the objective was given it's status.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status.state","title":"<code>state: State</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An indication as to whether the objective is satisfied or not.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status1","title":"<code> Status1            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes the operational status of the system component.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Status1(OscalBaseModel):\n\"\"\"\n    Describes the operational status of the system component.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: State1 = Field(..., description='The operational status.', title='State')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status1-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status1.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status1.state","title":"<code>state: State1</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The operational status.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Status1.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step","title":"<code> Step            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an individual step in a series of steps related to an activity, such as an assessment test or examination procedure.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Step(OscalBaseModel):\n\"\"\"\n    Identifies an individual step in a series of steps related to an activity, such as an assessment test or examination procedure.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this step elsewhere in this or other OSCAL instances. The locally defined UUID of the step (in a series of steps) can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Step Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this step.', title='Step Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this step.',\n        title='Step Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    reviewed_controls: Optional[ReviewedControls] = Field(None, alias='reviewed-controls')\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this step.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step.reviewed_controls","title":"<code>reviewed_controls: ReviewedControls</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this step.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this step elsewhere in this or other OSCAL instances. The locally defined UUID of the step (in a series of steps) can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.Step.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent","title":"<code> SystemComponent            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A defined component that can be part of an implemented system.</p> Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class SystemComponent(OscalBaseModel):\n\"\"\"\n    A defined component that can be part of an implemented system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Component Identifier',\n    )\n    type: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='A category describing the purpose of the component.',\n        title='Component Type',\n    )\n    title: str = Field(\n        ...,\n        description='A human readable name for the system component.',\n        title='Component Title',\n    )\n    description: str = Field(\n        ...,\n        description='A description of the component, including information about its function.',\n        title='Component Description',\n    )\n    purpose: Optional[str] = Field(\n        None,\n        description='A summary of the technological or business purpose of the component.',\n        title='Purpose',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    status: Status1 = Field(\n        ...,\n        description='Describes the operational status of the system component.',\n        title='Status',\n    )\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    protocols: Optional[List[common.Protocol]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of the component, including information about its function.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.protocols","title":"<code>protocols: List[trestle.oscal.common.Protocol]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.purpose","title":"<code>purpose: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the technological or business purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.status","title":"<code>status: Status1</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Describes the operational status of the system component.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human readable name for the system component.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A category describing the purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.assessment_results/#trestle.oscal.assessment_results.SystemComponent.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/assessment_results.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.catalog/","title":"catalog","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog","title":"<code>trestle.oscal.catalog</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog-classes","title":"Classes","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Catalog","title":"<code> Catalog            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A collection of controls.</p> Source code in <code>trestle/oscal/catalog.py</code> <pre><code>class Catalog(OscalBaseModel):\n\"\"\"\n    A collection of controls.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A globally unique identifier with cross-instance scope for this catalog instance. This UUID should be changed when this document is revised.',\n        title='Catalog Universally Unique Identifier',\n    )\n    metadata: common.Metadata\n    params: Optional[List[common.Parameter]] = Field(None)\n    controls: Optional[List[Control]] = Field(None)\n    groups: Optional[List[Group]] = Field(None)\n    back_matter: Optional[common.BackMatter] = Field(None, alias='back-matter')\n</code></pre>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Catalog-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Catalog.back_matter","title":"<code>back_matter: BackMatter</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Catalog.controls","title":"<code>controls: List[trestle.oscal.catalog.Control]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Catalog.groups","title":"<code>groups: List[trestle.oscal.catalog.Group]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Catalog.metadata","title":"<code>metadata: Metadata</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Catalog.params","title":"<code>params: List[trestle.oscal.common.Parameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Catalog.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A globally unique identifier with cross-instance scope for this catalog instance. This UUID should be changed when this document is revised.</p>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Catalog.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/catalog.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control","title":"<code> Control            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A structured information object representing a security or privacy control. Each security or privacy control within the Catalog is defined by a distinct control instance.</p> Source code in <code>trestle/oscal/catalog.py</code> <pre><code>class Control(OscalBaseModel):\n\"\"\"\n    A structured information object representing a security or privacy control. Each security or privacy control within the Catalog is defined by a distinct control instance.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\n        'A human-oriented, locally unique identifier with instance scope that can be used to reference this control elsewhere in this and other OSCAL instances (e.g., profiles). This id should be assigned per-subject, which means it should be consistently used to identify the same control across revisions of the document.',\n        title='Control Identifier',\n    )\n    class_: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='class',\n        description='A textual label that provides a sub-type or characterization of the control.',\n        title='Control Class',\n    )\n    title: str = Field(\n        ...,\n        description='A name given to the control, which may be used by a tool for display and navigation.',\n        title='Control Title',\n    )\n    params: Optional[List[common.Parameter]] = Field(None)\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    parts: Optional[List[common.Part]] = Field(None)\n    controls: Optional[List[Control]] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control.class_","title":"<code>class_: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A textual label that provides a sub-type or characterization of the control.</p>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control.controls","title":"<code>controls: List[trestle.oscal.catalog.Control]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control.id","title":"<code>id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented, locally unique identifier with instance scope that can be used to reference this control elsewhere in this and other OSCAL instances (e.g., profiles). This id should be assigned per-subject, which means it should be consistently used to identify the same control across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control.params","title":"<code>params: List[trestle.oscal.common.Parameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control.parts","title":"<code>parts: List[trestle.oscal.common.Part]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A name given to the control, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Control.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/catalog.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group","title":"<code> Group            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A group of controls, or of groups of controls.</p> Source code in <code>trestle/oscal/catalog.py</code> <pre><code>class Group(OscalBaseModel):\n\"\"\"\n    A group of controls, or of groups of controls.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    id: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        description=\n        'A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined group elsewhere in in this and other OSCAL instances (e.g., profiles). This id should be assigned per-subject, which means it should be consistently used to identify the same group across revisions of the document.',\n        title='Group Identifier',\n    )\n    class_: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='class',\n        description='A textual label that provides a sub-type or characterization of the group.',\n        title='Group Class',\n    )\n    title: str = Field(\n        ...,\n        description='A name given to the group, which may be used by a tool for display and navigation.',\n        title='Group Title',\n    )\n    params: Optional[List[common.Parameter]] = Field(None)\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    parts: Optional[List[common.Part]] = Field(None)\n    groups: Optional[List[Group]] = None\n    controls: Optional[List[Control]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.class_","title":"<code>class_: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A textual label that provides a sub-type or characterization of the group.</p>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.controls","title":"<code>controls: List[trestle.oscal.catalog.Control]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.groups","title":"<code>groups: List[trestle.oscal.catalog.Group]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.id","title":"<code>id: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined group elsewhere in in this and other OSCAL instances (e.g., profiles). This id should be assigned per-subject, which means it should be consistently used to identify the same group across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.params","title":"<code>params: List[trestle.oscal.common.Parameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.parts","title":"<code>parts: List[trestle.oscal.common.Part]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A name given to the group, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Group.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/catalog.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Model","title":"<code> Model            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/catalog.py</code> <pre><code>class Model(OscalBaseModel):\n    catalog: Catalog\n</code></pre>"},{"location":"api_reference/trestle.oscal.catalog/#trestle.oscal.catalog.Model.catalog","title":"<code>catalog: Catalog</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/","title":"common","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common","title":"<code>trestle.oscal.common</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common-classes","title":"Classes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AddrLine","title":"<code> AddrLine            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class AddrLine(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$'\n                     ) = Field(..., description='A single line of an address.', title='Address line')\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AddrLine-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AddrLine.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>A single line of an address.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Address","title":"<code> Address            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A postal address for the location.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Address(OscalBaseModel):\n\"\"\"\n    A postal address for the location.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    type: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None, description='Indicates the type of address.', title='Address Type'\n    )\n    addr_lines: Optional[List[constr(regex=r'^\\S(.*\\S)?$')]] = Field(None, alias='addr-lines')\n    city: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        description='City, town or geographical region for the mailing address.',\n        title='City',\n    )\n    state: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        description='State, province or analogous geographical region for mailing address',\n        title='State',\n    )\n    postal_code: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        alias='postal-code',\n        description='Postal or ZIP code for mailing address',\n        title='Postal Code',\n    )\n    country: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        description='The ISO 3166-1 alpha-2 country code for the mailing address.',\n        title='Country Code',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Address-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Address.addr_lines","title":"<code>addr_lines: List[trestle.oscal.common.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Address.city","title":"<code>city: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>City, town or geographical region for the mailing address.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Address.country","title":"<code>country: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>The ISO 3166-1 alpha-2 country code for the mailing address.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Address.postal_code","title":"<code>postal_code: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Postal or ZIP code for mailing address</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Address.state","title":"<code>state: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>State, province or analogous geographical region for mailing address</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Address.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Indicates the type of address.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Address.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart","title":"<code> AssessmentPart            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A partition of an assessment plan or results or a child of another part.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class AssessmentPart(OscalBaseModel):\n\"\"\"\n    A partition of an assessment plan or results or a child of another part.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this part elsewhere in this or other OSCAL instances. The locally defined UUID of the part can be used to reference the data item locally or globally (e.g., in an ported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Part Identifier',\n    )\n    name: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\"A textual label that uniquely identifies the part's semantic type.\",\n        title='Part Name',\n    )\n    ns: Optional[AnyUrl] = Field(\n        None,\n        description=\n        \"A namespace qualifying the part's name. This allows different organizations to associate distinct semantics with the same name.\",\n        title='Part Namespace',\n    )\n    class_: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='class',\n        description=\n        \"A textual label that provides a sub-type or characterization of the part's name. This can be used to further distinguish or discriminate between the semantics of multiple parts of the same control with the same name and ns.\",\n        title='Part Class',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='A name given to the part, which may be used by a tool for display and navigation.',\n        title='Part Title',\n    )\n    props: Optional[List[Property]] = Field(None)\n    prose: Optional[str] = Field(\n        None,\n        description='Permits multiple paragraphs, lists, tables etc.',\n        title='Part Text',\n    )\n    parts: Optional[List[AssessmentPart]] = None\n    links: Optional[List[Link]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.class_","title":"<code>class_: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A textual label that provides a sub-type or characterization of the part's name. This can be used to further distinguish or discriminate between the semantics of multiple parts of the same control with the same name and ns.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.name","title":"<code>name: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A textual label that uniquely identifies the part's semantic type.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.ns","title":"<code>ns: AnyUrl</code>  <code>pydantic-field</code>","text":"<p>A namespace qualifying the part's name. This allows different organizations to associate distinct semantics with the same name.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.parts","title":"<code>parts: List[trestle.oscal.common.AssessmentPart]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.prose","title":"<code>prose: str</code>  <code>pydantic-field</code>","text":"<p>Permits multiple paragraphs, lists, tables etc.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>A name given to the part, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this part elsewhere in this or other OSCAL instances. The locally defined UUID of the part can be used to reference the data item locally or globally (e.g., in an ported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPart.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPlatform","title":"<code> AssessmentPlatform            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to represent the toolset used to perform aspects of the assessment.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class AssessmentPlatform(OscalBaseModel):\n\"\"\"\n    Used to represent the toolset used to perform aspects of the assessment.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment platform elsewhere in this or other OSCAL instances. The locally defined UUID of the assessment platform can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Assessment Platform Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='The title or name for the assessment platform.',\n        title='Assessment Platform Title',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    uses_components: Optional[List[UsesComponent]] = Field(None, alias='uses-components')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPlatform-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPlatform.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPlatform.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPlatform.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPlatform.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title or name for the assessment platform.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPlatform.uses_components","title":"<code>uses_components: List[trestle.oscal.common.UsesComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPlatform.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment platform elsewhere in this or other OSCAL instances. The locally defined UUID of the assessment platform can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentPlatform.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject","title":"<code> AssessmentSubject            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies system elements being assessed, such as components, inventory items, and locations. In the assessment plan, this identifies a planned assessment subject. In the assessment results this is an actual assessment subject, and reflects any changes from the plan. exactly what will be the focus of this assessment. Any subjects not identified in this way are out-of-scope.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class AssessmentSubject(OscalBaseModel):\n\"\"\"\n    Identifies system elements being assessed, such as components, inventory items, and locations. In the assessment plan, this identifies a planned assessment subject. In the assessment results this is an actual assessment subject, and reflects any changes from the plan. exactly what will be the focus of this assessment. Any subjects not identified in this way are out-of-scope.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    type: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\n        'Indicates the type of assessment subject, such as a component, inventory, item, location, or party represented by this selection statement.',\n        title='Subject Type',\n    )\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of the collection of subjects being included in this assessment.',\n        title='Include Subjects Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    include_all: Optional[IncludeAll] = Field(None, alias='include-all')\n    include_subjects: Optional[List[SelectSubjectById]] = Field(None, alias='include-subjects')\n    exclude_subjects: Optional[List[SelectSubjectById]] = Field(None, alias='exclude-subjects')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of the collection of subjects being included in this assessment.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject.exclude_subjects","title":"<code>exclude_subjects: List[trestle.oscal.common.SelectSubjectById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject.include_all","title":"<code>include_all: IncludeAll</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject.include_subjects","title":"<code>include_subjects: List[trestle.oscal.common.SelectSubjectById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Indicates the type of assessment subject, such as a component, inventory, item, location, or party represented by this selection statement.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubject.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubjectPlaceholder","title":"<code> AssessmentSubjectPlaceholder            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used when the assessment subjects will be determined as part of one or more other assessment activities. These assessment subjects will be recorded in the assessment results in the assessment log.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class AssessmentSubjectPlaceholder(OscalBaseModel):\n\"\"\"\n    Used when the assessment subjects will be determined as part of one or more other assessment activities. These assessment subjects will be recorded in the assessment results in the assessment log.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier for a set of assessment subjects that will be identified by a task or an activity that is part of a task. The locally defined UUID of the assessment subject placeholder can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Assessment Subject Placeholder Universally Unique Identifier',\n    )\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of intent of this assessment subject placeholder.',\n        title='Assessment Subject Placeholder Description',\n    )\n    sources: List[Source] = Field(...)\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubjectPlaceholder-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubjectPlaceholder.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of intent of this assessment subject placeholder.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubjectPlaceholder.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubjectPlaceholder.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubjectPlaceholder.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubjectPlaceholder.sources","title":"<code>sources: List[trestle.oscal.common.Source]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubjectPlaceholder.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier for a set of assessment subjects that will be identified by a task or an activity that is part of a task. The locally defined UUID of the assessment subject placeholder can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssessmentSubjectPlaceholder.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssociatedActivity","title":"<code> AssociatedActivity            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an individual activity to be performed as part of a task.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class AssociatedActivity(OscalBaseModel):\n\"\"\"\n    Identifies an individual activity to be performed as part of a task.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    activity_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='activity-uuid',\n        description='A machine-oriented identifier reference to an activity defined in the list of activities.',\n        title='Activity Universally Unique Identifier Reference',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    responsible_roles: Optional[List[ResponsibleRole]] = Field(None, alias='responsible-roles')\n    subjects: List[AssessmentSubject] = Field(...)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssociatedActivity-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssociatedActivity.activity_uuid","title":"<code>activity_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to an activity defined in the list of activities.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssociatedActivity.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssociatedActivity.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssociatedActivity.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssociatedActivity.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssociatedActivity.subjects","title":"<code>subjects: List[trestle.oscal.common.AssessmentSubject]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AssociatedActivity.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AtFrequency","title":"<code> AtFrequency            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The task is intended to occur at the specified frequency.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class AtFrequency(OscalBaseModel):\n\"\"\"\n    The task is intended to occur at the specified frequency.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    period: conint(\n        ge=1, multiple_of=1\n    ) = Field(\n        ...,\n        description='The task must occur after the specified period has elapsed.',\n        title='Period',\n    )\n    unit: Unit = Field(..., description='The unit of time for the period.', title='Time Unit')\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AtFrequency-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AtFrequency.period","title":"<code>period: ConstrainedIntValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The task must occur after the specified period has elapsed.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AtFrequency.unit","title":"<code>unit: Unit</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The unit of time for the period.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AtFrequency.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AuthorizedPrivilege","title":"<code> AuthorizedPrivilege            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies a specific system privilege held by the user, along with an associated description and/or rationale for the privilege.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class AuthorizedPrivilege(OscalBaseModel):\n\"\"\"\n    Identifies a specific system privilege held by the user, along with an associated description and/or rationale for the privilege.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    title: str = Field(\n        ...,\n        description='A human readable name for the privilege.',\n        title='Privilege Title',\n    )\n    description: Optional[str] = Field(\n        None,\n        description=\"A summary of the privilege's purpose within the system.\",\n        title='Privilege Description',\n    )\n    functions_performed: List[constr(regex=r'^\\S(.*\\S)?$')] = Field(..., alias='functions-performed')\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AuthorizedPrivilege-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AuthorizedPrivilege.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the privilege's purpose within the system.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AuthorizedPrivilege.functions_performed","title":"<code>functions_performed: List[trestle.oscal.common.ConstrainedStrValue]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AuthorizedPrivilege.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human readable name for the privilege.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.AuthorizedPrivilege.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.BackMatter","title":"<code> BackMatter            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A collection of resources, which may be included directly or by reference.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class BackMatter(OscalBaseModel):\n\"\"\"\n    A collection of resources, which may be included directly or by reference.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    resources: Optional[List[Resource]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.BackMatter.resources","title":"<code>resources: List[trestle.oscal.common.Resource]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.BackMatter.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Base64","title":"<code> Base64            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The Base64 alphabet in RFC 2045 - aligned with XSD.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Base64(OscalBaseModel):\n\"\"\"\n    The Base64 alphabet in RFC 2045 - aligned with XSD.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    filename: Optional[str] = Field(\n        None,\n        description=\n        'Name of the file before it was encoded as Base64 to be embedded in a resource. This is the name that will be assigned to the file when the file is decoded.',\n        title='File Name',\n    )\n    media_type: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        alias='media-type',\n        description=\n        'Specifies a media type as defined by the Internet Assigned Numbers Authority (IANA) Media Types Registry.',\n        title='Media Type',\n    )\n    value: str\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Base64-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Base64.filename","title":"<code>filename: str</code>  <code>pydantic-field</code>","text":"<p>Name of the file before it was encoded as Base64 to be embedded in a resource. This is the name that will be assigned to the file when the file is decoded.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Base64.media_type","title":"<code>media_type: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Specifies a media type as defined by the Internet Assigned Numbers Authority (IANA) Media Types Registry.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Base64.value","title":"<code>value: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Base64.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Citation","title":"<code> Citation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A citation consisting of end note text and optional structured bibliographic data.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Citation(OscalBaseModel):\n\"\"\"\n    A citation consisting of end note text and optional structured bibliographic data.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    text: str = Field(..., description='A line of citation text.', title='Citation Text')\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Citation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Citation.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Citation.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Citation.text","title":"<code>text: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A line of citation text.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Citation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection","title":"<code> ControlObjectiveSelection            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the control objectives of the assessment. In the assessment plan, these are the planned objectives. In the assessment results, these are the assessed objectives, and reflects any changes from the plan.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ControlObjectiveSelection(OscalBaseModel):\n\"\"\"\n    Identifies the control objectives of the assessment. In the assessment plan, these are the planned objectives. In the assessment results, these are the assessed objectives, and reflects any changes from the plan.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of this collection of control objectives.',\n        title='Control Objectives Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    include_all: Optional[IncludeAll] = Field(None, alias='include-all')\n    include_objectives: Optional[List[SelectObjectiveById]] = Field(None, alias='include-objectives')\n    exclude_objectives: Optional[List[SelectObjectiveById]] = Field(None, alias='exclude-objectives')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of this collection of control objectives.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection.exclude_objectives","title":"<code>exclude_objectives: List[trestle.oscal.common.SelectObjectiveById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection.include_all","title":"<code>include_all: IncludeAll</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection.include_objectives","title":"<code>include_objectives: List[trestle.oscal.common.SelectObjectiveById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ControlObjectiveSelection.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Dependency","title":"<code> Dependency            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to indicate that a task is dependent on another task.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Dependency(OscalBaseModel):\n\"\"\"\n    Used to indicate that a task is dependent on another task.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    task_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='task-uuid',\n        description='A machine-oriented identifier reference to a unique task.',\n        title='Task Universally Unique Identifier Reference',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Dependency-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Dependency.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Dependency.task_uuid","title":"<code>task_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a unique task.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Dependency.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.DocumentId","title":"<code> DocumentId            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A document identifier qualified by an identifier scheme. A document identifier provides a globally unique identifier with a cross-instance scope that is used for a group of documents that are to be treated as different versions of the same document. If this element does not appear, or if the value of this element is empty, the value of \"document-id\" is equal to the value of the \"uuid\" flag of the top-level root element.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class DocumentId(OscalBaseModel):\n\"\"\"\n    A document identifier qualified by an identifier scheme. A document identifier provides a globally unique identifier with a cross-instance scope that is used for a group of documents that are to be treated as different versions of the same document. If this element does not appear, or if the value of this element is empty, the value of \"document-id\" is equal to the value of the \"uuid\" flag of the top-level root element.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    scheme: Optional[AnyUrl] = Field(\n        None,\n        description=\n        'Qualifies the kind of document identifier using a URI. If the scheme is not provided the value of the element will be interpreted as a string of characters.',\n        title='Document Identification Scheme',\n    )\n    identifier: str\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.DocumentId-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.DocumentId.identifier","title":"<code>identifier: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.DocumentId.scheme","title":"<code>scheme: AnyUrl</code>  <code>pydantic-field</code>","text":"<p>Qualifies the kind of document identifier using a URI. If the scheme is not provided the value of the element will be interpreted as a string of characters.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.DocumentId.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.EmailAddress","title":"<code> EmailAddress            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class EmailAddress(OscalBaseModel):\n    __root__: EmailStr = Field(\n        ...,\n        description='An email address as defined by RFC 5322 Section 3.4.1.',\n        title='Email Address',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.EmailAddress-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.EmailAddress.__root__","title":"<code>__root__: EmailStr</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>An email address as defined by RFC 5322 Section 3.4.1.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ExternalId","title":"<code> ExternalId            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>An identifier for a person or organization using a designated scheme. e.g. an Open Researcher and Contributor ID (ORCID)</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ExternalId(OscalBaseModel):\n\"\"\"\n    An identifier for a person or organization using a designated scheme. e.g. an Open Researcher and Contributor ID (ORCID)\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    scheme: AnyUrl = Field(\n        ...,\n        description='Indicates the type of external identifier.',\n        title='External Identifier Schema',\n    )\n    id: str\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ExternalId-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ExternalId.id","title":"<code>id: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ExternalId.scheme","title":"<code>scheme: AnyUrl</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Indicates the type of external identifier.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ExternalId.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Facet","title":"<code> Facet            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>An individual characteristic that is part of a larger set produced by the same actor.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Facet(OscalBaseModel):\n\"\"\"\n    An individual characteristic that is part of a larger set produced by the same actor.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    name: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description='The name of the risk metric within the specified system.',\n        title='Facet Name',\n    )\n    system: AnyUrl = Field(\n        ...,\n        description=\n        'Specifies the naming system under which this risk metric is organized, which allows for the same names to be used in different systems controlled by different parties. This avoids the potential of a name clash.',\n        title='Naming System',\n    )\n    value: constr(regex=r'^\\S(.*\\S)?$'\n                  ) = Field(..., description='Indicates the value of the facet.', title='Facet Value')\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Facet-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Facet.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Facet.name","title":"<code>name: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The name of the risk metric within the specified system.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Facet.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Facet.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Facet.system","title":"<code>system: AnyUrl</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Specifies the naming system under which this risk metric is organized, which allows for the same names to be used in different systems controlled by different parties. This avoids the potential of a name clash.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Facet.value","title":"<code>value: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Indicates the value of the facet.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Facet.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.FunctionPerformed","title":"<code> FunctionPerformed            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class FunctionPerformed(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='Describes a function performed for a given authorized privilege by this user class.',\n        title='Functions Performed',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.FunctionPerformed-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.FunctionPerformed.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Describes a function performed for a given authorized privilege by this user class.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Hash","title":"<code> Hash            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A representation of a cryptographic digest generated over a resource using a specified hash algorithm.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Hash(OscalBaseModel):\n\"\"\"\n    A representation of a cryptographic digest generated over a resource using a specified hash algorithm.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    algorithm: constr(regex=r'^\\S(.*\\S)?$'\n                      ) = Field(..., description='Method by which a hash is derived', title='Hash algorithm')\n    value: str\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Hash-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Hash.algorithm","title":"<code>algorithm: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Method by which a hash is derived</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Hash.value","title":"<code>value: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Hash.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.HowMany","title":"<code> HowMany            (Enum)         </code>","text":"<p>Describes the number of selections that must occur. Without this setting, only one value should be assumed to be permitted.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class HowMany(Enum):\n\"\"\"\n    Describes the number of selections that must occur. Without this setting, only one value should be assumed to be permitted.\n    \"\"\"\n\n    one = 'one'\n    one_or_more = 'one-or-more'\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.HowMany.one","title":"<code>one</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.HowMany.one_or_more","title":"<code>one_or_more</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.IdentifiedSubject","title":"<code> IdentifiedSubject            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to detail assessment subjects that were identfied by this task.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class IdentifiedSubject(OscalBaseModel):\n\"\"\"\n    Used to detail assessment subjects that were identfied by this task.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    subject_placeholder_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='subject-placeholder-uuid',\n        description=\n        'A machine-oriented identifier reference to a unique assessment subject placeholder defined by this task.',\n        title='Assessment Subject Placeholder Universally Unique Identifier Reference',\n    )\n    subjects: List[AssessmentSubject] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.IdentifiedSubject-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.IdentifiedSubject.subject_placeholder_uuid","title":"<code>subject_placeholder_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a unique assessment subject placeholder defined by this task.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.IdentifiedSubject.subjects","title":"<code>subjects: List[trestle.oscal.common.AssessmentSubject]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.IdentifiedSubject.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementationStatus","title":"<code> ImplementationStatus            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Indicates the degree to which the a given control is implemented.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ImplementationStatus(OscalBaseModel):\n\"\"\"\n    Indicates the degree to which the a given control is implemented.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description='Identifies the implementation status of the control or control objective.',\n        title='Implementation State',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementationStatus-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementationStatus.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementationStatus.state","title":"<code>state: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Identifies the implementation status of the control or control objective.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementationStatus.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementedComponent","title":"<code> ImplementedComponent            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The set of components that are implemented in a given system inventory item.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ImplementedComponent(OscalBaseModel):\n\"\"\"\n    The set of components that are implemented in a given system inventory item.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    component_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='component-uuid',\n        description=\n        'A machine-oriented identifier reference to a component that is implemented as part of an inventory item.',\n        title='Component Universally Unique Identifier Reference',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    responsible_parties: Optional[List[ResponsibleParty]] = Field(None, alias='responsible-parties')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementedComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementedComponent.component_uuid","title":"<code>component_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a component that is implemented as part of an inventory item.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementedComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementedComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementedComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementedComponent.responsible_parties","title":"<code>responsible_parties: List[trestle.oscal.common.ResponsibleParty]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImplementedComponent.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImportSsp","title":"<code> ImportSsp            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used by the assessment plan and POA&amp;M to import information about the system.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ImportSsp(OscalBaseModel):\n\"\"\"\n    Used by the assessment plan and POA&amp;M to import information about the system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    href: str = Field(\n        ...,\n        description='A resolvable URL reference to the system security plan for the system being assessed.',\n        title='System Security Plan Reference',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImportSsp-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImportSsp.href","title":"<code>href: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A resolvable URL reference to the system security plan for the system being assessed.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImportSsp.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ImportSsp.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.IncludeAll","title":"<code> IncludeAll            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Include all controls from the imported catalog or profile resources.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class IncludeAll(OscalBaseModel):\n\"\"\"\n    Include all controls from the imported catalog or profile resources.\n    \"\"\"\n\n    pass\n\n    class Config:\n        extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.IncludeAll.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem","title":"<code> InventoryItem            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A single managed inventory item within the system.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class InventoryItem(OscalBaseModel):\n\"\"\"\n    A single managed inventory item within the system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this inventory item elsewhere in this or other OSCAL instances. The locally defined UUID of the inventory item can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Inventory Item Universally Unique Identifier',\n    )\n    description: str = Field(\n        ...,\n        description='A summary of the inventory item stating its purpose within the system.',\n        title='Inventory Item Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    responsible_parties: Optional[List[ResponsibleParty]] = Field(None, alias='responsible-parties')\n    implemented_components: Optional[List[ImplementedComponent]] = Field(None, alias='implemented-components')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A summary of the inventory item stating its purpose within the system.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem.implemented_components","title":"<code>implemented_components: List[trestle.oscal.common.ImplementedComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem.responsible_parties","title":"<code>responsible_parties: List[trestle.oscal.common.ResponsibleParty]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this inventory item elsewhere in this or other OSCAL instances. The locally defined UUID of the inventory item can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.InventoryItem.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LastModified","title":"<code> LastModified            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class LastModified(OscalBaseModel):\n    __root__: datetime = Field(\n        ...,\n        description=\n        'The date and time the document was last modified. The date-time value must be formatted according to RFC 3339 with full time and time zone included.',\n        title='Last Modified Timestamp',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LastModified-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LastModified.__root__","title":"<code>__root__: datetime</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>The date and time the document was last modified. The date-time value must be formatted according to RFC 3339 with full time and time zone included.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Link","title":"<code> Link            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A reference to a local or remote resource</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Link(OscalBaseModel):\n\"\"\"\n    A reference to a local or remote resource\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    href: str = Field(\n        ...,\n        description='A resolvable URL reference to a resource.',\n        title='Hypertext Reference',\n    )\n    rel: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        description=\n        \"Describes the type of relationship provided by the link. This can be an indicator of the link's purpose.\",\n        title='Relation',\n    )\n    media_type: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        alias='media-type',\n        description=\n        'Specifies a media type as defined by the Internet Assigned Numbers Authority (IANA) Media Types Registry.',\n        title='Media Type',\n    )\n    text: Optional[str] = Field(\n        None,\n        description='A textual label to associate with the link, which may be used for presentation in a tool.',\n        title='Link Text',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Link-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Link.href","title":"<code>href: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A resolvable URL reference to a resource.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Link.media_type","title":"<code>media_type: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Specifies a media type as defined by the Internet Assigned Numbers Authority (IANA) Media Types Registry.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Link.rel","title":"<code>rel: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Describes the type of relationship provided by the link. This can be an indicator of the link's purpose.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Link.text","title":"<code>text: str</code>  <code>pydantic-field</code>","text":"<p>A textual label to associate with the link, which may be used for presentation in a tool.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Link.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocalObjective","title":"<code> LocalObjective            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A local definition of a control objective for this assessment. Uses catalog syntax for control objective and assessment actions.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class LocalObjective(OscalBaseModel):\n\"\"\"\n    A local definition of a control objective for this assessment. Uses catalog syntax for control objective and assessment actions.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    control_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='control-id',\n        description=\n        'A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).',\n        title='Control Identifier Reference',\n    )\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of this control objective.',\n        title='Objective Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    parts: List[Part] = Field(...)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocalObjective-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocalObjective.control_id","title":"<code>control_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocalObjective.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of this control objective.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocalObjective.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocalObjective.parts","title":"<code>parts: List[trestle.oscal.common.Part]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocalObjective.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocalObjective.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocalObjective.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location","title":"<code> Location            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A location, with associated metadata that can be referenced.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Location(OscalBaseModel):\n\"\"\"\n    A location, with associated metadata that can be referenced.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this defined location elsewhere in this or other OSCAL instances. The locally defined UUID of the location can be used to reference the data item locally or globally (e.g., from an importing OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Location Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='A name given to the location, which may be used by a tool for display and navigation.',\n        title='Location Title',\n    )\n    address: Address\n    email_addresses: Optional[List[EmailStr]] = Field(None, alias='email-addresses')\n    telephone_numbers: Optional[List[TelephoneNumber]] = Field(None, alias='telephone-numbers')\n    urls: Optional[List[Url]] = Field(None)\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.address","title":"<code>address: Address</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.email_addresses","title":"<code>email_addresses: List[pydantic.networks.EmailStr]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.telephone_numbers","title":"<code>telephone_numbers: List[trestle.oscal.common.TelephoneNumber]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>A name given to the location, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.urls","title":"<code>urls: List[trestle.oscal.common.Url]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this defined location elsewhere in this or other OSCAL instances. The locally defined UUID of the location can be used to reference the data item locally or globally (e.g., from an importing OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Location.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocationUuid","title":"<code> LocationUuid            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class LocationUuid(OscalBaseModel):\n    __root__: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented identifier reference to a location defined in the metadata section of this or another OSCAL instance. The UUID of the location in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).',\n        title='Location Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocationUuid-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LocationUuid.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>A machine-oriented identifier reference to a location defined in the metadata section of this or another OSCAL instance. The UUID of the location in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LoggedBy","title":"<code> LoggedBy            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to indicate who created a log entry in what role.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class LoggedBy(OscalBaseModel):\n\"\"\"\n    Used to indicate who created a log entry in what role.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    party_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='party-uuid',\n        description='A machine-oriented identifier reference to the party who is making the log entry.',\n        title='Party UUID Reference',\n    )\n    role_id: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='role-id',\n        description='A point to the role-id of the role in which the party is making the log entry.',\n        title='Actor Role',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LoggedBy-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LoggedBy.party_uuid","title":"<code>party_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to the party who is making the log entry.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LoggedBy.role_id","title":"<code>role_id: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A point to the role-id of the role in which the party is making the log entry.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.LoggedBy.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MemberOfOrganization","title":"<code> MemberOfOrganization            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class MemberOfOrganization(OscalBaseModel):\n    __root__: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented identifier reference to another party (person or organization) that this subject is associated with. The UUID of the party in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).',\n        title='Organizational Affiliation',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MemberOfOrganization-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MemberOfOrganization.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>A machine-oriented identifier reference to another party (person or organization) that this subject is associated with. The UUID of the party in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata","title":"<code> Metadata            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Provides information about the publication and availability of the containing document.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Metadata(OscalBaseModel):\n\"\"\"\n    Provides information about the publication and availability of the containing document.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    title: str = Field(\n        ...,\n        description='A name given to the document, which may be used by a tool for display and navigation.',\n        title='Document Title',\n    )\n    published: Optional[datetime] = None\n    last_modified: datetime = Field(..., alias='last-modified')\n    version: constr(regex=r'^\\S(.*\\S)?$')\n    oscal_version: OscalVersion = Field(..., alias='oscal-version')\n    revisions: Optional[List[Revision]] = Field(None)\n    document_ids: Optional[List[DocumentId]] = Field(None, alias='document-ids')\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    roles: Optional[List[Role]] = Field(None)\n    locations: Optional[List[Location]] = Field(None)\n    parties: Optional[List[Party]] = Field(None)\n    responsible_parties: Optional[List[ResponsibleParty]] = Field(None, alias='responsible-parties')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.document_ids","title":"<code>document_ids: List[trestle.oscal.common.DocumentId]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.last_modified","title":"<code>last_modified: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.locations","title":"<code>locations: List[trestle.oscal.common.Location]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.oscal_version","title":"<code>oscal_version: OscalVersion</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.parties","title":"<code>parties: List[trestle.oscal.common.Party]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.published","title":"<code>published: datetime</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.responsible_parties","title":"<code>responsible_parties: List[trestle.oscal.common.ResponsibleParty]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.revisions","title":"<code>revisions: List[trestle.oscal.common.Revision]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.roles","title":"<code>roles: List[trestle.oscal.common.Role]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A name given to the document, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.version","title":"<code>version: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Metadata.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MitigatingFactor","title":"<code> MitigatingFactor            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes an existing mitigating factor that may affect the overall determination of the risk, with an optional link to an implementation statement in the SSP.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class MitigatingFactor(OscalBaseModel):\n\"\"\"\n    Describes an existing mitigating factor that may affect the overall determination of the risk, with an optional link to an implementation statement in the SSP.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this mitigating factor elsewhere in this or other OSCAL instances. The locally defined UUID of the mitigating factor can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Mitigating Factor Universally Unique Identifier',\n    )\n    implementation_uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        alias='implementation-uuid',\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this implementation statement elsewhere in this or other OSCAL instancess. The locally defined UUID of the implementation statement can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Implementation UUID',\n    )\n    description: str = Field(\n        ...,\n        description='A human-readable description of this mitigating factor.',\n        title='Mitigating Factor Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    subjects: Optional[List[SubjectReference]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MitigatingFactor-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MitigatingFactor.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this mitigating factor.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MitigatingFactor.implementation_uuid","title":"<code>implementation_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this implementation statement elsewhere in this or other OSCAL instancess. The locally defined UUID of the implementation statement can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MitigatingFactor.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MitigatingFactor.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MitigatingFactor.subjects","title":"<code>subjects: List[trestle.oscal.common.SubjectReference]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MitigatingFactor.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this mitigating factor elsewhere in this or other OSCAL instances. The locally defined UUID of the mitigating factor can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.MitigatingFactor.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OnDate","title":"<code> OnDate            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The task is intended to occur on the specified date.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class OnDate(OscalBaseModel):\n\"\"\"\n    The task is intended to occur on the specified date.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    date: datetime = Field(\n        ...,\n        description='The task must occur on the specified date.',\n        title='On Date Condition',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OnDate-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OnDate.date","title":"<code>date: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The task must occur on the specified date.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OnDate.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OriginActor","title":"<code> OriginActor            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The actor that produces an observation, a finding, or a risk. One or more actor type can be used to specify a person that is using a tool.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class OriginActor(OscalBaseModel):\n\"\"\"\n    The actor that produces an observation, a finding, or a risk. One or more actor type can be used to specify a person that is using a tool.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    type: Type3 = Field(..., description='The kind of actor.', title='Actor Type')\n    actor_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='actor-uuid',\n        description='A machine-oriented identifier reference to the tool or person based on the associated type.',\n        title='Actor Universally Unique Identifier Reference',\n    )\n    role_id: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='role-id',\n        description='For a party, this can optionally be used to specify the role the actor was performing.',\n        title='Actor Role',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OriginActor-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OriginActor.actor_uuid","title":"<code>actor_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to the tool or person based on the associated type.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OriginActor.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OriginActor.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OriginActor.role_id","title":"<code>role_id: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>For a party, this can optionally be used to specify the role the actor was performing.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OriginActor.type","title":"<code>type: Type3</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The kind of actor.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OriginActor.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OscalVersion","title":"<code> OscalVersion            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class OscalVersion(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='The OSCAL model version the document was authored against.',\n        title='OSCAL version',\n    )\n\n    @validator('__root__')\n    def oscal_version_is_valid(cls, v):\n        p = re.compile(OSCAL_VERSION_REGEX)\n        matched = p.match(v)\n        if matched is None:\n            raise ValueError(f'OSCAL version: {v} is not supported, use {OSCAL_VERSION} instead.')\n        return v\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OscalVersion-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OscalVersion.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>The OSCAL model version the document was authored against.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.OscalVersion.oscal_version_is_valid","title":"<code>oscal_version_is_valid(v)</code>  <code>classmethod</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>@validator('__root__')\ndef oscal_version_is_valid(cls, v):\n    p = re.compile(OSCAL_VERSION_REGEX)\n    matched = p.match(v)\n    if matched is None:\n        raise ValueError(f'OSCAL version: {v} is not supported, use {OSCAL_VERSION} instead.')\n    return v\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter","title":"<code> Parameter            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Parameters provide a mechanism for the dynamic assignment of value(s) in a control.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Parameter(OscalBaseModel):\n\"\"\"\n    Parameters provide a mechanism for the dynamic assignment of value(s) in a control.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\n        'A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined parameter elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, this identifier must be referenced in the context of the containing resource (e.g., import-profile). This id should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Parameter Identifier',\n    )\n    class_: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='class',\n        description='A textual label that provides a characterization of the parameter.',\n        title='Parameter Class',\n    )\n    depends_on: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='depends-on',\n        description=\n        '**(deprecated)** Another parameter invoking this one. This construct has been deprecated and should not be used.',\n        title='Depends on',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    label: Optional[str] = Field(\n        None,\n        description=\n        'A short, placeholder name for the parameter, which can be used as a substitute for a value if no value is assigned.',\n        title='Parameter Label',\n    )\n    usage: Optional[str] = Field(\n        None,\n        description='Describes the purpose and use of a parameter',\n        title='Parameter Usage Description',\n    )\n    constraints: Optional[List[ParameterConstraint]] = Field(None)\n    guidelines: Optional[List[ParameterGuideline]] = Field(None)\n    values: Optional[List[constr(regex=r'^\\S(.*\\S)?$')]] = Field(None)\n    select: Optional[ParameterSelection] = None\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.class_","title":"<code>class_: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A textual label that provides a characterization of the parameter.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.constraints","title":"<code>constraints: List[trestle.oscal.common.ParameterConstraint]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.depends_on","title":"<code>depends_on: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>(deprecated) Another parameter invoking this one. This construct has been deprecated and should not be used.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.guidelines","title":"<code>guidelines: List[trestle.oscal.common.ParameterGuideline]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.id","title":"<code>id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined parameter elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, this identifier must be referenced in the context of the containing resource (e.g., import-profile). This id should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.label","title":"<code>label: str</code>  <code>pydantic-field</code>","text":"<p>A short, placeholder name for the parameter, which can be used as a substitute for a value if no value is assigned.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.select","title":"<code>select: ParameterSelection</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.usage","title":"<code>usage: str</code>  <code>pydantic-field</code>","text":"<p>Describes the purpose and use of a parameter</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.values","title":"<code>values: List[trestle.oscal.common.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Parameter.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterConstraint","title":"<code> ParameterConstraint            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A formal or informal expression of a constraint or test</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ParameterConstraint(OscalBaseModel):\n\"\"\"\n    A formal or informal expression of a constraint or test\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: Optional[str] = Field(\n        None,\n        description='A textual summary of the constraint to be applied.',\n        title='Constraint Description',\n    )\n    tests: Optional[List[Test]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterConstraint-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterConstraint.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A textual summary of the constraint to be applied.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterConstraint.tests","title":"<code>tests: List[trestle.oscal.common.Test]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterConstraint.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterGuideline","title":"<code> ParameterGuideline            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A prose statement that provides a recommendation for the use of a parameter.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ParameterGuideline(OscalBaseModel):\n\"\"\"\n    A prose statement that provides a recommendation for the use of a parameter.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    prose: str = Field(\n        ...,\n        description='Prose permits multiple paragraphs, lists, tables etc.',\n        title='Guideline Text',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterGuideline-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterGuideline.prose","title":"<code>prose: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Prose permits multiple paragraphs, lists, tables etc.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterGuideline.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterSelection","title":"<code> ParameterSelection            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Presenting a choice among alternatives</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ParameterSelection(OscalBaseModel):\n\"\"\"\n    Presenting a choice among alternatives\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    how_many: Optional[HowMany] = Field(\n        None,\n        alias='how-many',\n        description=\n        'Describes the number of selections that must occur. Without this setting, only one value should be assumed to be permitted.',\n        title='Parameter Cardinality',\n    )\n    choice: Optional[List[str]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterSelection-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterSelection.choice","title":"<code>choice: List[str]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterSelection.how_many","title":"<code>how_many: HowMany</code>  <code>pydantic-field</code>","text":"<p>Describes the number of selections that must occur. Without this setting, only one value should be assumed to be permitted.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterSelection.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterValue","title":"<code> ParameterValue            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class ParameterValue(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$'\n                     ) = Field(..., description='A parameter value or set of values.', title='Parameter Value')\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterValue-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ParameterValue.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>A parameter value or set of values.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part","title":"<code> Part            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A partition of a control's definition or a child of another part.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Part(OscalBaseModel):\n\"\"\"\n    A partition of a control's definition or a child of another part.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    id: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        description=\n        'A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined part elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, this identifier must be referenced in the context of the containing resource (e.g., import-profile). This id should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Part Identifier',\n    )\n    name: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\"A textual label that uniquely identifies the part's semantic type.\",\n        title='Part Name',\n    )\n    ns: Optional[AnyUrl] = Field(\n        None,\n        description=\n        \"A namespace qualifying the part's name. This allows different organizations to associate distinct semantics with the same name.\",\n        title='Part Namespace',\n    )\n    class_: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='class',\n        description=\n        \"A textual label that provides a sub-type or characterization of the part's name. This can be used to further distinguish or discriminate between the semantics of multiple parts of the same control with the same name and ns.\",\n        title='Part Class',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='A name given to the part, which may be used by a tool for display and navigation.',\n        title='Part Title',\n    )\n    props: Optional[List[Property]] = Field(None)\n    prose: Optional[str] = Field(\n        None,\n        description='Permits multiple paragraphs, lists, tables etc.',\n        title='Part Text',\n    )\n    parts: Optional[List[Part]] = None\n    links: Optional[List[Link]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.class_","title":"<code>class_: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A textual label that provides a sub-type or characterization of the part's name. This can be used to further distinguish or discriminate between the semantics of multiple parts of the same control with the same name and ns.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.id","title":"<code>id: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined part elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, this identifier must be referenced in the context of the containing resource (e.g., import-profile). This id should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.name","title":"<code>name: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A textual label that uniquely identifies the part's semantic type.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.ns","title":"<code>ns: AnyUrl</code>  <code>pydantic-field</code>","text":"<p>A namespace qualifying the part's name. This allows different organizations to associate distinct semantics with the same name.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.parts","title":"<code>parts: List[trestle.oscal.common.Part]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.prose","title":"<code>prose: str</code>  <code>pydantic-field</code>","text":"<p>Permits multiple paragraphs, lists, tables etc.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>A name given to the part, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Part.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party","title":"<code> Party            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A responsible entity which is either a person or an organization.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Party(OscalBaseModel):\n\"\"\"\n    A responsible entity which is either a person or an organization.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this defined party elsewhere in this or other OSCAL instances. The locally defined UUID of the party can be used to reference the data item locally or globally (e.g., from an importing OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Party Universally Unique Identifier',\n    )\n    type: Type = Field(\n        ...,\n        description='A category describing the kind of party the object describes.',\n        title='Party Type',\n    )\n    name: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        description='The full name of the party. This is typically the legal name associated with the party.',\n        title='Party Name',\n    )\n    short_name: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        alias='short-name',\n        description='A short common name, abbreviation, or acronym for the party.',\n        title='Party Short Name',\n    )\n    external_ids: Optional[List[ExternalId]] = Field(None, alias='external-ids')\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    email_addresses: Optional[List[EmailStr]] = Field(None, alias='email-addresses')\n    telephone_numbers: Optional[List[TelephoneNumber]] = Field(None, alias='telephone-numbers')\n    addresses: Optional[List[Address]] = Field(None)\n    location_uuids: Optional[List[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )]] = Field(\n        None, alias='location-uuids'\n    )\n    member_of_organizations: Optional[List[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )]] = Field(\n        None, alias='member-of-organizations'\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.addresses","title":"<code>addresses: List[trestle.oscal.common.Address]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.email_addresses","title":"<code>email_addresses: List[pydantic.networks.EmailStr]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.external_ids","title":"<code>external_ids: List[trestle.oscal.common.ExternalId]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.location_uuids","title":"<code>location_uuids: List[trestle.oscal.common.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.member_of_organizations","title":"<code>member_of_organizations: List[trestle.oscal.common.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.name","title":"<code>name: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>The full name of the party. This is typically the legal name associated with the party.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.short_name","title":"<code>short_name: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A short common name, abbreviation, or acronym for the party.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.telephone_numbers","title":"<code>telephone_numbers: List[trestle.oscal.common.TelephoneNumber]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.type","title":"<code>type: Type</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A category describing the kind of party the object describes.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this defined party elsewhere in this or other OSCAL instances. The locally defined UUID of the party can be used to reference the data item locally or globally (e.g., from an importing OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Party.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.PartyUuid","title":"<code> PartyUuid            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class PartyUuid(OscalBaseModel):\n    __root__: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented identifier reference to another party defined in metadata. The UUID of the party in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).',\n        title='Party Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.PartyUuid-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.PartyUuid.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>A machine-oriented identifier reference to another party defined in metadata. The UUID of the party in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.PortRange","title":"<code> PortRange            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Where applicable this is the IPv4 port range on which the service operates.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class PortRange(OscalBaseModel):\n\"\"\"\n    Where applicable this is the IPv4 port range on which the service operates.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    start: Optional[conint(ge=0, multiple_of=1)] = Field(\n        None,\n        description='Indicates the starting port number in a port range',\n        title='Start',\n    )\n    end: Optional[conint(ge=0, multiple_of=1)] = Field(\n        None,\n        description='Indicates the ending port number in a port range',\n        title='End',\n    )\n    transport: Optional[Transport] = Field(None, description='Indicates the transport type.', title='Transport')\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.PortRange-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.PortRange.end","title":"<code>end: ConstrainedIntValue</code>  <code>pydantic-field</code>","text":"<p>Indicates the ending port number in a port range</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.PortRange.start","title":"<code>start: ConstrainedIntValue</code>  <code>pydantic-field</code>","text":"<p>Indicates the starting port number in a port range</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.PortRange.transport","title":"<code>transport: Transport</code>  <code>pydantic-field</code>","text":"<p>Indicates the transport type.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.PortRange.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Property","title":"<code> Property            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>An attribute, characteristic, or quality of the containing object expressed as a namespace qualified name/value pair. The value of a property is a simple scalar value, which may be expressed as a list of values.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Property(OscalBaseModel):\n\"\"\"\n    An attribute, characteristic, or quality of the containing object expressed as a namespace qualified name/value pair. The value of a property is a simple scalar value, which may be expressed as a list of values.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    name: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\n        \"A textual label that uniquely identifies a specific attribute, characteristic, or quality of the property's containing object.\",\n        title='Property Name',\n    )\n    uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this defined property elsewhere in this or other OSCAL instances. This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Property Universally Unique Identifier',\n    )\n    ns: Optional[AnyUrl] = Field(\n        None,\n        description=\n        \"A namespace qualifying the property's name. This allows different organizations to associate distinct semantics with the same name.\",\n        title='Property Namespace',\n    )\n    value: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='Indicates the value of the attribute, characteristic, or quality.',\n        title='Property Value',\n    )\n    class_: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='class',\n        description=\n        \"A textual label that provides a sub-type or characterization of the property's name. This can be used to further distinguish or discriminate between the semantics of multiple properties of the same object with the same name and ns.\",\n        title='Property Class',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Property-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Property.class_","title":"<code>class_: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A textual label that provides a sub-type or characterization of the property's name. This can be used to further distinguish or discriminate between the semantics of multiple properties of the same object with the same name and ns.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Property.name","title":"<code>name: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A textual label that uniquely identifies a specific attribute, characteristic, or quality of the property's containing object.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Property.ns","title":"<code>ns: AnyUrl</code>  <code>pydantic-field</code>","text":"<p>A namespace qualifying the property's name. This allows different organizations to associate distinct semantics with the same name.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Property.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Property.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this defined property elsewhere in this or other OSCAL instances. This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Property.value","title":"<code>value: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Indicates the value of the attribute, characteristic, or quality.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Property.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Protocol","title":"<code> Protocol            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Information about the protocol used to provide a service.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Protocol(OscalBaseModel):\n\"\"\"\n    Information about the protocol used to provide a service.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this service protocol information elsewhere in this or other OSCAL instances. The locally defined UUID of the service protocol can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Service Protocol Information Universally Unique Identifier',\n    )\n    name: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description=\n        'The common name of the protocol, which should be the appropriate \"service name\" from the IANA Service Name and Transport Protocol Port Number Registry.',\n        title='Protocol Name',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='A human readable name for the protocol (e.g., Transport Layer Security).',\n        title='Protocol Title',\n    )\n    port_ranges: Optional[List[PortRange]] = Field(None, alias='port-ranges')\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Protocol-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Protocol.name","title":"<code>name: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The common name of the protocol, which should be the appropriate \"service name\" from the IANA Service Name and Transport Protocol Port Number Registry.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Protocol.port_ranges","title":"<code>port_ranges: List[trestle.oscal.common.PortRange]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Protocol.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>A human readable name for the protocol (e.g., Transport Layer Security).</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Protocol.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this service protocol information elsewhere in this or other OSCAL instances. The locally defined UUID of the service protocol can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Protocol.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Published","title":"<code> Published            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Published(OscalBaseModel):\n    __root__: datetime = Field(\n        ...,\n        description=\n        'The date and time the document was published. The date-time value must be formatted according to RFC 3339 with full time and time zone included.',\n        title='Publication Timestamp',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Published-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Published.__root__","title":"<code>__root__: datetime</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>The date and time the document was published. The date-time value must be formatted according to RFC 3339 with full time and time zone included.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedResponse","title":"<code> RelatedResponse            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an individual risk response that this log entry is for.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class RelatedResponse(OscalBaseModel):\n\"\"\"\n    Identifies an individual risk response that this log entry is for.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    response_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='response-uuid',\n        description='A machine-oriented identifier reference to a unique risk response.',\n        title='Response Universally Unique Identifier Reference',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    related_tasks: Optional[List[RelatedTask]] = Field(None, alias='related-tasks')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedResponse-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedResponse.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedResponse.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedResponse.related_tasks","title":"<code>related_tasks: List[trestle.oscal.common.RelatedTask]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedResponse.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedResponse.response_uuid","title":"<code>response_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a unique risk response.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedResponse.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedRisk","title":"<code> RelatedRisk            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Relates the finding to a set of referenced risks that were used to determine the finding.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class RelatedRisk(OscalBaseModel):\n\"\"\"\n    Relates the finding to a set of referenced risks that were used to determine the finding.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    risk_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='risk-uuid',\n        description='A machine-oriented identifier reference to a risk defined in the list of risks.',\n        title='Risk Universally Unique Identifier Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedRisk-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedRisk.risk_uuid","title":"<code>risk_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a risk defined in the list of risks.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedRisk.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask","title":"<code> RelatedTask            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an individual task for which the containing object is a consequence of.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class RelatedTask(OscalBaseModel):\n\"\"\"\n    Identifies an individual task for which the containing object is a consequence of.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    task_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='task-uuid',\n        description='A machine-oriented identifier reference to a unique task.',\n        title='Task Universally Unique Identifier Reference',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    responsible_parties: Optional[List[ResponsibleParty]] = Field(None, alias='responsible-parties')\n    subjects: Optional[List[AssessmentSubject]] = Field(None)\n    identified_subject: Optional[IdentifiedSubject] = Field(\n        None,\n        alias='identified-subject',\n        description='Used to detail assessment subjects that were identfied by this task.',\n        title='Identified Subject',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask.identified_subject","title":"<code>identified_subject: IdentifiedSubject</code>  <code>pydantic-field</code>","text":"<p>Used to detail assessment subjects that were identfied by this task.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask.responsible_parties","title":"<code>responsible_parties: List[trestle.oscal.common.ResponsibleParty]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask.subjects","title":"<code>subjects: List[trestle.oscal.common.AssessmentSubject]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask.task_uuid","title":"<code>task_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a unique task.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelatedTask.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelevantEvidence","title":"<code> RelevantEvidence            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Links this observation to relevant evidence.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class RelevantEvidence(OscalBaseModel):\n\"\"\"\n    Links this observation to relevant evidence.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    href: Optional[str] = Field(\n        None,\n        description='A resolvable URL reference to relevant evidence.',\n        title='Relevant Evidence Reference',\n    )\n    description: str = Field(\n        ...,\n        description='A human-readable description of this evidence.',\n        title='Relevant Evidence Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelevantEvidence-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelevantEvidence.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this evidence.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelevantEvidence.href","title":"<code>href: str</code>  <code>pydantic-field</code>","text":"<p>A resolvable URL reference to relevant evidence.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelevantEvidence.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelevantEvidence.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelevantEvidence.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RelevantEvidence.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Remarks","title":"<code> Remarks            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Remarks(OscalBaseModel):\n    __root__: str = Field(\n        ...,\n        description='Additional commentary on the containing object.',\n        title='Remarks',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Remarks-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Remarks.__root__","title":"<code>__root__: str</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Additional commentary on the containing object.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset","title":"<code> RequiredAsset            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an asset required to achieve remediation.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class RequiredAsset(OscalBaseModel):\n\"\"\"\n    Identifies an asset required to achieve remediation.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this required asset elsewhere in this or other OSCAL instances. The locally defined UUID of the asset can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Required Universally Unique Identifier',\n    )\n    subjects: Optional[List[SubjectReference]] = Field(None)\n    title: Optional[str] = Field(\n        None,\n        description='The title for this required asset.',\n        title='Title for Required Asset',\n    )\n    description: str = Field(\n        ...,\n        description='A human-readable description of this required asset.',\n        title='Description of Required Asset',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this required asset.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset.subjects","title":"<code>subjects: List[trestle.oscal.common.SubjectReference]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this required asset.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this required asset elsewhere in this or other OSCAL instances. The locally defined UUID of the asset can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RequiredAsset.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource","title":"<code> Resource            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A resource associated with content in the containing document. A resource may be directly included in the document base64 encoded or may point to one or more equivalent internet resources.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Resource(OscalBaseModel):\n\"\"\"\n    A resource associated with content in the containing document. A resource may be directly included in the document base64 encoded or may point to one or more equivalent internet resources.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this defined resource elsewhere in this or other OSCAL instances. This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Resource Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='A name given to the resource, which may be used by a tool for display and navigation.',\n        title='Resource Title',\n    )\n    description: Optional[str] = Field(\n        None,\n        description='A short summary of the resource used to indicate the purpose of the resource.',\n        title='Resource Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    document_ids: Optional[List[DocumentId]] = Field(None, alias='document-ids')\n    citation: Optional[Citation] = Field(\n        None,\n        description='A citation consisting of end note text and optional structured bibliographic data.',\n        title='Citation',\n    )\n    rlinks: Optional[List[Rlink]] = Field(None)\n    base64: Optional[Base64] = Field(\n        None,\n        description='The Base64 alphabet in RFC 2045 - aligned with XSD.',\n        title='Base64',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.base64","title":"<code>base64: Base64</code>  <code>pydantic-field</code>","text":"<p>The Base64 alphabet in RFC 2045 - aligned with XSD.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.citation","title":"<code>citation: Citation</code>  <code>pydantic-field</code>","text":"<p>A citation consisting of end note text and optional structured bibliographic data.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A short summary of the resource used to indicate the purpose of the resource.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.document_ids","title":"<code>document_ids: List[trestle.oscal.common.DocumentId]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.rlinks","title":"<code>rlinks: List[trestle.oscal.common.Rlink]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>A name given to the resource, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this defined resource elsewhere in this or other OSCAL instances. This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Resource.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleParty","title":"<code> ResponsibleParty            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A reference to a set of organizations or persons that have responsibility for performing a referenced role in the context of the containing object.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ResponsibleParty(OscalBaseModel):\n\"\"\"\n    A reference to a set of organizations or persons that have responsibility for performing a referenced role in the context of the containing object.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    role_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='role-id',\n        description='A human-oriented identifier reference to roles served by the user.',\n        title='Responsible Role',\n    )\n    party_uuids: List[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(..., alias='party-uuids')\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleParty-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleParty.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleParty.party_uuids","title":"<code>party_uuids: List[trestle.oscal.common.ConstrainedStrValue]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleParty.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleParty.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleParty.role_id","title":"<code>role_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to roles served by the user.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleParty.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleRole","title":"<code> ResponsibleRole            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A reference to one or more roles with responsibility for performing a function relative to the containing object.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ResponsibleRole(OscalBaseModel):\n\"\"\"\n    A reference to one or more roles with responsibility for performing a function relative to the containing object.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    role_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='role-id',\n        description='A human-oriented identifier reference to roles responsible for the business function.',\n        title='Responsible Role ID',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    party_uuids: Optional[List[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )]] = Field(\n        None, alias='party-uuids'\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleRole-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleRole.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleRole.party_uuids","title":"<code>party_uuids: List[trestle.oscal.common.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleRole.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleRole.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleRole.role_id","title":"<code>role_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to roles responsible for the business function.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ResponsibleRole.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision","title":"<code> Revision            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>An entry in a sequential list of revisions to the containing document in reverse chronological order (i.e., most recent previous revision first).</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Revision(OscalBaseModel):\n\"\"\"\n    An entry in a sequential list of revisions to the containing document in reverse chronological order (i.e., most recent previous revision first).\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    title: Optional[str] = Field(\n        None,\n        description='A name given to the document revision, which may be used by a tool for display and navigation.',\n        title='Document Title',\n    )\n    published: Optional[datetime] = None\n    last_modified: Optional[datetime] = Field(None, alias='last-modified')\n    version: constr(regex=r'^\\S(.*\\S)?$')\n    oscal_version: Optional[OscalVersion] = Field(None, alias='oscal-version')\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision.last_modified","title":"<code>last_modified: datetime</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision.oscal_version","title":"<code>oscal_version: OscalVersion</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision.published","title":"<code>published: datetime</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>A name given to the document revision, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision.version","title":"<code>version: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Revision.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RiskStatus","title":"<code> RiskStatus            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class RiskStatus(OscalBaseModel):\n    __root__: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description='Describes the status of the associated risk.',\n        title='Risk Status',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RiskStatus-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RiskStatus.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Describes the status of the associated risk.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Rlink","title":"<code> Rlink            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A pointer to an external resource with an optional hash for verification and change detection.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Rlink(OscalBaseModel):\n\"\"\"\n    A pointer to an external resource with an optional hash for verification and change detection.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    href: str = Field(\n        ...,\n        description='A resolvable URI reference to a resource.',\n        title='Hypertext Reference',\n    )\n    media_type: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        alias='media-type',\n        description=\n        'Specifies a media type as defined by the Internet Assigned Numbers Authority (IANA) Media Types Registry.',\n        title='Media Type',\n    )\n    hashes: Optional[List[Hash]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Rlink-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Rlink.hashes","title":"<code>hashes: List[trestle.oscal.common.Hash]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Rlink.href","title":"<code>href: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A resolvable URI reference to a resource.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Rlink.media_type","title":"<code>media_type: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Specifies a media type as defined by the Internet Assigned Numbers Authority (IANA) Media Types Registry.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Rlink.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role","title":"<code> Role            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Defines a function assumed or expected to be assumed by a party in a specific situation.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Role(OscalBaseModel):\n\"\"\"\n    Defines a function assumed or expected to be assumed by a party in a specific situation.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\n        'A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined role elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, the locally defined ID of the Role from the imported OSCAL instance must be referenced in the context of the containing resource (e.g., import, import-component-definition, import-profile, import-ssp or import-ap). This ID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Role Identifier',\n    )\n    title: str = Field(\n        ...,\n        description='A name given to the role, which may be used by a tool for display and navigation.',\n        title='Role Title',\n    )\n    short_name: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        alias='short-name',\n        description='A short common name, abbreviation, or acronym for the role.',\n        title='Role Short Name',\n    )\n    description: Optional[str] = Field(\n        None,\n        description=\"A summary of the role's purpose and associated responsibilities.\",\n        title='Role Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the role's purpose and associated responsibilities.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role.id","title":"<code>id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined role elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, the locally defined ID of the Role from the imported OSCAL instance must be referenced in the context of the containing resource (e.g., import, import-component-definition, import-profile, import-ssp or import-ap). This ID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role.short_name","title":"<code>short_name: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A short common name, abbreviation, or acronym for the role.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A name given to the role, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Role.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RoleId","title":"<code> RoleId            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class RoleId(OscalBaseModel):\n    __root__: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description='A human-oriented identifier reference to roles served by the user.',\n        title='Role Identifier Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RoleId-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.RoleId.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>A human-oriented identifier reference to roles served by the user.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectObjectiveById","title":"<code> SelectObjectiveById            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to select a control objective for inclusion/exclusion based on the control objective's identifier.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class SelectObjectiveById(OscalBaseModel):\n\"\"\"\n    Used to select a control objective for inclusion/exclusion based on the control objective's identifier.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    objective_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='objective-id',\n        description='Points to an assessment objective.',\n        title='Objective ID',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectObjectiveById-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectObjectiveById.objective_id","title":"<code>objective_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Points to an assessment objective.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectObjectiveById.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectSubjectById","title":"<code> SelectSubjectById            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies a set of assessment subjects to include/exclude by UUID.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class SelectSubjectById(OscalBaseModel):\n\"\"\"\n    Identifies a set of assessment subjects to include/exclude by UUID.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    subject_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='subject-uuid',\n        description=\n        \"A machine-oriented identifier reference to a component, inventory-item, location, party, user, or resource using it's UUID.\",\n        title='Subject Universally Unique Identifier Reference',\n    )\n    type: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description='Used to indicate the type of object pointed to by the uuid-ref within a subject.',\n        title='Subject Universally Unique Identifier Reference Type',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectSubjectById-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectSubjectById.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectSubjectById.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectSubjectById.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectSubjectById.subject_uuid","title":"<code>subject_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a component, inventory-item, location, party, user, or resource using it's UUID.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectSubjectById.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Used to indicate the type of object pointed to by the uuid-ref within a subject.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SelectSubjectById.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Source","title":"<code> Source            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Assessment subjects will be identified while conducting the referenced activity-instance.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Source(OscalBaseModel):\n\"\"\"\n    Assessment subjects will be identified while conducting the referenced activity-instance.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    task_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='task-uuid',\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference (in this or other OSCAL instances) an assessment activity to be performed as part of the event. The locally defined UUID of the task can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Task Universally Unique Identifier',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Source-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Source.task_uuid","title":"<code>task_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference (in this or other OSCAL instances) an assessment activity to be performed as part of the event. The locally defined UUID of the task can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Source.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.StatementId","title":"<code> StatementId            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class StatementId(OscalBaseModel):\n    __root__: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description='Used to constrain the selection to only specificity identified statements.',\n        title='Include Specific Statements',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.StatementId-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.StatementId.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Used to constrain the selection to only specificity identified statements.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SubjectReference","title":"<code> SubjectReference            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A human-oriented identifier reference to a resource. Use type to indicate whether the identified resource is a component, inventory item, location, user, or something else.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class SubjectReference(OscalBaseModel):\n\"\"\"\n    A human-oriented identifier reference to a resource. Use type to indicate whether the identified resource is a component, inventory item, location, user, or something else.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    subject_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='subject-uuid',\n        description=\n        \"A machine-oriented identifier reference to a component, inventory-item, location, party, user, or resource using it's UUID.\",\n        title='Subject Universally Unique Identifier Reference',\n    )\n    type: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description='Used to indicate the type of object pointed to by the uuid-ref within a subject.',\n        title='Subject Universally Unique Identifier Reference Type',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='The title or name for the referenced subject.',\n        title='Subject Reference Title',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SubjectReference-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SubjectReference.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SubjectReference.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SubjectReference.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SubjectReference.subject_uuid","title":"<code>subject_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a component, inventory-item, location, party, user, or resource using it's UUID.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SubjectReference.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title or name for the referenced subject.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SubjectReference.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Used to indicate the type of object pointed to by the uuid-ref within a subject.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SubjectReference.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemId","title":"<code> SystemId            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A human-oriented, globally unique identifier with cross-instance scope that can be used to reference this system identification property elsewhere in this or other OSCAL instances. When referencing an externally defined system identification, the system identification must be used in the context of the external / imported OSCAL instance (e.g., uri-reference). This string should be assigned per-subject, which means it should be consistently used to identify the same system across revisions of the document.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class SystemId(OscalBaseModel):\n\"\"\"\n    A human-oriented, globally unique identifier with cross-instance scope that can be used to reference this system identification property elsewhere in this or other OSCAL instances. When referencing an externally defined system identification, the system identification must be used in the context of the external / imported OSCAL instance (e.g., uri-reference). This string should be assigned per-subject, which means it should be consistently used to identify the same system across revisions of the document.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    identifier_type: Optional[AnyUrl] = Field(\n        None,\n        alias='identifier-type',\n        description='Identifies the identification system from which the provided identifier was assigned.',\n        title='Identification System Type',\n    )\n    id: str\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemId-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemId.id","title":"<code>id: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemId.identifier_type","title":"<code>identifier_type: AnyUrl</code>  <code>pydantic-field</code>","text":"<p>Identifies the identification system from which the provided identifier was assigned.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemId.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser","title":"<code> SystemUser            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A type of user that interacts with the system based on an associated role.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class SystemUser(OscalBaseModel):\n\"\"\"\n    A type of user that interacts with the system based on an associated role.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this user class elsewhere in this or other OSCAL instances. The locally defined UUID of the system user can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='User Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='A name given to the user, which may be used by a tool for display and navigation.',\n        title='User Title',\n    )\n    short_name: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        alias='short-name',\n        description='A short common name, abbreviation, or acronym for the user.',\n        title='User Short Name',\n    )\n    description: Optional[str] = Field(\n        None,\n        description=\"A summary of the user's purpose within the system.\",\n        title='User Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    role_ids: Optional[List[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )]] = Field(\n        None, alias='role-ids'\n    )\n    authorized_privileges: Optional[List[AuthorizedPrivilege]] = Field(None, alias='authorized-privileges')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.authorized_privileges","title":"<code>authorized_privileges: List[trestle.oscal.common.AuthorizedPrivilege]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the user's purpose within the system.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.role_ids","title":"<code>role_ids: List[trestle.oscal.common.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.short_name","title":"<code>short_name: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A short common name, abbreviation, or acronym for the user.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>A name given to the user, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this user class elsewhere in this or other OSCAL instances. The locally defined UUID of the system user can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.SystemUser.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task","title":"<code> Task            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Represents a scheduled event or milestone, which may be associated with a series of assessment actions.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Task(OscalBaseModel):\n\"\"\"\n    Represents a scheduled event or milestone, which may be associated with a series of assessment actions.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this task elsewhere in this or other OSCAL instances. The locally defined UUID of the task can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Task Universally Unique Identifier',\n    )\n    type: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(..., description='The type of task.', title='Task Type')\n    title: str = Field(..., description='The title for this task.', title='Task Title')\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of this task.',\n        title='Task Description',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    timing: Optional[Timing] = Field(\n        None,\n        description='The timing under which the task is intended to occur.',\n        title='Event Timing',\n    )\n    dependencies: Optional[List[Dependency]] = Field(None)\n    tasks: Optional[List[Task]] = None\n    associated_activities: Optional[List[AssociatedActivity]] = Field(None, alias='associated-activities')\n    subjects: Optional[List[AssessmentSubject]] = Field(None)\n    responsible_roles: Optional[List[ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.associated_activities","title":"<code>associated_activities: List[trestle.oscal.common.AssociatedActivity]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.dependencies","title":"<code>dependencies: List[trestle.oscal.common.Dependency]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of this task.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.subjects","title":"<code>subjects: List[trestle.oscal.common.AssessmentSubject]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.tasks","title":"<code>tasks: List[trestle.oscal.common.Task]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.timing","title":"<code>timing: Timing</code>  <code>pydantic-field</code>","text":"<p>The timing under which the task is intended to occur.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title for this task.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The type of task.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this task elsewhere in this or other OSCAL instances. The locally defined UUID of the task can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Task.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.TelephoneNumber","title":"<code> TelephoneNumber            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Contact number by telephone.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class TelephoneNumber(OscalBaseModel):\n\"\"\"\n    Contact number by telephone.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    type: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None, description='Indicates the type of phone number.', title='type flag'\n    )\n    number: str\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.TelephoneNumber-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.TelephoneNumber.number","title":"<code>number: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.TelephoneNumber.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Indicates the type of phone number.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.TelephoneNumber.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Test","title":"<code> Test            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A test expression which is expected to be evaluated by a tool.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Test(OscalBaseModel):\n\"\"\"\n    A test expression which is expected to be evaluated by a tool.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    expression: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='A formal (executable) expression of a constraint',\n        title='Constraint test',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Test-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Test.expression","title":"<code>expression: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A formal (executable) expression of a constraint</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Test.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Test.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ThreatId","title":"<code> ThreatId            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A pointer, by ID, to an externally-defined threat.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class ThreatId(OscalBaseModel):\n\"\"\"\n    A pointer, by ID, to an externally-defined threat.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    system: AnyUrl = Field(\n        ...,\n        description='Specifies the source of the threat information.',\n        title='Threat Type Identification System',\n    )\n    href: Optional[str] = Field(\n        None,\n        description='An optional location for the threat data, from which this ID originates.',\n        title='Threat Information Resource Reference',\n    )\n    id: str\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ThreatId-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ThreatId.href","title":"<code>href: str</code>  <code>pydantic-field</code>","text":"<p>An optional location for the threat data, from which this ID originates.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ThreatId.id","title":"<code>id: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ThreatId.system","title":"<code>system: AnyUrl</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Specifies the source of the threat information.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.ThreatId.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Timing","title":"<code> Timing            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The timing under which the task is intended to occur.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Timing(OscalBaseModel):\n\"\"\"\n    The timing under which the task is intended to occur.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    on_date: Optional[OnDate] = Field(\n        None,\n        alias='on-date',\n        description='The task is intended to occur on the specified date.',\n        title='On Date Condition',\n    )\n    within_date_range: Optional[WithinDateRange] = Field(\n        None,\n        alias='within-date-range',\n        description='The task is intended to occur within the specified date range.',\n        title='On Date Range Condition',\n    )\n    at_frequency: Optional[AtFrequency] = Field(\n        None,\n        alias='at-frequency',\n        description='The task is intended to occur at the specified frequency.',\n        title='Frequency Condition',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Timing-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Timing.at_frequency","title":"<code>at_frequency: AtFrequency</code>  <code>pydantic-field</code>","text":"<p>The task is intended to occur at the specified frequency.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Timing.on_date","title":"<code>on_date: OnDate</code>  <code>pydantic-field</code>","text":"<p>The task is intended to occur on the specified date.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Timing.within_date_range","title":"<code>within_date_range: WithinDateRange</code>  <code>pydantic-field</code>","text":"<p>The task is intended to occur within the specified date range.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Timing.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Transport","title":"<code> Transport            (Enum)         </code>","text":"<p>Indicates the transport type.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Transport(Enum):\n\"\"\"\n    Indicates the transport type.\n    \"\"\"\n\n    TCP = 'TCP'\n    UDP = 'UDP'\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Transport.TCP","title":"<code>TCP</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Transport.UDP","title":"<code>UDP</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type","title":"<code> Type            (Enum)         </code>","text":"<p>A category describing the kind of party the object describes.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Type(Enum):\n\"\"\"\n    A category describing the kind of party the object describes.\n    \"\"\"\n\n    person = 'person'\n    organization = 'organization'\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type.organization","title":"<code>organization</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type.person","title":"<code>person</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type1","title":"<code> Type1            (Enum)         </code>","text":"<p>Identifies the type of the target.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Type1(Enum):\n\"\"\"\n    Identifies the type of the target.\n    \"\"\"\n\n    statement_id = 'statement-id'\n    objective_id = 'objective-id'\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type1.objective_id","title":"<code>objective_id</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type1.statement_id","title":"<code>statement_id</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type2","title":"<code> Type2            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Type2(OscalBaseModel):\n    __root__: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\n        'Identifies the nature of the observation. More than one may be used to further qualify and enable filtering.',\n        title='Observation Type',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type2-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type2.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Identifies the nature of the observation. More than one may be used to further qualify and enable filtering.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type3","title":"<code> Type3            (Enum)         </code>","text":"<p>The kind of actor.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Type3(Enum):\n\"\"\"\n    The kind of actor.\n    \"\"\"\n\n    tool = 'tool'\n    assessment_platform = 'assessment-platform'\n    party = 'party'\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type3.assessment_platform","title":"<code>assessment_platform</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type3.party","title":"<code>party</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Type3.tool","title":"<code>tool</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Unit","title":"<code> Unit            (Enum)         </code>","text":"<p>The unit of time for the period.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class Unit(Enum):\n\"\"\"\n    The unit of time for the period.\n    \"\"\"\n\n    seconds = 'seconds'\n    minutes = 'minutes'\n    hours = 'hours'\n    days = 'days'\n    months = 'months'\n    years = 'years'\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Unit.days","title":"<code>days</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Unit.hours","title":"<code>hours</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Unit.minutes","title":"<code>minutes</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Unit.months","title":"<code>months</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Unit.seconds","title":"<code>seconds</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Unit.years","title":"<code>years</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Url","title":"<code> Url            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Url(OscalBaseModel):\n    __root__: AnyUrl = Field(\n        ...,\n        description=\n        'The uniform resource locator (URL) for a web site or Internet presence associated with the location.',\n        title='Location URL',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Url-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Url.__root__","title":"<code>__root__: AnyUrl</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>The uniform resource locator (URL) for a web site or Internet presence associated with the location.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.UsesComponent","title":"<code> UsesComponent            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The set of components that are used by the assessment platform.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class UsesComponent(OscalBaseModel):\n\"\"\"\n    The set of components that are used by the assessment platform.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    component_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='component-uuid',\n        description=\n        'A machine-oriented identifier reference to a component that is implemented as part of an inventory item.',\n        title='Component Universally Unique Identifier Reference',\n    )\n    props: Optional[List[Property]] = Field(None)\n    links: Optional[List[Link]] = Field(None)\n    responsible_parties: Optional[List[ResponsibleParty]] = Field(None, alias='responsible-parties')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.UsesComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.UsesComponent.component_uuid","title":"<code>component_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a component that is implemented as part of an inventory item.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.UsesComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.UsesComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.UsesComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.UsesComponent.responsible_parties","title":"<code>responsible_parties: List[trestle.oscal.common.ResponsibleParty]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.UsesComponent.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Value","title":"<code> Value            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Value(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$'\n                     ) = Field(..., description='A parameter value or set of values.', title='Parameter Value')\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Value-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Value.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>A parameter value or set of values.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Version","title":"<code> Version            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Version(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description=\n        'A string used to distinguish the current version of the document from other previous (and future) versions.',\n        title='Document Version',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Version-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.Version.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>A string used to distinguish the current version of the document from other previous (and future) versions.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.WithinDateRange","title":"<code> WithinDateRange            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The task is intended to occur within the specified date range.</p> Source code in <code>trestle/oscal/common.py</code> <pre><code>class WithinDateRange(OscalBaseModel):\n\"\"\"\n    The task is intended to occur within the specified date range.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    start: datetime = Field(\n        ...,\n        description='The task must occur on or after the specified date.',\n        title='Start Date Condition',\n    )\n    end: datetime = Field(\n        ...,\n        description='The task must occur on or before the specified date.',\n        title='End Date Condition',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.WithinDateRange-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.WithinDateRange.end","title":"<code>end: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The task must occur on or before the specified date.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.WithinDateRange.start","title":"<code>start: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The task must occur on or after the specified date.</p>"},{"location":"api_reference/trestle.oscal.common/#trestle.oscal.common.WithinDateRange.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/common.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/","title":"component","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component","title":"<code>trestle.oscal.component</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component-classes","title":"Classes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability","title":"<code> Capability            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A grouping of other components and/or capabilities.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class Capability(OscalBaseModel):\n\"\"\"\n    A grouping of other components and/or capabilities.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this capability elsewhere in this or other OSCAL instances. The locally defined UUID of the capability can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Capability Identifier',\n    )\n    name: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description=\"The capability's human-readable name.\",\n        title='Capability Name',\n    )\n    description: str = Field(..., description='A summary of the capability.', title='Capability Description')\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    incorporates_components: Optional[List[IncorporatesComponent]] = Field(None, alias='incorporates-components')\n    control_implementations: Optional[List[ControlImplementation]] = Field(None, alias='control-implementations')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability.control_implementations","title":"<code>control_implementations: List[trestle.oscal.component.ControlImplementation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A summary of the capability.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability.incorporates_components","title":"<code>incorporates_components: List[trestle.oscal.component.IncorporatesComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability.name","title":"<code>name: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The capability's human-readable name.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this capability elsewhere in this or other OSCAL instances. The locally defined UUID of the capability can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Capability.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ComponentDefinition","title":"<code> ComponentDefinition            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A collection of component descriptions, which may optionally be grouped by capability.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class ComponentDefinition(OscalBaseModel):\n\"\"\"\n    A collection of component descriptions, which may optionally be grouped by capability.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component definition elsewhere in this or other OSCAL instances. The locally defined UUID of the component definition can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Component Definition Universally Unique Identifier',\n    )\n    metadata: common.Metadata\n    import_component_definitions: Optional[List[ImportComponentDefinition]] = Field(\n        None, alias='import-component-definitions'\n    )\n    components: Optional[List[DefinedComponent]] = Field(None)\n    capabilities: Optional[List[Capability]] = Field(None)\n    back_matter: Optional[common.BackMatter] = Field(None, alias='back-matter')\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ComponentDefinition-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ComponentDefinition.back_matter","title":"<code>back_matter: BackMatter</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ComponentDefinition.capabilities","title":"<code>capabilities: List[trestle.oscal.component.Capability]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ComponentDefinition.components","title":"<code>components: List[trestle.oscal.component.DefinedComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ComponentDefinition.import_component_definitions","title":"<code>import_component_definitions: List[trestle.oscal.component.ImportComponentDefinition]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ComponentDefinition.metadata","title":"<code>metadata: Metadata</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ComponentDefinition.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component definition elsewhere in this or other OSCAL instances. The locally defined UUID of the component definition can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ComponentDefinition.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation","title":"<code> ControlImplementation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Defines how the component or capability supports a set of controls.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class ControlImplementation(OscalBaseModel):\n\"\"\"\n    Defines how the component or capability supports a set of controls.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference a set of implemented controls elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation set can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Control Implementation Set Identifier',\n    )\n    source: str = Field(\n        ...,\n        description=\n        'A reference to an OSCAL catalog or profile providing the referenced control or subcontrol definition.',\n        title='Source Resource Reference',\n    )\n    description: str = Field(\n        ...,\n        description=\n        'A description of how the specified set of controls are implemented for the containing component or capability.',\n        title='Control Implementation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    set_parameters: Optional[List[SetParameter]] = Field(None, alias='set-parameters')\n    implemented_requirements: List[ImplementedRequirement] = Field(..., alias='implemented-requirements')\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of how the specified set of controls are implemented for the containing component or capability.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation.implemented_requirements","title":"<code>implemented_requirements: List[trestle.oscal.component.ImplementedRequirement]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation.set_parameters","title":"<code>set_parameters: List[trestle.oscal.component.SetParameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation.source","title":"<code>source: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A reference to an OSCAL catalog or profile providing the referenced control or subcontrol definition.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference a set of implemented controls elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation set can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ControlImplementation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent","title":"<code> DefinedComponent            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A defined component that can be part of an implemented system.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class DefinedComponent(OscalBaseModel):\n\"\"\"\n    A defined component that can be part of an implemented system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Component Identifier',\n    )\n    type: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='A category describing the purpose of the component.',\n        title='Component Type',\n    )\n    title: str = Field(\n        ...,\n        description='A human readable name for the component.',\n        title='Component Title',\n    )\n    description: str = Field(\n        ...,\n        description='A description of the component, including information about its function.',\n        title='Component Description',\n    )\n    purpose: Optional[str] = Field(\n        None,\n        description='A summary of the technological or business purpose of the component.',\n        title='Purpose',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    protocols: Optional[List[common.Protocol]] = Field(None)\n    control_implementations: Optional[List[ControlImplementation]] = Field(None, alias='control-implementations')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.control_implementations","title":"<code>control_implementations: List[trestle.oscal.component.ControlImplementation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of the component, including information about its function.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.protocols","title":"<code>protocols: List[trestle.oscal.common.Protocol]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.purpose","title":"<code>purpose: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the technological or business purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human readable name for the component.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A category describing the purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.DefinedComponent.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement","title":"<code> ImplementedRequirement            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes how the containing component or capability implements an individual control.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class ImplementedRequirement(OscalBaseModel):\n\"\"\"\n    Describes how the containing component or capability implements an individual control.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference a specific control implementation elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Control Implementation Identifier',\n    )\n    control_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='control-id',\n        description=\n        'A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).',\n        title='Control Identifier Reference',\n    )\n    description: str = Field(\n        ...,\n        description=\n        'A suggestion for how the specified control may be implemented if the containing component or capability is instantiated in a system security plan.',\n        title='Control Implementation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    set_parameters: Optional[List[SetParameter]] = Field(None, alias='set-parameters')\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    statements: Optional[List[Statement]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.control_id","title":"<code>control_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A suggestion for how the specified control may be implemented if the containing component or capability is instantiated in a system security plan.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.set_parameters","title":"<code>set_parameters: List[trestle.oscal.component.SetParameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.statements","title":"<code>statements: List[trestle.oscal.component.Statement]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference a specific control implementation elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImplementedRequirement.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImportComponentDefinition","title":"<code> ImportComponentDefinition            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Loads a component definition from another resource.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class ImportComponentDefinition(OscalBaseModel):\n\"\"\"\n    Loads a component definition from another resource.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    href: str = Field(\n        ...,\n        description=\n        'A link to a resource that defines a set of components and/or capabilities to import into this collection.',\n        title='Hyperlink Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImportComponentDefinition-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImportComponentDefinition.href","title":"<code>href: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A link to a resource that defines a set of components and/or capabilities to import into this collection.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.ImportComponentDefinition.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.IncorporatesComponent","title":"<code> IncorporatesComponent            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>TBD</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class IncorporatesComponent(OscalBaseModel):\n\"\"\"\n    TBD\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    component_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='component-uuid',\n        description='A machine-oriented identifier reference to a component.',\n        title='Component Reference',\n    )\n    description: str = Field(\n        ...,\n        description='A description of the component, including information about its function.',\n        title='Component Description',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.IncorporatesComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.IncorporatesComponent.component_uuid","title":"<code>component_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to a component.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.IncorporatesComponent.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of the component, including information about its function.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.IncorporatesComponent.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Model","title":"<code> Model            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Model(OscalBaseModel):\n    component_definition: ComponentDefinition = Field(..., alias='component-definition')\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Model.component_definition","title":"<code>component_definition: ComponentDefinition</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.SetParameter","title":"<code> SetParameter            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the parameter that will be set by the enclosed value.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class SetParameter(OscalBaseModel):\n\"\"\"\n    Identifies the parameter that will be set by the enclosed value.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    param_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='param-id',\n        description=\n        \"A human-oriented reference to a parameter within a control, who's catalog has been imported into the current implementation context.\",\n        title='Parameter ID',\n    )\n    values: List[constr(regex=r'^\\S(.*\\S)?$')] = Field(...)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.SetParameter-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.SetParameter.param_id","title":"<code>param_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented reference to a parameter within a control, who's catalog has been imported into the current implementation context.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.SetParameter.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.SetParameter.values","title":"<code>values: List[trestle.oscal.component.ConstrainedStrValue]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.SetParameter.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.State","title":"<code> State            (Enum)         </code>","text":"<p>The operational status.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class State(Enum):\n\"\"\"\n    The operational status.\n    \"\"\"\n\n    under_development = 'under-development'\n    operational = 'operational'\n    disposition = 'disposition'\n    other = 'other'\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.State.disposition","title":"<code>disposition</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.State.operational","title":"<code>operational</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.State.other","title":"<code>other</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.State.under_development","title":"<code>under_development</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement","title":"<code> Statement            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies which statements within a control are addressed.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class Statement(OscalBaseModel):\n\"\"\"\n    Identifies which statements within a control are addressed.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    statement_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='statement-id',\n        description='A human-oriented identifier reference to a control statement.',\n        title='Control Statement Reference',\n    )\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this control statement elsewhere in this or other OSCAL instances. The UUID of the control statement in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).',\n        title='Control Statement Reference Universally Unique Identifier',\n    )\n    description: str = Field(\n        ...,\n        description='A summary of how the containing control statement is implemented by the component or capability.',\n        title='Statement Implementation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A summary of how the containing control statement is implemented by the component or capability.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement.statement_id","title":"<code>statement_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control statement.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this control statement elsewhere in this or other OSCAL instances. The UUID of the control statement in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Statement.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Status","title":"<code> Status            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes the operational status of the system component.</p> Source code in <code>trestle/oscal/component.py</code> <pre><code>class Status(OscalBaseModel):\n\"\"\"\n    Describes the operational status of the system component.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: State = Field(..., description='The operational status.', title='State')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Status-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Status.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Status.state","title":"<code>state: State</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The operational status.</p>"},{"location":"api_reference/trestle.oscal.component/#trestle.oscal.component.Status.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/component.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/","title":"poam","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam","title":"<code>trestle.oscal.poam</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam-classes","title":"Classes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity","title":"<code> Activity            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an assessment or related process that can be performed. In the assessment plan, this is an intended activity which may be associated with an assessment task. In the assessment results, this an activity that was actually performed as part of an assessment.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Activity(OscalBaseModel):\n\"\"\"\n    Identifies an assessment or related process that can be performed. In the assessment plan, this is an intended activity which may be associated with an assessment task. In the assessment results, this an activity that was actually performed as part of an assessment.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment activity elsewhere in this or other OSCAL instances. The locally defined UUID of the activity can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Assessment Activity Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='The title for this included activity.',\n        title='Included Activity Title',\n    )\n    description: str = Field(\n        ...,\n        description='A human-readable description of this included activity.',\n        title='Included Activity Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    steps: Optional[List[Step]] = Field(None)\n    related_controls: Optional[ReviewedControls] = Field(None, alias='related-controls')\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this included activity.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.related_controls","title":"<code>related_controls: ReviewedControls</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.steps","title":"<code>steps: List[trestle.oscal.poam.Step]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this included activity.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this assessment activity elsewhere in this or other OSCAL instances. The locally defined UUID of the activity can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Activity.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Characterization","title":"<code> Characterization            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A collection of descriptive data about the containing object from a specific origin.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Characterization(OscalBaseModel):\n\"\"\"\n    A collection of descriptive data about the containing object from a specific origin.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    origin: Origin1\n    facets: List[common.Facet] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Characterization.facets","title":"<code>facets: List[trestle.oscal.common.Facet]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Characterization.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Characterization.origin","title":"<code>origin: Origin1</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Characterization.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Characterization.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection","title":"<code> ControlSelection            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the controls being assessed. In the assessment plan, these are the planned controls. In the assessment results, these are the actual controls, and reflects any changes from the plan.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class ControlSelection(OscalBaseModel):\n\"\"\"\n    Identifies the controls being assessed. In the assessment plan, these are the planned controls. In the assessment results, these are the actual controls, and reflects any changes from the plan.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of in-scope controls specified for assessment.',\n        title='Assessed Controls Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    include_all: Optional[common.IncludeAll] = Field(None, alias='include-all')\n    include_controls: Optional[List[SelectControlById]] = Field(None, alias='include-controls')\n    exclude_controls: Optional[List[SelectControlById]] = Field(None, alias='exclude-controls')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of in-scope controls specified for assessment.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection.exclude_controls","title":"<code>exclude_controls: List[trestle.oscal.poam.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection.include_all","title":"<code>include_all: IncludeAll</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection.include_controls","title":"<code>include_controls: List[trestle.oscal.poam.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ControlSelection.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry","title":"<code> Entry            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an individual risk response that occurred as part of managing an identified risk.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Entry(OscalBaseModel):\n\"\"\"\n    Identifies an individual risk response that occurred as part of managing an identified risk.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk log entry elsewhere in this or other OSCAL instances. The locally defined UUID of the risk log entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Risk Log Entry Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this risk log entry.', title='Title')\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of what was done regarding the risk.',\n        title='Risk Task Description',\n    )\n    start: datetime = Field(\n        ...,\n        description='Identifies the start date and time of the event.',\n        title='Start',\n    )\n    end: Optional[datetime] = Field(\n        None,\n        description=\n        'Identifies the end date and time of the event. If the event is a point in time, the start and end will be the same date and time.',\n        title='End',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    logged_by: Optional[List[common.LoggedBy]] = Field(None, alias='logged-by')\n    status_change: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None, alias='status-change'\n    )\n    related_responses: Optional[List[common.RelatedResponse]] = Field(None, alias='related-responses')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of what was done regarding the risk.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.end","title":"<code>end: datetime</code>  <code>pydantic-field</code>","text":"<p>Identifies the end date and time of the event. If the event is a point in time, the start and end will be the same date and time.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.logged_by","title":"<code>logged_by: List[trestle.oscal.common.LoggedBy]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.related_responses","title":"<code>related_responses: List[trestle.oscal.common.RelatedResponse]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.start","title":"<code>start: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Identifies the start date and time of the event.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.status_change","title":"<code>status_change: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this risk log entry.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk log entry elsewhere in this or other OSCAL instances. The locally defined UUID of the risk log entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Entry.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.LocalDefinitions","title":"<code> LocalDefinitions            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Allows components, and inventory-items to be defined within the POA&amp;M for circumstances where no OSCAL-based SSP exists, or is not delivered with the POA&amp;M.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class LocalDefinitions(OscalBaseModel):\n\"\"\"\n    Allows components, and inventory-items to be defined within the POA&amp;M for circumstances where no OSCAL-based SSP exists, or is not delivered with the POA&amp;M.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    components: Optional[List[SystemComponent]] = Field(None)\n    inventory_items: Optional[List[common.InventoryItem]] = Field(None, alias='inventory-items')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.LocalDefinitions.components","title":"<code>components: List[trestle.oscal.poam.SystemComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.LocalDefinitions.inventory_items","title":"<code>inventory_items: List[trestle.oscal.common.InventoryItem]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.LocalDefinitions.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.LocalDefinitions.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Method","title":"<code> Method            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Method(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='Identifies how the observation was made.',\n        title='Observation Method',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Method-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Method.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>Identifies how the observation was made.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Model","title":"<code> Model            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Model(OscalBaseModel):\n    plan_of_action_and_milestones: PlanOfActionAndMilestones = Field(..., alias='plan-of-action-and-milestones')\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Model.plan_of_action_and_milestones","title":"<code>plan_of_action_and_milestones: PlanOfActionAndMilestones</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation","title":"<code> Observation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes an individual observation.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Observation(OscalBaseModel):\n\"\"\"\n    Describes an individual observation.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this observation elsewhere in this or other OSCAL instances. The locally defined UUID of the observation can be used to reference the data item locally or globally (e.g., in an imorted OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Observation Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this observation.', title='Observation Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this assessment observation.',\n        title='Observation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    methods: List[Method] = Field(...)\n    types: Optional[List[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )]] = Field(None)\n    origins: Optional[List[Origin1]] = Field(None)\n    subjects: Optional[List[common.SubjectReference]] = Field(None)\n    relevant_evidence: Optional[List[common.RelevantEvidence]] = Field(None, alias='relevant-evidence')\n    collected: datetime = Field(\n        ...,\n        description='Date/time stamp identifying when the finding information was collected.',\n        title='Collected Field',\n    )\n    expires: Optional[datetime] = Field(\n        None,\n        description=\n        'Date/time identifying when the finding information is out-of-date and no longer valid. Typically used with continuous assessment scenarios.',\n        title='Expires Field',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.collected","title":"<code>collected: datetime</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Date/time stamp identifying when the finding information was collected.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this assessment observation.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.expires","title":"<code>expires: datetime</code>  <code>pydantic-field</code>","text":"<p>Date/time identifying when the finding information is out-of-date and no longer valid. Typically used with continuous assessment scenarios.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.methods","title":"<code>methods: List[trestle.oscal.poam.Method]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.origins","title":"<code>origins: List[trestle.oscal.poam.Origin1]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.relevant_evidence","title":"<code>relevant_evidence: List[trestle.oscal.common.RelevantEvidence]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.subjects","title":"<code>subjects: List[trestle.oscal.common.SubjectReference]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this observation.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.types","title":"<code>types: List[trestle.oscal.poam.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this observation elsewhere in this or other OSCAL instances. The locally defined UUID of the observation can be used to reference the data item locally or globally (e.g., in an imorted OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Observation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Origin","title":"<code> Origin            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the source of the finding, such as a tool or person.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Origin(OscalBaseModel):\n\"\"\"\n    Identifies the source of the finding, such as a tool or person.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    actors: List[common.OriginActor] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Origin.actors","title":"<code>actors: List[trestle.oscal.common.OriginActor]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Origin.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Origin1","title":"<code> Origin1            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the source of the finding, such as a tool, interviewed person, or activity.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Origin1(OscalBaseModel):\n\"\"\"\n    Identifies the source of the finding, such as a tool, interviewed person, or activity.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    actors: List[common.OriginActor] = Field(...)\n    related_tasks: Optional[List[common.RelatedTask]] = Field(None, alias='related-tasks')\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Origin1.actors","title":"<code>actors: List[trestle.oscal.common.OriginActor]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Origin1.related_tasks","title":"<code>related_tasks: List[trestle.oscal.common.RelatedTask]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Origin1.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones","title":"<code> PlanOfActionAndMilestones            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A plan of action and milestones which identifies initial and residual risks, deviations, and disposition, such as those required by FedRAMP.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class PlanOfActionAndMilestones(OscalBaseModel):\n\"\"\"\n    A plan of action and milestones which identifies initial and residual risks, deviations, and disposition, such as those required by FedRAMP.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with instancescope that can be used to reference this POA&amp;M instance in this OSCAL instance. This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='POA&amp;M Universally Unique Identifier',\n    )\n    metadata: common.Metadata\n    import_ssp: Optional[common.ImportSsp] = Field(None, alias='import-ssp')\n    system_id: Optional[common.SystemId] = Field(None, alias='system-id')\n    local_definitions: Optional[LocalDefinitions] = Field(None, alias='local-definitions')\n    observations: Optional[List[Observation]] = Field(None)\n    risks: Optional[List[Risk]] = Field(None)\n    poam_items: List[PoamItem] = Field(..., alias='poam-items')\n    back_matter: Optional[common.BackMatter] = Field(None, alias='back-matter')\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.back_matter","title":"<code>back_matter: BackMatter</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.import_ssp","title":"<code>import_ssp: ImportSsp</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.local_definitions","title":"<code>local_definitions: LocalDefinitions</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.metadata","title":"<code>metadata: Metadata</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.observations","title":"<code>observations: List[trestle.oscal.poam.Observation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.poam_items","title":"<code>poam_items: List[trestle.oscal.poam.PoamItem]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.risks","title":"<code>risks: List[trestle.oscal.poam.Risk]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.system_id","title":"<code>system_id: SystemId</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with instancescope that can be used to reference this POA&amp;M instance in this OSCAL instance. This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PlanOfActionAndMilestones.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem","title":"<code> PoamItem            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes an individual POA&amp;M item.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class PoamItem(OscalBaseModel):\n\"\"\"\n    Describes an individual POA&amp;M item.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        description=\n        'A machine-oriented, globally unique identifier with instance scope that can be used to reference this POA&amp;M item entry in this OSCAL instance. This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='POA&amp;M Item Universally Unique Identifier',\n    )\n    title: str = Field(\n        ...,\n        description='The title or name for this POA&amp;M item .',\n        title='POA&amp;M Item Title',\n    )\n    description: str = Field(\n        ...,\n        description='A human-readable description of POA&amp;M item.',\n        title='POA&amp;M Item Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    origins: Optional[List[Origin]] = Field(None)\n    related_observations: Optional[List[RelatedObservation]] = Field(None, alias='related-observations')\n    related_risks: Optional[List[common.RelatedRisk]] = Field(None, alias='related-risks')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of POA&amp;M item.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.origins","title":"<code>origins: List[trestle.oscal.poam.Origin]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.related_observations","title":"<code>related_observations: List[trestle.oscal.poam.RelatedObservation]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.related_risks","title":"<code>related_risks: List[trestle.oscal.common.RelatedRisk]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title or name for this POA&amp;M item .</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented, globally unique identifier with instance scope that can be used to reference this POA&amp;M item entry in this OSCAL instance. This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.PoamItem.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RelatedObservation","title":"<code> RelatedObservation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Relates the poam-item to a set of referenced observations that were used to determine the finding.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class RelatedObservation(OscalBaseModel):\n\"\"\"\n    Relates the poam-item to a set of referenced observations that were used to determine the finding.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    observation_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='observation-uuid',\n        description='A machine-oriented identifier reference to an observation defined in the list of observations.',\n        title='Observation Universally Unique Identifier Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RelatedObservation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RelatedObservation.observation_uuid","title":"<code>observation_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to an observation defined in the list of observations.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RelatedObservation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RelatedObservation1","title":"<code> RelatedObservation1            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Relates the finding to a set of referenced observations that were used to determine the finding.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class RelatedObservation1(OscalBaseModel):\n\"\"\"\n    Relates the finding to a set of referenced observations that were used to determine the finding.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    observation_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='observation-uuid',\n        description='A machine-oriented identifier reference to an observation defined in the list of observations.',\n        title='Observation Universally Unique Identifier Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RelatedObservation1-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RelatedObservation1.observation_uuid","title":"<code>observation_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to an observation defined in the list of observations.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RelatedObservation1.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response","title":"<code> Response            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes either recommended or an actual plan for addressing the risk.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Response(OscalBaseModel):\n\"\"\"\n    Describes either recommended or an actual plan for addressing the risk.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this remediation elsewhere in this or other OSCAL instances. The locally defined UUID of the risk response can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Remediation Universally Unique Identifier',\n    )\n    lifecycle: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        description=\n        'Identifies whether this is a recommendation, such as from an assessor or tool, or an actual plan accepted by the system owner.',\n        title='Remediation Intent',\n    )\n    title: str = Field(..., description='The title for this response activity.', title='Response Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this response plan.',\n        title='Response Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    origins: Optional[List[Origin1]] = Field(None)\n    required_assets: Optional[List[common.RequiredAsset]] = Field(None, alias='required-assets')\n    tasks: Optional[List[common.Task]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this response plan.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.lifecycle","title":"<code>lifecycle: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Identifies whether this is a recommendation, such as from an assessor or tool, or an actual plan accepted by the system owner.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.origins","title":"<code>origins: List[trestle.oscal.poam.Origin1]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.required_assets","title":"<code>required_assets: List[trestle.oscal.common.RequiredAsset]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.tasks","title":"<code>tasks: List[trestle.oscal.common.Task]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title for this response activity.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this remediation elsewhere in this or other OSCAL instances. The locally defined UUID of the risk response can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Response.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ReviewedControls","title":"<code> ReviewedControls            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the controls being assessed and their control objectives.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class ReviewedControls(OscalBaseModel):\n\"\"\"\n    Identifies the controls being assessed and their control objectives.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: Optional[str] = Field(\n        None,\n        description='A human-readable description of control objectives.',\n        title='Control Objective Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    control_selections: List[ControlSelection] = Field(..., alias='control-selections')\n    control_objective_selections: Optional[List[common.ControlObjectiveSelection]] = Field(\n        None, alias='control-objective-selections'\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ReviewedControls-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ReviewedControls.control_objective_selections","title":"<code>control_objective_selections: List[trestle.oscal.common.ControlObjectiveSelection]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ReviewedControls.control_selections","title":"<code>control_selections: List[trestle.oscal.poam.ControlSelection]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ReviewedControls.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A human-readable description of control objectives.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ReviewedControls.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ReviewedControls.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ReviewedControls.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.ReviewedControls.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk","title":"<code> Risk            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>An identified risk.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Risk(OscalBaseModel):\n\"\"\"\n    An identified risk.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk elsewhere in this or other OSCAL instances. The locally defined UUID of the risk can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Risk Universally Unique Identifier',\n    )\n    title: str = Field(..., description='The title for this risk.', title='Risk Title')\n    description: str = Field(\n        ...,\n        description=\n        'A human-readable summary of the identified risk, to include a statement of how the risk impacts the system.',\n        title='Risk Description',\n    )\n    statement: str = Field(\n        ...,\n        description='An summary of impact for how the risk affects the system.',\n        title='Risk Statement',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    status: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )\n    origins: Optional[List[Origin1]] = Field(None)\n    threat_ids: Optional[List[common.ThreatId]] = Field(None, alias='threat-ids')\n    characterizations: Optional[List[Characterization]] = Field(None)\n    mitigating_factors: Optional[List[common.MitigatingFactor]] = Field(None, alias='mitigating-factors')\n    deadline: Optional[datetime] = Field(\n        None,\n        description='The date/time by which the risk must be resolved.',\n        title='Risk Resolution Deadline',\n    )\n    remediations: Optional[List[Response]] = Field(None)\n    risk_log: Optional[RiskLog] = Field(\n        None,\n        alias='risk-log',\n        description='A log of all risk-related tasks taken.',\n        title='Risk Log',\n    )\n    related_observations: Optional[List[RelatedObservation1]] = Field(None, alias='related-observations')\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.characterizations","title":"<code>characterizations: List[trestle.oscal.poam.Characterization]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.deadline","title":"<code>deadline: datetime</code>  <code>pydantic-field</code>","text":"<p>The date/time by which the risk must be resolved.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable summary of the identified risk, to include a statement of how the risk impacts the system.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.mitigating_factors","title":"<code>mitigating_factors: List[trestle.oscal.common.MitigatingFactor]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.origins","title":"<code>origins: List[trestle.oscal.poam.Origin1]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.related_observations","title":"<code>related_observations: List[trestle.oscal.poam.RelatedObservation1]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.remediations","title":"<code>remediations: List[trestle.oscal.poam.Response]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.risk_log","title":"<code>risk_log: RiskLog</code>  <code>pydantic-field</code>","text":"<p>A log of all risk-related tasks taken.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.statement","title":"<code>statement: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An summary of impact for how the risk affects the system.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.status","title":"<code>status: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.threat_ids","title":"<code>threat_ids: List[trestle.oscal.common.ThreatId]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The title for this risk.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this risk elsewhere in this or other OSCAL instances. The locally defined UUID of the risk can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Risk.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RiskLog","title":"<code> RiskLog            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A log of all risk-related tasks taken.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class RiskLog(OscalBaseModel):\n\"\"\"\n    A log of all risk-related tasks taken.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    entries: List[Entry] = Field(...)\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RiskLog.entries","title":"<code>entries: List[trestle.oscal.poam.Entry]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.RiskLog.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SelectControlById","title":"<code> SelectControlById            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to select a control for inclusion/exclusion based on one or more control identifiers. A set of statement identifiers can be used to target the inclusion/exclusion to only specific control statements providing more granularity over the specific statements that are within the asessment scope.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class SelectControlById(OscalBaseModel):\n\"\"\"\n    Used to select a control for inclusion/exclusion based on one or more control identifiers. A set of statement identifiers can be used to target the inclusion/exclusion to only specific control statements providing more granularity over the specific statements that are within the asessment scope.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    control_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='control-id',\n        description=\n        'A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).',\n        title='Control Identifier Reference',\n    )\n    statement_ids: Optional[List[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )]] = Field(\n        None, alias='statement-ids'\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SelectControlById-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SelectControlById.control_id","title":"<code>control_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SelectControlById.statement_ids","title":"<code>statement_ids: List[trestle.oscal.poam.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SelectControlById.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.State","title":"<code> State            (Enum)         </code>","text":"<p>The operational status.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class State(Enum):\n\"\"\"\n    The operational status.\n    \"\"\"\n\n    under_development = 'under-development'\n    operational = 'operational'\n    disposition = 'disposition'\n    other = 'other'\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.State.disposition","title":"<code>disposition</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.State.operational","title":"<code>operational</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.State.other","title":"<code>other</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.State.under_development","title":"<code>under_development</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.State1","title":"<code> State1            (Enum)         </code>","text":"<p>An indication as to whether the objective is satisfied or not.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class State1(Enum):\n\"\"\"\n    An indication as to whether the objective is satisfied or not.\n    \"\"\"\n\n    satisfied = 'satisfied'\n    not_satisfied = 'not-satisfied'\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.State1.not_satisfied","title":"<code>not_satisfied</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.State1.satisfied","title":"<code>satisfied</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status","title":"<code> Status            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes the operational status of the system component.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Status(OscalBaseModel):\n\"\"\"\n    Describes the operational status of the system component.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: State = Field(..., description='The operational status.', title='State')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status.state","title":"<code>state: State</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The operational status.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status1","title":"<code> Status1            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A determination of if the objective is satisfied or not within a given system.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Status1(OscalBaseModel):\n\"\"\"\n    A determination of if the objective is satisfied or not within a given system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: State1 = Field(\n        ...,\n        description='An indication as to whether the objective is satisfied or not.',\n        title='Objective Status State',\n    )\n    reason: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        description=\"The reason the objective was given it's status.\",\n        title='Objective Status Reason',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status1-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status1.reason","title":"<code>reason: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>The reason the objective was given it's status.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status1.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status1.state","title":"<code>state: State1</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An indication as to whether the objective is satisfied or not.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Status1.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step","title":"<code> Step            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies an individual step in a series of steps related to an activity, such as an assessment test or examination procedure.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Step(OscalBaseModel):\n\"\"\"\n    Identifies an individual step in a series of steps related to an activity, such as an assessment test or examination procedure.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this step elsewhere in this or other OSCAL instances. The locally defined UUID of the step (in a series of steps) can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Step Universally Unique Identifier',\n    )\n    title: Optional[str] = Field(None, description='The title for this step.', title='Step Title')\n    description: str = Field(\n        ...,\n        description='A human-readable description of this step.',\n        title='Step Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    reviewed_controls: Optional[ReviewedControls] = Field(None, alias='reviewed-controls')\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-readable description of this step.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step.reviewed_controls","title":"<code>reviewed_controls: ReviewedControls</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>The title for this step.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this step elsewhere in this or other OSCAL instances. The locally defined UUID of the step (in a series of steps) can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.Step.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent","title":"<code> SystemComponent            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A defined component that can be part of an implemented system.</p> Source code in <code>trestle/oscal/poam.py</code> <pre><code>class SystemComponent(OscalBaseModel):\n\"\"\"\n    A defined component that can be part of an implemented system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Component Identifier',\n    )\n    type: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='A category describing the purpose of the component.',\n        title='Component Type',\n    )\n    title: str = Field(\n        ...,\n        description='A human readable name for the system component.',\n        title='Component Title',\n    )\n    description: str = Field(\n        ...,\n        description='A description of the component, including information about its function.',\n        title='Component Description',\n    )\n    purpose: Optional[str] = Field(\n        None,\n        description='A summary of the technological or business purpose of the component.',\n        title='Purpose',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    status: Status = Field(\n        ...,\n        description='Describes the operational status of the system component.',\n        title='Status',\n    )\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    protocols: Optional[List[common.Protocol]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of the component, including information about its function.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.protocols","title":"<code>protocols: List[trestle.oscal.common.Protocol]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.purpose","title":"<code>purpose: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the technological or business purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.status","title":"<code>status: Status</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Describes the operational status of the system component.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human readable name for the system component.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A category describing the purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.poam/#trestle.oscal.poam.SystemComponent.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/poam.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/","title":"profile","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile","title":"<code>trestle.oscal.profile</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile-classes","title":"Classes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add","title":"<code> Add            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Specifies contents to be added into controls, in resolution</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Add(OscalBaseModel):\n\"\"\"\n    Specifies contents to be added into controls, in resolution\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    position: Optional[Position] = Field(\n        None,\n        description='Where to add the new content with respect to the targeted element (beside it or inside it)',\n        title='Position',\n    )\n    by_id: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='by-id',\n        description='Target location of the addition.',\n        title='Reference by ID',\n    )\n    title: Optional[str] = Field(\n        None,\n        description='A name given to the control, which may be used by a tool for display and navigation.',\n        title='Title Change',\n    )\n    params: Optional[List[common.Parameter]] = Field(None)\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    parts: Optional[List[common.Part]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add.by_id","title":"<code>by_id: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Target location of the addition.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add.params","title":"<code>params: List[trestle.oscal.common.Parameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add.parts","title":"<code>parts: List[trestle.oscal.common.Part]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add.position","title":"<code>position: Position</code>  <code>pydantic-field</code>","text":"<p>Where to add the new content with respect to the targeted element (beside it or inside it)</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add.title","title":"<code>title: str</code>  <code>pydantic-field</code>","text":"<p>A name given to the control, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Add.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Alter","title":"<code> Alter            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>An Alter element specifies changes to be made to an included control when a profile is resolved.</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Alter(OscalBaseModel):\n\"\"\"\n    An Alter element specifies changes to be made to an included control when a profile is resolved.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    control_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='control-id',\n        description=\n        'A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).',\n        title='Control Identifier Reference',\n    )\n    removes: Optional[List[Remove]] = Field(None)\n    adds: Optional[List[Add]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Alter-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Alter.adds","title":"<code>adds: List[trestle.oscal.profile.Add]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Alter.control_id","title":"<code>control_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Alter.removes","title":"<code>removes: List[trestle.oscal.profile.Remove]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Alter.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Combine","title":"<code> Combine            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A Combine element defines how to combine multiple (competing) versions of the same control.</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Combine(OscalBaseModel):\n\"\"\"\n    A Combine element defines how to combine multiple (competing) versions of the same control.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    method: Optional[Method] = Field(\n        None,\n        description='How clashing controls should be handled',\n        title='Combination method',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Combine-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Combine.method","title":"<code>method: Method</code>  <code>pydantic-field</code>","text":"<p>How clashing controls should be handled</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Combine.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Custom","title":"<code> Custom            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A Custom element frames a structure for embedding represented controls in resolution.</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Custom(OscalBaseModel):\n\"\"\"\n    A Custom element frames a structure for embedding represented controls in resolution.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    groups: Optional[List[Group]] = Field(None)\n    insert_controls: Optional[List[InsertControls]] = Field(None, alias='insert-controls')\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Custom.groups","title":"<code>groups: List[trestle.oscal.profile.Group]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Custom.insert_controls","title":"<code>insert_controls: List[trestle.oscal.profile.InsertControls]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Custom.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group","title":"<code> Group            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A group of (selected) controls or of groups of controls</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Group(OscalBaseModel):\n\"\"\"\n    A group of (selected) controls or of groups of controls\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    id: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        description=\n        'A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined group elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, this identifier must be referenced in the context of the containing resource (e.g., import-profile). This id should be assigned per-subject, which means it should be consistently used to identify the same group across revisions of the document.',\n        title='Group Identifier',\n    )\n    class_: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='class',\n        description='A textual label that provides a sub-type or characterization of the group.',\n        title='Group Class',\n    )\n    title: str = Field(\n        ...,\n        description='A name given to the group, which may be used by a tool for display and navigation.',\n        title='Group Title',\n    )\n    params: Optional[List[common.Parameter]] = Field(None)\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    parts: Optional[List[common.Part]] = Field(None)\n    groups: Optional[List[Group]] = None\n    insert_controls: Optional[List[InsertControls]] = Field(None, alias='insert-controls')\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.class_","title":"<code>class_: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A textual label that provides a sub-type or characterization of the group.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.groups","title":"<code>groups: List[trestle.oscal.profile.Group]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.id","title":"<code>id: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined group elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, this identifier must be referenced in the context of the containing resource (e.g., import-profile). This id should be assigned per-subject, which means it should be consistently used to identify the same group across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.insert_controls","title":"<code>insert_controls: List[trestle.oscal.profile.InsertControls]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.params","title":"<code>params: List[trestle.oscal.common.Parameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.parts","title":"<code>parts: List[trestle.oscal.common.Part]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A name given to the group, which may be used by a tool for display and navigation.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Group.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Import","title":"<code> Import            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The import designates a catalog or profile to be included (referenced and potentially modified) by this profile. The import also identifies which controls to select using the include-all, include-controls, and exclude-controls directives.</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Import(OscalBaseModel):\n\"\"\"\n    The import designates a catalog or profile to be included (referenced and potentially modified) by this profile. The import also identifies which controls to select using the include-all, include-controls, and exclude-controls directives.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    href: str = Field(\n        ...,\n        description='A resolvable URL reference to the base catalog or profile that this profile is tailoring.',\n        title='Catalog or Profile Reference',\n    )\n    include_all: Optional[common.IncludeAll] = Field(None, alias='include-all')\n    include_controls: Optional[List[SelectControlById]] = Field(None, alias='include-controls')\n    exclude_controls: Optional[List[SelectControlById]] = Field(None, alias='exclude-controls')\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Import-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Import.exclude_controls","title":"<code>exclude_controls: List[trestle.oscal.profile.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Import.href","title":"<code>href: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A resolvable URL reference to the base catalog or profile that this profile is tailoring.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Import.include_all","title":"<code>include_all: IncludeAll</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Import.include_controls","title":"<code>include_controls: List[trestle.oscal.profile.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Import.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.InsertControls","title":"<code> InsertControls            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Specifies which controls to use in the containing context.</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class InsertControls(OscalBaseModel):\n\"\"\"\n    Specifies which controls to use in the containing context.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    order: Optional[Order] = Field(\n        None,\n        description='A designation of how a selection of controls in a profile is to be ordered.',\n        title='Order',\n    )\n    include_all: Optional[common.IncludeAll] = Field(None, alias='include-all')\n    include_controls: Optional[List[SelectControlById]] = Field(None, alias='include-controls')\n    exclude_controls: Optional[List[SelectControlById]] = Field(None, alias='exclude-controls')\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.InsertControls-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.InsertControls.exclude_controls","title":"<code>exclude_controls: List[trestle.oscal.profile.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.InsertControls.include_all","title":"<code>include_all: IncludeAll</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.InsertControls.include_controls","title":"<code>include_controls: List[trestle.oscal.profile.SelectControlById]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.InsertControls.order","title":"<code>order: Order</code>  <code>pydantic-field</code>","text":"<p>A designation of how a selection of controls in a profile is to be ordered.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.InsertControls.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Matching","title":"<code> Matching            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Select controls by (regular expression) match on ID</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Matching(OscalBaseModel):\n\"\"\"\n    Select controls by (regular expression) match on ID\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    pattern: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        description='A glob expression matching the IDs of one or more controls to be selected.',\n        title='Pattern',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Matching-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Matching.pattern","title":"<code>pattern: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A glob expression matching the IDs of one or more controls to be selected.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Matching.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Merge","title":"<code> Merge            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A Merge element provides structuring directives that drive how controls are organized after resolution.</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Merge(OscalBaseModel):\n\"\"\"\n    A Merge element provides structuring directives that drive how controls are organized after resolution.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    combine: Optional[Combine] = Field(\n        None,\n        description='A Combine element defines how to combine multiple (competing) versions of the same control.',\n        title='Combination rule',\n    )\n    flat: Optional[Dict[str, Any]] = Field(None, description='Use the flat structuring method.', title='Flat')\n    as_is: Optional[bool] = Field(\n        None,\n        alias='as-is',\n        description=\n        'An As-is element indicates that the controls should be structured in resolution as they are structured in their source catalogs. It does not contain any elements or attributes.',\n        title='As-Is Structuring Directive',\n    )\n    custom: Optional[Custom] = Field(\n        None,\n        description='A Custom element frames a structure for embedding represented controls in resolution.',\n        title='Custom grouping',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Merge-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Merge.as_is","title":"<code>as_is: bool</code>  <code>pydantic-field</code>","text":"<p>An As-is element indicates that the controls should be structured in resolution as they are structured in their source catalogs. It does not contain any elements or attributes.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Merge.combine","title":"<code>combine: Combine</code>  <code>pydantic-field</code>","text":"<p>A Combine element defines how to combine multiple (competing) versions of the same control.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Merge.custom","title":"<code>custom: Custom</code>  <code>pydantic-field</code>","text":"<p>A Custom element frames a structure for embedding represented controls in resolution.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Merge.flat","title":"<code>flat: Dict[str, Any]</code>  <code>pydantic-field</code>","text":"<p>Use the flat structuring method.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Merge.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Method","title":"<code> Method            (Enum)         </code>","text":"<p>How clashing controls should be handled</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Method(Enum):\n\"\"\"\n    How clashing controls should be handled\n    \"\"\"\n\n    use_first = 'use-first'\n    merge = 'merge'\n    keep = 'keep'\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Method.keep","title":"<code>keep</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Method.merge","title":"<code>merge</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Method.use_first","title":"<code>use_first</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Model","title":"<code> Model            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Model(OscalBaseModel):\n    profile: Profile\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Model.profile","title":"<code>profile: Profile</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Modify","title":"<code> Modify            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Set parameters or amend controls in resolution</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Modify(OscalBaseModel):\n\"\"\"\n    Set parameters or amend controls in resolution\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    set_parameters: Optional[List[SetParameter]] = Field(None, alias='set-parameters')\n    alters: Optional[List[Alter]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Modify.alters","title":"<code>alters: List[trestle.oscal.profile.Alter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Modify.set_parameters","title":"<code>set_parameters: List[trestle.oscal.profile.SetParameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Modify.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Order","title":"<code> Order            (Enum)         </code>","text":"<p>A designation of how a selection of controls in a profile is to be ordered.</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Order(Enum):\n\"\"\"\n    A designation of how a selection of controls in a profile is to be ordered.\n    \"\"\"\n\n    keep = 'keep'\n    ascending = 'ascending'\n    descending = 'descending'\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Order.ascending","title":"<code>ascending</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Order.descending","title":"<code>descending</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Order.keep","title":"<code>keep</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Position","title":"<code> Position            (Enum)         </code>","text":"<p>Where to add the new content with respect to the targeted element (beside it or inside it)</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Position(Enum):\n\"\"\"\n    Where to add the new content with respect to the targeted element (beside it or inside it)\n    \"\"\"\n\n    before = 'before'\n    after = 'after'\n    starting = 'starting'\n    ending = 'ending'\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Position.after","title":"<code>after</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Position.before","title":"<code>before</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Position.ending","title":"<code>ending</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Position.starting","title":"<code>starting</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Profile","title":"<code> Profile            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Each OSCAL profile is defined by a Profile element</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Profile(OscalBaseModel):\n\"\"\"\n    Each OSCAL profile is defined by a Profile element\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this profile elsewhere in this or other OSCAL instances. The locally defined UUID of the profile can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This identifier should be assigned per-subject, which means it should be consistently used to identify the same profile across revisions of the document.',\n        title='Profile Universally Unique Identifier',\n    )\n    metadata: common.Metadata\n    imports: List[Import] = Field(...)\n    merge: Optional[Merge] = None\n    modify: Optional[Modify] = None\n    back_matter: Optional[common.BackMatter] = Field(None, alias='back-matter')\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Profile-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Profile.back_matter","title":"<code>back_matter: BackMatter</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Profile.imports","title":"<code>imports: List[trestle.oscal.profile.Import]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Profile.merge","title":"<code>merge: Merge</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Profile.metadata","title":"<code>metadata: Metadata</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Profile.modify","title":"<code>modify: Modify</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Profile.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this profile elsewhere in this or other OSCAL instances. The locally defined UUID of the profile can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This identifier should be assigned per-subject, which means it should be consistently used to identify the same profile across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Profile.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Remove","title":"<code> Remove            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Specifies objects to be removed from a control based on specific aspects of the object that must all match.</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Remove(OscalBaseModel):\n\"\"\"\n    Specifies objects to be removed from a control based on specific aspects of the object that must all match.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    by_name: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='by-name',\n        description='Identify items to remove by matching their assigned name',\n        title='Reference by (assigned) name',\n    )\n    by_class: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='by-class',\n        description='Identify items to remove by matching their class.',\n        title='Reference by class',\n    )\n    by_id: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='by-id',\n        description='Identify items to remove indicated by their id.',\n        title='Reference by ID',\n    )\n    by_item_name: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='by-item-name',\n        description=\"Identify items to remove by the name of the item's information element name, e.g. title or prop\",\n        title='Item Name Reference',\n    )\n    by_ns: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='by-ns',\n        description=\"Identify items to remove by the item's ns, which is the namespace associated with a part, or prop.\",\n        title='Item Namespace Reference',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Remove-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Remove.by_class","title":"<code>by_class: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Identify items to remove by matching their class.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Remove.by_id","title":"<code>by_id: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Identify items to remove indicated by their id.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Remove.by_item_name","title":"<code>by_item_name: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Identify items to remove by the name of the item's information element name, e.g. title or prop</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Remove.by_name","title":"<code>by_name: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Identify items to remove by matching their assigned name</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Remove.by_ns","title":"<code>by_ns: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>Identify items to remove by the item's ns, which is the namespace associated with a part, or prop.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.Remove.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SelectControlById","title":"<code> SelectControlById            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Call a control by its ID</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class SelectControlById(OscalBaseModel):\n\"\"\"\n    Call a control by its ID\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    with_child_controls: Optional[WithChildControls] = Field(\n        None,\n        alias='with-child-controls',\n        description='When a control is included, whether its child (dependent) controls are also included.',\n        title='Include contained controls with control',\n    )\n    with_ids: Optional[List[WithId]] = Field(None, alias='with-ids')\n    matching: Optional[List[Matching]] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SelectControlById-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SelectControlById.matching","title":"<code>matching: List[trestle.oscal.profile.Matching]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SelectControlById.with_child_controls","title":"<code>with_child_controls: WithChildControls</code>  <code>pydantic-field</code>","text":"<p>When a control is included, whether its child (dependent) controls are also included.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SelectControlById.with_ids","title":"<code>with_ids: List[trestle.oscal.profile.WithId]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SelectControlById.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter","title":"<code> SetParameter            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A parameter setting, to be propagated to points of insertion</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class SetParameter(OscalBaseModel):\n\"\"\"\n    A parameter setting, to be propagated to points of insertion\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    param_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='param-id',\n        description=\n        'A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined parameter elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, this identifier must be referenced in the context of the containing resource (e.g., import-profile). This id should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Parameter ID',\n    )\n    class_: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='class',\n        description='A textual label that provides a characterization of the parameter.',\n        title='Parameter Class',\n    )\n    depends_on: Optional[constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    )] = Field(\n        None,\n        alias='depends-on',\n        description=\n        '**(deprecated)** Another parameter invoking this one. This construct has been deprecated and should not be used.',\n        title='Depends on',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    label: Optional[str] = Field(\n        None,\n        description=\n        'A short, placeholder name for the parameter, which can be used as a substitute for a value if no value is assigned.',\n        title='Parameter Label',\n    )\n    usage: Optional[str] = Field(\n        None,\n        description='Describes the purpose and use of a parameter',\n        title='Parameter Usage Description',\n    )\n    constraints: Optional[List[common.ParameterConstraint]] = Field(None)\n    guidelines: Optional[List[common.ParameterGuideline]] = Field(None)\n    values: Optional[List[constr(regex=r'^\\S(.*\\S)?$')]] = Field(None)\n    select: Optional[common.ParameterSelection] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.class_","title":"<code>class_: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A textual label that provides a characterization of the parameter.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.constraints","title":"<code>constraints: List[trestle.oscal.common.ParameterConstraint]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.depends_on","title":"<code>depends_on: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>(deprecated) Another parameter invoking this one. This construct has been deprecated and should not be used.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.guidelines","title":"<code>guidelines: List[trestle.oscal.common.ParameterGuideline]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.label","title":"<code>label: str</code>  <code>pydantic-field</code>","text":"<p>A short, placeholder name for the parameter, which can be used as a substitute for a value if no value is assigned.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.param_id","title":"<code>param_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented, locally unique identifier with cross-instance scope that can be used to reference this defined parameter elsewhere in this or other OSCAL instances. When referenced from another OSCAL instance, this identifier must be referenced in the context of the containing resource (e.g., import-profile). This id should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.select","title":"<code>select: ParameterSelection</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.usage","title":"<code>usage: str</code>  <code>pydantic-field</code>","text":"<p>Describes the purpose and use of a parameter</p>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.values","title":"<code>values: List[trestle.oscal.profile.ConstrainedStrValue]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.SetParameter.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.WithChildControls","title":"<code> WithChildControls            (Enum)         </code>","text":"<p>When a control is included, whether its child (dependent) controls are also included.</p> Source code in <code>trestle/oscal/profile.py</code> <pre><code>class WithChildControls(Enum):\n\"\"\"\n    When a control is included, whether its child (dependent) controls are also included.\n    \"\"\"\n\n    yes = 'yes'\n    no = 'no'\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.WithChildControls.no","title":"<code>no</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.WithChildControls.yes","title":"<code>yes</code>","text":""},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.WithId","title":"<code> WithId            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/profile.py</code> <pre><code>class WithId(OscalBaseModel):\n    __root__: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(..., description='', title='Match Controls by Identifier')\n</code></pre>"},{"location":"api_reference/trestle.oscal.profile/#trestle.oscal.profile.WithId.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/","title":"ssp","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp","title":"<code>trestle.oscal.ssp</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp-classes","title":"Classes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AdjustmentJustification","title":"<code> AdjustmentJustification            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class AdjustmentJustification(OscalBaseModel):\n    __root__: str = Field(\n        ...,\n        description=\n        'If the selected security level is different from the base security level, this contains the justification for the change.',\n        title='Adjustment Justification',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AdjustmentJustification-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AdjustmentJustification.__root__","title":"<code>__root__: str</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>If the selected security level is different from the base security level, this contains the justification for the change.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AuthorizationBoundary","title":"<code> AuthorizationBoundary            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A description of this system's authorization boundary, optionally supplemented by diagrams that illustrate the authorization boundary.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class AuthorizationBoundary(OscalBaseModel):\n\"\"\"\n    A description of this system's authorization boundary, optionally supplemented by diagrams that illustrate the authorization boundary.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: str = Field(\n        ...,\n        description=\"A summary of the system's authorization boundary.\",\n        title='Authorization Boundary Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    diagrams: Optional[List[Diagram]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AuthorizationBoundary-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AuthorizationBoundary.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A summary of the system's authorization boundary.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AuthorizationBoundary.diagrams","title":"<code>diagrams: List[trestle.oscal.ssp.Diagram]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AuthorizationBoundary.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AuthorizationBoundary.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AuthorizationBoundary.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AuthorizationBoundary.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AvailabilityImpact","title":"<code> AvailabilityImpact            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The expected level of impact resulting from the disruption of access to or use of the described information or the information system.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class AvailabilityImpact(OscalBaseModel):\n\"\"\"\n    The expected level of impact resulting from the disruption of access to or use of the described information or the information system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    base: Base\n    selected: Optional[Selected] = None\n    adjustment_justification: Optional[AdjustmentJustification] = Field(None, alias='adjustment-justification')\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AvailabilityImpact.adjustment_justification","title":"<code>adjustment_justification: AdjustmentJustification</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AvailabilityImpact.base","title":"<code>base: Base</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AvailabilityImpact.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AvailabilityImpact.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AvailabilityImpact.selected","title":"<code>selected: Selected</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.AvailabilityImpact.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Base","title":"<code> Base            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Base(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='The prescribed base (Confidentiality, Integrity, or Availability) security impact level.',\n        title='Base Level (Confidentiality, Integrity, or Availability)',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Base-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Base.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>The prescribed base (Confidentiality, Integrity, or Availability) security impact level.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent","title":"<code> ByComponent            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Defines how the referenced component implements a set of controls.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class ByComponent(OscalBaseModel):\n\"\"\"\n    Defines how the referenced component implements a set of controls.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    component_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='component-uuid',\n        description='A machine-oriented identifier reference to the component that is implemeting a given control.',\n        title='Component Universally Unique Identifier Reference',\n    )\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this by-component entry elsewhere in this or other OSCAL instances. The locally defined UUID of the by-component entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='By-Component Universally Unique Identifier',\n    )\n    description: str = Field(\n        ...,\n        description=\n        'An implementation statement that describes how a control or a control statement is implemented within the referenced system component.',\n        title='Control Implementation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    set_parameters: Optional[List[SetParameter]] = Field(None, alias='set-parameters')\n    implementation_status: Optional[common.ImplementationStatus] = Field(None, alias='implementation-status')\n    export: Optional[Export] = Field(\n        None,\n        description='Identifies content intended for external consumption, such as with leveraged organizations.',\n        title='Export',\n    )\n    inherited: Optional[List[Inherited]] = Field(None)\n    satisfied: Optional[List[Satisfied]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.component_uuid","title":"<code>component_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to the component that is implemeting a given control.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An implementation statement that describes how a control or a control statement is implemented within the referenced system component.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.export","title":"<code>export: Export</code>  <code>pydantic-field</code>","text":"<p>Identifies content intended for external consumption, such as with leveraged organizations.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.implementation_status","title":"<code>implementation_status: ImplementationStatus</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.inherited","title":"<code>inherited: List[trestle.oscal.ssp.Inherited]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.satisfied","title":"<code>satisfied: List[trestle.oscal.ssp.Satisfied]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.set_parameters","title":"<code>set_parameters: List[trestle.oscal.ssp.SetParameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this by-component entry elsewhere in this or other OSCAL instances. The locally defined UUID of the by-component entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ByComponent.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Categorization","title":"<code> Categorization            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A set of information type identifiers qualified by the given identification system used, such as NIST SP 800-60.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Categorization(OscalBaseModel):\n\"\"\"\n    A set of information type identifiers qualified by the given identification system used, such as NIST SP 800-60.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    system: AnyUrl = Field(\n        ...,\n        description='Specifies the information type identification system used.',\n        title='Information Type Identification System',\n    )\n    information_type_ids: Optional[List[InformationTypeId]] = Field(None, alias='information-type-ids')\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Categorization-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Categorization.information_type_ids","title":"<code>information_type_ids: List[trestle.oscal.ssp.InformationTypeId]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Categorization.system","title":"<code>system: AnyUrl</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Specifies the information type identification system used.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Categorization.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ConfidentialityImpact","title":"<code> ConfidentialityImpact            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The expected level of impact resulting from the unauthorized disclosure of the described information.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class ConfidentialityImpact(OscalBaseModel):\n\"\"\"\n    The expected level of impact resulting from the unauthorized disclosure of the described information.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    base: Base\n    selected: Optional[Selected] = None\n    adjustment_justification: Optional[AdjustmentJustification] = Field(None, alias='adjustment-justification')\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ConfidentialityImpact.adjustment_justification","title":"<code>adjustment_justification: AdjustmentJustification</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ConfidentialityImpact.base","title":"<code>base: Base</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ConfidentialityImpact.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ConfidentialityImpact.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ConfidentialityImpact.selected","title":"<code>selected: Selected</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ConfidentialityImpact.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ControlImplementation","title":"<code> ControlImplementation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes how the system satisfies a set of controls.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class ControlImplementation(OscalBaseModel):\n\"\"\"\n    Describes how the system satisfies a set of controls.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: str = Field(\n        ...,\n        description=\n        'A statement describing important things to know about how this set of control satisfaction documentation is approached.',\n        title='Control Implementation Description',\n    )\n    set_parameters: Optional[List[SetParameter]] = Field(None, alias='set-parameters')\n    implemented_requirements: List[ImplementedRequirement] = Field(..., alias='implemented-requirements')\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ControlImplementation-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ControlImplementation.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A statement describing important things to know about how this set of control satisfaction documentation is approached.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ControlImplementation.implemented_requirements","title":"<code>implemented_requirements: List[trestle.oscal.ssp.ImplementedRequirement]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ControlImplementation.set_parameters","title":"<code>set_parameters: List[trestle.oscal.ssp.SetParameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ControlImplementation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DataFlow","title":"<code> DataFlow            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A description of the logical flow of information within the system and across its boundaries, optionally supplemented by diagrams that illustrate these flows.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class DataFlow(OscalBaseModel):\n\"\"\"\n    A description of the logical flow of information within the system and across its boundaries, optionally supplemented by diagrams that illustrate these flows.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: str = Field(\n        ...,\n        description=\"A summary of the system's data flow.\",\n        title='Data Flow Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    diagrams: Optional[List[Diagram]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DataFlow-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DataFlow.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A summary of the system's data flow.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DataFlow.diagrams","title":"<code>diagrams: List[trestle.oscal.ssp.Diagram]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DataFlow.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DataFlow.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DataFlow.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DataFlow.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DateAuthorized","title":"<code> DateAuthorized            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class DateAuthorized(OscalBaseModel):\n    __root__: constr(\n        regex=\n        r'^((2000|2400|2800|(19|2[0-9](0[48]|[2468][048]|[13579][26])))-02-29)|(((19|2[0-9])[0-9]{2})-02-(0[1-9]|1[0-9]|2[0-8]))|(((19|2[0-9])[0-9]{2})-(0[13578]|10|12)-(0[1-9]|[12][0-9]|3[01]))|(((19|2[0-9])[0-9]{2})-(0[469]|11)-(0[1-9]|[12][0-9]|30))(Z|[+-][0-9]{2}:[0-9]{2})?$'\n    ) = Field(\n        ...,\n        description='The date the system received its authorization.',\n        title='System Authorization Date',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DateAuthorized-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.DateAuthorized.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>The date the system received its authorization.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Diagram","title":"<code> Diagram            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A graphic that provides a visual representation the system, or some aspect of it.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Diagram(OscalBaseModel):\n\"\"\"\n    A graphic that provides a visual representation the system, or some aspect of it.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this diagram elsewhere in this or other OSCAL instances. The locally defined UUID of the diagram can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Diagram ID',\n    )\n    description: Optional[str] = Field(None, description='A summary of the diagram.', title='Diagram Description')\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    caption: Optional[str] = Field(None, description='A brief caption to annotate the diagram.', title='Caption')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Diagram-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Diagram.caption","title":"<code>caption: str</code>  <code>pydantic-field</code>","text":"<p>A brief caption to annotate the diagram.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Diagram.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the diagram.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Diagram.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Diagram.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Diagram.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Diagram.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this diagram elsewhere in this or other OSCAL instances. The locally defined UUID of the diagram can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Diagram.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Export","title":"<code> Export            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies content intended for external consumption, such as with leveraged organizations.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Export(OscalBaseModel):\n\"\"\"\n    Identifies content intended for external consumption, such as with leveraged organizations.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: Optional[str] = Field(\n        None,\n        description=\n        'An implementation statement that describes the aspects of the control or control statement implementation that can be available to another system leveraging this system.',\n        title='Control Implementation Export Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    provided: Optional[List[Provided]] = Field(None)\n    responsibilities: Optional[List[Responsibility]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Export-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Export.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":"<p>An implementation statement that describes the aspects of the control or control statement implementation that can be available to another system leveraging this system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Export.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Export.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Export.provided","title":"<code>provided: List[trestle.oscal.ssp.Provided]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Export.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Export.responsibilities","title":"<code>responsibilities: List[trestle.oscal.ssp.Responsibility]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Export.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement","title":"<code> ImplementedRequirement            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes how the system satisfies the requirements of an individual control.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class ImplementedRequirement(OscalBaseModel):\n\"\"\"\n    Describes how the system satisfies the requirements of an individual control.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this control requirement elsewhere in this or other OSCAL instances. The locally defined UUID of the control requirement can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Control Requirement Universally Unique Identifier',\n    )\n    control_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='control-id',\n        description=\n        'A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).',\n        title='Control Identifier Reference',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    set_parameters: Optional[List[SetParameter]] = Field(None, alias='set-parameters')\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    statements: Optional[List[Statement]] = Field(None)\n    by_components: Optional[List[ByComponent]] = Field(None, alias='by-components')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.by_components","title":"<code>by_components: List[trestle.oscal.ssp.ByComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.control_id","title":"<code>control_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control with a corresponding id value. When referencing an externally defined control, the Control Identifier Reference must be used in the context of the external / imported OSCAL instance (e.g., uri-reference).</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.set_parameters","title":"<code>set_parameters: List[trestle.oscal.ssp.SetParameter]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.statements","title":"<code>statements: List[trestle.oscal.ssp.Statement]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this control requirement elsewhere in this or other OSCAL instances. The locally defined UUID of the control requirement can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImplementedRequirement.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImportProfile","title":"<code> ImportProfile            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Used to import the OSCAL profile representing the system's control baseline.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class ImportProfile(OscalBaseModel):\n\"\"\"\n    Used to import the OSCAL profile representing the system's control baseline.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    href: str = Field(\n        ...,\n        description=\"A resolvable URL reference to the profile or catalog to use as the system's control baseline.\",\n        title='Profile Reference',\n    )\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImportProfile-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImportProfile.href","title":"<code>href: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A resolvable URL reference to the profile or catalog to use as the system's control baseline.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImportProfile.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.ImportProfile.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType","title":"<code> InformationType            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Contains details about one information type that is stored, processed, or transmitted by the system, such as privacy information, and those defined in NIST SP 800-60.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class InformationType(OscalBaseModel):\n\"\"\"\n    Contains details about one information type that is stored, processed, or transmitted by the system, such as privacy information, and those defined in NIST SP 800-60.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this information type elsewhere in this or other OSCAL instances. The locally defined UUID of the information type can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Information Type Universally Unique Identifier',\n    )\n    title: str = Field(\n        ...,\n        description=\n        'A human readable name for the information type. This title should be meaningful within the context of the system.',\n        title='title field',\n    )\n    description: str = Field(\n        ...,\n        description='A summary of how this information type is used within the system.',\n        title='Information Type Description',\n    )\n    categorizations: Optional[List[Categorization]] = Field(None)\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    confidentiality_impact: ConfidentialityImpact = Field(\n        ...,\n        alias='confidentiality-impact',\n        description=\n        'The expected level of impact resulting from the unauthorized disclosure of the described information.',\n        title='Confidentiality Impact Level',\n    )\n    integrity_impact: IntegrityImpact = Field(\n        ...,\n        alias='integrity-impact',\n        description=\n        'The expected level of impact resulting from the unauthorized modification of the described information.',\n        title='Integrity Impact Level',\n    )\n    availability_impact: AvailabilityImpact = Field(\n        ...,\n        alias='availability-impact',\n        description=\n        'The expected level of impact resulting from the disruption of access to or use of the described information or the information system.',\n        title='Availability Impact Level',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.availability_impact","title":"<code>availability_impact: AvailabilityImpact</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The expected level of impact resulting from the disruption of access to or use of the described information or the information system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.categorizations","title":"<code>categorizations: List[trestle.oscal.ssp.Categorization]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.confidentiality_impact","title":"<code>confidentiality_impact: ConfidentialityImpact</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The expected level of impact resulting from the unauthorized disclosure of the described information.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A summary of how this information type is used within the system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.integrity_impact","title":"<code>integrity_impact: IntegrityImpact</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The expected level of impact resulting from the unauthorized modification of the described information.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human readable name for the information type. This title should be meaningful within the context of the system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this information type elsewhere in this or other OSCAL instances. The locally defined UUID of the information type can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationType.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationTypeId","title":"<code> InformationTypeId            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class InformationTypeId(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description=\n        'A human-oriented, globally unique identifier qualified by the given identification system used, such as NIST SP 800-60. This identifier has cross-instance scope and can be used to reference this system elsewhere in this or other OSCAL instances. This id should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Information Type Systematized Identifier',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationTypeId-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.InformationTypeId.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>A human-oriented, globally unique identifier qualified by the given identification system used, such as NIST SP 800-60. This identifier has cross-instance scope and can be used to reference this system elsewhere in this or other OSCAL instances. This id should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Inherited","title":"<code> Inherited            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes a control implementation inherited by a leveraging system.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Inherited(OscalBaseModel):\n\"\"\"\n    Describes a control implementation inherited by a leveraging system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this inherited entry elsewhere in this or other OSCAL instances. The locally defined UUID of the inherited control implementation can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Inherited Universally Unique Identifier',\n    )\n    provided_uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        alias='provided-uuid',\n        description=\n        'A machine-oriented identifier reference to an inherited control implementation that a leveraging system is inheriting from a leveraged system.',\n        title='Provided UUID',\n    )\n    description: str = Field(\n        ...,\n        description=\n        'An implementation statement that describes the aspects of a control or control statement implementation that a leveraging system is inheriting from a leveraged system.',\n        title='Inherited Control Implementation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Inherited-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Inherited.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An implementation statement that describes the aspects of a control or control statement implementation that a leveraging system is inheriting from a leveraged system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Inherited.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Inherited.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Inherited.provided_uuid","title":"<code>provided_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented identifier reference to an inherited control implementation that a leveraging system is inheriting from a leveraged system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Inherited.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Inherited.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this inherited entry elsewhere in this or other OSCAL instances. The locally defined UUID of the inherited control implementation can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Inherited.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.IntegrityImpact","title":"<code> IntegrityImpact            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The expected level of impact resulting from the unauthorized modification of the described information.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class IntegrityImpact(OscalBaseModel):\n\"\"\"\n    The expected level of impact resulting from the unauthorized modification of the described information.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    base: Base\n    selected: Optional[Selected] = None\n    adjustment_justification: Optional[AdjustmentJustification] = Field(None, alias='adjustment-justification')\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.IntegrityImpact.adjustment_justification","title":"<code>adjustment_justification: AdjustmentJustification</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.IntegrityImpact.base","title":"<code>base: Base</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.IntegrityImpact.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.IntegrityImpact.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.IntegrityImpact.selected","title":"<code>selected: Selected</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.IntegrityImpact.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization","title":"<code> LeveragedAuthorization            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A description of another authorized system from which this system inherits capabilities that satisfy security requirements. Another term for this concept is a common control provider.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class LeveragedAuthorization(OscalBaseModel):\n\"\"\"\n    A description of another authorized system from which this system inherits capabilities that satisfy security requirements. Another term for this concept is a common control provider.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope and can be used to reference this leveraged authorization elsewhere in this or other OSCAL instances. The locally defined UUID of the leveraged authorization can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Leveraged Authorization Universally Unique Identifier',\n    )\n    title: str = Field(\n        ...,\n        description='A human readable name for the leveraged authorization in the context of the system.',\n        title='title field',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    party_uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        alias='party-uuid',\n        description='A machine-oriented identifier reference to the party that manages the leveraged system.',\n        title='party-uuid field',\n    )\n    date_authorized: DateAuthorized = Field(..., alias='date-authorized')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization.date_authorized","title":"<code>date_authorized: DateAuthorized</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization.party_uuid","title":"<code>party_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented identifier reference to the party that manages the leveraged system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human readable name for the leveraged authorization in the context of the system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope and can be used to reference this leveraged authorization elsewhere in this or other OSCAL instances. The locally defined UUID of the leveraged authorization can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.LeveragedAuthorization.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Model","title":"<code> Model            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Model(OscalBaseModel):\n    system_security_plan: SystemSecurityPlan = Field(..., alias='system-security-plan')\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Model.system_security_plan","title":"<code>system_security_plan: SystemSecurityPlan</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.NetworkArchitecture","title":"<code> NetworkArchitecture            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A description of the system's network architecture, optionally supplemented by diagrams that illustrate the network architecture.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class NetworkArchitecture(OscalBaseModel):\n\"\"\"\n    A description of the system's network architecture, optionally supplemented by diagrams that illustrate the network architecture.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    description: str = Field(\n        ...,\n        description=\"A summary of the system's network architecture.\",\n        title='Network Architecture Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    diagrams: Optional[List[Diagram]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.NetworkArchitecture-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.NetworkArchitecture.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A summary of the system's network architecture.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.NetworkArchitecture.diagrams","title":"<code>diagrams: List[trestle.oscal.ssp.Diagram]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.NetworkArchitecture.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.NetworkArchitecture.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.NetworkArchitecture.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.NetworkArchitecture.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Provided","title":"<code> Provided            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes a capability which may be inherited by a leveraging system.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Provided(OscalBaseModel):\n\"\"\"\n    Describes a capability which may be inherited by a leveraging system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this provided entry elsewhere in this or other OSCAL instances. The locally defined UUID of the provided entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Provided Universally Unique Identifier',\n    )\n    description: str = Field(\n        ...,\n        description=\n        'An implementation statement that describes the aspects of the control or control statement implementation that can be provided to another system leveraging this system.',\n        title='Provided Control Implementation Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Provided-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Provided.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An implementation statement that describes the aspects of the control or control statement implementation that can be provided to another system leveraging this system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Provided.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Provided.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Provided.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Provided.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Provided.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this provided entry elsewhere in this or other OSCAL instances. The locally defined UUID of the provided entry can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Provided.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility","title":"<code> Responsibility            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes a control implementation responsibility imposed on a leveraging system.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Responsibility(OscalBaseModel):\n\"\"\"\n    Describes a control implementation responsibility imposed on a leveraging system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this responsibility elsewhere in this or other OSCAL instances. The locally defined UUID of the responsibility can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Responsibility Universally Unique Identifier',\n    )\n    provided_uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        alias='provided-uuid',\n        description=\n        'A machine-oriented identifier reference to an inherited control implementation that a leveraging system is inheriting from a leveraged system.',\n        title='Provided UUID',\n    )\n    description: str = Field(\n        ...,\n        description=\n        'An implementation statement that describes the aspects of the control or control statement implementation that a leveraging system must implement to satisfy the control provided by a leveraged system.',\n        title='Control Implementation Responsibility Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An implementation statement that describes the aspects of the control or control statement implementation that a leveraging system must implement to satisfy the control provided by a leveraged system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility.provided_uuid","title":"<code>provided_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented identifier reference to an inherited control implementation that a leveraging system is inheriting from a leveraged system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this responsibility elsewhere in this or other OSCAL instances. The locally defined UUID of the responsibility can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Responsibility.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied","title":"<code> Satisfied            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes how this system satisfies a responsibility imposed by a leveraged system.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Satisfied(OscalBaseModel):\n\"\"\"\n    Describes how this system satisfies a responsibility imposed by a leveraged system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this satisfied control implementation entry elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Satisfied Universally Unique Identifier',\n    )\n    responsibility_uuid: Optional[constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    )] = Field(\n        None,\n        alias='responsibility-uuid',\n        description=\n        'A machine-oriented identifier reference to a control implementation that satisfies a responsibility imposed by a leveraged system.',\n        title='Responsibility UUID',\n    )\n    description: str = Field(\n        ...,\n        description=\n        'An implementation statement that describes the aspects of a control or control statement implementation that a leveraging system is implementing based on a requirement from a leveraged system.',\n        title='Satisfied Control Implementation Responsibility Description',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>An implementation statement that describes the aspects of a control or control statement implementation that a leveraging system is implementing based on a requirement from a leveraged system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied.responsibility_uuid","title":"<code>responsibility_uuid: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A machine-oriented identifier reference to a control implementation that satisfies a responsibility imposed by a leveraged system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this satisfied control implementation entry elsewhere in this or other OSCAL instances. The locally defined UUID of the control implementation can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Satisfied.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SecurityImpactLevel","title":"<code> SecurityImpactLevel            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>The overall level of expected impact resulting from unauthorized disclosure, modification, or loss of access to information.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class SecurityImpactLevel(OscalBaseModel):\n\"\"\"\n    The overall level of expected impact resulting from unauthorized disclosure, modification, or loss of access to information.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    security_objective_confidentiality: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        alias='security-objective-confidentiality',\n        description=\n        'A target-level of confidentiality for the system, based on the sensitivity of information within the system.',\n        title='Security Objective: Confidentiality',\n    )\n    security_objective_integrity: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        alias='security-objective-integrity',\n        description=\n        'A target-level of integrity for the system, based on the sensitivity of information within the system.',\n        title='Security Objective: Integrity',\n    )\n    security_objective_availability: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        alias='security-objective-availability',\n        description=\n        'A target-level of availability for the system, based on the sensitivity of information within the system.',\n        title='Security Objective: Availability',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SecurityImpactLevel-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SecurityImpactLevel.security_objective_availability","title":"<code>security_objective_availability: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A target-level of availability for the system, based on the sensitivity of information within the system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SecurityImpactLevel.security_objective_confidentiality","title":"<code>security_objective_confidentiality: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A target-level of confidentiality for the system, based on the sensitivity of information within the system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SecurityImpactLevel.security_objective_integrity","title":"<code>security_objective_integrity: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A target-level of integrity for the system, based on the sensitivity of information within the system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SecurityImpactLevel.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Selected","title":"<code> Selected            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Selected(OscalBaseModel):\n    __root__: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='The selected (Confidentiality, Integrity, or Availability) security impact level.',\n        title='Selected Level (Confidentiality, Integrity, or Availability)',\n    )\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Selected-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Selected.__root__","title":"<code>__root__: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code> <code>special</code>","text":"<p>The selected (Confidentiality, Integrity, or Availability) security impact level.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SetParameter","title":"<code> SetParameter            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies the parameter that will be set by the enclosed value.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class SetParameter(OscalBaseModel):\n\"\"\"\n    Identifies the parameter that will be set by the enclosed value.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    param_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='param-id',\n        description=\n        \"A human-oriented reference to a parameter within a control, who's catalog has been imported into the current implementation context.\",\n        title='Parameter ID',\n    )\n    values: List[constr(regex=r'^\\S(.*\\S)?$')] = Field(...)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SetParameter-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SetParameter.param_id","title":"<code>param_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented reference to a parameter within a control, who's catalog has been imported into the current implementation context.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SetParameter.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SetParameter.values","title":"<code>values: List[trestle.oscal.ssp.ConstrainedStrValue]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SetParameter.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State","title":"<code> State            (Enum)         </code>","text":"<p>The current operating status.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class State(Enum):\n\"\"\"\n    The current operating status.\n    \"\"\"\n\n    operational = 'operational'\n    under_development = 'under-development'\n    under_major_modification = 'under-major-modification'\n    disposition = 'disposition'\n    other = 'other'\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State.disposition","title":"<code>disposition</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State.operational","title":"<code>operational</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State.other","title":"<code>other</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State.under_development","title":"<code>under_development</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State.under_major_modification","title":"<code>under_major_modification</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State1","title":"<code> State1            (Enum)         </code>","text":"<p>The operational status.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class State1(Enum):\n\"\"\"\n    The operational status.\n    \"\"\"\n\n    under_development = 'under-development'\n    operational = 'operational'\n    disposition = 'disposition'\n    other = 'other'\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State1.disposition","title":"<code>disposition</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State1.operational","title":"<code>operational</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State1.other","title":"<code>other</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.State1.under_development","title":"<code>under_development</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement","title":"<code> Statement            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Identifies which statements within a control are addressed.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Statement(OscalBaseModel):\n\"\"\"\n    Identifies which statements within a control are addressed.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    statement_id: constr(\n        regex=\n        r'^[_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-\\.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$'\n    ) = Field(\n        ...,\n        alias='statement-id',\n        description='A human-oriented identifier reference to a control statement.',\n        title='Control Statement Reference',\n    )\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this control statement elsewhere in this or other OSCAL instances. The UUID of the control statement in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).',\n        title='Control Statement Reference Universally Unique Identifier',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    by_components: Optional[List[ByComponent]] = Field(None, alias='by-components')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement.by_components","title":"<code>by_components: List[trestle.oscal.ssp.ByComponent]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement.statement_id","title":"<code>statement_id: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human-oriented identifier reference to a control statement.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this control statement elsewhere in this or other OSCAL instances. The UUID of the control statement in the source OSCAL instance is sufficient to reference the data item locally or globally (e.g., in an imported OSCAL instance).</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Statement.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status","title":"<code> Status            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes the operational status of the system component.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Status(OscalBaseModel):\n\"\"\"\n    Describes the operational status of the system component.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: State1 = Field(..., description='The operational status.', title='State')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status.state","title":"<code>state: State1</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The operational status.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status1","title":"<code> Status1            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Describes the operational status of the system.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Status1(OscalBaseModel):\n\"\"\"\n    Describes the operational status of the system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    state: State = Field(..., description='The current operating status.', title='State')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status1-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status1.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status1.state","title":"<code>state: State</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The current operating status.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.Status1.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics","title":"<code> SystemCharacteristics            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Contains the characteristics of the system, such as its name, purpose, and security impact level.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class SystemCharacteristics(OscalBaseModel):\n\"\"\"\n    Contains the characteristics of the system, such as its name, purpose, and security impact level.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    system_ids: List[common.SystemId] = Field(..., alias='system-ids')\n    system_name: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        alias='system-name',\n        description='The full name of the system.',\n        title='System Name - Full',\n    )\n    system_name_short: Optional[constr(regex=r'^\\S(.*\\S)?$')] = Field(\n        None,\n        alias='system-name-short',\n        description=\n        'A short name for the system, such as an acronym, that is suitable for display in a data table or summary list.',\n        title='System Name - Short',\n    )\n    description: str = Field(..., description='A summary of the system.', title='System Description')\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    date_authorized: Optional[DateAuthorized] = Field(None, alias='date-authorized')\n    security_sensitivity_level: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        alias='security-sensitivity-level',\n        description='The overall information system sensitivity categorization, such as defined by FIPS-199.',\n        title='Security Sensitivity Level',\n    )\n    system_information: SystemInformation = Field(..., alias='system-information')\n    security_impact_level: SecurityImpactLevel = Field(..., alias='security-impact-level')\n    status: Status1\n    authorization_boundary: AuthorizationBoundary = Field(..., alias='authorization-boundary')\n    network_architecture: Optional[NetworkArchitecture] = Field(None, alias='network-architecture')\n    data_flow: Optional[DataFlow] = Field(None, alias='data-flow')\n    responsible_parties: Optional[List[common.ResponsibleParty]] = Field(None, alias='responsible-parties')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.authorization_boundary","title":"<code>authorization_boundary: AuthorizationBoundary</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.data_flow","title":"<code>data_flow: DataFlow</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.date_authorized","title":"<code>date_authorized: DateAuthorized</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A summary of the system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.network_architecture","title":"<code>network_architecture: NetworkArchitecture</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.responsible_parties","title":"<code>responsible_parties: List[trestle.oscal.common.ResponsibleParty]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.security_impact_level","title":"<code>security_impact_level: SecurityImpactLevel</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.security_sensitivity_level","title":"<code>security_sensitivity_level: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The overall information system sensitivity categorization, such as defined by FIPS-199.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.status","title":"<code>status: Status1</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.system_ids","title":"<code>system_ids: List[trestle.oscal.common.SystemId]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.system_information","title":"<code>system_information: SystemInformation</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.system_name","title":"<code>system_name: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>The full name of the system.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.system_name_short","title":"<code>system_name_short: ConstrainedStrValue</code>  <code>pydantic-field</code>","text":"<p>A short name for the system, such as an acronym, that is suitable for display in a data table or summary list.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemCharacteristics.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent","title":"<code> SystemComponent            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A defined component that can be part of an implemented system.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class SystemComponent(OscalBaseModel):\n\"\"\"\n    A defined component that can be part of an implemented system.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='Component Identifier',\n    )\n    type: constr(regex=r'^\\S(.*\\S)?$') = Field(\n        ...,\n        description='A category describing the purpose of the component.',\n        title='Component Type',\n    )\n    title: str = Field(\n        ...,\n        description='A human readable name for the system component.',\n        title='Component Title',\n    )\n    description: str = Field(\n        ...,\n        description='A description of the component, including information about its function.',\n        title='Component Description',\n    )\n    purpose: Optional[str] = Field(\n        None,\n        description='A summary of the technological or business purpose of the component.',\n        title='Purpose',\n    )\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    status: Status = Field(\n        ...,\n        description='Describes the operational status of the system component.',\n        title='Status',\n    )\n    responsible_roles: Optional[List[common.ResponsibleRole]] = Field(None, alias='responsible-roles')\n    protocols: Optional[List[common.Protocol]] = Field(None)\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.description","title":"<code>description: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A description of the component, including information about its function.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.protocols","title":"<code>protocols: List[trestle.oscal.common.Protocol]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.purpose","title":"<code>purpose: str</code>  <code>pydantic-field</code>","text":"<p>A summary of the technological or business purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.responsible_roles","title":"<code>responsible_roles: List[trestle.oscal.common.ResponsibleRole]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.status","title":"<code>status: Status</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>Describes the operational status of the system component.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.title","title":"<code>title: str</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A human readable name for the system component.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.type","title":"<code>type: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A category describing the purpose of the component.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this component elsewhere in this or other OSCAL instances. The locally defined UUID of the component can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance). This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemComponent.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemImplementation","title":"<code> SystemImplementation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Provides information as to how the system is implemented.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class SystemImplementation(OscalBaseModel):\n\"\"\"\n    Provides information as to how the system is implemented.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    leveraged_authorizations: Optional[List[LeveragedAuthorization]] = Field(None, alias='leveraged-authorizations')\n    users: List[common.SystemUser] = Field(...)\n    components: List[SystemComponent] = Field(...)\n    inventory_items: Optional[List[common.InventoryItem]] = Field(None, alias='inventory-items')\n    remarks: Optional[str] = None\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemImplementation.components","title":"<code>components: List[trestle.oscal.ssp.SystemComponent]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemImplementation.inventory_items","title":"<code>inventory_items: List[trestle.oscal.common.InventoryItem]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemImplementation.leveraged_authorizations","title":"<code>leveraged_authorizations: List[trestle.oscal.ssp.LeveragedAuthorization]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemImplementation.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemImplementation.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemImplementation.remarks","title":"<code>remarks: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemImplementation.users","title":"<code>users: List[trestle.oscal.common.SystemUser]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemImplementation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemInformation","title":"<code> SystemInformation            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Contains details about all information types that are stored, processed, or transmitted by the system, such as privacy information, and those defined in NIST SP 800-60.</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class SystemInformation(OscalBaseModel):\n\"\"\"\n    Contains details about all information types that are stored, processed, or transmitted by the system, such as privacy information, and those defined in NIST SP 800-60.\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    props: Optional[List[common.Property]] = Field(None)\n    links: Optional[List[common.Link]] = Field(None)\n    information_types: List[InformationType] = Field(..., alias='information-types')\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemInformation.information_types","title":"<code>information_types: List[trestle.oscal.ssp.InformationType]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemInformation.links","title":"<code>links: List[trestle.oscal.common.Link]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemInformation.props","title":"<code>props: List[trestle.oscal.common.Property]</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemInformation.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan","title":"<code> SystemSecurityPlan            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>A system security plan, such as those described in NIST SP 800-18</p> Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class SystemSecurityPlan(OscalBaseModel):\n\"\"\"\n    A system security plan, such as those described in NIST SP 800-18\n    \"\"\"\n\n    class Config:\n        extra = Extra.forbid\n\n    uuid: constr(\n        regex=r'^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[45][0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$'\n    ) = Field(\n        ...,\n        description=\n        'A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this system security plan (SSP) elsewhere in this or other OSCAL instances. The locally defined UUID of the SSP can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.',\n        title='System Security Plan Universally Unique Identifier',\n    )\n    metadata: common.Metadata\n    import_profile: ImportProfile = Field(..., alias='import-profile')\n    system_characteristics: SystemCharacteristics = Field(..., alias='system-characteristics')\n    system_implementation: SystemImplementation = Field(..., alias='system-implementation')\n    control_implementation: ControlImplementation = Field(..., alias='control-implementation')\n    back_matter: Optional[common.BackMatter] = Field(None, alias='back-matter')\n</code></pre>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan.back_matter","title":"<code>back_matter: BackMatter</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan.control_implementation","title":"<code>control_implementation: ControlImplementation</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan.import_profile","title":"<code>import_profile: ImportProfile</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan.metadata","title":"<code>metadata: Metadata</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan.system_characteristics","title":"<code>system_characteristics: SystemCharacteristics</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan.system_implementation","title":"<code>system_implementation: SystemImplementation</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan.uuid","title":"<code>uuid: ConstrainedStrValue</code>  <code>pydantic-field</code> <code>required</code>","text":"<p>A machine-oriented, globally unique identifier with cross-instance scope that can be used to reference this system security plan (SSP) elsewhere in this or other OSCAL instances. The locally defined UUID of the SSP can be used to reference the data item locally or globally (e.g., in an imported OSCAL instance).This UUID should be assigned per-subject, which means it should be consistently used to identify the same subject across revisions of the document.</p>"},{"location":"api_reference/trestle.oscal.ssp/#trestle.oscal.ssp.SystemSecurityPlan.Config","title":"<code> Config        </code>","text":"Source code in <code>trestle/oscal/ssp.py</code> <pre><code>class Config:\n    extra = Extra.forbid\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/","title":"base_task","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task","title":"<code>trestle.tasks.base_task</code>","text":"<p>Trestle tasks base templating.</p>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.PassFail","title":"<code> PassFail            (TaskBase)         </code>","text":"<p>Holding pattern template for a task which does nothing and always passes.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>class PassFail(TaskBase):\n\"\"\"\n    Holding pattern template for a task which does nothing and always passes.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'pass-fail'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task pass-fail.\n\n        Attributes:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        logger.info(f'Help information for {self.name} task.')\n        logger.info('This is a template task which reports pass fail depending on the specific configuration.')\n        logger.info(\n            'In this case if no config section is provided the task will fail. This a a task specific behavior.'\n        )\n        logger.info('Configuration flags sit under [task.pass-fail]')\n        logger.info('with two boolean flags')\n        logger.info('execute_status = True/False with a default pass')\n        logger.info('simulate_status = True/False with a default fail')\n        logger.info('Note that if the config file does not have the appropriate section this should fail.')\n        logger.info('The princple goal is a simple development example.')\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        if self._config:\n            outcome = self._config.getboolean('simulate_status', fallback=True)\n            if outcome:\n                return TaskOutcome('simulated-success')\n        return TaskOutcome('simulated-failure')\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide a actual outcome.\"\"\"\n        if self._config:\n            outcome = self._config.getboolean('execute_status', fallback=True)\n            if outcome:\n                return TaskOutcome('success')\n        return TaskOutcome('failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.PassFail.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.PassFail-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.PassFail.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task pass-fail.</p> <p>Attributes:</p> Name Type Description <code>config_object</code> <p>Config section associated with the task.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task pass-fail.\n\n    Attributes:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.PassFail.execute","title":"<code>execute(self)</code>","text":"<p>Provide a actual outcome.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide a actual outcome.\"\"\"\n    if self._config:\n        outcome = self._config.getboolean('execute_status', fallback=True)\n        if outcome:\n            return TaskOutcome('success')\n    return TaskOutcome('failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.PassFail.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    logger.info(f'Help information for {self.name} task.')\n    logger.info('This is a template task which reports pass fail depending on the specific configuration.')\n    logger.info(\n        'In this case if no config section is provided the task will fail. This a a task specific behavior.'\n    )\n    logger.info('Configuration flags sit under [task.pass-fail]')\n    logger.info('with two boolean flags')\n    logger.info('execute_status = True/False with a default pass')\n    logger.info('simulate_status = True/False with a default fail')\n    logger.info('Note that if the config file does not have the appropriate section this should fail.')\n    logger.info('The princple goal is a simple development example.')\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.PassFail.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    if self._config:\n        outcome = self._config.getboolean('simulate_status', fallback=True)\n        if outcome:\n            return TaskOutcome('simulated-success')\n    return TaskOutcome('simulated-failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskBase","title":"<code> TaskBase            (ABC)         </code>","text":"<p>Abstract base class for tasks.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>class TaskBase(ABC):\n\"\"\"\n    Abstract base class for tasks.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name: str = 'base'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"Initialize task base and store config.\"\"\"\n        self._config = config_object\n\n    @abstractmethod\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n\n    @abstractmethod\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Execute the task including potential rollback.\"\"\"\n\n    @abstractmethod\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Simulate the task and report task outcome.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskBase.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskBase-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskBase.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize task base and store config.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"Initialize task base and store config.\"\"\"\n    self._config = config_object\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskBase.execute","title":"<code>execute(self)</code>","text":"<p>Execute the task including potential rollback.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>@abstractmethod\ndef execute(self) -&gt; TaskOutcome:\n\"\"\"Execute the task including potential rollback.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskBase.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>@abstractmethod\ndef print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskBase.simulate","title":"<code>simulate(self)</code>","text":"<p>Simulate the task and report task outcome.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>@abstractmethod\ndef simulate(self) -&gt; TaskOutcome:\n\"\"\"Simulate the task and report task outcome.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskOutcome","title":"<code> TaskOutcome            (Enum)         </code>","text":"<p>Enum describing possible task outcomes.</p> Source code in <code>trestle/tasks/base_task.py</code> <pre><code>class TaskOutcome(Enum):\n\"\"\"Enum describing possible task outcomes.\"\"\"\n\n    SUCCESS = 'success'\n    FAILURE = 'failure'\n    ROLLEDBACK = 'rolledback'\n    SIM_SUCCESS = 'simulated-success'\n    SIM_FAILURE = 'simulated-failure'\n    NOT_IMPLEMENTED = 'not-implemented'\n</code></pre>"},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskOutcome.FAILURE","title":"<code>FAILURE</code>","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskOutcome.NOT_IMPLEMENTED","title":"<code>NOT_IMPLEMENTED</code>","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskOutcome.ROLLEDBACK","title":"<code>ROLLEDBACK</code>","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskOutcome.SIM_FAILURE","title":"<code>SIM_FAILURE</code>","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskOutcome.SIM_SUCCESS","title":"<code>SIM_SUCCESS</code>","text":""},{"location":"api_reference/trestle.tasks.base_task/#trestle.tasks.base_task.TaskOutcome.SUCCESS","title":"<code>SUCCESS</code>","text":""},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/","title":"cis_xlsx_to_oscal_catalog","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog","title":"<code>trestle.tasks.cis_xlsx_to_oscal_catalog</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.timestamp","title":"<code>timestamp</code>","text":""},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CatalogHelper","title":"<code> CatalogHelper        </code>","text":"<p>OSCAL Catalog Helper.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>class CatalogHelper:\n\"\"\"OSCAL Catalog Helper.\"\"\"\n\n    def __init__(self, title: str, version: str) -&gt; None:\n\"\"\"Initialize.\"\"\"\n        # metadata\n        self._metadata = Metadata(title=title, last_modified=timestamp, oscal_version=OSCAL_VERSION, version=version)\n        self._root_group = OrderedDict()\n        self._root_resources = OrderedDict()\n        self._all_groups = OrderedDict()\n        self._all_controls = OrderedDict()\n\n    def add_group(self, section: str, title: str, props: List[Property], parts: List[Part]) -&gt; None:\n\"\"\"Add group.\"\"\"\n        numdots = section.count('.')\n        if numdots == 0:\n            group = Group(title=f'{title}', id=f'CIS-{section}')\n            if props:\n                group.props = props\n            if parts:\n                group.parts = parts\n            self._root_group[section] = group\n            self._all_groups[section] = group\n        else:\n            key = '.'.join(section.split('.')[:-1])\n            parent = self._all_groups[key]\n            if parent.groups is None:\n                parent.groups = []\n            group = Group(title=f'{title}', id=f'CIS-{section}')\n            if props:\n                group.props = props\n            if parts:\n                group.parts = parts\n            parent.groups.append(group)\n            self._all_groups[section] = group\n\n    def _add_prop(self, control: Control, prop: Property) -&gt; None:\n\"\"\"Add property to control.\"\"\"\n        control_props = control.props\n        control.props = []\n        last = 0\n        for i, control_prop in enumerate(control_props):\n            if control_prop.name == prop.name:\n                last = i\n        for i, control_prop in enumerate(control_props):\n            control.props.append(control_prop)\n            if i == last:\n                control.props.append(prop)\n\n    def add_control(\n        self,\n        section: str,\n        recommendation: str,\n        title: str,\n        props: List[Property],\n        parts: List[Part],\n        links: List[Link]\n    ) -&gt; None:\n\"\"\"Add control.\"\"\"\n        group = self._all_groups[section]\n        if group.controls is None:\n            group.controls = []\n        id_ = f'CIS-{recommendation}'\n        if id_ in self._all_controls:\n            control = self._all_controls[id_]\n            for prop in props:\n                if prop.name == 'profile':\n                    self._add_prop(control, prop)\n        else:\n            title = f'{title}'\n            control = Control(id=id_, title=title)\n            self._all_controls[id_] = control\n            if props:\n                control.props = props\n            if parts:\n                control.parts = parts\n            if links:\n                control.links = links\n            group.controls.append(control)\n\n    def add_link(\n        self,\n        recommendation: str,\n        reference: str,\n        links: List[Link],\n    ) -&gt; None:\n\"\"\"Add link.\"\"\"\n        id_ = f'CIS-{recommendation}'\n        if id_ not in self._root_resources:\n            res_id = str(uuid.uuid4())\n            link = Link(href=f'#{res_id}', rel='reference')\n            links.append(link)\n            resource = Resource(\n                uuid=res_id,\n                description=reference,\n            )\n            self._root_resources[id_] = resource\n\n    def get_catalog(self) -&gt; Catalog:\n\"\"\"Get catalog.\"\"\"\n        back_matter = BackMatter(resources=list(self._root_resources.values()))\n        catalog = Catalog(\n            uuid=str(uuid.uuid4()),\n            metadata=self._metadata,\n            groups=list(self._root_group.values()),\n            back_matter=back_matter\n        )\n        return catalog\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CatalogHelper-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CatalogHelper.__init__","title":"<code>__init__(self, title, version)</code>  <code>special</code>","text":"<p>Initialize.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def __init__(self, title: str, version: str) -&gt; None:\n\"\"\"Initialize.\"\"\"\n    # metadata\n    self._metadata = Metadata(title=title, last_modified=timestamp, oscal_version=OSCAL_VERSION, version=version)\n    self._root_group = OrderedDict()\n    self._root_resources = OrderedDict()\n    self._all_groups = OrderedDict()\n    self._all_controls = OrderedDict()\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CatalogHelper.add_control","title":"<code>add_control(self, section, recommendation, title, props, parts, links)</code>","text":"<p>Add control.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def add_control(\n    self,\n    section: str,\n    recommendation: str,\n    title: str,\n    props: List[Property],\n    parts: List[Part],\n    links: List[Link]\n) -&gt; None:\n\"\"\"Add control.\"\"\"\n    group = self._all_groups[section]\n    if group.controls is None:\n        group.controls = []\n    id_ = f'CIS-{recommendation}'\n    if id_ in self._all_controls:\n        control = self._all_controls[id_]\n        for prop in props:\n            if prop.name == 'profile':\n                self._add_prop(control, prop)\n    else:\n        title = f'{title}'\n        control = Control(id=id_, title=title)\n        self._all_controls[id_] = control\n        if props:\n            control.props = props\n        if parts:\n            control.parts = parts\n        if links:\n            control.links = links\n        group.controls.append(control)\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CatalogHelper.add_group","title":"<code>add_group(self, section, title, props, parts)</code>","text":"<p>Add group.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def add_group(self, section: str, title: str, props: List[Property], parts: List[Part]) -&gt; None:\n\"\"\"Add group.\"\"\"\n    numdots = section.count('.')\n    if numdots == 0:\n        group = Group(title=f'{title}', id=f'CIS-{section}')\n        if props:\n            group.props = props\n        if parts:\n            group.parts = parts\n        self._root_group[section] = group\n        self._all_groups[section] = group\n    else:\n        key = '.'.join(section.split('.')[:-1])\n        parent = self._all_groups[key]\n        if parent.groups is None:\n            parent.groups = []\n        group = Group(title=f'{title}', id=f'CIS-{section}')\n        if props:\n            group.props = props\n        if parts:\n            group.parts = parts\n        parent.groups.append(group)\n        self._all_groups[section] = group\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CatalogHelper.add_link","title":"<code>add_link(self, recommendation, reference, links)</code>","text":"<p>Add link.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def add_link(\n    self,\n    recommendation: str,\n    reference: str,\n    links: List[Link],\n) -&gt; None:\n\"\"\"Add link.\"\"\"\n    id_ = f'CIS-{recommendation}'\n    if id_ not in self._root_resources:\n        res_id = str(uuid.uuid4())\n        link = Link(href=f'#{res_id}', rel='reference')\n        links.append(link)\n        resource = Resource(\n            uuid=res_id,\n            description=reference,\n        )\n        self._root_resources[id_] = resource\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CatalogHelper.get_catalog","title":"<code>get_catalog(self)</code>","text":"<p>Get catalog.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def get_catalog(self) -&gt; Catalog:\n\"\"\"Get catalog.\"\"\"\n    back_matter = BackMatter(resources=list(self._root_resources.values()))\n    catalog = Catalog(\n        uuid=str(uuid.uuid4()),\n        metadata=self._metadata,\n        groups=list(self._root_group.values()),\n        back_matter=back_matter\n    )\n    return catalog\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CisXlsxToOscalCatalog","title":"<code> CisXlsxToOscalCatalog            (TaskBase)         </code>","text":"<p>Task to transform CIS .xlsx to OSCAL catalog.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>class CisXlsxToOscalCatalog(TaskBase):\n\"\"\"\n    Task to transform CIS .xlsx to OSCAL catalog.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'cis-xlsx-to-oscal-catalog'\n    ns = 'https://ibm.github.io/compliance-trestle/schemas/oscal/catalog/cis'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task ocp4-cis-profile-to-oscal-catalog.\n\n        Args:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        logger.info(f'Help information for {self.name} task.')\n        logger.info('')\n        logger.info('Purpose: Create catalog from standard (e.g. CIS benchmark).')\n        logger.info('')\n        logger.info('Configuration flags sit under [task.cis-xlsx-to-oscal-catalog]:')\n        text1 = '  input-file             = '\n        text2 = '(required) path to read the compliance-as-code .xlsx spread sheet file.'\n        logger.info(text1 + text2)\n        text1 = '  output-dir             = '\n        text2 = '(required) location to write the generated catalog.json file.'\n        logger.info(text1 + text2)\n        text1 = '  title                  = '\n        text2 = '(required) title of the CIS catalog.'\n        logger.info(text1 + text2)\n        text1 = '  version                = '\n        text2 = '(required) version :q!of the CIS catalog.'\n        logger.info(text1 + text2)\n        text1 = '  output-overwrite       = '\n        text2 = '(optional) true [default] or false; replace existing output when true.'\n        logger.info(text1 + text2)\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        return TaskOutcome('simulated-success')\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n        try:\n            return self._execute()\n        except Exception:\n            logger.info(traceback.format_exc())\n            return TaskOutcome('failure')\n\n    def _get_normalized_name(self, key: str) -&gt; str:\n\"\"\"Get normalized name.\"\"\"\n        name = key\n        name = name.replace(' ', '_')\n        name = name.replace('&amp;', 'a')\n        name = name.replace('(', '')\n        name = name.replace(')', '')\n        return name\n\n    def _create_property(self, name: str, value: str) -&gt; Property:\n        return Property(name=name, value=value, ns=CisXlsxToOscalCatalog.ns)\n\n    def _add_property(self, xlsx_helper: XlsxHelper, props: List[Property], row: int, key: str) -&gt; None:\n\"\"\"Add property.\"\"\"\n        name = self._get_normalized_name(key)\n        value = xlsx_helper.get(row, key)\n        if value:\n            props.append(self._create_property(name, value))\n\n    def _add_property_boolean(self, xlsx_helper: XlsxHelper, props: List[Property], row: int, key: str) -&gt; None:\n\"\"\"Add property.\"\"\"\n        name = self._get_normalized_name(key)\n        value = xlsx_helper.get(row, key)\n        if value:\n            props.append(self._create_property(name, 'True'))\n        else:\n            props.append(self._create_property(name, 'False'))\n\n    def _add_part(self, xlsx_helper: XlsxHelper, parts: List[Part], id_: str, row: int, key: str) -&gt; None:\n\"\"\"Add part.\"\"\"\n        value = xlsx_helper.get(row, key)\n        if value:\n            name = self._get_normalized_name(key)\n            parts.append(Part(id=id_, name=name, prose=value))\n\n    def _add_links(\n        self, xlsx_helper: XlsxHelper, catalog_helper: CatalogHelper, links: List[Link], row: int, key: str\n    ) -&gt; None:\n\"\"\"Add links.\"\"\"\n        value = xlsx_helper.get(row, key)\n        if value:\n            recommendation = xlsx_helper.get(row, 'recommendation #')\n            catalog_helper.add_link(recommendation, value, links)\n\n    def _execute(self) -&gt; TaskOutcome:\n\"\"\"Wrap the execute for exception handling.\"\"\"\n        if not self._config:\n            logger.warning('config missing')\n            return TaskOutcome('failure')\n        try:\n            ifile = self._config['input-file']\n            odir = self._config['output-dir']\n            title = self._config['title']\n            version = self._config['version']\n        except KeyError as e:\n            logger.info(f'key {e.args[0]} missing')\n            return TaskOutcome('failure')\n        # verbosity\n        _quiet = self._config.get('quiet', False)\n        _verbose = not _quiet\n        # output\n        overwrite = self._config.getboolean('output-overwrite', True)\n        opth = pathlib.Path(odir)\n        # insure output dir exists\n        opth.mkdir(exist_ok=True, parents=True)\n        # calculate output file name &amp; check writability\n        oname = 'catalog.json'\n        ofile = opth / oname\n        if not overwrite and pathlib.Path(ofile).exists():\n            logger.warning(f'output: {ofile} already exists')\n            return TaskOutcome('failure')\n        xlsx_helper = XlsxHelper(ifile)\n        catalog_helper = CatalogHelper(title, version)\n        if xlsx_helper.is_ocp():\n            self._process_ocp(xlsx_helper, catalog_helper)\n        else:\n            self._process_rhel(xlsx_helper, catalog_helper)\n        catalog = catalog_helper.get_catalog()\n        # write OSCAL ComponentDefinition to file\n        if _verbose:\n            logger.info(f'output: {ofile}')\n        catalog.oscal_write(pathlib.Path(ofile))\n        return TaskOutcome('success')\n\n    def _process_ocp(self, xlsx_helper: XlsxHelper, catalog_helper: CatalogHelper) -&gt; None:\n\"\"\"Process OCP.\"\"\"\n        # transform each row into OSCAL equivalent\n        for row in xlsx_helper.row_generator():\n            section = xlsx_helper.get(row, 'section #')\n            recommendation = xlsx_helper.get(row, 'recommendation #')\n            title = xlsx_helper.get(row, 'title')\n            # init\n            props = []\n            parts = []\n            links = []\n            # props\n            self._add_property(xlsx_helper, props, row, 'profile')\n            self._add_property(xlsx_helper, props, row, 'status')\n            self._add_property(xlsx_helper, props, row, 'assessment status')\n            if recommendation is None:\n                frag = section\n            else:\n                frag = recommendation\n            # parts\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_smt', row, 'statement')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_rat', row, 'rationale statement')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_imp', row, 'impact statement')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_rem', row, 'remediation procedure')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_aud', row, 'audit procedure')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_inf', row, 'additional information')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_ctl', row, 'CIS Controls')\n            # group or control\n            if recommendation is None:\n                catalog_helper.add_group(section, title, props, parts)\n            else:\n                self._add_property_boolean(xlsx_helper, props, row, 'v7 IG1')\n                self._add_property_boolean(xlsx_helper, props, row, 'v7 IG2')\n                self._add_property_boolean(xlsx_helper, props, row, 'v7 IG3')\n                self._add_property_boolean(xlsx_helper, props, row, 'v8 IG1')\n                self._add_property_boolean(xlsx_helper, props, row, 'v8 IG2')\n                self._add_property_boolean(xlsx_helper, props, row, 'v8 IG3')\n                self._add_property(xlsx_helper, props, row, 'MITRE ATT&amp;CK Mappings')\n                self._add_links(xlsx_helper, catalog_helper, links, row, 'references')\n                catalog_helper.add_control(section, recommendation, title, props, parts, links)\n\n    def _process_rhel(self, xlsx_helper: XlsxHelper, catalog_helper: CatalogHelper) -&gt; None:\n\"\"\"Process RHEL.\"\"\"\n        # transform each row into OSCAL equivalent\n        for row in xlsx_helper.row_generator():\n            section = xlsx_helper.get(row, 'section #')\n            recommendation = xlsx_helper.get(row, 'recommendation #')\n            title = xlsx_helper.get(row, 'title')\n            # init\n            props = []\n            parts = []\n            links = []\n            # props\n            self._add_property(xlsx_helper, props, row, 'profile')\n            self._add_property(xlsx_helper, props, row, 'assessment status')\n            if recommendation is None:\n                frag = section\n            else:\n                frag = recommendation\n            # parts\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_smt', row, 'statement')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_rat', row, 'rational statement')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_imp', row, 'impact statement')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_rem', row, 'remediation procedure')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_aud', row, 'audit procedure')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_inf', row, 'additional information')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_ctl', row, 'CIS Controls')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_1v8', row, 'CIS Safeguards 1 (v8)')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_2v8', row, 'CIS Safeguards 2 (v8)')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_3v8', row, 'CIS Safeguards 3 (v8)')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_1v7', row, 'CIS Safeguards 1 (v7)')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_2v7', row, 'CIS Safeguards 2 (v7)')\n            self._add_part(xlsx_helper, parts, f'CIS-{frag}_3v7', row, 'CIS Safeguards 3 (v7)')\n            # group or control\n            if recommendation is None:\n                catalog_helper.add_group(section, title, props, parts)\n            else:\n                self._add_property_boolean(xlsx_helper, props, row, 'v7 IG1')\n                self._add_property_boolean(xlsx_helper, props, row, 'v7 IG2')\n                self._add_property_boolean(xlsx_helper, props, row, 'v7 IG3')\n                self._add_property_boolean(xlsx_helper, props, row, 'v8 IG1')\n                self._add_property_boolean(xlsx_helper, props, row, 'v8 IG2')\n                self._add_property_boolean(xlsx_helper, props, row, 'v8 IG3')\n                self._add_links(xlsx_helper, catalog_helper, links, row, 'references')\n                catalog_helper.add_control(section, recommendation, title, props, parts, links)\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CisXlsxToOscalCatalog.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CisXlsxToOscalCatalog.ns","title":"<code>ns</code>","text":""},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CisXlsxToOscalCatalog-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CisXlsxToOscalCatalog.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task ocp4-cis-profile-to-oscal-catalog.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>Optional[configparser.SectionProxy]</code> <p>Config section associated with the task.</p> required Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task ocp4-cis-profile-to-oscal-catalog.\n\n    Args:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CisXlsxToOscalCatalog.execute","title":"<code>execute(self)</code>","text":"<p>Provide an actual outcome.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n    try:\n        return self._execute()\n    except Exception:\n        logger.info(traceback.format_exc())\n        return TaskOutcome('failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CisXlsxToOscalCatalog.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    logger.info(f'Help information for {self.name} task.')\n    logger.info('')\n    logger.info('Purpose: Create catalog from standard (e.g. CIS benchmark).')\n    logger.info('')\n    logger.info('Configuration flags sit under [task.cis-xlsx-to-oscal-catalog]:')\n    text1 = '  input-file             = '\n    text2 = '(required) path to read the compliance-as-code .xlsx spread sheet file.'\n    logger.info(text1 + text2)\n    text1 = '  output-dir             = '\n    text2 = '(required) location to write the generated catalog.json file.'\n    logger.info(text1 + text2)\n    text1 = '  title                  = '\n    text2 = '(required) title of the CIS catalog.'\n    logger.info(text1 + text2)\n    text1 = '  version                = '\n    text2 = '(required) version :q!of the CIS catalog.'\n    logger.info(text1 + text2)\n    text1 = '  output-overwrite       = '\n    text2 = '(optional) true [default] or false; replace existing output when true.'\n    logger.info(text1 + text2)\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.CisXlsxToOscalCatalog.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    return TaskOutcome('simulated-success')\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.XlsxHelper","title":"<code> XlsxHelper        </code>","text":"<p>Xlsx Helper common functions and assistance navigating spread sheet.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>class XlsxHelper:\n\"\"\"Xlsx Helper common functions and assistance navigating spread sheet.\"\"\"\n\n    def __init__(self, file: str) -&gt; None:\n\"\"\"Initialize.\"\"\"\n        self._spread_sheet = file\n        self._wb = load_workbook(self._spread_sheet)\n        sheet_candidates = ['Combined Profiles', 'Combined']\n        self._sheet_name = None\n        for sheet_candidate in sheet_candidates:\n            if sheet_candidate in self._wb.sheetnames:\n                self._sheet_name = sheet_candidate\n                break\n        if not self._sheet_name:\n            raise RuntimeError(f'{file} missing one of {sheet_candidates} sheet')\n        self._work_sheet = self._wb[self._sheet_name]\n        self._mapper()\n        self._key_to_col_map = {'statement': 'description'}\n\n    def is_ocp(self) -&gt; bool:\n\"\"\"Check if sheet is for OCP.\"\"\"\n        return self._sheet_name == 'Combined Profiles'\n\n    def _normalize(self, name: str) -&gt; str:\n\"\"\"Normalize.\"\"\"\n        return name.lower()\n\n    def _translate(self, name: str) -&gt; str:\n\"\"\"Translate name key to column name.\"\"\"\n        return self._key_to_col_map.get(name, name)\n\n    def _mapper(self) -&gt; None:\n\"\"\"Map columns heading names to column numbers.\"\"\"\n        self._col_name_to_number = {}\n        cols = self._work_sheet.max_column\n        row = 1\n        for col in range(row, cols):\n            cell = self._work_sheet.cell(row, col)\n            if cell.value:\n                name = self._normalize(cell.value)\n                self._col_name_to_number[name] = col\n\n    def row_generator(self) -&gt; Iterator[int]:\n\"\"\"Generate rows until max reached.\"\"\"\n        row = 2\n        while row &lt;= self._work_sheet.max_row:\n            yield row\n            row += 1\n\n    def get(self, row: int, name: str) -&gt; str:\n\"\"\"Get cell value for given row and column name.\"\"\"\n        nname = self._normalize(name)\n        cname = self._translate(nname)\n        col = self._col_name_to_number[cname]\n        cell = self._work_sheet.cell(row, col)\n        return cell.value\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.XlsxHelper-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.XlsxHelper.__init__","title":"<code>__init__(self, file)</code>  <code>special</code>","text":"<p>Initialize.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def __init__(self, file: str) -&gt; None:\n\"\"\"Initialize.\"\"\"\n    self._spread_sheet = file\n    self._wb = load_workbook(self._spread_sheet)\n    sheet_candidates = ['Combined Profiles', 'Combined']\n    self._sheet_name = None\n    for sheet_candidate in sheet_candidates:\n        if sheet_candidate in self._wb.sheetnames:\n            self._sheet_name = sheet_candidate\n            break\n    if not self._sheet_name:\n        raise RuntimeError(f'{file} missing one of {sheet_candidates} sheet')\n    self._work_sheet = self._wb[self._sheet_name]\n    self._mapper()\n    self._key_to_col_map = {'statement': 'description'}\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.XlsxHelper.get","title":"<code>get(self, row, name)</code>","text":"<p>Get cell value for given row and column name.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def get(self, row: int, name: str) -&gt; str:\n\"\"\"Get cell value for given row and column name.\"\"\"\n    nname = self._normalize(name)\n    cname = self._translate(nname)\n    col = self._col_name_to_number[cname]\n    cell = self._work_sheet.cell(row, col)\n    return cell.value\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.XlsxHelper.is_ocp","title":"<code>is_ocp(self)</code>","text":"<p>Check if sheet is for OCP.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def is_ocp(self) -&gt; bool:\n\"\"\"Check if sheet is for OCP.\"\"\"\n    return self._sheet_name == 'Combined Profiles'\n</code></pre>"},{"location":"api_reference/trestle.tasks.cis_xlsx_to_oscal_catalog/#trestle.tasks.cis_xlsx_to_oscal_catalog.XlsxHelper.row_generator","title":"<code>row_generator(self)</code>","text":"<p>Generate rows until max reached.</p> Source code in <code>trestle/tasks/cis_xlsx_to_oscal_catalog.py</code> <pre><code>def row_generator(self) -&gt; Iterator[int]:\n\"\"\"Generate rows until max reached.\"\"\"\n    row = 2\n    while row &lt;= self._work_sheet.max_row:\n        yield row\n        row += 1\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/","title":"csv_to_oscal_cd","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd","title":"<code>trestle.tasks.csv_to_oscal_cd</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CHECK_DESCRIPTION","title":"<code>CHECK_DESCRIPTION</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CHECK_ID","title":"<code>CHECK_ID</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.COMPONENT_DESCRIPTION","title":"<code>COMPONENT_DESCRIPTION</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.COMPONENT_TITLE","title":"<code>COMPONENT_TITLE</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.COMPONENT_TYPE","title":"<code>COMPONENT_TYPE</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CONTROL_ID_LIST","title":"<code>CONTROL_ID_LIST</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.HEADER_DECORATION_CHAR","title":"<code>HEADER_DECORATION_CHAR</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.NAMESPACE","title":"<code>NAMESPACE</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.PARAMETER_DESCRIPTION","title":"<code>PARAMETER_DESCRIPTION</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.PARAMETER_ID","title":"<code>PARAMETER_ID</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.PARAMETER_VALUE_ALTERNATIVES","title":"<code>PARAMETER_VALUE_ALTERNATIVES</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.PARAMETER_VALUE_DEFAULT","title":"<code>PARAMETER_VALUE_DEFAULT</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.PROFILE_DESCRIPTION","title":"<code>PROFILE_DESCRIPTION</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.PROFILE_SOURCE","title":"<code>PROFILE_SOURCE</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.RULE_DESCRIPTION","title":"<code>RULE_DESCRIPTION</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.RULE_ID","title":"<code>RULE_ID</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn","title":"<code> CsvColumn        </code>","text":"<p>CsvColumn.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>class CsvColumn():\n\"\"\"CsvColumn.\"\"\"\n\n    columns_required = [\n        f'{COMPONENT_TITLE}',\n        f'{COMPONENT_DESCRIPTION}',\n        f'{COMPONENT_TYPE}',\n        f'{RULE_ID}',\n        f'{RULE_DESCRIPTION}',\n        f'{PROFILE_SOURCE}',\n        f'{PROFILE_DESCRIPTION}',\n        f'{CONTROL_ID_LIST}',\n        f'{NAMESPACE}',\n    ]\n\n    # columns required which do not become properties\n    columns_required_filtered = [\n        f'{COMPONENT_TITLE}',\n        f'{COMPONENT_DESCRIPTION}',\n        f'{COMPONENT_TYPE}',\n        f'{PROFILE_SOURCE}',\n        f'{PROFILE_DESCRIPTION}',\n        f'{CONTROL_ID_LIST}',\n        f'{NAMESPACE}',\n    ]\n\n    columns_optional = [\n        f'{PARAMETER_ID}',\n        f'{PARAMETER_DESCRIPTION}',\n        f'{PARAMETER_VALUE_ALTERNATIVES}',\n        f'{PARAMETER_VALUE_DEFAULT}',\n        f'{CHECK_ID}',\n        f'{CHECK_DESCRIPTION}',\n    ]\n\n    # optional columns which do not become properties, initially\n    columns_optional_filtered = [\n        f'{PARAMETER_ID}',\n        f'{PARAMETER_DESCRIPTION}',\n        f'{PARAMETER_VALUE_ALTERNATIVES}',\n        f'{PARAMETER_VALUE_DEFAULT}',\n    ]\n\n    # optional columns which do become properties, afterwards\n    columns_parameters = [\n        f'{PARAMETER_ID}',\n        f'{PARAMETER_DESCRIPTION}',\n        f'{PARAMETER_VALUE_ALTERNATIVES}',\n    ]\n\n    # optional columns which require Param_Id be present in the row\n    columns_parameters_dependent = [\n        f'{PARAMETER_DESCRIPTION}',\n        f'{PARAMETER_VALUE_ALTERNATIVES}',\n        f'{PARAMETER_VALUE_DEFAULT}',\n    ]\n\n    columns_filtered = columns_required_filtered + columns_optional_filtered\n\n    @staticmethod\n    def get_order(column_name: str) -&gt; int:\n\"\"\"Get order for column_name.\"\"\"\n        rval = sys.maxsize\n        columns_ordered = CsvColumn.columns_required + CsvColumn.columns_optional\n        if column_name in columns_ordered:\n            rval = columns_ordered.index(column_name)\n        return rval\n\n    @staticmethod\n    def get_required_column_names() -&gt; List[str]:\n\"\"\"Get required column names.\"\"\"\n        rval = []\n        rval += CsvColumn.columns_required\n        return rval\n\n    @staticmethod\n    def get_filtered_required_column_names() -&gt; List[str]:\n\"\"\"Get filtered required column names.\"\"\"\n        rval = []\n        for column_name in CsvColumn.get_required_column_names():\n            if column_name not in CsvColumn.columns_filtered:\n                rval.append(column_name)\n        return rval\n\n    @staticmethod\n    def get_optional_column_names() -&gt; List[str]:\n\"\"\"Get optional column names.\"\"\"\n        rval = []\n        rval += CsvColumn.columns_optional\n        return rval\n\n    @staticmethod\n    def get_filtered_optional_column_names() -&gt; List[str]:\n\"\"\"Get filtered optional column names.\"\"\"\n        rval = []\n        for column_name in CsvColumn.get_optional_column_names():\n            if column_name not in CsvColumn.columns_filtered:\n                rval.append(column_name)\n        return rval\n\n    @staticmethod\n    def get_reserved_column_names() -&gt; List[str]:\n\"\"\"Get reserved column names.\"\"\"\n        rval = []\n        rval += CsvColumn.columns_required\n        rval += CsvColumn.columns_optional\n        return rval\n\n    @staticmethod\n    def get_parameter_column_names() -&gt; List[str]:\n\"\"\"Get parameter column names.\"\"\"\n        rval = []\n        rval += CsvColumn.columns_parameters\n        return rval\n\n    @staticmethod\n    def get_parameter_dependent_column_names() -&gt; List[str]:\n\"\"\"Get parameter dependent column names.\"\"\"\n        rval = []\n        rval += CsvColumn.columns_parameters_dependent\n        return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.columns_filtered","title":"<code>columns_filtered</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.columns_optional","title":"<code>columns_optional</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.columns_optional_filtered","title":"<code>columns_optional_filtered</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.columns_parameters","title":"<code>columns_parameters</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.columns_parameters_dependent","title":"<code>columns_parameters_dependent</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.columns_required","title":"<code>columns_required</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.columns_required_filtered","title":"<code>columns_required_filtered</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.get_filtered_optional_column_names","title":"<code>get_filtered_optional_column_names()</code>  <code>staticmethod</code>","text":"<p>Get filtered optional column names.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>@staticmethod\ndef get_filtered_optional_column_names() -&gt; List[str]:\n\"\"\"Get filtered optional column names.\"\"\"\n    rval = []\n    for column_name in CsvColumn.get_optional_column_names():\n        if column_name not in CsvColumn.columns_filtered:\n            rval.append(column_name)\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.get_filtered_required_column_names","title":"<code>get_filtered_required_column_names()</code>  <code>staticmethod</code>","text":"<p>Get filtered required column names.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>@staticmethod\ndef get_filtered_required_column_names() -&gt; List[str]:\n\"\"\"Get filtered required column names.\"\"\"\n    rval = []\n    for column_name in CsvColumn.get_required_column_names():\n        if column_name not in CsvColumn.columns_filtered:\n            rval.append(column_name)\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.get_optional_column_names","title":"<code>get_optional_column_names()</code>  <code>staticmethod</code>","text":"<p>Get optional column names.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>@staticmethod\ndef get_optional_column_names() -&gt; List[str]:\n\"\"\"Get optional column names.\"\"\"\n    rval = []\n    rval += CsvColumn.columns_optional\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.get_order","title":"<code>get_order(column_name)</code>  <code>staticmethod</code>","text":"<p>Get order for column_name.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>@staticmethod\ndef get_order(column_name: str) -&gt; int:\n\"\"\"Get order for column_name.\"\"\"\n    rval = sys.maxsize\n    columns_ordered = CsvColumn.columns_required + CsvColumn.columns_optional\n    if column_name in columns_ordered:\n        rval = columns_ordered.index(column_name)\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.get_parameter_column_names","title":"<code>get_parameter_column_names()</code>  <code>staticmethod</code>","text":"<p>Get parameter column names.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>@staticmethod\ndef get_parameter_column_names() -&gt; List[str]:\n\"\"\"Get parameter column names.\"\"\"\n    rval = []\n    rval += CsvColumn.columns_parameters\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.get_parameter_dependent_column_names","title":"<code>get_parameter_dependent_column_names()</code>  <code>staticmethod</code>","text":"<p>Get parameter dependent column names.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>@staticmethod\ndef get_parameter_dependent_column_names() -&gt; List[str]:\n\"\"\"Get parameter dependent column names.\"\"\"\n    rval = []\n    rval += CsvColumn.columns_parameters_dependent\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.get_required_column_names","title":"<code>get_required_column_names()</code>  <code>staticmethod</code>","text":"<p>Get required column names.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>@staticmethod\ndef get_required_column_names() -&gt; List[str]:\n\"\"\"Get required column names.\"\"\"\n    rval = []\n    rval += CsvColumn.columns_required\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvColumn.get_reserved_column_names","title":"<code>get_reserved_column_names()</code>  <code>staticmethod</code>","text":"<p>Get reserved column names.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>@staticmethod\ndef get_reserved_column_names() -&gt; List[str]:\n\"\"\"Get reserved column names.\"\"\"\n    rval = []\n    rval += CsvColumn.columns_required\n    rval += CsvColumn.columns_optional\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition","title":"<code> CsvToOscalComponentDefinition            (TaskBase)         </code>","text":"<p>Task to create OSCAL ComponentDefinition json.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>class CsvToOscalComponentDefinition(TaskBase):\n\"\"\"\n    Task to create OSCAL ComponentDefinition json.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'csv-to-oscal-cd'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task csv-to-oscal-cd.\n\n        Args:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        name = self.name\n        oscal_name = 'component_definition'\n        #\n        logger.info(f'Help information for {name} task.')\n        logger.info('')\n        logger.info(f'Purpose: From csv produce OSCAL {oscal_name} file.')\n        logger.info('')\n        logger.info('')\n        logger.info(f'Configuration flags sit under [task.{name}]:')\n        text1 = '  title                = '\n        text2 = '(required) the component definition title.'\n        logger.info(text1 + text2)\n        text1 = '  version              = '\n        text2 = '(required) the component definition version.'\n        logger.info(text1 + text2)\n        text1 = '  csv-file             = '\n        text2 = '(required) the path of the csv file.'\n        text3 = ' [1st row are column headings; 2nd row are column descriptions; 3rd row and beyond is data]'\n        logger.info(text1 + text2 + text3)\n        text1 = '  required columns:      '\n        for text2 in CsvColumn.columns_required:\n            logger.info(text1 + text2)\n            text1 = '                         '\n        text1 = '  optional columns:      '\n        for text2 in CsvColumn.columns_optional:\n            logger.info(text1 + text2)\n            text1 = '                         '\n        text1 = '  output-dir           = '\n        text2 = '(required) the path of the output directory for synthesized OSCAL .json files.'\n        logger.info(text1 + text2)\n        text1 = '  component-definition = '\n        text2 = '(optional) the path of the existing component-definition OSCAL .json file.'\n        logger.info(text1 + text2)\n        text1 = '  class.column-name    = '\n        text2 = f'(optional) the class to associate with the specified column name, e.g. class.{RULE_ID} = scc_class'\n        logger.info(text1 + text2)\n        text1 = '  output-overwrite     = '\n        text2 = '(optional) true [default] or false; replace existing output when true.'\n        logger.info(text1 + text2)\n        text1 = '  validate-controls    = '\n        text2 = '(optional) on, warn, or off [default]; validate controls exist in resolved profile.'\n        logger.info(text1 + text2)\n\n    def configure(self) -&gt; bool:\n\"\"\"Configure.\"\"\"\n        self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                    ).isoformat()\n        # config verbosity\n        self._quiet = self._config.get('quiet', False)\n        self._verbose = not self._quiet\n        # title\n        self._title = self._config.get('title')\n        if self._title is None:\n            logger.warning('config missing \"title\"')\n            return False\n        # version\n        self._version = self._config.get('version')\n        if self._version is None:\n            logger.warning('config missing \"version\"')\n            return False\n        # config csv\n        self._csv_file = self._config.get('csv-file')\n        if self._csv_file is None:\n            logger.warning('config missing \"csv-file\"')\n            return False\n        self._csv_path = pathlib.Path(self._csv_file)\n        if not self._csv_path.exists():\n            logger.warning('\"csv-file\" not found')\n            return False\n        # announce csv\n        if self._verbose:\n            logger.info(f'input: {self._csv_file}')\n        # config cd\n        self._cd_path = None\n        self._cd_file = self._config.get('component-definition')\n        if self._cd_file is not None:\n            self._cd_path = pathlib.Path(self._cd_file)\n            if not self._cd_path.exists():\n                logger.warning('\"component-definition\" not found')\n                return False\n        # workspace\n        self._workspace = os.getcwd()\n        # validate_controls\n        self._validate_controls = self._config.get('validate-controls', 'off')\n        return True\n\n    def get_class(self, name: str) -&gt; str:\n\"\"\"Get class value for specified name from config.\"\"\"\n        key = f'class.{name}'\n        return self._config.get(key)\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        return TaskOutcome('simulated-success')\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an executed outcome.\"\"\"\n        try:\n            return self._execute()\n        except Exception:\n            logger.error(traceback.format_exc())\n            return TaskOutcome('failure')\n\n    def _execute(self) -&gt; TaskOutcome:\n\"\"\"Execute path core.\"\"\"\n        if not self.configure():\n            return TaskOutcome('failure')\n        # config output\n        odir = self._config.get('output-dir')\n        opth = pathlib.Path(odir)\n        self._overwrite = self._config.getboolean('output-overwrite', True)\n        # insure output dir exists\n        opth.mkdir(exist_ok=True, parents=True)\n        # calculate output file name &amp; check writability\n        oname = 'component-definition.json'\n        ofile = opth / oname\n        if not self._overwrite and pathlib.Path(ofile).exists():\n            logger.warning(f'output: {ofile} already exists')\n            return TaskOutcome('failure')\n        # fetch existing component-definition, if any\n        self._cd_mgr = _CdMgr(self._cd_path, self._title, self._timestamp, self._version)\n        # fetch csv\n        self._csv_mgr = _CsvMgr(self._csv_path)\n        # create resolved profile -&gt; catalog helper\n        profile_list = self._csv_mgr.get_profile_list()\n        self._resolved_profile_catalog_helper = _ResolvedProfileCatalogHelper(profile_list, self._workspace)\n        self._unresolved_controls = []\n        # calculate deletion, addition &amp; modification rule lists\n        rules = self._calculate_rules()\n        # calculate deletion, addition &amp; modification set-parameter lists\n        set_params = self._calculate_set_params(rules[2])\n        # calculate deletion, addition &amp; modification control mapping lists\n        control_mappings = self._calculate_control_mappings(rules[2])\n        # rule set manager\n        self._rule_set_id_mgr = _RuleSetIdMgr(self._cd_mgr.get_max_rule_set_number(), len(rules[1]))\n        # rule additions, deletions &amp; modifications (by row)\n        self.rules_del(rules[0])\n        self.rules_add(rules[1])\n        self.rules_mod(rules[2])\n        # set-parameters additions, deletions &amp; modifications (by row)\n        self.set_params_del(set_params[0])\n        self.set_params_add(set_params[1])\n        self.set_params_mod(set_params[2])\n        # control mappings additions, deletions &amp; modifications (by row)\n        self.control_mappings_del(control_mappings[0])\n        self.control_mappings_add(control_mappings[1])\n        # note: control mappings mod is currently not possible\n        # note: add/del user columns not currently supported\n        if len(self._unresolved_controls) &gt; 0:\n            text = f'Unresolved controls: {self._unresolved_controls}'\n            if self._validate_controls == 'warn':\n                logger.warn(text)\n            elif self._validate_controls == 'on':\n                raise RuntimeError(text)\n        # prepare new/revised component definition\n        component_definition = self._cd_mgr.get_component_definition()\n        # write OSCAL ComponentDefinition to file\n        if self._verbose:\n            logger.info(f'output: {ofile}')\n        component_definition.oscal_write(pathlib.Path(ofile))\n        return TaskOutcome('success')\n\n    def _calculate_rules(self) -&gt; tuple:\n\"\"\"Calculate rules add, delete, modify.\"\"\"\n        cd_rules = self._cd_mgr.get_rule_keys()\n        csv_rules = self._csv_mgr.get_rule_keys()\n        del_rules = []\n        add_rules = []\n        mod_rules = []\n        for key in cd_rules:\n            if key in csv_rules:\n                continue\n            else:\n                del_rules.append(key)\n                logger.debug(f'rules del: {key}')\n        for key in csv_rules:\n            if key in cd_rules:\n                mod_rules.append(key)\n                logger.debug(f'rules mod: {key}')\n            else:\n                add_rules.append(key)\n                logger.debug(f'rules add: {key}')\n        return (del_rules, add_rules, mod_rules)\n\n    def _calculate_set_params(self, mod_rules: List) -&gt; tuple:\n\"\"\"Calculate set parameters add, delete, modify.\"\"\"\n        cd_set_params = self._cd_mgr.get_set_params_keys()\n        csv_set_params = self._csv_mgr.get_set_params_keys()\n        del_set_params = []\n        add_set_params = []\n        mod_set_params = []\n        for key in cd_set_params:\n            rule_key = (key[0], key[1], key[2])\n            if rule_key not in mod_rules:\n                continue\n            if key in csv_set_params:\n                continue\n            else:\n                del_set_params.append(key)\n                logger.debug(f'params del: {key}')\n        for key in csv_set_params:\n            rule_key = (key[0], key[1], key[2])\n            if rule_key not in mod_rules:\n                continue\n            if key in cd_set_params:\n                mod_set_params.append(key)\n                logger.debug(f'params mod: {key}')\n            else:\n                add_set_params.append(key)\n                logger.debug(f'prams add: {key}')\n        return (del_set_params, add_set_params, mod_set_params)\n\n    def _calculate_control_mappings(self, mod_rules: List) -&gt; tuple:\n\"\"\"Calculate control mappings add, delete, modify.\"\"\"\n        cd_controls = self._cd_mgr.get_control_keys()\n        csv_controls = self._csv_mgr.get_control_keys()\n        del_control_mappings = []\n        add_control_mappings = []\n        mod_control_mappings = []\n        for key in cd_controls:\n            rule_key = (key[0], key[1], key[2])\n            if rule_key not in mod_rules:\n                continue\n            if key in csv_controls:\n                continue\n            else:\n                del_control_mappings.append(key)\n                logger.debug(f'ctl-maps del: {key}')\n        for key in csv_controls:\n            rule_key = (key[0], key[1], key[2])\n            if rule_key not in mod_rules:\n                continue\n            if key in cd_controls:\n                mod_control_mappings.append(key)\n                logger.debug(f'ctl-maps mod: {key}')\n            else:\n                add_control_mappings.append(key)\n                logger.debug(f'ctl-maps add: {key}')\n        return (del_control_mappings, add_control_mappings, mod_control_mappings)\n\n    def _get_namespace(self, rule_key: tuple) -&gt; str:\n\"\"\"Get namespace.\"\"\"\n        return self._csv_mgr.get_value(rule_key, NAMESPACE).strip()\n\n    def _get_prop_name(self, column_name: str) -&gt; str:\n\"\"\"Get property name.\"\"\"\n        return column_name.lstrip('$')\n\n    def rules_del(self, del_rules: List[str]) -&gt; None:\n\"\"\"Delete rules.\"\"\"\n        for tokens in del_rules:\n            component_title = tokens[0]\n            component_type = tokens[1]\n            rule_id = tokens[2]\n            description = ''\n            # component\n            component = self._cd_mgr.get_component(component_title, component_type, description)\n            # props\n            component.props = self._delete_rule_props(component, rule_id)\n\n    def _delete_rule_props(self, component: DefinedComponent, rule_id: str) -&gt; List[Property]:\n\"\"\"Delete rule props.\"\"\"\n        props = []\n        rule_set = _RuleSetHelper.get_rule_set(component.props, rule_id)\n        for prop in component.props:\n            if prop.remarks != rule_set:\n                props.append(prop)\n            elif prop.name == PARAMETER_ID:\n                self._delete_rule_set_parameter(component, prop.value)\n            elif prop.name == RULE_ID:\n                self._delete_rule_implemented_requirement(component, prop.value)\n        return props\n\n    def _control_implementation_generator(\n        self, control_implementations: List[ControlImplementation]\n    ) -&gt; Iterator[ControlImplementation]:\n\"\"\"Control implementation generator.\"\"\"\n        if control_implementations:\n            for control_implementation in control_implementations:\n                yield control_implementation\n\n    def _set_parameter_generator(self, set_parameters: List[SetParameter]) -&gt; Iterator[SetParameter]:\n\"\"\"Set parameter generator.\"\"\"\n        if set_parameters:\n            for set_parameter in set_parameters:\n                yield set_parameter\n\n    def _implemented_requirement_generator(\n        self, implemented_requirements: List[ImplementedRequirement]\n    ) -&gt; Iterator[ImplementedRequirement]:\n\"\"\"Implemented-requirement generator.\"\"\"\n        if implemented_requirements:\n            for implemented_requirement in implemented_requirements:\n                yield implemented_requirement\n\n    def _delete_rule_set_parameter(self, component: DefinedComponent, parameter_id: str) -&gt; None:\n\"\"\"Delete rule set-parameter.\"\"\"\n        control_implementations = component.control_implementations\n        for control_implementation in self._control_implementation_generator(control_implementations):\n            if control_implementation.set_parameters:\n                set_parameters = control_implementation.set_parameters\n                control_implementation.set_parameters = []\n                for set_parameter in set_parameters:\n                    if set_parameter.param_id != parameter_id:\n                        _OscalHelper.add_set_parameter(control_implementation.set_parameters, set_parameter)\n                if not len(control_implementation.set_parameters):\n                    control_implementation.set_parameters = None\n\n    def _delete_rule_implemented_requirement(self, component: DefinedComponent, rule_id: str) -&gt; None:\n\"\"\"Delete rule implemented_requirement.\"\"\"\n        control_implementations = component.control_implementations\n        component.control_implementations = []\n        for control_implementation in self._control_implementation_generator(control_implementations):\n            if control_implementation.implemented_requirements:\n                implemented_requirements = control_implementation.implemented_requirements\n                control_implementation.implemented_requirements = []\n                for implemented_requirement in implemented_requirements:\n                    self._delete_ir_props(implemented_requirement, rule_id)\n                    self._delete_ir_statements(implemented_requirement, rule_id)\n                    if len(as_list(implemented_requirement.props)) or len(as_list(implemented_requirement.statements)):\n                        control_implementation.implemented_requirements.append(implemented_requirement)\n            if len(as_list(control_implementation.implemented_requirements)):\n                component.control_implementations.append(control_implementation)\n\n    def _delete_ir_statements(self, implemented_requirement: ImplementedRequirement, rule_id: str) -&gt; None:\n\"\"\"Delete implemented-requirement statements.\"\"\"\n        if implemented_requirement.statements:\n            statements = implemented_requirement.statements\n            implemented_requirement.statements = []\n            for statement in statements:\n                statement.props = self._delete_props(statement.props, rule_id)\n                if not len(statement.props):\n                    statement.props = None\n                if statement.props:\n                    implemented_requirement.statements.append(statement)\n            if not len(implemented_requirement.statements):\n                implemented_requirement.statements = None\n\n    def _delete_ir_props(self, implemented_requirement: ImplementedRequirement, rule_id: str) -&gt; None:\n\"\"\"Delete implemented-requirement props.\"\"\"\n        if implemented_requirement.props:\n            implemented_requirement.props = self._delete_props(implemented_requirement.props, rule_id)\n            if not len(implemented_requirement.props):\n                implemented_requirement.props = None\n\n    def _delete_props(self, props: List[Property], rule_id: str) -&gt; List[property]:\n\"\"\"Delete props.\"\"\"\n        rval = []\n        if props:\n            for prop in props:\n                if prop.name == RULE_ID and prop.value == rule_id:\n                    continue\n                rval.append(prop)\n        return rval\n\n    def rules_add(self, add_rules: List[str]) -&gt; None:\n\"\"\"Add rules.\"\"\"\n        for rule_key in add_rules:\n            component_title = self._csv_mgr.get_value(rule_key, COMPONENT_TITLE)\n            component_type = self._csv_mgr.get_value(rule_key, COMPONENT_TYPE)\n            component_description = self._csv_mgr.get_value(rule_key, COMPONENT_DESCRIPTION)\n            # component\n            component = self._cd_mgr.get_component(component_title, component_type, component_description)\n            # props\n            component.props = as_list(component.props)\n            component.props = component.props + self._create_rule_props(rule_key)\n            # control implementation\n            source = self._csv_mgr.get_value(rule_key, PROFILE_SOURCE)\n            description = self._csv_mgr.get_value(rule_key, PROFILE_DESCRIPTION)\n            control_implementation = self._get_control_implementation(component, source, description)\n            # set-parameter\n            set_parameter = self._create_set_parameter(rule_key)\n            if set_parameter:\n                control_implementation.set_parameters = as_list(control_implementation.set_parameters)\n                _OscalHelper.add_set_parameter(control_implementation.set_parameters, set_parameter)\n            # control-mappings\n            control_mappings = self._csv_mgr.get_value(rule_key, CONTROL_ID_LIST).split()\n            self._add_rule_prop(control_implementation, control_mappings, rule_key)\n\n    def _add_rule_prop(\n        self, control_implementation: ControlImplementation, control_mappings: List[str], rule_key: tuple\n    ) -&gt; None:\n\"\"\"Add rule prop.\"\"\"\n        namespace = self._get_namespace(rule_key)\n        for control_mapping in control_mappings:\n            control_id = derive_control_id(control_mapping)\n            implemented_requirement = self._get_implemented_requirement(control_implementation, control_id)\n            # create rule implementation (as property)\n            name = RULE_ID\n            prop = Property(\n                name=name,\n                value=self._csv_mgr.get_value(rule_key, name),\n                ns=namespace,\n                class_=self.get_class(name),\n            )\n            part_id = derive_part_id(control_mapping)\n            if part_id is None:\n                implemented_requirement.props = as_list(implemented_requirement.props)\n                implemented_requirement.props.append(prop)\n            else:\n                statement = self._get_statement(implemented_requirement, part_id)\n                statement.props.append(prop)\n\n    def _create_rule_props(self, rule_key: tuple) -&gt; List[Property]:\n\"\"\"Create rule props.\"\"\"\n        rule_set = self._rule_set_id_mgr.get_next_rule_set_id()\n        row_number = self._csv_mgr.get_row_number(rule_key)\n        rule_set_mgr = _RuleSetMgr(row_number, rule_set)\n        column_names = CsvColumn.get_filtered_required_column_names() + CsvColumn.get_filtered_optional_column_names()\n        namespace = self._get_namespace(rule_key)\n        # req'd &amp; optional props\n        for column_name in column_names:\n            prop_name = self._get_prop_name(column_name)\n            prop_value = self._csv_mgr.get_value(rule_key, column_name).strip()\n            rule_set_mgr.add_prop(prop_name, prop_value, namespace, self.get_class(prop_name))\n        # parameter columns\n        column_names = CsvColumn.get_parameter_column_names()\n        for column_name in column_names:\n            prop_name = self._get_prop_name(column_name)\n            prop_value = self._csv_mgr.get_value(rule_key, column_name).strip()\n            rule_set_mgr.add_prop(prop_name, prop_value, namespace, self.get_class(prop_name))\n        # user props\n        column_names = self._csv_mgr.get_user_column_names()\n        for column_name in column_names:\n            prop_name = self._get_prop_name(column_name)\n            prop_value = self._csv_mgr.get_value(rule_key, column_name).strip()\n            rule_set_mgr.add_prop(prop_name, prop_value, namespace, self.get_class(prop_name))\n        rule_set_mgr.validate()\n        return rule_set_mgr.get_props()\n\n    def _get_control_implementation(\n        self, component: DefinedComponent, source: str, description: str\n    ) -&gt; ControlImplementation:\n\"\"\"Find or create control implementation.\"\"\"\n        component.control_implementations = as_list(component.control_implementations)\n        for control_implementation in component.control_implementations:\n            if control_implementation.source == source and control_implementation.description == description:\n                return control_implementation\n        control_implementation = ControlImplementation(\n            uuid=str(uuid.uuid4()), source=source, description=description, implemented_requirements=[]\n        )\n        component.control_implementations.append(control_implementation)\n        return control_implementation\n\n    def _create_set_parameter(self, rule_key: tuple) -&gt; SetParameter:\n\"\"\"Create create set parameters.\"\"\"\n        set_parameter = None\n        name = self._csv_mgr.get_value(rule_key, PARAMETER_ID)\n        if name:\n            value = self._csv_mgr.get_value(rule_key, PARAMETER_VALUE_DEFAULT)\n            if value == '':\n                row_number = self._csv_mgr.get_row_number(rule_key)\n                column_name = PARAMETER_VALUE_DEFAULT\n                text = f'row \"{row_number}\" missing value for \"{column_name}\"'\n                raise RuntimeError(text)\n            values = value.split(',')\n            set_parameter = SetParameter(\n                param_id=name,\n                values=values,\n            )\n        return set_parameter\n\n    def _get_implemented_requirement(\n        self, control_implementation: ControlImplementation, control_id: str\n    ) -&gt; ImplementedRequirement:\n\"\"\"Find or create implemented requirement.\"\"\"\n        if self._validate_controls != 'off':\n            if not self._resolved_profile_catalog_helper.validate(control_id):\n                if control_id not in self._unresolved_controls:\n                    self._unresolved_controls.append(control_id)\n        for implemented_requirement in control_implementation.implemented_requirements:\n            if implemented_requirement.control_id == control_id:\n                return implemented_requirement\n        implemented_requirement = ImplementedRequirement(\n            uuid=str(uuid.uuid4()),\n            control_id=control_id,\n            description='',\n        )\n        control_implementation.implemented_requirements.append(implemented_requirement)\n        return implemented_requirement\n\n    def _get_statement(self, implemented_requirement: ImplementedRequirement, part_id: str) -&gt; Statement:\n\"\"\"Find or create statement.\"\"\"\n        implemented_requirement.statements = as_list(implemented_requirement.statements)\n        for statement in implemented_requirement.statements:\n            if statement.statement_id == part_id:\n                return statement\n        statement = Statement(\n            uuid=str(uuid.uuid4()),\n            statement_id=part_id,\n            description='',\n            props=[],\n        )\n        implemented_requirement.statements.append(statement)\n        return statement\n\n    def rules_mod(self, mod_rules: List[str]) -&gt; None:\n\"\"\"Modify rules.\"\"\"\n        for rule_key in mod_rules:\n            component_title = self._csv_mgr.get_value(rule_key, COMPONENT_TITLE)\n            component_type = self._csv_mgr.get_value(rule_key, COMPONENT_TYPE)\n            component_description = self._csv_mgr.get_value(rule_key, COMPONENT_DESCRIPTION)\n            # component\n            component = self._cd_mgr.get_component(component_title, component_type, component_description)\n            # props\n            component.props = self._modify_rule_props(component, rule_key)\n\n    def _modify_rule_props(self, component: DefinedComponent, rule_key: tuple) -&gt; List[Property]:\n\"\"\"Modify rule props.\"\"\"\n        rule_id = self._csv_mgr.get_value(rule_key, RULE_ID)\n        rule_set = _RuleSetHelper.get_rule_set(component.props, rule_id)\n        rule_ns = self._csv_mgr.get_value(rule_key, NAMESPACE)\n        column_names = CsvColumn.get_filtered_required_column_names() + CsvColumn.get_filtered_optional_column_names()\n        # req'd &amp; optional props\n        for column_name in column_names:\n            column_value = self._csv_mgr.get_value(rule_key, column_name).strip()\n            class_ = self.get_class(column_name)\n            self._cd_mgr.update_rule_definition(component, rule_set, column_name, column_value, rule_ns, class_)\n        # parameter columns\n        column_names = CsvColumn.get_parameter_column_names()\n        for column_name in column_names:\n            column_value = self._csv_mgr.get_value(rule_key, column_name).strip()\n            class_ = self.get_class(column_name)\n            self._cd_mgr.update_rule_definition(component, rule_set, column_name, column_value, rule_ns, class_)\n        # user props\n        column_names = self._csv_mgr.get_user_column_names()\n        for column_name in column_names:\n            column_value = self._csv_mgr.get_value(rule_key, column_name).strip()\n            self._cd_mgr.update_rule_definition(component, rule_set, column_name, column_value, rule_ns, class_)\n        return component.props\n\n    def set_params_del(self, del_set_params: List[str]) -&gt; None:\n\"\"\"Set parameters delete.\"\"\"\n        for tokens in del_set_params:\n            component_title = tokens[0]\n            component_type = tokens[1]\n            source = tokens[3]\n            description = tokens[4]\n            param_id = tokens[5]\n            control_implementation = self._cd_mgr.find_control_implementation(\n                component_title, component_type, source, description\n            )\n            if control_implementation:\n                set_parameters = control_implementation.set_parameters\n                control_implementation.set_parameters = []\n                for set_parameter in self._set_parameter_generator(set_parameters):\n                    if set_parameter.param_id == param_id:\n                        continue\n                    _OscalHelper.add_set_parameter(control_implementation.set_parameters, set_parameter)\n                if control_implementation.set_parameters == []:\n                    control_implementation.set_parameters = None\n\n    def set_params_add(self, add_set_params: List[str]) -&gt; None:\n\"\"\"Set parameters add.\"\"\"\n        for tokens in add_set_params:\n            component_title = tokens[0]\n            component_type = tokens[1]\n            rule_id = tokens[2]\n            source = tokens[3]\n            description = tokens[4]\n            param_id = tokens[5]\n            control_implementation = self._cd_mgr.find_control_implementation(\n                component_title, component_type, source, description\n            )\n            control_implementation.set_parameters = as_list(control_implementation.set_parameters)\n            # add\n            rule_key = _CsvMgr.get_rule_key(component_title, component_type, rule_id)\n            values = [self._csv_mgr.get_value(rule_key, PARAMETER_VALUE_DEFAULT)]\n            set_parameter = SetParameter(\n                param_id=param_id,\n                values=values,\n            )\n            _OscalHelper.add_set_parameter(control_implementation.set_parameters, set_parameter)\n\n    def set_params_mod(self, mod_set_params: List[str]) -&gt; None:\n\"\"\"Set parameters modify.\"\"\"\n        for tokens in mod_set_params:\n            component_title = tokens[0]\n            component_type = tokens[1]\n            rule_id = tokens[2]\n            source = tokens[3]\n            description = tokens[4]\n            param_id = tokens[5]\n            control_implementation = self._cd_mgr.find_control_implementation(\n                component_title, component_type, source, description\n            )\n            if control_implementation:\n                set_parameters = control_implementation.set_parameters\n                for set_parameter in self._set_parameter_generator(set_parameters):\n                    if set_parameter.param_id != param_id:\n                        continue\n                    rule_key = _CsvMgr.get_rule_key(component_title, component_type, rule_id)\n                    values = [self._csv_mgr.get_value(rule_key, PARAMETER_VALUE_DEFAULT)]\n                    replacement = SetParameter(\n                        param_id=param_id,\n                        values=values,\n                    )\n                    if set_parameter.values == replacement.values:\n                        continue\n                    logger.debug(f'params-mod: {rule_id} {param_id} {set_parameter.values} -&gt; {replacement.values}')\n                    set_parameter.values = replacement.values\n\n    def _control_mappings_generator(self, control_mappings: List[str]) -&gt; Iterator[List[str]]:\n\"\"\"Control mappings generator.\"\"\"\n        for tokens in control_mappings:\n            component_title = tokens[0]\n            component_type = tokens[1]\n            source = tokens[3]\n            description = tokens[4]\n            control_implementation = self._cd_mgr.find_control_implementation(\n                component_title, component_type, source, description\n            )\n            if control_implementation:\n                yield tokens\n\n    def control_mappings_del(self, del_control_mappings: List[str]) -&gt; None:\n\"\"\"Control mappings delete.\"\"\"\n        for tokens in self._control_mappings_generator(del_control_mappings):\n            component_title = tokens[0]\n            component_type = tokens[1]\n            rule_id = tokens[2]\n            source = tokens[3]\n            description = tokens[4]\n            smt_id = tokens[5]\n            control_id = derive_control_id(smt_id)\n            control_implementation = self._cd_mgr.find_control_implementation(\n                component_title, component_type, source, description\n            )\n            implemented_requirements = control_implementation.implemented_requirements\n            control_implementation.implemented_requirements = []\n            for implemented_requirement in self._implemented_requirement_generator(implemented_requirements):\n                if implemented_requirement.control_id == control_id:\n                    implemented_requirement.statements = _OscalHelper.remove_rule_statement(\n                        implemented_requirement.statements, rule_id, smt_id\n                    )\n                    implemented_requirement.props = _OscalHelper.remove_rule(implemented_requirement.props, rule_id)\n                    if len(as_list(implemented_requirement.props)) or len(as_list(implemented_requirement.statements)):\n                        control_implementation.implemented_requirements.append(implemented_requirement)\n                else:\n                    control_implementation.implemented_requirements.append(implemented_requirement)\n\n    def control_mappings_add(self, add_control_mappings: List[str]) -&gt; None:\n\"\"\"Control mappings add.\"\"\"\n        for tokens in self._control_mappings_generator(add_control_mappings):\n            component_title = tokens[0]\n            component_type = tokens[1]\n            rule_id = tokens[2]\n            source = tokens[3]\n            description = tokens[4]\n            smt_id = tokens[5]\n            control_id = derive_control_id(smt_id)\n            control_implementation = self._cd_mgr.find_control_implementation(\n                component_title, component_type, source, description\n            )\n            implemented_requirement = self._get_implemented_requirement(control_implementation, control_id)\n            # namespace\n            rule_key = (tokens[0], tokens[1], tokens[2])\n            ns = self._get_namespace(rule_key)\n            # create rule implementation (as property)\n            name = RULE_ID\n            prop = Property(\n                name=name,\n                value=rule_id,\n                ns=ns,\n                class_=self.get_class(name),\n            )\n            if smt_id == control_id:\n                implemented_requirement.props = as_list(implemented_requirement.props)\n                implemented_requirement.props.append(prop)\n            else:\n                statement = self._get_statement(implemented_requirement, smt_id)\n                statement.props.append(prop)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task csv-to-oscal-cd.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>Optional[configparser.SectionProxy]</code> <p>Config section associated with the task.</p> required Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task csv-to-oscal-cd.\n\n    Args:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.configure","title":"<code>configure(self)</code>","text":"<p>Configure.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def configure(self) -&gt; bool:\n\"\"\"Configure.\"\"\"\n    self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                ).isoformat()\n    # config verbosity\n    self._quiet = self._config.get('quiet', False)\n    self._verbose = not self._quiet\n    # title\n    self._title = self._config.get('title')\n    if self._title is None:\n        logger.warning('config missing \"title\"')\n        return False\n    # version\n    self._version = self._config.get('version')\n    if self._version is None:\n        logger.warning('config missing \"version\"')\n        return False\n    # config csv\n    self._csv_file = self._config.get('csv-file')\n    if self._csv_file is None:\n        logger.warning('config missing \"csv-file\"')\n        return False\n    self._csv_path = pathlib.Path(self._csv_file)\n    if not self._csv_path.exists():\n        logger.warning('\"csv-file\" not found')\n        return False\n    # announce csv\n    if self._verbose:\n        logger.info(f'input: {self._csv_file}')\n    # config cd\n    self._cd_path = None\n    self._cd_file = self._config.get('component-definition')\n    if self._cd_file is not None:\n        self._cd_path = pathlib.Path(self._cd_file)\n        if not self._cd_path.exists():\n            logger.warning('\"component-definition\" not found')\n            return False\n    # workspace\n    self._workspace = os.getcwd()\n    # validate_controls\n    self._validate_controls = self._config.get('validate-controls', 'off')\n    return True\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.control_mappings_add","title":"<code>control_mappings_add(self, add_control_mappings)</code>","text":"<p>Control mappings add.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def control_mappings_add(self, add_control_mappings: List[str]) -&gt; None:\n\"\"\"Control mappings add.\"\"\"\n    for tokens in self._control_mappings_generator(add_control_mappings):\n        component_title = tokens[0]\n        component_type = tokens[1]\n        rule_id = tokens[2]\n        source = tokens[3]\n        description = tokens[4]\n        smt_id = tokens[5]\n        control_id = derive_control_id(smt_id)\n        control_implementation = self._cd_mgr.find_control_implementation(\n            component_title, component_type, source, description\n        )\n        implemented_requirement = self._get_implemented_requirement(control_implementation, control_id)\n        # namespace\n        rule_key = (tokens[0], tokens[1], tokens[2])\n        ns = self._get_namespace(rule_key)\n        # create rule implementation (as property)\n        name = RULE_ID\n        prop = Property(\n            name=name,\n            value=rule_id,\n            ns=ns,\n            class_=self.get_class(name),\n        )\n        if smt_id == control_id:\n            implemented_requirement.props = as_list(implemented_requirement.props)\n            implemented_requirement.props.append(prop)\n        else:\n            statement = self._get_statement(implemented_requirement, smt_id)\n            statement.props.append(prop)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.control_mappings_del","title":"<code>control_mappings_del(self, del_control_mappings)</code>","text":"<p>Control mappings delete.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def control_mappings_del(self, del_control_mappings: List[str]) -&gt; None:\n\"\"\"Control mappings delete.\"\"\"\n    for tokens in self._control_mappings_generator(del_control_mappings):\n        component_title = tokens[0]\n        component_type = tokens[1]\n        rule_id = tokens[2]\n        source = tokens[3]\n        description = tokens[4]\n        smt_id = tokens[5]\n        control_id = derive_control_id(smt_id)\n        control_implementation = self._cd_mgr.find_control_implementation(\n            component_title, component_type, source, description\n        )\n        implemented_requirements = control_implementation.implemented_requirements\n        control_implementation.implemented_requirements = []\n        for implemented_requirement in self._implemented_requirement_generator(implemented_requirements):\n            if implemented_requirement.control_id == control_id:\n                implemented_requirement.statements = _OscalHelper.remove_rule_statement(\n                    implemented_requirement.statements, rule_id, smt_id\n                )\n                implemented_requirement.props = _OscalHelper.remove_rule(implemented_requirement.props, rule_id)\n                if len(as_list(implemented_requirement.props)) or len(as_list(implemented_requirement.statements)):\n                    control_implementation.implemented_requirements.append(implemented_requirement)\n            else:\n                control_implementation.implemented_requirements.append(implemented_requirement)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.execute","title":"<code>execute(self)</code>","text":"<p>Provide an executed outcome.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an executed outcome.\"\"\"\n    try:\n        return self._execute()\n    except Exception:\n        logger.error(traceback.format_exc())\n        return TaskOutcome('failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.get_class","title":"<code>get_class(self, name)</code>","text":"<p>Get class value for specified name from config.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def get_class(self, name: str) -&gt; str:\n\"\"\"Get class value for specified name from config.\"\"\"\n    key = f'class.{name}'\n    return self._config.get(key)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    name = self.name\n    oscal_name = 'component_definition'\n    #\n    logger.info(f'Help information for {name} task.')\n    logger.info('')\n    logger.info(f'Purpose: From csv produce OSCAL {oscal_name} file.')\n    logger.info('')\n    logger.info('')\n    logger.info(f'Configuration flags sit under [task.{name}]:')\n    text1 = '  title                = '\n    text2 = '(required) the component definition title.'\n    logger.info(text1 + text2)\n    text1 = '  version              = '\n    text2 = '(required) the component definition version.'\n    logger.info(text1 + text2)\n    text1 = '  csv-file             = '\n    text2 = '(required) the path of the csv file.'\n    text3 = ' [1st row are column headings; 2nd row are column descriptions; 3rd row and beyond is data]'\n    logger.info(text1 + text2 + text3)\n    text1 = '  required columns:      '\n    for text2 in CsvColumn.columns_required:\n        logger.info(text1 + text2)\n        text1 = '                         '\n    text1 = '  optional columns:      '\n    for text2 in CsvColumn.columns_optional:\n        logger.info(text1 + text2)\n        text1 = '                         '\n    text1 = '  output-dir           = '\n    text2 = '(required) the path of the output directory for synthesized OSCAL .json files.'\n    logger.info(text1 + text2)\n    text1 = '  component-definition = '\n    text2 = '(optional) the path of the existing component-definition OSCAL .json file.'\n    logger.info(text1 + text2)\n    text1 = '  class.column-name    = '\n    text2 = f'(optional) the class to associate with the specified column name, e.g. class.{RULE_ID} = scc_class'\n    logger.info(text1 + text2)\n    text1 = '  output-overwrite     = '\n    text2 = '(optional) true [default] or false; replace existing output when true.'\n    logger.info(text1 + text2)\n    text1 = '  validate-controls    = '\n    text2 = '(optional) on, warn, or off [default]; validate controls exist in resolved profile.'\n    logger.info(text1 + text2)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.rules_add","title":"<code>rules_add(self, add_rules)</code>","text":"<p>Add rules.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def rules_add(self, add_rules: List[str]) -&gt; None:\n\"\"\"Add rules.\"\"\"\n    for rule_key in add_rules:\n        component_title = self._csv_mgr.get_value(rule_key, COMPONENT_TITLE)\n        component_type = self._csv_mgr.get_value(rule_key, COMPONENT_TYPE)\n        component_description = self._csv_mgr.get_value(rule_key, COMPONENT_DESCRIPTION)\n        # component\n        component = self._cd_mgr.get_component(component_title, component_type, component_description)\n        # props\n        component.props = as_list(component.props)\n        component.props = component.props + self._create_rule_props(rule_key)\n        # control implementation\n        source = self._csv_mgr.get_value(rule_key, PROFILE_SOURCE)\n        description = self._csv_mgr.get_value(rule_key, PROFILE_DESCRIPTION)\n        control_implementation = self._get_control_implementation(component, source, description)\n        # set-parameter\n        set_parameter = self._create_set_parameter(rule_key)\n        if set_parameter:\n            control_implementation.set_parameters = as_list(control_implementation.set_parameters)\n            _OscalHelper.add_set_parameter(control_implementation.set_parameters, set_parameter)\n        # control-mappings\n        control_mappings = self._csv_mgr.get_value(rule_key, CONTROL_ID_LIST).split()\n        self._add_rule_prop(control_implementation, control_mappings, rule_key)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.rules_del","title":"<code>rules_del(self, del_rules)</code>","text":"<p>Delete rules.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def rules_del(self, del_rules: List[str]) -&gt; None:\n\"\"\"Delete rules.\"\"\"\n    for tokens in del_rules:\n        component_title = tokens[0]\n        component_type = tokens[1]\n        rule_id = tokens[2]\n        description = ''\n        # component\n        component = self._cd_mgr.get_component(component_title, component_type, description)\n        # props\n        component.props = self._delete_rule_props(component, rule_id)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.rules_mod","title":"<code>rules_mod(self, mod_rules)</code>","text":"<p>Modify rules.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def rules_mod(self, mod_rules: List[str]) -&gt; None:\n\"\"\"Modify rules.\"\"\"\n    for rule_key in mod_rules:\n        component_title = self._csv_mgr.get_value(rule_key, COMPONENT_TITLE)\n        component_type = self._csv_mgr.get_value(rule_key, COMPONENT_TYPE)\n        component_description = self._csv_mgr.get_value(rule_key, COMPONENT_DESCRIPTION)\n        # component\n        component = self._cd_mgr.get_component(component_title, component_type, component_description)\n        # props\n        component.props = self._modify_rule_props(component, rule_key)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.set_params_add","title":"<code>set_params_add(self, add_set_params)</code>","text":"<p>Set parameters add.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def set_params_add(self, add_set_params: List[str]) -&gt; None:\n\"\"\"Set parameters add.\"\"\"\n    for tokens in add_set_params:\n        component_title = tokens[0]\n        component_type = tokens[1]\n        rule_id = tokens[2]\n        source = tokens[3]\n        description = tokens[4]\n        param_id = tokens[5]\n        control_implementation = self._cd_mgr.find_control_implementation(\n            component_title, component_type, source, description\n        )\n        control_implementation.set_parameters = as_list(control_implementation.set_parameters)\n        # add\n        rule_key = _CsvMgr.get_rule_key(component_title, component_type, rule_id)\n        values = [self._csv_mgr.get_value(rule_key, PARAMETER_VALUE_DEFAULT)]\n        set_parameter = SetParameter(\n            param_id=param_id,\n            values=values,\n        )\n        _OscalHelper.add_set_parameter(control_implementation.set_parameters, set_parameter)\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.set_params_del","title":"<code>set_params_del(self, del_set_params)</code>","text":"<p>Set parameters delete.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def set_params_del(self, del_set_params: List[str]) -&gt; None:\n\"\"\"Set parameters delete.\"\"\"\n    for tokens in del_set_params:\n        component_title = tokens[0]\n        component_type = tokens[1]\n        source = tokens[3]\n        description = tokens[4]\n        param_id = tokens[5]\n        control_implementation = self._cd_mgr.find_control_implementation(\n            component_title, component_type, source, description\n        )\n        if control_implementation:\n            set_parameters = control_implementation.set_parameters\n            control_implementation.set_parameters = []\n            for set_parameter in self._set_parameter_generator(set_parameters):\n                if set_parameter.param_id == param_id:\n                    continue\n                _OscalHelper.add_set_parameter(control_implementation.set_parameters, set_parameter)\n            if control_implementation.set_parameters == []:\n                control_implementation.set_parameters = None\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.set_params_mod","title":"<code>set_params_mod(self, mod_set_params)</code>","text":"<p>Set parameters modify.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def set_params_mod(self, mod_set_params: List[str]) -&gt; None:\n\"\"\"Set parameters modify.\"\"\"\n    for tokens in mod_set_params:\n        component_title = tokens[0]\n        component_type = tokens[1]\n        rule_id = tokens[2]\n        source = tokens[3]\n        description = tokens[4]\n        param_id = tokens[5]\n        control_implementation = self._cd_mgr.find_control_implementation(\n            component_title, component_type, source, description\n        )\n        if control_implementation:\n            set_parameters = control_implementation.set_parameters\n            for set_parameter in self._set_parameter_generator(set_parameters):\n                if set_parameter.param_id != param_id:\n                    continue\n                rule_key = _CsvMgr.get_rule_key(component_title, component_type, rule_id)\n                values = [self._csv_mgr.get_value(rule_key, PARAMETER_VALUE_DEFAULT)]\n                replacement = SetParameter(\n                    param_id=param_id,\n                    values=values,\n                )\n                if set_parameter.values == replacement.values:\n                    continue\n                logger.debug(f'params-mod: {rule_id} {param_id} {set_parameter.values} -&gt; {replacement.values}')\n                set_parameter.values = replacement.values\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.CsvToOscalComponentDefinition.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    return TaskOutcome('simulated-success')\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd-functions","title":"Functions","text":""},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.derive_control_id","title":"<code>derive_control_id(control_mapping)</code>","text":"<p>Derive control id.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def derive_control_id(control_mapping: str) -&gt; str:\n\"\"\"Derive control id.\"\"\"\n    rval = control_mapping.split('_smt')[0]\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.csv_to_oscal_cd/#trestle.tasks.csv_to_oscal_cd.derive_part_id","title":"<code>derive_part_id(control_mapping)</code>","text":"<p>Derive part id.</p> Source code in <code>trestle/tasks/csv_to_oscal_cd.py</code> <pre><code>def derive_part_id(control_mapping: str) -&gt; str:\n\"\"\"Derive part id.\"\"\"\n    if '_smt.' in control_mapping:\n        rval = control_mapping\n    else:\n        rval = None\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/","title":"ocp4_cis_profile_to_oscal_catalog","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog","title":"<code>trestle.tasks.ocp4_cis_profile_to_oscal_catalog</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Node","title":"<code> Node            (BaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Representation of CIS profile entry.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_catalog.py</code> <pre><code>class Node(BaseModel):\n\"\"\"Representation of CIS profile entry.\"\"\"\n\n    name: Optional[str] = Field(None)\n    description: Optional[str] = Field(None)\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Node.description","title":"<code>description: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Node.name","title":"<code>name: str</code>  <code>pydantic-field</code>","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Ocp4CisProfileToOscalCatalog","title":"<code> Ocp4CisProfileToOscalCatalog            (TaskBase)         </code>","text":"<p>Task to transform OCP4 CIS profile to OSCAL catalog.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_catalog.py</code> <pre><code>class Ocp4CisProfileToOscalCatalog(TaskBase):\n\"\"\"\n    Task to transform OCP4 CIS profile to OSCAL catalog.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'ocp4-cis-profile-to-oscal-catalog'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task ocp4-cis-profile-to-oscal-catalog.\n\n        Args:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n        self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                    ).isoformat()\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        logger.info(f'Help information for {self.name} task.')\n        logger.info('')\n        logger.info('Purpose: Create catalog from standard (e.g. CIS benchmark).')\n        logger.info('')\n        logger.info('Configuration flags sit under [task.ocp4-cis-profile-to-oscal-catalog]:')\n        text1 = '  input-dir              = '\n        text2 = '(required) location to read the compliance-as-code profile files.'\n        logger.info(text1 + text2)\n        text1 = '  output-dir             = '\n        text2 = '(required) location to write the generated catalog.json file.'\n        logger.info(text1 + text2)\n        text1 = '  output-overwrite       = '\n        text2 = '(optional) true [default] or false; replace existing output when true.'\n        logger.info(text1 + text2)\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        return TaskOutcome('simulated-success')\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n        try:\n            return self._execute()\n        except Exception:\n            logger.info(traceback.format_exc())\n            return TaskOutcome('failure')\n\n    def _execute(self) -&gt; TaskOutcome:\n\"\"\"Wrap the execute for exception handling.\"\"\"\n        if not self._config:\n            logger.warning('config missing')\n            return TaskOutcome('failure')\n        try:\n            idir = self._config['input-dir']\n            odir = self._config['output-dir']\n        except KeyError as e:\n            logger.info(f'key {e.args[0]} missing')\n            return TaskOutcome('failure')\n        # verbosity\n        quiet = self._config.get('quiet', False)\n        verbose = not quiet\n        # output\n        overwrite = self._config.getboolean('output-overwrite', True)\n        opth = pathlib.Path(odir)\n        # insure output dir exists\n        opth.mkdir(exist_ok=True, parents=True)\n        # calculate output file name &amp; check writability\n        oname = 'catalog.json'\n        ofile = opth / oname\n        if not overwrite and pathlib.Path(ofile).exists():\n            logger.warning(f'output: {ofile} already exists')\n            return TaskOutcome('failure')\n        # metadata links (optional)\n        metadata_links = self._config.get('metadata-links')\n        # get list or &lt;name&gt;.profile files\n        filelist = self._get_filelist(idir)\n        if len(filelist) &lt; 1:\n            logger.warning(f'input: {idir} no .profile file found')\n            return TaskOutcome('failure')\n        # initialize node list\n        self._node_map = {}\n        # process files\n        for fp in filelist:\n            lines = self._get_content(fp)\n            self._parse(lines)\n        # get root nodes\n        root_nodes = self._get_root_nodes()\n        # groups and controls\n        root = Group(title='root', groups=[])\n        for node in root_nodes:\n            group = Group(title=f'{node.name} {node.description}')\n            root.groups.append(group)\n            depth = self._depth(node.name)\n            if depth == 3:\n                self._add_groups(group, node.name, depth)\n            if depth == 2:\n                self._add_controls(group, node.name, depth)\n        # metadata\n        metadata = Metadata(\n            title=self._title, last_modified=self._timestamp, oscal_version=OSCAL_VERSION, version=trestle.__version__\n        )\n        # metadata links\n        if metadata_links is not None:\n            metadata.links = []\n            for item in metadata_links.split():\n                link = Link(href=item)\n                metadata.links.append(link)\n        # catalog\n        catalog = Catalog(uuid=_uuid(), metadata=metadata, groups=root.groups)\n        # write OSCAL ComponentDefinition to file\n        if verbose:\n            logger.info(f'output: {ofile}')\n        catalog.oscal_write(pathlib.Path(ofile))\n        return TaskOutcome('success')\n\n    def _get_filelist(self, idir: str) -&gt; List[pathlib.Path]:\n\"\"\"Get filelist.\"\"\"\n        return [x for x in pathlib.Path(idir).iterdir() if x.is_file() and x.suffix == '.profile']\n\n    def _get_content(self, fp: pathlib.Path) -&gt; List[str]:\n\"\"\"Fetch content from file.\"\"\"\n        content = None\n        try:\n            f = fp.open('r', encoding=const.FILE_ENCODING)\n            content = f.readlines()\n            f.close()\n            return content\n        except Exception as e:\n            logger.warning(f'unable to process {fp.name}')\n            raise e\n\n    def _parse(self, lines: List[str]) -&gt; None:\n\"\"\"Parse lines to build data structure.\"\"\"\n        for line in lines:\n            line = line.strip()\n            if line.startswith('title: ') and \"'\" in line:\n                self._title = line.split(\"'\")[1]\n                continue\n            line_parts = line.split(None, 2)\n            # must be 3 parts exactly\n            if len(line_parts) &lt; 3:\n                continue\n            # normalized name and description\n            name = line_parts[1].rstrip('.')\n            description = line_parts[2]\n            # name must be numbers and decimal points\n            if not set(name) &lt;= set('0123456789.'):\n                continue\n            # derive desired sortable key from name\n            key = self._get_key(name)\n            self._node_map[key] = Node(name=name, description=description)\n\n    def _get_key(self, name: str) -&gt; (int, int, int):\n\"\"\"Convert name to desired sortable key.\"\"\"\n        parts = name.split('.')\n        if len(parts) == 1:\n            key = (int(parts[0]), 0, 0)\n        elif len(parts) == 2:\n            key = (int(parts[0]), int(parts[1]), 0)\n        elif len(parts) == 3:\n            key = (int(parts[0]), int(parts[1]), int(parts[2]))\n        else:\n            text = f'Unexpected value: {name}'\n            raise RuntimeError(text)\n        return key\n\n    def _get_root_nodes(self) -&gt; ValuesView[Node]:\n\"\"\"Get root nodes.\"\"\"\n        root_nodes = {}\n        for node in self._node_map.values():\n            if len(node.name) == 1:\n                root_nodes[node.name] = node\n        return root_nodes.values()\n\n    def _depth(self, prefix: str) -&gt; int:\n\"\"\"Get maximum depth for prefix.\"\"\"\n        depth = 0\n        for node in self._node_map.values():\n            name = node.name\n            if not name.startswith(prefix):\n                continue\n            dots = name.split('.')\n            if len(dots) &lt;= depth:\n                continue\n            depth = len(dots)\n        return depth\n\n    def _add_controls(self, group: Group, prefix: str, depth: int):\n\"\"\"Add controls to group.\"\"\"\n        controls = []\n        for key in sorted(self._node_map.keys()):\n            node = self._node_map[key]\n            name = node.name\n            if name.startswith(prefix):\n                dots = name.split('.')\n                if len(dots) == depth:\n                    id_ = f'CIS-{node.name}'\n                    title = f'{node.name} {node.description}'\n                    control = Control(id=id_, title=title)\n                    controls.append(control)\n        if len(controls) &gt; 0:\n            group.controls = controls\n\n    def _add_groups(self, group: Group, prefix: str, depth: int):\n\"\"\"Add sub-groups to group.\"\"\"\n        groups = []\n        for key in sorted(self._node_map.keys()):\n            node = self._node_map[key]\n            name = node.name\n            if not name.startswith(prefix):\n                continue\n            if name == prefix:\n                continue\n            dots = name.split('.')\n            if len(dots) != depth - 1:\n                continue\n            title = f'{node.name} {node.description}'\n            sub_group = Group(title=title)\n            groups.append(sub_group)\n            sub_prefix = node.name\n            self._add_controls(sub_group, sub_prefix, depth)\n        if len(groups) &gt; 0:\n            group.groups = groups\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Ocp4CisProfileToOscalCatalog.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Ocp4CisProfileToOscalCatalog-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Ocp4CisProfileToOscalCatalog.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task ocp4-cis-profile-to-oscal-catalog.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>Optional[configparser.SectionProxy]</code> <p>Config section associated with the task.</p> required Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_catalog.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task ocp4-cis-profile-to-oscal-catalog.\n\n    Args:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n    self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                ).isoformat()\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Ocp4CisProfileToOscalCatalog.execute","title":"<code>execute(self)</code>","text":"<p>Provide an actual outcome.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_catalog.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n    try:\n        return self._execute()\n    except Exception:\n        logger.info(traceback.format_exc())\n        return TaskOutcome('failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Ocp4CisProfileToOscalCatalog.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_catalog.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    logger.info(f'Help information for {self.name} task.')\n    logger.info('')\n    logger.info('Purpose: Create catalog from standard (e.g. CIS benchmark).')\n    logger.info('')\n    logger.info('Configuration flags sit under [task.ocp4-cis-profile-to-oscal-catalog]:')\n    text1 = '  input-dir              = '\n    text2 = '(required) location to read the compliance-as-code profile files.'\n    logger.info(text1 + text2)\n    text1 = '  output-dir             = '\n    text2 = '(required) location to write the generated catalog.json file.'\n    logger.info(text1 + text2)\n    text1 = '  output-overwrite       = '\n    text2 = '(optional) true [default] or false; replace existing output when true.'\n    logger.info(text1 + text2)\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_catalog/#trestle.tasks.ocp4_cis_profile_to_oscal_catalog.Ocp4CisProfileToOscalCatalog.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_catalog.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    return TaskOutcome('simulated-success')\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/","title":"ocp4_cis_profile_to_oscal_cd","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd","title":"<code>trestle.tasks.ocp4_cis_profile_to_oscal_cd</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd.Ocp4CisProfileToOscalCD","title":"<code> Ocp4CisProfileToOscalCD            (TaskBase)         </code>","text":"<p>Task to transform OCP4 CIS profile to OSCAL component-definition.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_cd.py</code> <pre><code>class Ocp4CisProfileToOscalCD(TaskBase):\n\"\"\"\n    Task to transform OCP4 CIS profile to OSCAL component-definition.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'ocp4-cis-profile-to-oscal-cd'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task ocp4-cis-profile-to-oscal-cd.\n\n        Args:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n        self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                    ).isoformat()\n\n    def set_timestamp(self, timestamp: str) -&gt; None:\n\"\"\"Set the timestamp.\"\"\"\n        self._timestamp = timestamp\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        logger.info(f'Help information for {self.name} task.')\n        logger.info('')\n        logger.info('Purpose: Create component definition from standard (e.g. CIS benchmark).')\n        logger.info('')\n        logger.info('Configuration flags sit under [task.ocp4-cis-profile-to-oscal-cd]:')\n        text1 = '  component-name         = '\n        text2 = 'component name, e.g. OSCO.'\n        logger.info(text1 + text2)\n        text1 = '  org-name               = '\n        text2 = 'organization name, e.g. International Business Machines.'\n        logger.info(text1 + text2)\n        text1 = '  org-remarks            = '\n        text2 = 'organization remarks, e.g. IBM.'\n        logger.info(text1 + text2)\n        text1 = '  folder-cac             = '\n        text2 = 'folder containing compliance-as-code artifacts, e.g adjunct-data/cis-benchmarks/content.'\n        logger.info(text1 + text2)\n        text1 = '  output-dir             = '\n        text2 = 'location to write the generated component-definition.json file.'\n        logger.info(text1 + text2)\n        #\n        text1 = '  profile-name           = '\n        text2 = 'profile name, e.g. OCP4 CIS-benchmark v4.'\n        logger.info(text1 + text2)\n        text1 = '  profile-mnemonic       = '\n        text2 = 'profile mnemonic, e.g. ocp4-cis-node.'\n        logger.info(text1 + text2)\n        text1 = '  profile-ns             = '\n        text2 = 'profile ns, e.g. https://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud.'\n        logger.info(text1 + text2)\n        text1 = '  profile-version        = '\n        text2 = 'profile version, e.g. 1.1.'\n        logger.info(text1 + text2)\n        text1 = '  profile-check-version  = '\n        text2 = 'profile check version, e.g. 0.1.58.'\n        logger.info(text1 + text2)\n        #\n        text1 = '  profile-type           = '\n        text2 = 'profile type, e.g. OCP4.'\n        logger.info(text1 + text2)\n        text1 = '  profile-list           = '\n        text2 = 'profile list is blank separated list of \"&lt;suffix&gt;\" for config entries: '\n        logger.info(text1 + text2)\n        text1 = '                           profile-file.&lt;suffix&gt;, profile-title.&lt;suffix&gt;, profile-url.&lt;suffix&gt;'\n        text2 = ', e.g. cis cis-node.'\n        logger.info(text1 + text2)\n        text1 = '  profile-file.&lt;suffix&gt;  = '\n        text2 = 'path of the profile file to ingest'\n        text3 = ', e.g. ${folder-cac}/products/ocp4/profiles/cis-node.profile.'  # noqa\n        logger.info(text1 + text2 + text3)\n        text1 = '  profile-title.&lt;suffix&gt; = '\n        text2 = 'title of the profile'\n        text3 = ', e.g. CIS Red Hat OpenShift Container Platform 4 Benchmark.'\n        logger.info(text1 + text2 + text3)\n        text1 = '  profile-url.&lt;suffix&gt;   = '\n        text2 = 'URL of the profile'\n        text3 = ', e.g. https://github.com/ComplianceAsCode/content/blob/master/products/ocp4/profiles/cis.profile.'\n        logger.info(text1 + text2 + text3)\n        text1 = '  rule-to-parameters-map = '\n        text2 = 'map file for set-parameters, e.g. '\n        text3 = 'adjunct-data/task-files/rule2var.json.'\n        logger.info(text1 + text2 + text3)\n        text1 = '  selected-rules         = '\n        text2 = 'file with list of selected rules, e.g. '\n        text3 = 'adjunct-data/task-files/selected_rules.json.'\n        logger.info(text1 + text2 + text3)\n        text1 = '  enabled-rules          = '\n        text2 = 'file with list of enabled rules, e.g. '\n        text3 = 'adjunct-data/task-files/enabled_rules.json.'\n        logger.info(text1 + text2 + text3)\n        #\n        text = ''\n        logger.info(text)\n        text = 'Notes:'\n        logger.info(text)\n        text = '1. If a control has selected rules but no enabled rules, then all those selected are included.'\n        logger.info(text)\n        text = '2. If a control has selected and enabled rules, then only those enabled are included.'\n        logger.info(text)\n        text = '3. If a control has no selected rules, then none are included regardless of enabled.'\n        logger.info(text)\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        return TaskOutcome('simulated-success')\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n        try:\n            return self._execute()\n        except Exception:\n            logger.info(traceback.format_exc())\n            return TaskOutcome('failure')\n\n    def _execute(self) -&gt; TaskOutcome:\n        if not self._config:\n            logger.warning('config missing')\n            return TaskOutcome('failure')\n        try:\n            component_name = self._config['component-name']\n            org_name = self._config['org-name']\n            org_remarks = self._config['org-remarks']\n            self._folder_cac = self._config['folder-cac']\n            profile_check_version = self._config['profile-check-version']\n            profile_type = self._config['profile-type']\n            profile_mnemonic = self._config['profile-mnemonic']\n            profile_name = self._config['profile-name']\n            profile_ns = self._config['profile-ns']\n            profile_version = self._config['profile-version']\n            profile_sets = {}\n            profile_list = self._config['profile-list'].split()\n            for profile in profile_list:\n                profile_sets[profile] = {}\n                profile_sets[profile]['profile-file'] = self._config[f'profile-file.{profile}']\n                profile_sets[profile]['profile-url'] = self._config[f'profile-url.{profile}']\n                profile_sets[profile]['profile-title'] = self._config[f'profile-title.{profile}']\n                profile_sets[profile]['profile-ns'] = profile_ns\n                profile_sets[profile]['component-name'] = component_name\n            odir = self._config['output-dir']\n        except KeyError as e:\n            logger.info(f'key {e.args[0]} missing')\n            return TaskOutcome('failure')\n        # selected rules\n        self._selected_rules = self._get_filter_rules('selected-rules', 'selected')\n        # enabled rules\n        self._enabled_rules = self._get_filter_rules('enabled-rules', 'enabled')\n        # verbosity\n        quiet = self._config.get('quiet', False)\n        verbose = not quiet\n        # output\n        overwrite = self._config.getboolean('output-overwrite', True)\n        opth = pathlib.Path(odir)\n        # insure output dir exists\n        opth.mkdir(exist_ok=True, parents=True)\n        # calculate output file name &amp; check writability\n        oname = 'component-definition.json'\n        ofile = opth / oname\n        if not overwrite and pathlib.Path(ofile).exists():\n            logger.warning(f'output: {ofile} already exists')\n            return TaskOutcome('failure')\n        # fetch rule to parameters map\n        self._rule_to_parm_map = self._get_parameters_map('rule-to-parameters-map')\n        # roles, responsible_roles, parties, responsible parties\n        party_uuid_01 = str(uuid.uuid4())\n        party_uuid_02 = str(uuid.uuid4())\n        party_uuid_03 = str(uuid.uuid4())\n        roles = self._build_roles()\n        responsible_roles = self._build_responsible_roles(party_uuid_01, party_uuid_02, party_uuid_03)\n        parties = self._build_parties(org_name, org_remarks, party_uuid_01, party_uuid_02, party_uuid_03)\n        responsible_parties = self._build_responsible_parties(party_uuid_01, party_uuid_02, party_uuid_03)\n        # metadata\n        metadata = Metadata(\n            title=f'Component definition for {profile_type} profiles',\n            last_modified=self._timestamp,\n            oscal_version=OSCAL_VERSION,\n            version=trestle.__version__,\n            roles=roles,\n            parties=parties,\n            responsible_parties=responsible_parties\n        )\n        # defined component\n        component_title = component_name\n        component_description = component_name\n        defined_component = DefinedComponent(\n            uuid=str(uuid.uuid4()),\n            description=component_description,\n            title=component_title,\n            type='Service',\n        )\n        # add control implementation per profile\n        prop1 = Property(\n            name='profile_name',\n            value=profile_name,\n            class_='scc_profile_name',\n            ns=profile_ns,\n        )\n        prop2 = Property(\n            name='profile_mnemonic',\n            value=profile_mnemonic,\n            class_='scc_profile_mnemonic',\n            ns=profile_ns,\n        )\n        prop3 = Property(\n            name='profile_version',\n            value=profile_version,\n            class_='scc_profile_version',\n            ns=profile_ns,\n        )\n        prop4 = Property(\n            name='profile_check_version',\n            value=profile_check_version,\n        )\n        props = [prop1, prop2, prop3, prop4]\n        for profile in profile_list:\n            profile_set = profile_sets[profile]\n            control_implementation = self._build_control_implementation(profile_set, responsible_roles, props)\n            if control_implementation is not None:\n                if defined_component.control_implementations is None:\n                    defined_component.control_implementations = [control_implementation]\n                else:\n                    defined_component.control_implementations.append(control_implementation)\n        # defined components\n        defined_components = [defined_component]\n        # component definition\n        component_definition = ComponentDefinition(\n            uuid=str(uuid.uuid4()),\n            metadata=metadata,\n            components=defined_components,\n        )\n        # write OSCAL ComponentDefinition to file\n        if verbose:\n            logger.info(f'output: {ofile}')\n        component_definition.oscal_write(pathlib.Path(ofile))\n        return TaskOutcome('success')\n\n    def _get_set_parameter(self, rule: str) -&gt; SetParameter:\n\"\"\"Get set parameter.\"\"\"\n        set_parameter = None\n        for key in self._rule_to_parm_map.keys():\n            logger.debug(f'{key} {rule}')\n            if key == rule:\n                value = self._rule_to_parm_map[key]\n                remarks = value['description']\n                options = value['options']\n                default_value = options['default']\n                logger.debug(f'key: {key} options: {options}')\n                set_parameter = SetParameter(\n                    param_id=rule,\n                    values=[f'{default_value}'],\n                    remarks=remarks,\n                )\n        return set_parameter\n\n    def _get_controls(self, rules: Dict[str, Tuple[str, str, str]]) -&gt; Dict[str, List[str]]:\n\"\"\"Get controls.\"\"\"\n        controls = {}\n        for rule in rules.keys():\n            control = rules[rule][1]\n            if control not in controls.keys():\n                controls[control] = [rule]\n            else:\n                controls[control] = controls[control] + [rule]\n        # trim rules associated with control with respect to enabled rules\n        for control in controls:\n            controls[control] = self._get_trimmed_rules(control, controls[control])\n            logger.debug(f'{control} {controls[control]}')\n        return controls\n\n    # determine if trim is needed for the control, and if so then\n    # for the associated set of rules drop those that are not enabled\n    def _get_trimmed_rules(self, control: str, rules_for_control: List[str]) -&gt; List[str]:\n\"\"\"Trim rules if any rule for control appears in enabled rules list.\"\"\"\n        retval = rules_for_control\n        if self._is_trim_needed(rules_for_control):\n            retval = []\n            for rule in rules_for_control:\n                if rule in self._enabled_rules:\n                    retval = retval + [rule]\n                    logger.debug(f'keep {control} {rule}')\n                else:\n                    logger.debug(f'drop {control} {rule}')\n        return retval\n\n    # if any rule in the set of rules for the control appears in the enabled list,\n    # then trim is needed\n    def _is_trim_needed(self, rules_for_control: List[str]) -&gt; bool:\n\"\"\"Check if trim is needed.\"\"\"\n        retval = False\n        for rule in rules_for_control:\n            if rule in self._enabled_rules:\n                retval = True\n                break\n        return retval\n\n    # fetch the set of rules that will be included/excluded from the CIS rules\n    def _get_parameters_map(self, config_key: str) -&gt; List[str]:\n\"\"\"Get parameters map.\"\"\"\n        try:\n            fp = pathlib.Path(self._config[config_key])\n            f = fp.open('r', encoding=const.FILE_ENCODING)\n            jdata = json.load(f)\n            parameters_map = jdata\n            f.close()\n        except KeyError as e:\n            logger.debug(f'key {e.args[0]} missing')\n            parameters_map = {}\n        except Exception:\n            logger.warning(f'unable to process {self._config[config_key]}')\n            parameters_map = {}\n        return parameters_map\n\n    # fetch the set of rules that will be included/excluded from the CIS rules\n    def _get_filter_rules(self, config_key: str, file_key: str) -&gt; List[str]:\n\"\"\"Get filter rules.\"\"\"\n        try:\n            fp = pathlib.Path(self._config[config_key])\n            f = fp.open('r', encoding=const.FILE_ENCODING)\n            jdata = json.load(f)\n            try:\n                filter_rules = jdata[file_key]\n            except Exception:\n                filter_rules = jdata\n            f.close()\n        except KeyError as e:\n            logger.debug(f'key {e.args[0]} missing')\n            filter_rules = []\n        except Exception:\n            logger.warning(f'unable to process {self._config[config_key]}')\n            filter_rules = []\n        return filter_rules\n\n    # create map from file:\n    # key is rule\n    # value is tuple comprising [ category, control, description ]\n    def _get_cis_rules(self, filename: str) -&gt; Dict[str, Tuple[str, str, str]]:\n\"\"\"Get CIS rules.\"\"\"\n        try:\n            fp = pathlib.Path(filename)\n            f = fp.open('r', encoding=const.FILE_ENCODING)\n            content = f.readlines()\n            rules = self._parse_cis_rules(content)\n            f.close()\n        except Exception:\n            logger.warning(f'unable to process {filename}')\n            rules = {}\n        return rules\n\n    def _parse_cis_rules(self, content: List[str]) -&gt; Dict[str, Tuple[str, str, str]]:\n\"\"\"Parse CIS rules.\"\"\"\n        rules = {}\n        lineno = 0\n        for line in content:\n            lineno += 1\n            line = line.replace('\\n', '')\n            if line.startswith('  #### '):\n                category = line.split('  #### ')[1]\n                logger.debug(f'{lineno} category: {category}')\n            elif line.startswith('  # '):\n                text = line.split('  # ')[1].split(' ', 1)\n                if '.' in text[0]:\n                    control = text[0]\n                    desc = text[1]\n                    logger.debug(f'{lineno} control: {control} description: {desc}')\n                else:\n                    logger.debug(f'{lineno} skip: {line}')\n            elif line.startswith('    - '):\n                rule = line.split('    - ')[1]\n                logger.debug(f'{lineno} rule: {rule}')\n                if not self._is_selected(rule):\n                    logger.debug(f'not selected rule: {rule}')\n                elif rule in rules.keys():\n                    logger.info(f'duplicate rule: {rule}')\n                else:\n                    rules[rule] = [category, control, desc]\n            else:\n                logger.debug(f'{lineno} skip: {line}')\n        return rules\n\n    # rule is selected if:\n    # a) the selected rules file is not specified or is empty or\n    # b) the rule appears in the list of selected rules from the file\n    def _is_selected(self, rule: str) -&gt; bool:\n\"\"\"Check if rule is selected.\"\"\"\n        retval = True\n        if len(self._selected_rules) &gt; 0 and rule not in self._selected_rules:\n            retval = False\n        logger.debug(f'{retval} {rule}')\n        return retval\n\n    # rule is excluded if it does not appear in the list of trimmed rules\n    # for the control\n    def _is_excluded(self, rule: str, control: str, controls: Dict[str, List[str]]) -&gt; bool:\n\"\"\"Check if rule is excluded.\"\"\"\n        retval = False\n        if rule not in controls[control]:\n            logger.debug(f'exclude {rule} {control}')\n            retval = True\n        return retval\n\n    def _build_roles(self) -&gt; List[Role]:\n\"\"\"Build roles.\"\"\"\n        value = [\n            Role(id='prepared-by', title='Indicates the organization that created this content.'),\n            Role(id='prepared-for', title='Indicates the organization for which this content was created..'),\n            Role(\n                id='content-approver',\n                title='Indicates the organization responsible for all content represented in the \"document\".'\n            ),\n        ]\n        return value\n\n    def _build_control_implementation(\n        self, profile_set: Dict[str, str], responsible_roles: List[ResponsibleRole], props: List[Property]\n    ) -&gt; ControlImplementation:\n\"\"\"Build control implementation.\"\"\"\n        implemented_requirements = self._build_implemented_requirements(profile_set, responsible_roles)\n        if len(implemented_requirements) == 0:\n            control_implementation = None\n        else:\n            control_implementation = ControlImplementation(\n                uuid=str(uuid.uuid4()),\n                source=profile_set['profile-url'],\n                description=f'{profile_set[\"component-name\"]} implemented controls for {profile_set[\"profile-title\"]}.',\n                implemented_requirements=implemented_requirements,\n                props=props,\n            )\n        return control_implementation\n\n    def _get_title(self, dir_name: str, root: str) -&gt; str:\n\"\"\"Extract rule title from compliance-as-code rule.yml.\"\"\"\n\"\"\"\n        Operation:\n        Given is a dir_name and a root directory. We walk the\n        directory tree looking for a directory named dir_name.\n        Once found, we read the content of the rule.yml file in\n        that directory. It is likely that we read each rule.yml\n        file exactly once, since each rule appears exactly once\n        in the one or more profiles, e.g. cis-node.profile, which\n        drive the search. From the content, we find the title and\n        return its corresponding value.\n        \"\"\"\n\n        title = None\n        for path, dirs, _files in os.walk(root):\n            if dir_name in dirs:\n                folder = os.path.join(path, dir_name)\n                tpath = pathlib.Path(folder) / 'rule.yml'\n                fp = pathlib.Path(tpath)\n                f = fp.open('r', encoding=const.FILE_ENCODING)\n                content = f.readlines()\n                f.close()\n                for line in content:\n                    if line.startswith('title:'):\n                        title = line.split('title:')[1]\n                        break\n        if title is None:\n            msg = f'unable to find \"{dir_name}\"'\n            logger.warning(msg)\n            title = 'no title'\n        title = title.strip().strip(\"'\").strip('\"')\n        logger.debug(f'{title}')\n        return title\n\n    def _build_implemented_requirements(self, profile_set: Dict[str, str],\n                                        responsible_roles: List[ResponsibleRole]) -&gt; List[ImplementedRequirement]:\n\"\"\"Build implemented requirements.\"\"\"\n        implemented_requirements = []\n        profile_file = profile_set['profile-file']\n        rules = self._get_cis_rules(profile_file)\n        controls = self._get_controls(rules)\n        rule_prefix = 'xccdf_org.ssgproject.content_rule_'\n        cac_openshift = f'{self._folder_cac}/applications/openshift'\n        for rule in rules:\n            if self._is_excluded(rule, rules[rule][1], controls):\n                continue\n            remarks = self._get_title(rule, cac_openshift)\n            prop = Property(\n                class_='scc_goal_name_id',\n                ns=profile_set['profile-ns'],\n                name='XCCDF_rule',\n                value=f'{rule_prefix}{rule}',\n                remarks=f'{remarks}'\n            )\n            props = [prop]\n            implemented_requirement = ImplementedRequirement(\n                uuid=f'{str(uuid.uuid4())}',\n                control_id=f'CIS-{rules[rule][1]}',\n                description=f'{rules[rule][2]}',\n                props=props,\n                responsible_roles=responsible_roles,\n            )\n            set_parameter = self._get_set_parameter(rule)\n            if set_parameter is not None:\n                implemented_requirement.set_parameters = [set_parameter]\n            implemented_requirements.append(implemented_requirement)\n        return implemented_requirements\n\n    def _build_responsible_roles(self, party_uuid_01: str, party_uuid_02: str,\n                                 party_uuid_03: str) -&gt; List[ResponsibleRole]:\n\"\"\"Build responsible roles.\"\"\"\n        role_prepared_by = ResponsibleRole(role_id='prepared-by', party_uuids=[party_uuid_01])\n        role_prepared_for = ResponsibleRole(role_id='prepared-for', party_uuids=[party_uuid_02, party_uuid_03])\n        role_content_approver = ResponsibleRole(role_id='content-approver', party_uuids=[party_uuid_01])\n        value = [\n            role_prepared_by,\n            role_prepared_for,\n            role_content_approver,\n        ]\n        return value\n\n    def _build_parties(\n        self, org_name: str, org_remarks: str, party_uuid_01: str, party_uuid_02: str, party_uuid_03: str\n    ) -&gt; List[Party]:\n\"\"\"Build parties.\"\"\"\n        value = [\n            Party(uuid=party_uuid_01, type='organization', name=org_name, remarks=org_remarks),\n            Party(\n                uuid=party_uuid_02,\n                type='organization',\n                name='Customer',\n                remarks='organization to be customized at account creation only for their Component Definition'\n            ),\n            Party(\n                uuid=party_uuid_03,\n                type='organization',\n                name='ISV',\n                remarks='organization to be customized at ISV subscription only for their Component Definition'\n            ),\n        ]\n        return value\n\n    def _build_responsible_parties(self, party_uuid_01: str, party_uuid_02: str,\n                                   party_uuid_03: str) -&gt; List[ResponsibleParty]:\n\"\"\"Build responsible parties.\"\"\"\n        prepared_by = ResponsibleParty(role_id='prepared-by', party_uuids=[party_uuid_01])\n        prepared_for = ResponsibleParty(role_id='prepared-for', party_uuids=[party_uuid_02, party_uuid_03])\n        content_approver = ResponsibleParty(role_id='content-approver', party_uuids=[party_uuid_01])\n        value = [\n            prepared_by,\n            prepared_for,\n            content_approver,\n        ]\n        return value\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd.Ocp4CisProfileToOscalCD.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd.Ocp4CisProfileToOscalCD-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd.Ocp4CisProfileToOscalCD.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task ocp4-cis-profile-to-oscal-cd.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>Optional[configparser.SectionProxy]</code> <p>Config section associated with the task.</p> required Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_cd.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task ocp4-cis-profile-to-oscal-cd.\n\n    Args:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n    self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                ).isoformat()\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd.Ocp4CisProfileToOscalCD.execute","title":"<code>execute(self)</code>","text":"<p>Provide an actual outcome.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_cd.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n    try:\n        return self._execute()\n    except Exception:\n        logger.info(traceback.format_exc())\n        return TaskOutcome('failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd.Ocp4CisProfileToOscalCD.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_cd.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    logger.info(f'Help information for {self.name} task.')\n    logger.info('')\n    logger.info('Purpose: Create component definition from standard (e.g. CIS benchmark).')\n    logger.info('')\n    logger.info('Configuration flags sit under [task.ocp4-cis-profile-to-oscal-cd]:')\n    text1 = '  component-name         = '\n    text2 = 'component name, e.g. OSCO.'\n    logger.info(text1 + text2)\n    text1 = '  org-name               = '\n    text2 = 'organization name, e.g. International Business Machines.'\n    logger.info(text1 + text2)\n    text1 = '  org-remarks            = '\n    text2 = 'organization remarks, e.g. IBM.'\n    logger.info(text1 + text2)\n    text1 = '  folder-cac             = '\n    text2 = 'folder containing compliance-as-code artifacts, e.g adjunct-data/cis-benchmarks/content.'\n    logger.info(text1 + text2)\n    text1 = '  output-dir             = '\n    text2 = 'location to write the generated component-definition.json file.'\n    logger.info(text1 + text2)\n    #\n    text1 = '  profile-name           = '\n    text2 = 'profile name, e.g. OCP4 CIS-benchmark v4.'\n    logger.info(text1 + text2)\n    text1 = '  profile-mnemonic       = '\n    text2 = 'profile mnemonic, e.g. ocp4-cis-node.'\n    logger.info(text1 + text2)\n    text1 = '  profile-ns             = '\n    text2 = 'profile ns, e.g. https://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud.'\n    logger.info(text1 + text2)\n    text1 = '  profile-version        = '\n    text2 = 'profile version, e.g. 1.1.'\n    logger.info(text1 + text2)\n    text1 = '  profile-check-version  = '\n    text2 = 'profile check version, e.g. 0.1.58.'\n    logger.info(text1 + text2)\n    #\n    text1 = '  profile-type           = '\n    text2 = 'profile type, e.g. OCP4.'\n    logger.info(text1 + text2)\n    text1 = '  profile-list           = '\n    text2 = 'profile list is blank separated list of \"&lt;suffix&gt;\" for config entries: '\n    logger.info(text1 + text2)\n    text1 = '                           profile-file.&lt;suffix&gt;, profile-title.&lt;suffix&gt;, profile-url.&lt;suffix&gt;'\n    text2 = ', e.g. cis cis-node.'\n    logger.info(text1 + text2)\n    text1 = '  profile-file.&lt;suffix&gt;  = '\n    text2 = 'path of the profile file to ingest'\n    text3 = ', e.g. ${folder-cac}/products/ocp4/profiles/cis-node.profile.'  # noqa\n    logger.info(text1 + text2 + text3)\n    text1 = '  profile-title.&lt;suffix&gt; = '\n    text2 = 'title of the profile'\n    text3 = ', e.g. CIS Red Hat OpenShift Container Platform 4 Benchmark.'\n    logger.info(text1 + text2 + text3)\n    text1 = '  profile-url.&lt;suffix&gt;   = '\n    text2 = 'URL of the profile'\n    text3 = ', e.g. https://github.com/ComplianceAsCode/content/blob/master/products/ocp4/profiles/cis.profile.'\n    logger.info(text1 + text2 + text3)\n    text1 = '  rule-to-parameters-map = '\n    text2 = 'map file for set-parameters, e.g. '\n    text3 = 'adjunct-data/task-files/rule2var.json.'\n    logger.info(text1 + text2 + text3)\n    text1 = '  selected-rules         = '\n    text2 = 'file with list of selected rules, e.g. '\n    text3 = 'adjunct-data/task-files/selected_rules.json.'\n    logger.info(text1 + text2 + text3)\n    text1 = '  enabled-rules          = '\n    text2 = 'file with list of enabled rules, e.g. '\n    text3 = 'adjunct-data/task-files/enabled_rules.json.'\n    logger.info(text1 + text2 + text3)\n    #\n    text = ''\n    logger.info(text)\n    text = 'Notes:'\n    logger.info(text)\n    text = '1. If a control has selected rules but no enabled rules, then all those selected are included.'\n    logger.info(text)\n    text = '2. If a control has selected and enabled rules, then only those enabled are included.'\n    logger.info(text)\n    text = '3. If a control has no selected rules, then none are included regardless of enabled.'\n    logger.info(text)\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd.Ocp4CisProfileToOscalCD.set_timestamp","title":"<code>set_timestamp(self, timestamp)</code>","text":"<p>Set the timestamp.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_cd.py</code> <pre><code>def set_timestamp(self, timestamp: str) -&gt; None:\n\"\"\"Set the timestamp.\"\"\"\n    self._timestamp = timestamp\n</code></pre>"},{"location":"api_reference/trestle.tasks.ocp4_cis_profile_to_oscal_cd/#trestle.tasks.ocp4_cis_profile_to_oscal_cd.Ocp4CisProfileToOscalCD.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/ocp4_cis_profile_to_oscal_cd.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    return TaskOutcome('simulated-success')\n</code></pre>"},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/","title":"oscal_profile_to_osco_profile","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile","title":"<code>trestle.tasks.oscal_profile_to_osco_profile</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile.ProfileToOsco","title":"<code> ProfileToOsco            (TaskBase)         </code>","text":"<p>Task to convert Profile to OSC yaml.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/oscal_profile_to_osco_profile.py</code> <pre><code>class ProfileToOsco(TaskBase):\n\"\"\"\n    Task to convert Profile to OSC yaml.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'oscal-profile-to-osco-profile'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task oscal-profile-to-osco-profile.\n\n        Args:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        logger.info(f'Help information for {self.name} task.')\n        logger.info('')\n        logger.info(\n            'Purpose: Transform Open Security Controls Assessment Language (OSCAL) Profile '\n            + 'into Open Shift Compliance Operator (OSCO) .yaml file.'\n        )\n        logger.info('')\n        logger.info('Configuration flags sit under [task.oscal-profile-to-osco-profile]:')\n        logger.info('  input-file = (required) path of the input file comprising OSCAL profile.')\n        logger.info('  output-dir = (required) path of the output directory comprising synthesized .yaml file.')\n        logger.info(\n            '  output-name = (optional) name of created file in output directory, default is osco-profile.yaml.'\n        )\n        logger.info('  output-overwrite = (optional) true [default] or false; replace existing output when true.')\n        logger.info(\n            '  quiet = (optional) true or false [default]; display file creations and rules analysis when false.'\n        )\n        logger.info('')\n        logger.info('Operation: The specified input profile is transformed into OSCO .yaml.')\n        logger.info('')\n        logger.info('Notes:')\n        note11 = '[1] The input-file OSCAL profile should specify a metadata property with'\n        note12 = 'name \"osco_version\" and value of the form \"0.1.46\".'\n        note13 = 'The value corresponds with the OpenShift Compliance Operator (OSCO) version'\n        note14 = 'and affects the format of the emitted yaml.'\n        note15 = 'If not specified, the default is \"0.1.46\".'\n        logger.info(f'{note11} {note12} {note13} {note14} {note15}')\n        note21 = '[2] For OSCO version \"0.1.39\" and prior no \"description\" is emitted for \"spec\".'\n        logger.info(f'{note21}')\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        return TaskOutcome('simulated-success')\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n        try:\n            return self._execute()\n        except Exception:\n            logger.warning(traceback.format_exc())\n            return TaskOutcome('failure')\n\n    def _execute(self) -&gt; TaskOutcome:\n\"\"\"Perform transformation.\"\"\"\n        # check config\n        if not self._config:\n            logger.warning('config missing')\n            return TaskOutcome('failure')\n        # input-file\n        input_file = self._config.get('input-file')\n        if input_file is None:\n            logger.warning('config missing \"input-file\"')\n            return TaskOutcome('failure')\n        logger.info(f'input-file: {input_file}')\n        input_path = pathlib.Path(input_file)\n        # output-dir\n        output_dir = self._config.get('output-dir')\n        if output_dir is None:\n            logger.warning('config missing \"output-dir\"')\n            return TaskOutcome('failure')\n        output_path = pathlib.Path(output_dir)\n        # insure output dir exists\n        output_path.mkdir(exist_ok=True, parents=True)\n        # output file path\n        output_name = self._config.get('output-name', 'osco-profile.yaml')\n        output_filepath = pathlib.Path(output_dir, output_name)\n        logger.info(f'output-file: {output_filepath}')\n        # overwrite\n        overwrite = self._config.getboolean('output-overwrite', True)\n        if not overwrite and pathlib.Path(output_filepath).exists():\n            logger.warning(f'output-file: {output_filepath} already exists')\n            return TaskOutcome('failure')\n        # read input\n        profile = Profile.oscal_read(input_path)\n        # transform\n        transformer = OscalProfileToOscoProfileTransformer()\n        ydata = json.loads(transformer.transform(profile))\n        # write output\n        yaml = YAML(typ='safe')\n        yaml.default_flow_style = False\n        with open(output_filepath, 'w') as outfile:\n            yaml.dump(ydata, outfile)\n        # success\n        return TaskOutcome('success')\n</code></pre>"},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile.ProfileToOsco.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile.ProfileToOsco-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile.ProfileToOsco.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task oscal-profile-to-osco-profile.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>Optional[configparser.SectionProxy]</code> <p>Config section associated with the task.</p> required Source code in <code>trestle/tasks/oscal_profile_to_osco_profile.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task oscal-profile-to-osco-profile.\n\n    Args:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n</code></pre>"},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile.ProfileToOsco.execute","title":"<code>execute(self)</code>","text":"<p>Provide an actual outcome.</p> Source code in <code>trestle/tasks/oscal_profile_to_osco_profile.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n    try:\n        return self._execute()\n    except Exception:\n        logger.warning(traceback.format_exc())\n        return TaskOutcome('failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile.ProfileToOsco.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/oscal_profile_to_osco_profile.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    logger.info(f'Help information for {self.name} task.')\n    logger.info('')\n    logger.info(\n        'Purpose: Transform Open Security Controls Assessment Language (OSCAL) Profile '\n        + 'into Open Shift Compliance Operator (OSCO) .yaml file.'\n    )\n    logger.info('')\n    logger.info('Configuration flags sit under [task.oscal-profile-to-osco-profile]:')\n    logger.info('  input-file = (required) path of the input file comprising OSCAL profile.')\n    logger.info('  output-dir = (required) path of the output directory comprising synthesized .yaml file.')\n    logger.info(\n        '  output-name = (optional) name of created file in output directory, default is osco-profile.yaml.'\n    )\n    logger.info('  output-overwrite = (optional) true [default] or false; replace existing output when true.')\n    logger.info(\n        '  quiet = (optional) true or false [default]; display file creations and rules analysis when false.'\n    )\n    logger.info('')\n    logger.info('Operation: The specified input profile is transformed into OSCO .yaml.')\n    logger.info('')\n    logger.info('Notes:')\n    note11 = '[1] The input-file OSCAL profile should specify a metadata property with'\n    note12 = 'name \"osco_version\" and value of the form \"0.1.46\".'\n    note13 = 'The value corresponds with the OpenShift Compliance Operator (OSCO) version'\n    note14 = 'and affects the format of the emitted yaml.'\n    note15 = 'If not specified, the default is \"0.1.46\".'\n    logger.info(f'{note11} {note12} {note13} {note14} {note15}')\n    note21 = '[2] For OSCO version \"0.1.39\" and prior no \"description\" is emitted for \"spec\".'\n    logger.info(f'{note21}')\n</code></pre>"},{"location":"api_reference/trestle.tasks.oscal_profile_to_osco_profile/#trestle.tasks.oscal_profile_to_osco_profile.ProfileToOsco.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/oscal_profile_to_osco_profile.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    return TaskOutcome('simulated-success')\n</code></pre>"},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/","title":"osco_result_to_oscal_ar","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar","title":"<code>trestle.tasks.osco_result_to_oscal_ar</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar.OscoResultToOscalAR","title":"<code> OscoResultToOscalAR            (TaskBase)         </code>","text":"<p>Task to convert Osco result to OSCAL json.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/osco_result_to_oscal_ar.py</code> <pre><code>class OscoResultToOscalAR(TaskBase):\n\"\"\"\n    Task to convert Osco result to OSCAL json.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'osco-result-to-oscal-ar'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task osco-result-to-oscal-ar.\n\n        Args:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        logger.info(f'Help information for {self.name} task.')\n        logger.info('')\n        logger.info(\n            'Purpose: Transform Osco files into Open Security Controls Assessment Language (OSCAL) '\n            + 'partial results files.'\n        )\n        logger.info('')\n        logger.info('Configuration flags sit under [task.osco-result-to-oscal-ar]:')\n        logger.info(\n            '  checking  = (optional) True indicates perform strict checking of OSCAL properties, default is False.'\n        )\n        logger.info('  input-dir = (required) the path of the input directory comprising Osco results.')\n        logger.info(\n            '  output-dir = (required) the path of the output directory comprising synthesized OSCAL .json files.'\n        )\n        logger.info('  output-overwrite = (optional) true [default] or false; replace existing output when true.')\n        logger.info(\n            '  quiet = (optional) true or false [default]; display file creations and rules analysis when false.'\n        )\n        logger.info(\n            '  timestamp = (optional) timestamp for the Observations in ISO 8601 format, such as '\n            + ' 2021-01-04T00:05:23+04:00 for example; if not specified then value for \"Timestamp\" key in the Osco '\n            + ' result is used if present, otherwise current time is used.'\n        )\n        logger.info('')\n        logger.info(\n            'Operation: A transformation is performed on one or more Osco input files to produce output in OSCAL '\n            + 'partial results format.'\n        )\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        self._simulate = True\n        return self._transform()\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n        self._simulate = False\n        return self._transform()\n\n    def _transform(self) -&gt; TaskOutcome:\n\"\"\"Perform transformation.\"\"\"\n        try:\n            return self._transform_work()\n        except Exception:\n            logger.debug(traceback.format_exc())\n            mode = ''\n            if self._simulate:\n                mode = 'simulated-'\n            return TaskOutcome(mode + 'failure')\n\n    def _transform_work(self) -&gt; TaskOutcome:\n\"\"\"\n        Perform transformation work steps.\n\n        Work steps: read input, process, write output, display analysis\n        \"\"\"\n        mode = ''\n        if self._simulate:\n            mode = 'simulated-'\n        if not self._config:\n            logger.warning('config missing')\n            return TaskOutcome(mode + 'failure')\n        # config required input &amp; output dirs\n        try:\n            idir = self._config['input-dir']\n            ipth = pathlib.Path(idir)\n            odir = self._config['output-dir']\n            opth = pathlib.Path(odir)\n        except KeyError as e:\n            logger.debug(f'key {e.args[0]} missing')\n            return TaskOutcome(mode + 'failure')\n        # config optional overwrite &amp; quiet\n        self._overwrite = self._config.getboolean('output-overwrite', True)\n        quiet = self._config.get('quiet', False)\n        self._verbose = not self._simulate and not quiet\n        # config optional timestamp\n        timestamp = self._config.get('timestamp')\n        if timestamp is not None:\n            try:\n                OscoTransformer.set_timestamp(timestamp)\n            except Exception:\n                logger.warning('config invalid \"timestamp\"')\n                return TaskOutcome(mode + 'failure')\n        # config optional performance\n        modes = {\n            'checking': self._config.getboolean('checking', False),\n        }\n        # insure output dir exists\n        opth.mkdir(exist_ok=True, parents=True)\n        # process\n        for ifile in sorted(ipth.iterdir()):\n            if ifile.suffix not in ['.json', '.jsn', '.yaml', '.yml', '.xml']:\n                continue\n            blob = self._read_file(ifile)\n            osco_transformer = OscoTransformer()\n            osco_transformer.set_modes(modes)\n            results = osco_transformer.transform(blob)\n            oname = ifile.stem + '.oscal' + '.json'\n            ofile = opth / oname\n            if not self._overwrite and pathlib.Path(ofile).exists():\n                logger.warning(f'output: {ofile} already exists')\n                return TaskOutcome(mode + 'failure')\n            self._write_file(results, ofile)\n            self._show_analysis(osco_transformer)\n        return TaskOutcome(mode + 'success')\n\n    def _read_file(self, ifile: str) -&gt; str:\n\"\"\"Read raw input file.\"\"\"\n        if not self._simulate and self._verbose:\n            logger.info(f'input: {ifile}')\n        with open(ifile, encoding=const.FILE_ENCODING) as fp:\n            blob = fp.read()\n        return blob\n\n    def _write_file(self, result: str, ofile: str) -&gt; None:\n\"\"\"Write oscal results file.\"\"\"\n        if not self._simulate:\n            if self._verbose:\n                logger.info(f'output: {ofile}')\n            result.oscal_write(pathlib.Path(ofile))\n\n    def _show_analysis(self, osco_transformer: OscoTransformer) -&gt; None:\n\"\"\"Show analysis.\"\"\"\n        if not self._simulate and self._verbose:\n            analysis = osco_transformer.analysis\n            for line in analysis:\n                logger.info(line)\n</code></pre>"},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar.OscoResultToOscalAR.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar.OscoResultToOscalAR-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar.OscoResultToOscalAR.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task osco-result-to-oscal-ar.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>Optional[configparser.SectionProxy]</code> <p>Config section associated with the task.</p> required Source code in <code>trestle/tasks/osco_result_to_oscal_ar.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task osco-result-to-oscal-ar.\n\n    Args:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n</code></pre>"},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar.OscoResultToOscalAR.execute","title":"<code>execute(self)</code>","text":"<p>Provide an actual outcome.</p> Source code in <code>trestle/tasks/osco_result_to_oscal_ar.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n    self._simulate = False\n    return self._transform()\n</code></pre>"},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar.OscoResultToOscalAR.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/osco_result_to_oscal_ar.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    logger.info(f'Help information for {self.name} task.')\n    logger.info('')\n    logger.info(\n        'Purpose: Transform Osco files into Open Security Controls Assessment Language (OSCAL) '\n        + 'partial results files.'\n    )\n    logger.info('')\n    logger.info('Configuration flags sit under [task.osco-result-to-oscal-ar]:')\n    logger.info(\n        '  checking  = (optional) True indicates perform strict checking of OSCAL properties, default is False.'\n    )\n    logger.info('  input-dir = (required) the path of the input directory comprising Osco results.')\n    logger.info(\n        '  output-dir = (required) the path of the output directory comprising synthesized OSCAL .json files.'\n    )\n    logger.info('  output-overwrite = (optional) true [default] or false; replace existing output when true.')\n    logger.info(\n        '  quiet = (optional) true or false [default]; display file creations and rules analysis when false.'\n    )\n    logger.info(\n        '  timestamp = (optional) timestamp for the Observations in ISO 8601 format, such as '\n        + ' 2021-01-04T00:05:23+04:00 for example; if not specified then value for \"Timestamp\" key in the Osco '\n        + ' result is used if present, otherwise current time is used.'\n    )\n    logger.info('')\n    logger.info(\n        'Operation: A transformation is performed on one or more Osco input files to produce output in OSCAL '\n        + 'partial results format.'\n    )\n</code></pre>"},{"location":"api_reference/trestle.tasks.osco_result_to_oscal_ar/#trestle.tasks.osco_result_to_oscal_ar.OscoResultToOscalAR.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/osco_result_to_oscal_ar.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    self._simulate = True\n    return self._transform()\n</code></pre>"},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/","title":"tanium_result_to_oscal_ar","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar","title":"<code>trestle.tasks.tanium_result_to_oscal_ar</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar.TaniumResultToOscalAR","title":"<code> TaniumResultToOscalAR            (TaskBase)         </code>","text":"<p>Task to convert Tanium result to OSCAL json.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/tanium_result_to_oscal_ar.py</code> <pre><code>class TaniumResultToOscalAR(TaskBase):\n\"\"\"\n    Task to convert Tanium result to OSCAL json.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'tanium-result-to-oscal-ar'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task tanium-result-to-oscal-ar.\n\n        Args:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        logger.info(f'Help information for {self.name} task.')\n        logger.info('')\n        logger.info(\n            'Purpose: Transform Tanium files into Open Security Controls Assessment Language (OSCAL) results objects'\n            + 'and serialize to a file.'\n        )\n        logger.info('')\n        logger.info('Configuration flags sit under [task.tanium-result-to-oscal-ar]:')\n        logger.info('  blocksize = (optional) the desired number Tanuim result input lines to process per CPU.')\n        logger.info('  cpus-max  = (optional) the desired maximum number of CPUs to employ, default is 1.')\n        logger.info('  cpus-min  = (optional) the desired minimum number of CPUs to employ.')\n        logger.info('  aggregate = (optional) True indicates employ properties aggregation, default is True.')\n        logger.info('  caching   = (optional) True indicates employ object caching, default is True.')\n        logger.info(\n            '  checking  = (optional) True indicates perform strict checking of OSCAL properties, default is False.'\n        )\n        logger.info('  input-dir = (required) the path of the input directory comprising Tanium results.')\n        logger.info(\n            '  output-dir = (required) the path of the output directory comprising synthesized OSCAL .json files.'\n        )\n        logger.info('  output-overwrite = (optional) true [default] or false; replace existing output when true.')\n        logger.info(\n            '  quiet = (optional) true or false [default]; display file creations and rules analysis when false.'\n        )\n        logger.info(\n            '  timestamp = (optional) timestamp for the Observations in ISO 8601 format, such as '\n            + '2021-01-04T00:05:23+04:00 for example; if not specified then value for \"Timestamp\" key in the Tanium '\n            + 'result is used if present, otherwise current time is used.'\n        )\n        logger.info('')\n        logger.info(\n            'Operation: A transformation is performed on one or more Tanium input files to produce output in '\n            + 'OSCAL partial results format.'\n        )\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        self._simulate = True\n        return self._transform()\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n        self._simulate = False\n        return self._transform()\n\n    def _transform(self) -&gt; TaskOutcome:\n\"\"\"Perform transformation.\"\"\"\n        try:\n            return self._transform_work()\n        except Exception:\n            logger.info(traceback.format_exc())\n            mode = ''\n            if self._simulate:\n                mode = 'simulated-'\n            return TaskOutcome(mode + 'failure')\n\n    def _transform_work(self) -&gt; TaskOutcome:\n\"\"\"\n        Perform the transformation work.\n\n        Transformation work steps: read input, process, write output, display analysis.\n        \"\"\"\n        mode = ''\n        if self._simulate:\n            mode = 'simulated-'\n        if not self._config:\n            logger.warning('Config missing')\n            return TaskOutcome(mode + 'failure')\n        # config required input &amp; output dirs\n        try:\n            idir = self._config['input-dir']\n            ipth = pathlib.Path(idir)\n            odir = self._config['output-dir']\n            opth = pathlib.Path(odir)\n        except KeyError as e:\n            logger.debug(f'key {e.args[0]} missing')\n            return TaskOutcome(mode + 'failure')\n        # config optional overwrite &amp; quiet\n        self._overwrite = self._config.getboolean('output-overwrite', True)\n        quiet = self._config.get('quiet', False)\n        self._verbose = not self._simulate and not quiet\n        # config optional timestamp\n        timestamp = self._config.get('timestamp')\n        if timestamp is not None:\n            try:\n                TaniumTransformer.set_timestamp(timestamp)\n            except Exception:\n                logger.warning('config invalid \"timestamp\"')\n                return TaskOutcome(mode + 'failure')\n        # config optional performance\n        modes = {\n            'blocksize': self._config.getint('blocksize', 10000),\n            'cpus_max': self._config.getint('cpus-max', 1),\n            'cpus_min': self._config.getint('cpus-min', 1),\n            'aggregate': self._config.getboolean('aggregate', True),\n            'caching': self._config.getboolean('caching', True),\n            'checking': self._config.getboolean('checking', False),\n        }\n        # insure output dir exists\n        opth.mkdir(exist_ok=True, parents=True)\n        # process\n        for ifile in sorted(ipth.iterdir()):\n            blob = self._read_file(ifile)\n            tanium_transformer = TaniumTransformer()\n            tanium_transformer.set_modes(modes)\n            results = tanium_transformer.transform(blob)\n            oname = ifile.stem + '.oscal' + '.json'\n            ofile = opth / oname\n            if not self._overwrite and pathlib.Path(ofile).exists():\n                logger.warning(f'output: {ofile} already exists')\n                return TaskOutcome(mode + 'failure')\n            self._write_file(results, ofile)\n            self._show_analysis(tanium_transformer)\n        return TaskOutcome(mode + 'success')\n\n    def _read_file(self, ifile: str) -&gt; str:\n\"\"\"Read raw input file.\"\"\"\n        if not self._simulate and self._verbose:\n            logger.info(f'input: {ifile}')\n        with open(ifile, 'r', encoding=const.FILE_ENCODING) as fp:\n            blob = fp.read()\n        return blob\n\n    def _write_file(self, result: str, ofile: str) -&gt; None:\n\"\"\"Write oscal results file.\"\"\"\n        if not self._simulate:\n            if self._verbose:\n                logger.info(f'output: {ofile}')\n            result.oscal_write(pathlib.Path(ofile))\n\n    def _show_analysis(self, tanium_transformer: TaniumTransformer) -&gt; None:\n\"\"\"Show analysis.\"\"\"\n        if not self._simulate and self._verbose:\n            analysis = tanium_transformer.analysis\n            for line in analysis:\n                logger.info(line)\n</code></pre>"},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar.TaniumResultToOscalAR.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar.TaniumResultToOscalAR-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar.TaniumResultToOscalAR.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task tanium-result-to-oscal-ar.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>Optional[configparser.SectionProxy]</code> <p>Config section associated with the task.</p> required Source code in <code>trestle/tasks/tanium_result_to_oscal_ar.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task tanium-result-to-oscal-ar.\n\n    Args:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n</code></pre>"},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar.TaniumResultToOscalAR.execute","title":"<code>execute(self)</code>","text":"<p>Provide an actual outcome.</p> Source code in <code>trestle/tasks/tanium_result_to_oscal_ar.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an actual outcome.\"\"\"\n    self._simulate = False\n    return self._transform()\n</code></pre>"},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar.TaniumResultToOscalAR.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/tanium_result_to_oscal_ar.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    logger.info(f'Help information for {self.name} task.')\n    logger.info('')\n    logger.info(\n        'Purpose: Transform Tanium files into Open Security Controls Assessment Language (OSCAL) results objects'\n        + 'and serialize to a file.'\n    )\n    logger.info('')\n    logger.info('Configuration flags sit under [task.tanium-result-to-oscal-ar]:')\n    logger.info('  blocksize = (optional) the desired number Tanuim result input lines to process per CPU.')\n    logger.info('  cpus-max  = (optional) the desired maximum number of CPUs to employ, default is 1.')\n    logger.info('  cpus-min  = (optional) the desired minimum number of CPUs to employ.')\n    logger.info('  aggregate = (optional) True indicates employ properties aggregation, default is True.')\n    logger.info('  caching   = (optional) True indicates employ object caching, default is True.')\n    logger.info(\n        '  checking  = (optional) True indicates perform strict checking of OSCAL properties, default is False.'\n    )\n    logger.info('  input-dir = (required) the path of the input directory comprising Tanium results.')\n    logger.info(\n        '  output-dir = (required) the path of the output directory comprising synthesized OSCAL .json files.'\n    )\n    logger.info('  output-overwrite = (optional) true [default] or false; replace existing output when true.')\n    logger.info(\n        '  quiet = (optional) true or false [default]; display file creations and rules analysis when false.'\n    )\n    logger.info(\n        '  timestamp = (optional) timestamp for the Observations in ISO 8601 format, such as '\n        + '2021-01-04T00:05:23+04:00 for example; if not specified then value for \"Timestamp\" key in the Tanium '\n        + 'result is used if present, otherwise current time is used.'\n    )\n    logger.info('')\n    logger.info(\n        'Operation: A transformation is performed on one or more Tanium input files to produce output in '\n        + 'OSCAL partial results format.'\n    )\n</code></pre>"},{"location":"api_reference/trestle.tasks.tanium_result_to_oscal_ar/#trestle.tasks.tanium_result_to_oscal_ar.TaniumResultToOscalAR.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/tanium_result_to_oscal_ar.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    self._simulate = True\n    return self._transform()\n</code></pre>"},{"location":"api_reference/trestle.tasks.transform/","title":"transform","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.transform/#trestle.tasks.transform","title":"<code>trestle.tasks.transform</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.xlsx_helper/","title":"xlsx_helper","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper","title":"<code>trestle.tasks.xlsx_helper</code>","text":"<p>XLSX utilities.</p>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column","title":"<code> Column        </code>","text":"<p>Spread sheet columns.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>class Column():\n\"\"\"Spread sheet columns.\"\"\"\n\n    control_id = 'ControlId'\n    control_text = 'ControlText'\n    goal_name_id = 'goal_name_id'\n    goal_version = 'goal_version'\n    rule_name_id = 'rule_name_id'\n    rule_version = 'rule_version'\n    nist_mappings = 'NIST Mappings'\n    resource_title = 'ResourceTitle'\n    parameter_opt_parm = 'Parameter [optional parameter]'\n    values_alternatives = 'Values default , [alternatives]'\n    filter_column = None\n\n    tokens_nist_mappings = nist_mappings.split()\n    tokens_parameter_opt_parm = parameter_opt_parm.split()\n    rename_parameter_opt_parm = 'ParameterName'\n    tokens_values_alternatives = values_alternatives.split()\n    rename_values_alternatives = 'ParameterValue'\n\n    help_list = []\n    text1 = '                      '\n    text2 = f'column \"{control_id}\" contains control ID.'\n    help_list.append(text1 + text2)\n    text2 = f'column \"{control_text}\" contains control text.'\n    help_list.append(text1 + text2)\n    text2 = f'columns \"{nist_mappings}\" contain NIST control mappings.'\n    help_list.append(text1 + text2)\n    text2 = f'column \"{resource_title}\" contains component name.'\n    help_list.append(text1 + text2)\n    text2 = f'column \"{goal_name_id}\" contains goal name.'\n    help_list.append(text1 + text2)\n    text2 = f'column \"{goal_version}\" contains goal version.'\n    help_list.append(text1 + text2)\n    text2 = f'column \"{rule_name_id}\" contains rule name.'\n    help_list.append(text1 + text2)\n    text2 = f'column \"{rule_version}\" contains rule version.'\n    help_list.append(text1 + text2)\n    text2 = f'column \"{parameter_opt_parm}\" contains parameter name + description, separated by newline.'\n    help_list.append(text1 + text2)\n    text2 = f'column \"{values_alternatives}\" contains parameter values.'\n    help_list.append(text1 + text2)\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.control_id","title":"<code>control_id</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.control_text","title":"<code>control_text</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.filter_column","title":"<code>filter_column</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.goal_name_id","title":"<code>goal_name_id</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.goal_version","title":"<code>goal_version</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.help_list","title":"<code>help_list</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.nist_mappings","title":"<code>nist_mappings</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.parameter_opt_parm","title":"<code>parameter_opt_parm</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.rename_parameter_opt_parm","title":"<code>rename_parameter_opt_parm</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.rename_values_alternatives","title":"<code>rename_values_alternatives</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.resource_title","title":"<code>resource_title</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.rule_name_id","title":"<code>rule_name_id</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.rule_version","title":"<code>rule_version</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.text1","title":"<code>text1</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.text2","title":"<code>text2</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.tokens_nist_mappings","title":"<code>tokens_nist_mappings</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.tokens_parameter_opt_parm","title":"<code>tokens_parameter_opt_parm</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.tokens_values_alternatives","title":"<code>tokens_values_alternatives</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.Column.values_alternatives","title":"<code>values_alternatives</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper","title":"<code> XlsxHelper        </code>","text":"<p>Xlsx Helper common functions and assistance navigating spread sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>class XlsxHelper:\n\"\"\"Xlsx Helper common functions and assistance navigating spread sheet.\"\"\"\n\n    by_goal = 'by-goal'\n    by_rule = 'by-rule'\n    by_control = 'by-control'\n    by_check = 'by-check'\n\n    profile_types = [by_goal, by_rule, by_control, by_check]\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize.\"\"\"\n        self._column = Column()\n\n    def print_info(self, name, oscal_name) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        logger.info(f'Help information for {name} task.')\n        logger.info('')\n        logger.info(f'Purpose: From spread sheet and catalog produce OSCAL {oscal_name} file.')\n        logger.info('')\n        logger.info(f'Configuration flags sit under [task.{name}]:')\n        if oscal_name == 'component_definition':\n            text1 = '  catalog-file      = '\n            text2 = '(required) the path of the OSCAL catalog file.'\n            logger.info(text1 + text2)\n        text1 = '  spread-sheet-file = '\n        text2 = '(required) the path of the spread sheet file.'\n        logger.info(text1 + text2)\n        text1 = '  work-sheet-name   = '\n        text2 = '(required) the name of the work sheet in the spread sheet file.'\n        logger.info(text1 + text2)\n        for line in self._column.help_list:\n            logger.info(line)\n        text1 = '  output-dir        = '\n        text2 = '(required) the path of the output directory for synthesized OSCAL .json files.'\n        logger.info(text1 + text2)\n        text1 = '  output-overwrite  = '\n        text2 = '(optional) true [default] or false; replace existing output when true.'\n        logger.info(text1 + text2)\n        text1 = '  filter-column     = '\n        text2 = '(optional) column heading of yes/no values; process only \"yes\" rows.'\n        logger.info(text1 + text2)\n        text1 = '  profile-type      = '\n        text2 = f'(optional) one of {self.profile_types}'\n        logger.info(text1 + text2)\n\n    @property\n    def profile_type(self) -&gt; str:\n\"\"\"Profile type.\"\"\"\n        return self._profile_type\n\n    def configure(self, task: TaskBase) -&gt; bool:\n\"\"\"Configure.\"\"\"\n        if not task._config:\n            logger.warning('config missing')\n            return False\n        # config verbosity\n        quiet = task._config.get('quiet', False)\n        task._verbose = not quiet\n        # required for component-definition\n        if not self.configure_cd(task):\n            return False\n        # required for profile\n        if not self.configure_profile(task):\n            return False\n        # optional\n        self._column.filter_column = task._config.get('filter-column', None)\n        # config spread sheet\n        spread_sheet = task._config.get('spread-sheet-file')\n        if spread_sheet is None:\n            logger.warning('config missing \"spread-sheet\"')\n            return False\n        if not pathlib.Path(spread_sheet).exists():\n            logger.warning('\"spread-sheet\" not found')\n            return False\n        sheet_name = task._config.get('work-sheet-name')\n        if sheet_name is None:\n            logger.warning('config missing \"work-sheet-name\"')\n            return False\n        # announce spreadsheet\n        if task._verbose:\n            logger.info(f'input: {spread_sheet}')\n        # get profile type\n        if task.name == 'xlsx-to-oscal-profile':\n            self._profile_type = task._config.get('profile-type', self.profile_types[0])\n            if self._profile_type not in self.profile_types:\n                logger.warning(f'invalid \"profile-type\" {self._profile_type} ')\n                return False\n        else:\n            self._profile_type = None\n        # load spread sheet\n        self.load(spread_sheet, sheet_name)\n        return True\n\n    def configure_cd(self, task: TaskBase) -&gt; bool:\n\"\"\"Configure cd.\"\"\"\n        if task.name == 'xlsx-to-oscal-cd':\n            catalog_file = task._config.get('catalog-file')\n            if catalog_file is None:\n                logger.warning('config missing \"catalog-file\"')\n                return False\n            try:\n                catalog = Catalog.oscal_read(pathlib.Path(catalog_file))\n                logger.debug(f'catalog: {catalog_file}')\n            except Exception as e:  # pragma: no cover\n                raise TrestleError(f'Error loading catalog {catalog_file}: {e}')\n            task.catalog_interface = CatalogInterface(catalog)\n        return True\n\n    def configure_profile(self, task: TaskBase) -&gt; bool:\n\"\"\"Configure profile.\"\"\"\n        if task.name == 'xlsx-to-oscal-profile':\n            profile_title = task._config.get('profile-title')\n            if profile_title is None:\n                logger.warning('config missing \"profile-title\"')\n                return False\n            spread_sheet_url = task._config.get('spread-sheet-url')\n            if spread_sheet_url is None:\n                logger.warning('config missing \"spread-sheet-url\"')\n                return False\n        return True\n\n    def load(self, spread_sheet: str, sheet_name: str) -&gt; None:\n\"\"\"Load.\"\"\"\n        self._spread_sheet = spread_sheet\n        self._sheet_name = sheet_name\n        self._wb = load_workbook(self._spread_sheet)\n        self._work_sheet = self._wb[self._sheet_name]\n        self._map_name_to_letters = {}\n        # accumulators\n        self.rows_missing_control_id = []\n        self.rows_missing_goal_name_id = []\n        self.rows_invalid_goal_name_id = []\n        self.rows_missing_rule_name_id = []\n        self.rows_invalid_rule_name_id = []\n        self.rows_invalid_parameter_name = []\n        self.rows_missing_controls = []\n        self.rows_missing_parameters = []\n        self.rows_missing_parameters_values = []\n        self.rows_filtered = []\n        # map columns\n        self._map_columns()\n\n    def row_generator(self) -&gt; Iterator[int]:\n\"\"\"Generate rows until control_id is None.\"\"\"\n        row = 1\n        rows_skipped_consecutive = 0\n        # assume no more data when 100 consecutve rows no control id\n        rows_skipped_consecutive_limit = 100\n        while True:\n            row = row + 1\n            control_id = self._get_control_id(row)\n            goal_id = self.get_goal_name_id(row)\n            if control_id is None and goal_id is None:\n                rows_skipped_consecutive += 1\n                if rows_skipped_consecutive &lt; rows_skipped_consecutive_limit:\n                    continue\n                logger.debug(f'break: {row} {rows_skipped_consecutive}')\n                break\n            if control_id is None:\n                self._add_row(row, self.rows_missing_control_id)\n                continue\n            if goal_id is None:\n                self._add_row(row, self.rows_missing_goal_name_id)\n                continue\n            if self._is_filtered(row):\n                continue\n            yield row\n            rows_skipped_consecutive = 0\n\n    def _is_filtered(self, row) -&gt; bool:\n\"\"\"Return True if row is to be skipped.\"\"\"\n        if self._column.filter_column is None:\n            return False\n        col = self._get_column_letter(self._column.filter_column)\n        value = self._work_sheet[col + str(row)].value\n        if value is None:\n            return False\n        if value.lower() != 'yes':\n            return False\n        self._add_row(row, self.rows_filtered)\n        return True\n\n    def get_goal_name_id(self, row: int, strict: bool = True) -&gt; str:\n\"\"\"Get goal_name_id from work_sheet.\"\"\"\n        col = self._get_column_letter(self._column.goal_name_id)\n        value = self._work_sheet[col + str(row)].value\n        if value is None:\n            self._add_row(row, self.rows_missing_goal_name_id)\n        else:\n            value = str(value).strip()\n            if strict:\n                svalue = str(value).strip()\n                value = ''.join(str(svalue).split())\n                if value != svalue:\n                    self._add_row(row, self.rows_invalid_goal_name_id)\n        return value\n\n    def get_check_name_id(self, row: int, strict: bool = False) -&gt; str:\n\"\"\"Get check_name_id from work_sheet.\"\"\"\n        return self.get_goal_name_id(row, strict)\n\n    def get_rule_name_id(self, row: int, strict: bool = False) -&gt; str:\n\"\"\"Get rule_name_id from work_sheet.\"\"\"\n        col = self._get_column_letter(self._column.rule_name_id)\n        value = self._work_sheet[col + str(row)].value\n        if value is None:\n            self._add_row(row, self.rows_missing_rule_name_id)\n        else:\n            value = str(value).strip()\n            if strict:\n                svalue = str(value).strip()\n                value = ''.join(str(svalue).split())\n                if value != svalue:\n                    self._add_row(row, self.rows_invalid_rule_name_id)\n        return value\n\n    def get_parameter_usage(self, row: int) -&gt; str:\n\"\"\"Get parameter_usage from work_sheet.\"\"\"\n        return self.get_goal_remarks(row)\n\n    def get_parameter_value_default(self, row: int) -&gt; str:\n\"\"\"Get parameter_value_default from work_sheet.\"\"\"\n        col = self._get_column_letter(self._column.rename_values_alternatives)\n        value = self._work_sheet[col + str(row)].value\n        if value is not None:\n            value = str(value).split(',')[0].strip()\n        return value\n\n    def get_parameter_values(self, row: int) -&gt; str:\n\"\"\"Get parameter_values from work_sheet.\"\"\"\n        col = self._get_column_letter(self._column.rename_values_alternatives)\n        value = self._work_sheet[col + str(row)].value\n        if value is None and self.get_parameter_name(row) is not None:\n            self._add_row(row, self.rows_missing_parameters_values)\n        # massage into comma separated list of values\n        else:\n            value = str(value).strip().replace(' ', '')\n            value = value.replace(',[]', '')\n            value = value.replace('[', '')\n            value = value.replace(']', '')\n            value = value.split(',')\n        return value\n\n    def _get_goal_text(self, row: int) -&gt; str:\n\"\"\"Get goal_text from work_sheet.\"\"\"\n        col = self._get_column_letter(self._column.control_text)\n        goal_text = self._work_sheet[col + str(row)].value\n        # normalize &amp; tokenize\n        value = goal_text.replace('\\t', ' ')\n        return value\n\n    def _get_goal_text_tokens(self, row: int) -&gt; List[str]:\n\"\"\"Get goal_text tokens from work_sheet.\"\"\"\n        goal_text = self._get_goal_text(row)\n        tokens = goal_text.split()\n        return tokens\n\n    def get_goal_remarks(self, row: int) -&gt; str:\n\"\"\"Get goal_remarks from work_sheet.\"\"\"\n        tokens = self._get_goal_text_tokens(row)\n        # replace \"Check whether\" with \"Ensure\", if present\n        if tokens:\n            if tokens[0] == 'Check':\n                if len(tokens) &gt; 1:\n                    if tokens[1] == 'whether':\n                        tokens.pop(0)\n                tokens[0] = 'Ensure'\n        value = ' '.join(tokens)\n        return value\n\n    def get_controls(self, row: int) -&gt; Dict[str, List[str]]:\n\"\"\"Produce dict of controls mapped to statements.\n\n        Example: {'au-2': ['(a)', '(d)'], 'au-12': [], 'si-4': ['(a)', '(b)', '(c)']}\n        \"\"\"\n        value = {}\n        for col in self._get_column_letter(self._column.nist_mappings):\n            control = self._work_sheet[col + str(row)].value\n            if control is None:\n                continue\n            # remove blanks\n            control = ''.join(control.split())\n            if len(control) &lt; 1 or control.lower() == 'none':\n                continue\n            # remove rhs of : inclusive\n            if ':' in control:\n                control = control.split(':')[0]\n            # remove alphabet parts of control &amp; accumulate in statements\n            control, statements = self._normalize_control(control)\n            # skip bogus control made up if dashes only\n            if len(control.replace('-', '')) == 0:\n                continue\n            if control not in value.keys():\n                value[control] = statements\n        if len(value.keys()) == 0:\n            self._add_row(row, self.rows_missing_controls)\n        logger.debug(f'row: {row} controls {value}')\n        return value\n\n    def get_component_name(self, row: int) -&gt; str:\n\"\"\"Get component_name from work_sheet.\"\"\"\n        col = self._get_column_letter(self._column.resource_title)\n        value = self._work_sheet[col + str(row)].value\n        if value is None:\n            raise RuntimeError(f'row {row} col {col} missing component name')\n        return value.strip()\n\n    def get_parameter_name(self, row: int) -&gt; Tuple[str, str]:\n\"\"\"Get parameter_name from work_sheet.\"\"\"\n        return self.get_parameter_name_and_description(row)[0]\n\n    def get_parameter_name_and_description(self, row: int) -&gt; Tuple[str, str]:\n\"\"\"Get parameter_name and description from work_sheet.\"\"\"\n        name = None\n        description = None\n        col = self._get_column_letter(self._column.rename_parameter_opt_parm)\n        combined_values = self._work_sheet[col + str(row)].value\n        if combined_values is not None:\n            if '\\n' in combined_values:\n                parameter_parts = combined_values.split('\\n')\n            elif ' ' in combined_values:\n                parameter_parts = combined_values.split(' ', 1)\n            else:\n                parameter_parts = combined_values\n            if len(parameter_parts) == 2:\n                name = parameter_parts[1].strip()\n                description = parameter_parts[0].strip()\n                sname = str(name).strip()\n                name = sname.replace(' ', '_')\n                if name != sname:\n                    self._add_row(row, self.rows_invalid_parameter_name)\n            else:\n                logger.info(f'row {row} col {col} invalid value')\n        if name is None and self.get_parameter_value_default(row) is not None:\n            self._add_row(row, self.rows_missing_parameters)\n        value = name, description\n        return value\n\n    def _get_control_id(self, row: int) -&gt; int:\n\"\"\"Get control_id from work_sheet.\"\"\"\n        col = self._get_column_letter(self._column.control_id)\n        value = self._work_sheet[col + str(row)].value\n        return value\n\n    def _get_column_letter(self, name: str) -&gt; str:\n\"\"\"Get column letter.\"\"\"\n        value = self.map_name_to_letters[name]\n        if len(value) == 1:\n            value = value[0]\n        return value\n\n    def _map_columns(self) -&gt; None:\n\"\"\"Map columns.\"\"\"\n        self.map_name_to_letters = {}\n        columns = self._work_sheet.max_column\n        for column in range(1, columns + 1):\n            cell_value = self._cell_value(1, column)\n            if cell_value is None:\n                continue\n            cell_tokens = cell_value.split()\n            normalized_cell_value = ' '.join(cell_tokens)\n            # find columns of interest\n            if self._column.control_id in cell_tokens:\n                self._add_column(self._column.control_id, column, 1)\n            elif self._column.control_text in cell_tokens:\n                self._add_column(self._column.control_text, column, 1)\n            elif self._column.goal_name_id in cell_tokens:\n                self._add_column(self._column.goal_name_id, column, 1)\n            elif self._column.goal_version in cell_tokens:\n                self._add_column(self._column.goal_version, column, 1)\n            elif self._column.rule_name_id in cell_tokens:\n                self._add_column(self._column.rule_name_id, column, 1)\n            elif self._column.rule_version in cell_tokens:\n                self._add_column(self._column.rule_version, column, 1)\n            # parameters and alternatives (exact tokens match)\n            elif cell_tokens == self._column.tokens_parameter_opt_parm:\n                self._add_column(self._column.rename_parameter_opt_parm, column, 1)\n            elif cell_tokens == self._column.tokens_values_alternatives:\n                self._add_column(self._column.rename_values_alternatives, column, 1)\n            # filter column (exact string match)\n            elif self._column.filter_column == normalized_cell_value:\n                self._add_column(self._column.filter_column, column, 1)\n            # nist mappings and resource title (multiple columns match)\n            elif is_ordered_sublist(self._column.tokens_nist_mappings, cell_tokens):\n                self._add_column(self._column.nist_mappings, column, 0)\n            elif self._column.resource_title in cell_tokens:\n                self._add_column(self._column.resource_title, column, 0)\n        # insure expected columns found\n        for name in [self._column.control_id,\n                     self._column.control_text,\n                     self._column.rule_name_id,\n                     self._column.rule_version,\n                     self._column.goal_name_id,\n                     self._column.goal_version,\n                     self._column.nist_mappings,\n                     self._column.resource_title,\n                     self._column.rename_parameter_opt_parm,\n                     self._column.rename_values_alternatives]:\n            if name not in self.map_name_to_letters.keys():\n                raise RuntimeError(f'missing column {name}')\n\n    def _add_column(self, name: str, column: int, limit: int) -&gt; None:\n\"\"\"Add column.\"\"\"\n        if name not in self.map_name_to_letters:\n            self.map_name_to_letters[name] = []\n        if limit &gt; 0 and len(self.map_name_to_letters[name]) == limit:\n            raise RuntimeError(f'duplicate column {name} {get_column_letter(column)}')\n        self.map_name_to_letters[name].append(get_column_letter(column))\n\n    def _cell_value(self, row: int, col: int) -&gt; Any:\n\"\"\"Get value for cell, adjusting for merged cells.\"\"\"\n        cell = self._work_sheet.cell(row, col)\n        retval = cell.value\n        if isinstance(cell, MergedCell):\n            # cell is merged\n            for mc_range in self._work_sheet.merged_cells.ranges:\n                coord = get_column_letter(col) + str(row)\n                if coord in mc_range:\n                    retval = mc_range.start_cell.value\n        return retval\n\n    def _normalize_control(self, control: str) -&gt; Tuple[str, List[str]]:\n\"\"\"Remove parenthesized characters from controls.\"\"\"\n        statements = []\n        for i in string.ascii_lowercase:\n            needle = '(' + i + ')'\n            if needle in control:\n                statements.append(needle)\n                control = control.replace(needle, '')\n        control = control.lower()\n        return control, statements\n\n    def _add_row(self, row: int, account: List[int]) -&gt; None:\n\"\"\"Add row to accounting list of rows.\"\"\"\n        if row not in account:\n            account.append(row)\n\n    def report_issues(self) -&gt; None:\n\"\"\"Report issues.\"\"\"\n        if self.rows_missing_control_id:\n            logger.info(f'rows missing control_id: {self.rows_missing_control_id}')\n        if self.rows_invalid_goal_name_id:\n            logger.info(f'rows invalid goal_name_id: {self.rows_invalid_goal_name_id}')\n        if self.rows_missing_rule_name_id:\n            logger.info(f'rows missing rule_name_id: {self.rows_missing_rule_name_id}')\n        if self.rows_invalid_rule_name_id:\n            logger.info(f'rows invalid rule_name_id: {self.rows_invalid_rule_name_id}')\n        if self.rows_invalid_parameter_name:\n            logger.info(f'rows invalid parameter_name: {self.rows_invalid_parameter_name}')\n        if self.rows_missing_controls:\n            logger.info(f'rows missing controls: {self.rows_missing_controls}')\n        if self.rows_missing_parameters:\n            logger.info(f'rows missing parameters: {self.rows_missing_parameters}')\n        if self.rows_missing_parameters_values:\n            logger.info(f'rows missing parameters values: {self.rows_missing_parameters_values}')\n        if self.rows_filtered:\n            logger.info(f'rows filtered: {self.rows_filtered}')\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.by_check","title":"<code>by_check</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.by_control","title":"<code>by_control</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.by_goal","title":"<code>by_goal</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.by_rule","title":"<code>by_rule</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.profile_type","title":"<code>profile_type: str</code>  <code>property</code> <code>readonly</code>","text":"<p>Profile type.</p>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.profile_types","title":"<code>profile_types</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize.\"\"\"\n    self._column = Column()\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.configure","title":"<code>configure(self, task)</code>","text":"<p>Configure.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def configure(self, task: TaskBase) -&gt; bool:\n\"\"\"Configure.\"\"\"\n    if not task._config:\n        logger.warning('config missing')\n        return False\n    # config verbosity\n    quiet = task._config.get('quiet', False)\n    task._verbose = not quiet\n    # required for component-definition\n    if not self.configure_cd(task):\n        return False\n    # required for profile\n    if not self.configure_profile(task):\n        return False\n    # optional\n    self._column.filter_column = task._config.get('filter-column', None)\n    # config spread sheet\n    spread_sheet = task._config.get('spread-sheet-file')\n    if spread_sheet is None:\n        logger.warning('config missing \"spread-sheet\"')\n        return False\n    if not pathlib.Path(spread_sheet).exists():\n        logger.warning('\"spread-sheet\" not found')\n        return False\n    sheet_name = task._config.get('work-sheet-name')\n    if sheet_name is None:\n        logger.warning('config missing \"work-sheet-name\"')\n        return False\n    # announce spreadsheet\n    if task._verbose:\n        logger.info(f'input: {spread_sheet}')\n    # get profile type\n    if task.name == 'xlsx-to-oscal-profile':\n        self._profile_type = task._config.get('profile-type', self.profile_types[0])\n        if self._profile_type not in self.profile_types:\n            logger.warning(f'invalid \"profile-type\" {self._profile_type} ')\n            return False\n    else:\n        self._profile_type = None\n    # load spread sheet\n    self.load(spread_sheet, sheet_name)\n    return True\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.configure_cd","title":"<code>configure_cd(self, task)</code>","text":"<p>Configure cd.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def configure_cd(self, task: TaskBase) -&gt; bool:\n\"\"\"Configure cd.\"\"\"\n    if task.name == 'xlsx-to-oscal-cd':\n        catalog_file = task._config.get('catalog-file')\n        if catalog_file is None:\n            logger.warning('config missing \"catalog-file\"')\n            return False\n        try:\n            catalog = Catalog.oscal_read(pathlib.Path(catalog_file))\n            logger.debug(f'catalog: {catalog_file}')\n        except Exception as e:  # pragma: no cover\n            raise TrestleError(f'Error loading catalog {catalog_file}: {e}')\n        task.catalog_interface = CatalogInterface(catalog)\n    return True\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.configure_profile","title":"<code>configure_profile(self, task)</code>","text":"<p>Configure profile.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def configure_profile(self, task: TaskBase) -&gt; bool:\n\"\"\"Configure profile.\"\"\"\n    if task.name == 'xlsx-to-oscal-profile':\n        profile_title = task._config.get('profile-title')\n        if profile_title is None:\n            logger.warning('config missing \"profile-title\"')\n            return False\n        spread_sheet_url = task._config.get('spread-sheet-url')\n        if spread_sheet_url is None:\n            logger.warning('config missing \"spread-sheet-url\"')\n            return False\n    return True\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_check_name_id","title":"<code>get_check_name_id(self, row, strict=False)</code>","text":"<p>Get check_name_id from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_check_name_id(self, row: int, strict: bool = False) -&gt; str:\n\"\"\"Get check_name_id from work_sheet.\"\"\"\n    return self.get_goal_name_id(row, strict)\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_component_name","title":"<code>get_component_name(self, row)</code>","text":"<p>Get component_name from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_component_name(self, row: int) -&gt; str:\n\"\"\"Get component_name from work_sheet.\"\"\"\n    col = self._get_column_letter(self._column.resource_title)\n    value = self._work_sheet[col + str(row)].value\n    if value is None:\n        raise RuntimeError(f'row {row} col {col} missing component name')\n    return value.strip()\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_controls","title":"<code>get_controls(self, row)</code>","text":"<p>Produce dict of controls mapped to statements.</p> <p>Example: {'au-2': ['(a)', '(d)'], 'au-12': [], 'si-4': ['(a)', '(b)', '(c)']}</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_controls(self, row: int) -&gt; Dict[str, List[str]]:\n\"\"\"Produce dict of controls mapped to statements.\n\n    Example: {'au-2': ['(a)', '(d)'], 'au-12': [], 'si-4': ['(a)', '(b)', '(c)']}\n    \"\"\"\n    value = {}\n    for col in self._get_column_letter(self._column.nist_mappings):\n        control = self._work_sheet[col + str(row)].value\n        if control is None:\n            continue\n        # remove blanks\n        control = ''.join(control.split())\n        if len(control) &lt; 1 or control.lower() == 'none':\n            continue\n        # remove rhs of : inclusive\n        if ':' in control:\n            control = control.split(':')[0]\n        # remove alphabet parts of control &amp; accumulate in statements\n        control, statements = self._normalize_control(control)\n        # skip bogus control made up if dashes only\n        if len(control.replace('-', '')) == 0:\n            continue\n        if control not in value.keys():\n            value[control] = statements\n    if len(value.keys()) == 0:\n        self._add_row(row, self.rows_missing_controls)\n    logger.debug(f'row: {row} controls {value}')\n    return value\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_goal_name_id","title":"<code>get_goal_name_id(self, row, strict=True)</code>","text":"<p>Get goal_name_id from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_goal_name_id(self, row: int, strict: bool = True) -&gt; str:\n\"\"\"Get goal_name_id from work_sheet.\"\"\"\n    col = self._get_column_letter(self._column.goal_name_id)\n    value = self._work_sheet[col + str(row)].value\n    if value is None:\n        self._add_row(row, self.rows_missing_goal_name_id)\n    else:\n        value = str(value).strip()\n        if strict:\n            svalue = str(value).strip()\n            value = ''.join(str(svalue).split())\n            if value != svalue:\n                self._add_row(row, self.rows_invalid_goal_name_id)\n    return value\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_goal_remarks","title":"<code>get_goal_remarks(self, row)</code>","text":"<p>Get goal_remarks from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_goal_remarks(self, row: int) -&gt; str:\n\"\"\"Get goal_remarks from work_sheet.\"\"\"\n    tokens = self._get_goal_text_tokens(row)\n    # replace \"Check whether\" with \"Ensure\", if present\n    if tokens:\n        if tokens[0] == 'Check':\n            if len(tokens) &gt; 1:\n                if tokens[1] == 'whether':\n                    tokens.pop(0)\n            tokens[0] = 'Ensure'\n    value = ' '.join(tokens)\n    return value\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_parameter_name","title":"<code>get_parameter_name(self, row)</code>","text":"<p>Get parameter_name from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_parameter_name(self, row: int) -&gt; Tuple[str, str]:\n\"\"\"Get parameter_name from work_sheet.\"\"\"\n    return self.get_parameter_name_and_description(row)[0]\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_parameter_name_and_description","title":"<code>get_parameter_name_and_description(self, row)</code>","text":"<p>Get parameter_name and description from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_parameter_name_and_description(self, row: int) -&gt; Tuple[str, str]:\n\"\"\"Get parameter_name and description from work_sheet.\"\"\"\n    name = None\n    description = None\n    col = self._get_column_letter(self._column.rename_parameter_opt_parm)\n    combined_values = self._work_sheet[col + str(row)].value\n    if combined_values is not None:\n        if '\\n' in combined_values:\n            parameter_parts = combined_values.split('\\n')\n        elif ' ' in combined_values:\n            parameter_parts = combined_values.split(' ', 1)\n        else:\n            parameter_parts = combined_values\n        if len(parameter_parts) == 2:\n            name = parameter_parts[1].strip()\n            description = parameter_parts[0].strip()\n            sname = str(name).strip()\n            name = sname.replace(' ', '_')\n            if name != sname:\n                self._add_row(row, self.rows_invalid_parameter_name)\n        else:\n            logger.info(f'row {row} col {col} invalid value')\n    if name is None and self.get_parameter_value_default(row) is not None:\n        self._add_row(row, self.rows_missing_parameters)\n    value = name, description\n    return value\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_parameter_usage","title":"<code>get_parameter_usage(self, row)</code>","text":"<p>Get parameter_usage from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_parameter_usage(self, row: int) -&gt; str:\n\"\"\"Get parameter_usage from work_sheet.\"\"\"\n    return self.get_goal_remarks(row)\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_parameter_value_default","title":"<code>get_parameter_value_default(self, row)</code>","text":"<p>Get parameter_value_default from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_parameter_value_default(self, row: int) -&gt; str:\n\"\"\"Get parameter_value_default from work_sheet.\"\"\"\n    col = self._get_column_letter(self._column.rename_values_alternatives)\n    value = self._work_sheet[col + str(row)].value\n    if value is not None:\n        value = str(value).split(',')[0].strip()\n    return value\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_parameter_values","title":"<code>get_parameter_values(self, row)</code>","text":"<p>Get parameter_values from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_parameter_values(self, row: int) -&gt; str:\n\"\"\"Get parameter_values from work_sheet.\"\"\"\n    col = self._get_column_letter(self._column.rename_values_alternatives)\n    value = self._work_sheet[col + str(row)].value\n    if value is None and self.get_parameter_name(row) is not None:\n        self._add_row(row, self.rows_missing_parameters_values)\n    # massage into comma separated list of values\n    else:\n        value = str(value).strip().replace(' ', '')\n        value = value.replace(',[]', '')\n        value = value.replace('[', '')\n        value = value.replace(']', '')\n        value = value.split(',')\n    return value\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.get_rule_name_id","title":"<code>get_rule_name_id(self, row, strict=False)</code>","text":"<p>Get rule_name_id from work_sheet.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_rule_name_id(self, row: int, strict: bool = False) -&gt; str:\n\"\"\"Get rule_name_id from work_sheet.\"\"\"\n    col = self._get_column_letter(self._column.rule_name_id)\n    value = self._work_sheet[col + str(row)].value\n    if value is None:\n        self._add_row(row, self.rows_missing_rule_name_id)\n    else:\n        value = str(value).strip()\n        if strict:\n            svalue = str(value).strip()\n            value = ''.join(str(svalue).split())\n            if value != svalue:\n                self._add_row(row, self.rows_invalid_rule_name_id)\n    return value\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.load","title":"<code>load(self, spread_sheet, sheet_name)</code>","text":"<p>Load.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def load(self, spread_sheet: str, sheet_name: str) -&gt; None:\n\"\"\"Load.\"\"\"\n    self._spread_sheet = spread_sheet\n    self._sheet_name = sheet_name\n    self._wb = load_workbook(self._spread_sheet)\n    self._work_sheet = self._wb[self._sheet_name]\n    self._map_name_to_letters = {}\n    # accumulators\n    self.rows_missing_control_id = []\n    self.rows_missing_goal_name_id = []\n    self.rows_invalid_goal_name_id = []\n    self.rows_missing_rule_name_id = []\n    self.rows_invalid_rule_name_id = []\n    self.rows_invalid_parameter_name = []\n    self.rows_missing_controls = []\n    self.rows_missing_parameters = []\n    self.rows_missing_parameters_values = []\n    self.rows_filtered = []\n    # map columns\n    self._map_columns()\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.print_info","title":"<code>print_info(self, name, oscal_name)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def print_info(self, name, oscal_name) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    logger.info(f'Help information for {name} task.')\n    logger.info('')\n    logger.info(f'Purpose: From spread sheet and catalog produce OSCAL {oscal_name} file.')\n    logger.info('')\n    logger.info(f'Configuration flags sit under [task.{name}]:')\n    if oscal_name == 'component_definition':\n        text1 = '  catalog-file      = '\n        text2 = '(required) the path of the OSCAL catalog file.'\n        logger.info(text1 + text2)\n    text1 = '  spread-sheet-file = '\n    text2 = '(required) the path of the spread sheet file.'\n    logger.info(text1 + text2)\n    text1 = '  work-sheet-name   = '\n    text2 = '(required) the name of the work sheet in the spread sheet file.'\n    logger.info(text1 + text2)\n    for line in self._column.help_list:\n        logger.info(line)\n    text1 = '  output-dir        = '\n    text2 = '(required) the path of the output directory for synthesized OSCAL .json files.'\n    logger.info(text1 + text2)\n    text1 = '  output-overwrite  = '\n    text2 = '(optional) true [default] or false; replace existing output when true.'\n    logger.info(text1 + text2)\n    text1 = '  filter-column     = '\n    text2 = '(optional) column heading of yes/no values; process only \"yes\" rows.'\n    logger.info(text1 + text2)\n    text1 = '  profile-type      = '\n    text2 = f'(optional) one of {self.profile_types}'\n    logger.info(text1 + text2)\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.report_issues","title":"<code>report_issues(self)</code>","text":"<p>Report issues.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def report_issues(self) -&gt; None:\n\"\"\"Report issues.\"\"\"\n    if self.rows_missing_control_id:\n        logger.info(f'rows missing control_id: {self.rows_missing_control_id}')\n    if self.rows_invalid_goal_name_id:\n        logger.info(f'rows invalid goal_name_id: {self.rows_invalid_goal_name_id}')\n    if self.rows_missing_rule_name_id:\n        logger.info(f'rows missing rule_name_id: {self.rows_missing_rule_name_id}')\n    if self.rows_invalid_rule_name_id:\n        logger.info(f'rows invalid rule_name_id: {self.rows_invalid_rule_name_id}')\n    if self.rows_invalid_parameter_name:\n        logger.info(f'rows invalid parameter_name: {self.rows_invalid_parameter_name}')\n    if self.rows_missing_controls:\n        logger.info(f'rows missing controls: {self.rows_missing_controls}')\n    if self.rows_missing_parameters:\n        logger.info(f'rows missing parameters: {self.rows_missing_parameters}')\n    if self.rows_missing_parameters_values:\n        logger.info(f'rows missing parameters values: {self.rows_missing_parameters_values}')\n    if self.rows_filtered:\n        logger.info(f'rows filtered: {self.rows_filtered}')\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.XlsxHelper.row_generator","title":"<code>row_generator(self)</code>","text":"<p>Generate rows until control_id is None.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def row_generator(self) -&gt; Iterator[int]:\n\"\"\"Generate rows until control_id is None.\"\"\"\n    row = 1\n    rows_skipped_consecutive = 0\n    # assume no more data when 100 consecutve rows no control id\n    rows_skipped_consecutive_limit = 100\n    while True:\n        row = row + 1\n        control_id = self._get_control_id(row)\n        goal_id = self.get_goal_name_id(row)\n        if control_id is None and goal_id is None:\n            rows_skipped_consecutive += 1\n            if rows_skipped_consecutive &lt; rows_skipped_consecutive_limit:\n                continue\n            logger.debug(f'break: {row} {rows_skipped_consecutive}')\n            break\n        if control_id is None:\n            self._add_row(row, self.rows_missing_control_id)\n            continue\n        if goal_id is None:\n            self._add_row(row, self.rows_missing_goal_name_id)\n            continue\n        if self._is_filtered(row):\n            continue\n        yield row\n        rows_skipped_consecutive = 0\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper-functions","title":"Functions","text":""},{"location":"api_reference/trestle.tasks.xlsx_helper/#trestle.tasks.xlsx_helper.get_trestle_version","title":"<code>get_trestle_version()</code>","text":"<p>Get trestle version wrapper.</p> Source code in <code>trestle/tasks/xlsx_helper.py</code> <pre><code>def get_trestle_version() -&gt; str:\n\"\"\"Get trestle version wrapper.\"\"\"\n    return __version__\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/","title":"xlsx_to_oscal_cd","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd","title":"<code>trestle.tasks.xlsx_to_oscal_cd</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.key_sep","title":"<code>key_sep</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.sep","title":"<code>sep</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.XlsxToOscalComponentDefinition","title":"<code> XlsxToOscalComponentDefinition            (TaskBase)         </code>","text":"<p>Task to create OSCAL ComponentDefinition json.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_cd.py</code> <pre><code>class XlsxToOscalComponentDefinition(TaskBase):\n\"\"\"\n    Task to create OSCAL ComponentDefinition json.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'xlsx-to-oscal-cd'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task xlsx-to-oscal-cd.\n\n        Args:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n        self.xlsx_helper = XlsxHelper()\n        self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                    ).isoformat()\n\n    def set_timestamp(self, timestamp: str) -&gt; None:\n\"\"\"Set the timestamp.\"\"\"\n        self._timestamp = timestamp\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        self.xlsx_helper.print_info(self.name, 'component_definition')\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        return TaskOutcome('simulated-success')\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an executed outcome.\"\"\"\n        try:\n            return self._execute()\n        except Exception:\n            logger.info(traceback.format_exc())\n            return TaskOutcome('failure')\n\n    def _execute(self) -&gt; TaskOutcome:\n\"\"\"Execute path core.\"\"\"\n        if not self.xlsx_helper.configure(self):\n            return TaskOutcome('failure')\n        # config output\n        odir = self._config.get('output-dir')\n        opth = pathlib.Path(odir)\n        self._overwrite = self._config.getboolean('output-overwrite', True)\n        # insure output dir exists\n        opth.mkdir(exist_ok=True, parents=True)\n        # calculate output file name &amp; check writability\n        oname = 'component-definition.json'\n        ofile = opth / oname\n        if not self._overwrite and pathlib.Path(ofile).exists():\n            logger.warning(f'output: {ofile} already exists')\n            return TaskOutcome('failure')\n        # initialize\n        self.defined_components = {}\n        # roles, responsible_roles, parties, responsible parties\n        party_uuid_01 = str(uuid.uuid4())\n        party_uuid_02 = str(uuid.uuid4())\n        party_uuid_03 = str(uuid.uuid4())\n        roles = self._build_roles()\n        responsible_roles = self._build_responsible_roles(party_uuid_01, party_uuid_02, party_uuid_03)\n        parties = self._build_parties(party_uuid_01, party_uuid_02, party_uuid_03)\n        responsible_parties = self._build_responsible_parties(party_uuid_01, party_uuid_02, party_uuid_03)\n        # process each row of spread sheet\n        self._process_rows(responsible_roles)\n        # create OSCAL ComponentDefinition\n        metadata = Metadata(\n            title='Component definition for ' + self._get_catalog_title() + ' profiles',\n            last_modified=self._timestamp,\n            oscal_version=OSCAL_VERSION,\n            version=get_trestle_version(),\n            roles=roles,\n            parties=parties,\n            responsible_parties=responsible_parties\n        )\n        component_definition = ComponentDefinition(\n            uuid=str(uuid.uuid4()),\n            metadata=metadata,\n            components=list(self.defined_components.values()),\n        )\n        # write OSCAL ComponentDefinition to file\n        if self._verbose:\n            logger.info(f'output: {ofile}')\n        component_definition.oscal_write(pathlib.Path(ofile))\n        # issues\n        self._report_issues()\n        return TaskOutcome('success')\n\n    def _process_rows(self, responsible_roles: List[ResponsibleRole]) -&gt; None:\n\"\"\"Process spread sheet rows.\"\"\"\n        ci_map = {}\n        for row in self.xlsx_helper.row_generator():\n            # quit when first row with no goal_id encountered\n            goal_name_id = self.xlsx_helper.get_goal_name_id(row)\n            controls = self.xlsx_helper.get_controls(row)\n            if len(controls.keys()) == 0:\n                continue\n            # component\n            component_name = self.xlsx_helper.get_component_name(row)\n            component_type = 'Service'\n            defined_component = self._get_defined_component(component_name, component_type)\n            # parameter\n            parameter_name, parameter_description = self.xlsx_helper.get_parameter_name_and_description(row)\n            # control implementations\n            source = self._get_catalog_url()\n            description = component_name + ' implemented controls for ' + self._get_catalog_title(\n            ) + '. It includes assessment asset configuration for CICD.'\n            key = source + key_sep + description\n            control_implementation = ci_map.get(key)\n            if not control_implementation:\n                ci_map[key] = ControlImplementation(\n                    uuid=str(uuid.uuid4()),\n                    source=source,\n                    description=description,\n                    implemented_requirements=[],\n                )\n                control_implementation = ci_map[key]\n                if defined_component.control_implementations is None:\n                    defined_component.control_implementations = []\n                defined_component.control_implementations.append(control_implementation)\n            # implemented requirements\n            self._add_implemented_requirements(\n                row, control_implementation, controls, component_name, parameter_name, responsible_roles, goal_name_id\n            )\n            # keep alternative parameter values at control implementation level\n            parameter_values = self.xlsx_helper.get_parameter_values(row)\n            self._add_set_parameter_values(parameter_name, parameter_values, control_implementation)\n\n    def _add_implemented_requirements(\n        self,\n        row: int,\n        control_implementation: ControlImplementation,\n        controls: Dict[str, List[str]],\n        component_name: str,\n        parameter_name: str,\n        responsible_roles: List[ResponsibleRole],\n        goal_name_id: str\n    ) -&gt; None:\n\"\"\"Add implemented requirements.\"\"\"\n        goal_remarks = self.xlsx_helper.get_goal_remarks(row)\n        parameter_value_default = self.xlsx_helper.get_parameter_value_default(row)\n        for control in controls.keys():\n            control_uuid = str(uuid.uuid4())\n            prop1 = Property(\n                name='goal_name_id',\n                class_=self._get_class_for_property_name('goal_name_id'),\n                value=goal_name_id,\n                ns=self._get_namespace(),\n                remarks=str(goal_remarks)\n            )\n            prop2 = Property(\n                name='goal_version',\n                class_=self._get_class_for_property_name('goal_version'),\n                value=self._get_goal_version(),\n                ns=self._get_namespace(),\n                remarks=str(goal_name_id)\n            )\n            props = [prop1, prop2]\n            control_id, _ = self.catalog_interface.get_control_id_and_status(control)\n            if not control_id:\n                logger.info(f'row {row} control {control} not found in catalog')\n                control_id = control\n            # implemented_requirement\n            implemented_requirement = ImplementedRequirement(\n                uuid=control_uuid,\n                description=control,\n                props=props,\n                control_id=control_id,\n                responsible_roles=responsible_roles,\n            )\n            # add statements\n            self._add_statements(row, control, controls, component_name, implemented_requirement)\n            # add set_parameter\n            self._add_set_parameter_default(parameter_name, parameter_value_default, implemented_requirement)\n            # implemented_requirements\n            control_implementation.implemented_requirements.append(implemented_requirement)\n\n    def _add_statements(\n        self,\n        row: int,\n        control: str,\n        controls: Dict[str, List[str]],\n        component_name: str,\n        implemented_requirement: ImplementedRequirement\n    ) -&gt; None:\n\"\"\"Add statements.\"\"\"\n        control_statements = controls[control]\n        if control_statements:\n            statements = []\n            for control_statement in control_statements:\n                statement_id = control + control_statement\n                if any(i in control for i in '()'):\n                    control = control.replace('(', '_')\n                    control = control.replace(')', '')\n                    logger.info(f'row {row} control {control} edited to remove parentheses')\n                statement = Statement(\n                    statement_id=control,\n                    uuid=str(uuid.uuid4()),\n                    description=f'{component_name} implements {statement_id}'\n                )\n                statements.append(statement)\n            implemented_requirement.statements = statements\n\n    def _add_set_parameter_values(\n        self, parameter_name: str, parameter_values: str, control_implementation: ControlImplementation\n    ) -&gt; None:\n\"\"\"Add set parameter values (the set of choices).\"\"\"\n        if parameter_name is not None:\n            parameter_name = parameter_name.replace(' ', '_')\n            if parameter_values is not None:\n                set_parameters = [SetParameter(param_id=parameter_name, values=parameter_values)]\n                if control_implementation.set_parameters is None:\n                    control_implementation.set_parameters = []\n                # set_parameters is a list\n                control_implementation.set_parameters.extend(set_parameters)\n\n    def _add_set_parameter_default(\n        self, parameter_name: str, parameter_value_default: str, implemented_requirement: ImplementedRequirement\n    ) -&gt; None:\n\"\"\"Add set parameter default (the \"recommended\" value).\"\"\"\n        if parameter_name is not None:\n            parameter_name = parameter_name.replace(' ', '_')\n            if parameter_value_default is not None:\n                if implemented_requirement.set_parameters is None:\n                    implemented_requirement.set_parameters = []\n                values = [parameter_value_default]\n                set_parameter = SetParameter(param_id=parameter_name, values=values)\n                set_parameters = [set_parameter]\n                # set_parameters is a list\n                implemented_requirement.set_parameters.extend(set_parameters)\n\n    def _get_defined_component(self, component_name: str, component_type: str) -&gt; DefinedComponent:\n\"\"\"Get defined component.\"\"\"\n        key = component_name + key_sep + component_type\n        defined_component = self.defined_components.get(key)\n        if not defined_component:\n            # create new component\n            component_title = component_name\n            component_description = component_name\n            defined_component = DefinedComponent(\n                uuid=str(uuid.uuid4()),\n                description=component_description,\n                title=component_title,\n                type=component_type,\n            )\n            self.defined_components[key] = defined_component\n        return defined_component\n\n    def _build_roles(self) -&gt; List[Role]:\n\"\"\"Build roles.\"\"\"\n        value = [\n            Role(id='prepared-by', title='Indicates the organization that created this content.'),\n            Role(id='prepared-for', title='Indicates the organization for which this content was created..'),\n            Role(\n                id='content-approver',\n                title='Indicates the organization responsible for all content represented in the \"document\".'\n            ),\n        ]\n        return value\n\n    def _build_responsible_roles(self, party_uuid_01: str, party_uuid_02: str,\n                                 party_uuid_03: str) -&gt; List[ResponsibleRole]:\n\"\"\"Build responsible roles.\"\"\"\n        role_prepared_by = ResponsibleRole(role_id='prepared-by', party_uuids=[party_uuid_01])\n        role_prepared_for = ResponsibleRole(role_id='prepared-for', party_uuids=[party_uuid_02, party_uuid_03])\n        role_content_approver = ResponsibleRole(role_id='content-approver', party_uuids=[party_uuid_01])\n        value = [\n            role_prepared_by,\n            role_prepared_for,\n            role_content_approver,\n        ]\n        return value\n\n    def _build_parties(self, party_uuid_01: str, party_uuid_02: str, party_uuid_03: str) -&gt; List[Party]:\n\"\"\"Build parties.\"\"\"\n        value = [\n            Party(uuid=party_uuid_01, type='organization', name=self._get_org_name(), remarks=self._get_org_remarks()),\n            Party(\n                uuid=party_uuid_02,\n                type='organization',\n                name='Customer',\n                remarks='organization to be customized at account creation only for their Component Definition'\n            ),\n            Party(\n                uuid=party_uuid_03,\n                type='organization',\n                name='ISV',\n                remarks='organization to be customized at ISV subscription only for their Component Definition'\n            ),\n        ]\n        return value\n\n    def _build_responsible_parties(self, party_uuid_01: str, party_uuid_02: str,\n                                   party_uuid_03: str) -&gt; List[ResponsibleParty]:\n\"\"\"Build responsible parties.\"\"\"\n        prepared_by = ResponsibleParty(role_id='prepared-by', party_uuids=[party_uuid_01])\n        prepared_for = ResponsibleParty(role_id='prepared-for', party_uuids=[party_uuid_02, party_uuid_03])\n        content_approver = ResponsibleParty(role_id='content-approver', party_uuids=[party_uuid_01])\n        value = [\n            prepared_by,\n            prepared_for,\n            content_approver,\n        ]\n        return value\n\n    def _report_issues(self) -&gt; None:\n\"\"\"Report issues.\"\"\"\n        self.xlsx_helper.report_issues()\n\n    def _get_org_name(self) -&gt; str:\n\"\"\"Get org-name from config.\"\"\"\n        value = self._config.get('org-name')\n        logger.debug(f'org-name: {value}')\n        return value\n\n    def _get_org_remarks(self) -&gt; str:\n\"\"\"Get org-remarks from config.\"\"\"\n        value = self._config.get('org-remarks')\n        logger.debug(f'org-remarks: {value}')\n        return value\n\n    def _get_class_for_property_name(self, property_name: str) -&gt; str:\n\"\"\"Get class for property-name from config.\"\"\"\n        value = None\n        data = self._config.get('property-name-to-class')\n        if data is not None:\n            for item in data.split(','):\n                item = item.strip()\n                parts = item.split(':')\n                if len(parts) != 2 or parts[0] != property_name:\n                    continue\n                value = parts[1]\n                break\n        logger.debug(f'property-name-to-class: {property_name} -&gt; {value}')\n        return value\n\n    def _get_namespace(self) -&gt; str:\n\"\"\"Get namespace from config.\"\"\"\n        value = self._config.get('namespace')\n        logger.debug(f'namespace: {value}')\n        return value\n\n    def _get_catalog_url(self) -&gt; str:\n\"\"\"Get catalog url from config.\"\"\"\n        value = self._config.get('catalog-url')\n        logger.debug(f'catalog-url: {value}')\n        return value\n\n    def _get_catalog_title(self) -&gt; str:\n\"\"\"Get catalog title from config.\"\"\"\n        value = self._config.get('catalog-title')\n        logger.debug(f'catalog-title: {value}')\n        return value\n\n    def _get_goal_version(self) -&gt; str:\n\"\"\"Fix goal_version at 1.0.\"\"\"\n        return '1.0'\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.XlsxToOscalComponentDefinition.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.XlsxToOscalComponentDefinition-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.XlsxToOscalComponentDefinition.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task xlsx-to-oscal-cd.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>Optional[configparser.SectionProxy]</code> <p>Config section associated with the task.</p> required Source code in <code>trestle/tasks/xlsx_to_oscal_cd.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task xlsx-to-oscal-cd.\n\n    Args:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n    self.xlsx_helper = XlsxHelper()\n    self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                ).isoformat()\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.XlsxToOscalComponentDefinition.execute","title":"<code>execute(self)</code>","text":"<p>Provide an executed outcome.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_cd.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an executed outcome.\"\"\"\n    try:\n        return self._execute()\n    except Exception:\n        logger.info(traceback.format_exc())\n        return TaskOutcome('failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.XlsxToOscalComponentDefinition.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_cd.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    self.xlsx_helper.print_info(self.name, 'component_definition')\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.XlsxToOscalComponentDefinition.set_timestamp","title":"<code>set_timestamp(self, timestamp)</code>","text":"<p>Set the timestamp.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_cd.py</code> <pre><code>def set_timestamp(self, timestamp: str) -&gt; None:\n\"\"\"Set the timestamp.\"\"\"\n    self._timestamp = timestamp\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_cd/#trestle.tasks.xlsx_to_oscal_cd.XlsxToOscalComponentDefinition.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_cd.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    return TaskOutcome('simulated-success')\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/","title":"xlsx_to_oscal_profile","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile","title":"<code>trestle.tasks.xlsx_to_oscal_profile</code>","text":"<p>OSCAL transformation tasks.</p>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile-classes","title":"Classes","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile.XlsxToOscalProfile","title":"<code> XlsxToOscalProfile            (TaskBase)         </code>","text":"<p>Task to create OSCAL Profile json.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the task.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_profile.py</code> <pre><code>class XlsxToOscalProfile(TaskBase):\n\"\"\"\n    Task to create OSCAL Profile json.\n\n    Attributes:\n        name: Name of the task.\n    \"\"\"\n\n    name = 'xlsx-to-oscal-profile'\n\n    def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n        Initialize trestle task xlsx-to-oscal-profile.\n\n        Args:\n            config_object: Config section associated with the task.\n        \"\"\"\n        super().__init__(config_object)\n        self.xlsx_helper = XlsxHelper()\n        self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                    ).isoformat()\n\n    def set_timestamp(self, timestamp: str) -&gt; None:\n\"\"\"Set the timestamp.\"\"\"\n        self._timestamp = timestamp\n\n    def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n        self.xlsx_helper.print_info(self.name, 'profile')\n\n    def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n        return TaskOutcome('simulated-success')\n\n    def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an executed outcome.\"\"\"\n        try:\n            return self._execute()\n        except Exception:\n            logger.info(traceback.format_exc())\n            return TaskOutcome('failure')\n\n    def _execute(self) -&gt; TaskOutcome:\n\"\"\"Execute path core.\"\"\"\n        if not self.xlsx_helper.configure(self):\n            return TaskOutcome('failure')\n        # config output\n        odir = self._config.get('output-dir')\n        opth = pathlib.Path(odir)\n        self._overwrite = self._config.getboolean('output-overwrite', True)\n        # insure output dir exists\n        opth.mkdir(exist_ok=True, parents=True)\n        # calculate output file name &amp; check writability\n        oname = 'profile.json'\n        ofile = opth / oname\n        if not self._overwrite and pathlib.Path(ofile).exists():\n            logger.error(f'output: {ofile} already exists')\n            return TaskOutcome('failure')\n        # create OSCAL Profile\n        metadata = Metadata(\n            title='Profile for ' + self._get_profile_title(),\n            last_modified=self._timestamp,\n            oscal_version=OSCAL_VERSION,\n            version=get_trestle_version(),\n        )\n        if self.xlsx_helper.profile_type == self.xlsx_helper.by_control:\n            imports = self._get_imports_by_control()\n            profile = Profile(\n                uuid=str(uuid.uuid4()),\n                metadata=metadata,\n                imports=imports,\n            )\n        else:\n            if self.xlsx_helper.profile_type == self.xlsx_helper.by_rule:\n                imports = self._get_imports_by_rule()\n            elif self.xlsx_helper.profile_type == self.xlsx_helper.by_check:\n                imports = self._get_imports_by_check()\n            else:\n                imports = self._get_imports_by_goal()\n            set_parameters = self._get_set_parameters()\n            modify = Modify(set_parameters=set_parameters)\n            profile = Profile(\n                uuid=str(uuid.uuid4()),\n                metadata=metadata,\n                imports=imports,\n                modify=modify,\n            )\n        # write OSCAL Profile to file\n        if self._verbose:\n            logger.info(f'output: {ofile}')\n        profile.oscal_write(pathlib.Path(ofile))\n        # issues\n        self._report_issues()\n        return TaskOutcome('success')\n\n    def _get_imports_by_goal(self) -&gt; List[Import]:\n\"\"\"Get imports by goal.\"\"\"\n        return self._get_imports_by_check()\n\n    def _get_imports_by_control(self) -&gt; List[Import]:\n\"\"\"Get imports by control.\"\"\"\n        import_ = Import(\n            href=self._get_spread_sheet_url(),\n            include_controls=[SelectControlById(with_ids=self._get_with_ids_by_control())],\n        )\n        imports = [import_]\n        return imports\n\n    def _get_imports_by_rule(self) -&gt; List[Import]:\n\"\"\"Get imports by rule.\"\"\"\n        import_ = Import(\n            href=self._get_spread_sheet_url(),\n            include_controls=[SelectControlById(with_ids=self._get_with_ids_by_rule())],\n        )\n        imports = [import_]\n        return imports\n\n    def _get_imports_by_check(self) -&gt; List[Import]:\n\"\"\"Get imports by check.\"\"\"\n        import_ = Import(\n            href=self._get_spread_sheet_url(),\n            include_controls=[SelectControlById(with_ids=self._get_with_ids_by_check())],\n        )\n        imports = [import_]\n        return imports\n\n    def _get_with_ids_by_control(self) -&gt; List[str]:\n\"\"\"Get controls from spread sheet.\"\"\"\n        control_list = []\n        for row in self.xlsx_helper.row_generator():\n            # quit when first row with no goal_id encountered\n            controls = self.xlsx_helper.get_controls(row)\n            if controls is not None:\n                for control in controls:\n                    control = self._oscal_namify(control)\n                    if control in control_list:\n                        continue\n                    control_list.append(control)\n        return sorted(control_list, key=self._control_sort_key)\n\n    def _get_with_ids_by_rule(self) -&gt; List[str]:\n\"\"\"Get rules from spread sheet.\"\"\"\n        rule_name_id_list = []\n        for row in self.xlsx_helper.row_generator():\n            # quit when first row with no goal_id encountered\n            rule_name_id = self.xlsx_helper.get_rule_name_id(row, strict=True)\n            if rule_name_id is not None:\n                if rule_name_id in rule_name_id_list:\n                    continue\n                rule_name_id_list.append(rule_name_id)\n        return sorted(rule_name_id_list)\n\n    def _get_with_ids_by_check(self) -&gt; List[str]:\n\"\"\"Get check from spread sheet.\"\"\"\n        check_name_id_list = []\n        for row in self.xlsx_helper.row_generator():\n            # quit when first row with no goal_id encountered\n            check_name_id = self.xlsx_helper.get_check_name_id(row, strict=True)\n            if check_name_id is not None:\n                if check_name_id in check_name_id_list:\n                    continue\n                check_name_id_list.append(check_name_id)\n        return sorted(check_name_id_list)\n\n    def _control_sort_key(self, control: str) -&gt; (str, int, int):\n\"\"\"Fabricate sort key.\"\"\"\n        k1 = control.split('-')[0]\n        k2 = int(control.split('-')[1].split('.')[0])\n        if '.' in control:\n            k3 = int(control.split('-')[1].split('.')[1])\n        else:\n            k3 = 0\n        return (k1, k2, k3)\n\n    def _oscal_namify(self, control: str) -&gt; str:\n\"\"\"Rectify parenthesized numbers in controls.\"\"\"\n        control = control.replace('(', '.')\n        control = control.replace(')', '')\n        return control\n\n    def _get_set_parameters(self) -&gt; List[SetParameter]:\n\"\"\"Get set parameters from spread sheet.\"\"\"\n        set_parameters = []\n        for row in self.xlsx_helper.row_generator():\n            # quit when first row with no goal_id encountered\n            param_id, label = self.xlsx_helper.get_parameter_name_and_description(row)\n            usage = self.xlsx_helper.get_parameter_usage(row)\n            values = self.xlsx_helper.get_parameter_values(row)\n            if param_id is None:\n                continue\n            set_parameter = SetParameter(\n                param_id=param_id,\n                label=label,\n                usage=usage,\n            )\n            if values is not None:\n                set_parameter.values = values\n            set_parameters.append(set_parameter)\n        return set_parameters\n\n    def _get_profile_title(self) -&gt; str:\n\"\"\"Get profile title from config.\"\"\"\n        value = self._config.get('profile-title')\n        logger.debug(f'profile-title: {value}')\n        return value\n\n    def _get_spread_sheet_url(self) -&gt; str:\n\"\"\"Get spread sheet url from config.\"\"\"\n        value = self._config.get('spread-sheet-url')\n        logger.debug(f'spread-sheet-url: {value}')\n        return value\n\n    def _report_issues(self) -&gt; None:\n\"\"\"Report issues.\"\"\"\n        self.xlsx_helper.report_issues()\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile.XlsxToOscalProfile.name","title":"<code>name: str</code>","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile.XlsxToOscalProfile-methods","title":"Methods","text":""},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile.XlsxToOscalProfile.__init__","title":"<code>__init__(self, config_object)</code>  <code>special</code>","text":"<p>Initialize trestle task xlsx-to-oscal-profile.</p> <p>Parameters:</p> Name Type Description Default <code>config_object</code> <code>Optional[configparser.SectionProxy]</code> <p>Config section associated with the task.</p> required Source code in <code>trestle/tasks/xlsx_to_oscal_profile.py</code> <pre><code>def __init__(self, config_object: Optional[configparser.SectionProxy]) -&gt; None:\n\"\"\"\n    Initialize trestle task xlsx-to-oscal-profile.\n\n    Args:\n        config_object: Config section associated with the task.\n    \"\"\"\n    super().__init__(config_object)\n    self.xlsx_helper = XlsxHelper()\n    self._timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc\n                                                                                ).isoformat()\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile.XlsxToOscalProfile.execute","title":"<code>execute(self)</code>","text":"<p>Provide an executed outcome.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_profile.py</code> <pre><code>def execute(self) -&gt; TaskOutcome:\n\"\"\"Provide an executed outcome.\"\"\"\n    try:\n        return self._execute()\n    except Exception:\n        logger.info(traceback.format_exc())\n        return TaskOutcome('failure')\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile.XlsxToOscalProfile.print_info","title":"<code>print_info(self)</code>","text":"<p>Print the help string.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_profile.py</code> <pre><code>def print_info(self) -&gt; None:\n\"\"\"Print the help string.\"\"\"\n    self.xlsx_helper.print_info(self.name, 'profile')\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile.XlsxToOscalProfile.set_timestamp","title":"<code>set_timestamp(self, timestamp)</code>","text":"<p>Set the timestamp.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_profile.py</code> <pre><code>def set_timestamp(self, timestamp: str) -&gt; None:\n\"\"\"Set the timestamp.\"\"\"\n    self._timestamp = timestamp\n</code></pre>"},{"location":"api_reference/trestle.tasks.xlsx_to_oscal_profile/#trestle.tasks.xlsx_to_oscal_profile.XlsxToOscalProfile.simulate","title":"<code>simulate(self)</code>","text":"<p>Provide a simulated outcome.</p> Source code in <code>trestle/tasks/xlsx_to_oscal_profile.py</code> <pre><code>def simulate(self) -&gt; TaskOutcome:\n\"\"\"Provide a simulated outcome.\"\"\"\n    return TaskOutcome('simulated-success')\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/","title":"osco","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco","title":"<code>trestle.transforms.implementations.osco</code>","text":"<p>Facilitate OSCAL-OSCO transformation.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco-classes","title":"Classes","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.ComplianceOperatorResult","title":"<code> ComplianceOperatorResult        </code>","text":"<p>Represents one result of OSCO data.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>class ComplianceOperatorResult():\n\"\"\"Represents one result of OSCO data.\"\"\"\n\n    def __init__(self, osco_xml: str) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n        self.osco_xml = osco_xml\n\n    def _get_version(self, root: Element) -&gt; str:\n\"\"\"Extract version from the XML.\"\"\"\n        value = None\n        for key, val in root.attrib.items():\n            if key == 'version':\n                value = val\n                break\n        return value\n\n    def _get_id(self, root: Element) -&gt; str:\n\"\"\"Extract id from the XML.\"\"\"\n        value = None\n        for key, val in root.attrib.items():\n            if key == 'id':\n                value = val\n                break\n        return value\n\n    def _get_target(self, root: Element) -&gt; str:\n\"\"\"Extract target from the XML.\"\"\"\n        value = None\n        for lev1 in root:\n            tag = _remove_namespace(lev1.tag)\n            if tag == 'target':\n                value = root.find(lev1.tag).text\n                break\n        return value\n\n    def _get_target_type(self, root: Element) -&gt; str:\n\"\"\"Extract target_type from the XML.\"\"\"\n        value = None\n        benchmark_href = self._get_benchmark_href(root)\n        if benchmark_href is not None and '-' in benchmark_href:\n            value = benchmark_href.split('-')[1]\n        return value\n\n    def _get_benchmark(self, root: Element, kw) -&gt; str:\n\"\"\"Extract benchmark from the XML.\"\"\"\n        value = None\n        for lev1 in root:\n            tag = _remove_namespace(lev1.tag)\n            if tag == 'benchmark':\n                value = lev1.get(kw)\n                break\n        return value\n\n    def _get_benchmark_href(self, root: Element) -&gt; str:\n\"\"\"Extract benchmark.href from the XML.\"\"\"\n        return self._get_benchmark(root, 'href')\n\n    def _get_benchmark_id(self, root: Element) -&gt; str:\n\"\"\"Extract benchmark.id from the XML.\"\"\"\n        return self._get_benchmark(root, 'id')\n\n    def _get_fact(self, lev1: Element, kw: str) -&gt; str:\n\"\"\"Extract fact from the XML.\"\"\"\n        value = None\n        for lev2 in lev1:\n            tag = _remove_namespace(lev2.tag)\n            if tag == 'fact':\n                name = lev2.get('name')\n                if name == kw:\n                    value = lev2.text\n                    break\n        return value\n\n    def _get_scanner_name(self, root: Element) -&gt; str:\n\"\"\"Extract scanner:name from the XML.\"\"\"\n        value = None\n        for lev1 in root:\n            tag = _remove_namespace(lev1.tag)\n            if tag == 'target-facts':\n                value = self._get_fact(lev1, 'urn:xccdf:fact:scanner:name')\n                break\n        return value\n\n    def _get_scanner_version(self, root: Element) -&gt; str:\n\"\"\"Extract scanner:version from the XML.\"\"\"\n        value = None\n        for lev1 in root:\n            tag = _remove_namespace(lev1.tag)\n            if tag == 'target-facts':\n                value = self._get_fact(lev1, 'urn:xccdf:fact:scanner:version')\n                break\n        return value\n\n    def _get_host_name(self, root: Element) -&gt; str:\n\"\"\"Extract asset:identifier:host_name from the XML.\"\"\"\n        value = None\n        for lev1 in root:\n            tag = _remove_namespace(lev1.tag)\n            if tag == 'target-facts':\n                value = self._get_fact(lev1, 'urn:xccdf:fact:asset:identifier:host_name')\n                break\n        return value\n\n    def _get_result(self, lev1: Element) -&gt; str:\n\"\"\"Extract result from the XML.\"\"\"\n        value = None\n        for lev2 in lev1:\n            tag = _remove_namespace(lev2.tag)\n            if tag == 'result':\n                value = lev1.find(lev2.tag).text\n                break\n        return value\n\n    def _parse_xml(self) -&gt; Iterator[RuleUse]:\n\"\"\"Parse the stringified XML.\"\"\"\n        results = self.osco_xml\n        root = ElementTree.fromstring(results, forbid_dtd=True)\n        version = self._get_version(root)\n        id_ = self._get_id(root)\n        target = self._get_target(root)\n        target_type = self._get_target_type(root)\n        host_name = self._get_host_name(root)\n        benchmark_href = self._get_benchmark_href(root)\n        benchmark_id = self._get_benchmark_id(root)\n        scanner_name = self._get_scanner_name(root)\n        scanner_version = self._get_scanner_version(root)\n        for lev1 in root:\n            tag = _remove_namespace(lev1.tag)\n            if tag == 'rule-result':\n                idref = lev1.get('idref')\n                time = lev1.get('time')\n                severity = lev1.get('severity')\n                weight = lev1.get('weight')\n                result = self._get_result(lev1)\n                args = {\n                    'id_': id_,\n                    'target': target,\n                    'target_type': target_type,\n                    'host_name': host_name,\n                    'benchmark_href': benchmark_href,\n                    'benchmark_id': benchmark_id,\n                    'scanner_name': scanner_name,\n                    'scanner_version': scanner_version,\n                    'idref': idref,\n                    'version': version,\n                    'time': time,\n                    'result': result,\n                    'severity': severity,\n                    'weight': weight\n                }\n                rule_use = RuleUse(args)\n                yield rule_use\n\n    def rule_use_generator(self) -&gt; Iterator[RuleUse]:\n\"\"\"Generate RuleUses by way of parsing the embedded XML.\"\"\"\n        return self._parse_xml()\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.ComplianceOperatorResult-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.ComplianceOperatorResult.__init__","title":"<code>__init__(self, osco_xml)</code>  <code>special</code>","text":"<p>Initialize given specified args.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def __init__(self, osco_xml: str) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n    self.osco_xml = osco_xml\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.ComplianceOperatorResult.rule_use_generator","title":"<code>rule_use_generator(self)</code>","text":"<p>Generate RuleUses by way of parsing the embedded XML.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def rule_use_generator(self) -&gt; Iterator[RuleUse]:\n\"\"\"Generate RuleUses by way of parsing the embedded XML.\"\"\"\n    return self._parse_xml()\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalProfileToOscoProfileTransformer","title":"<code> OscalProfileToOscoProfileTransformer            (FromOscalTransformer)         </code>","text":"<p>Interface for Oscal Profile to Osco Profile transformer.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>class OscalProfileToOscoProfileTransformer(FromOscalTransformer):\n\"\"\"Interface for Oscal Profile to Osco Profile transformer.\"\"\"\n\n    def __init__(\n        self,\n        extends='ocp4-cis-node',\n        api_version='compliance.openshift.io/v1alpha1',\n        kind='TailoredProfile',\n        name='customized-tailored-profile',\n        namespace='openshift-compliance',\n    ) -&gt; None:\n\"\"\"Initialize.\"\"\"\n        self._extends = extends\n        self._api_version = api_version\n        self._kind = kind\n        self._name = name\n        self._namespace = namespace\n\n    def transform(self, profile: Profile) -&gt; str:\n\"\"\"Transform the Profile into a OSCO yaml.\"\"\"\n        self._profile = profile\n        self._osco_version = self._get_normalized_version('osco_version', '0.1.46')\n        # set values\n        set_values = self._get_set_values()\n        # spec\n        if self._osco_version &lt; (0, 1, 40):\n            # for versions prior to 0.1.40, exclude 'description'\n            spec = {\n                'extends': self._get_metadata_prop_value('base_profile_mnemonic', self._extends),\n                'title': self._profile.metadata.title,\n                'setValues': set_values,\n            }\n        else:\n            # for versions 0.1.40 and beyond, include 'description'\n            spec = {\n                'description': self._get_metadata_prop_value('profile_mnemonic', self._name),\n                'extends': self._get_metadata_prop_value('base_profile_mnemonic', self._extends),\n                'title': self._profile.metadata.title,\n                'setValues': set_values,\n            }\n        disable_rules = self._get_disable_rules()\n        if disable_rules:\n            spec['disableRules'] = disable_rules\n        # yaml data\n        ydata = {\n            'apiVersion': self._api_version,\n            'kind': self._kind,\n            'metadata': {\n                'name': self._get_metadata_prop_value('profile_mnemonic', self._name),\n                'namespace': self._namespace,\n            },\n            'spec': spec,\n        }\n        return json.dumps(ydata)\n\n    def _get_normalized_version(self, prop_name, prop_default) -&gt; Tuple[int, int, int]:\n\"\"\"Get normalized version.\n\n        Normalize the \"x.y.z\" string value to an integer: 1,000,000*x + 1,000*y + z.\n        \"\"\"\n        try:\n            vparts = self._get_metadata_prop_value(prop_name, prop_default).split('.')\n            normalized_version = (int(vparts[0]), int(vparts[1]), int(vparts[2]))\n        except Exception:\n            logger.warning(f'metadata prop name={prop_name} value error')\n            vparts = prop_default.split('.')\n            normalized_version = (int(vparts[0]), int(vparts[1]), int(vparts[2]))\n        return normalized_version\n\n    def _get_set_values(self) -&gt; List[Dict]:\n\"\"\"Extract set_paramater name/value pairs from profile.\"\"\"\n        set_values = []\n        # for check versions prior to 0.1.59 include parameters\n        # for later versions parameters should not be specified, caveat emptor\n        if self._profile.modify is not None:\n            for set_parameter in as_list(self._profile.modify.set_parameters):\n                name = self._format_osco_rule_name(set_parameter.param_id)\n                parameter_value = set_parameter.values[0]\n                value = parameter_value\n                rationale = self._get_rationale_for_set_value()\n                set_value = {'name': name, 'value': value, 'rationale': rationale}\n                set_values.append(set_value)\n        return set_values\n\n    def _format_osco_rule_name(self, name: str) -&gt; str:\n\"\"\"Format for OSCO.\n\n        1. remove prefix xccdf_org.ssgproject.content_rule_\n        2. change underscores to dashes\n        3. add prefix ocp4-\n        \"\"\"\n        normalized_name = name.replace('xccdf_org.ssgproject.content_rule_', '').replace('_', '-')\n        if not normalized_name.startswith('ocp4-'):\n            normalized_name = f'ocp4-{normalized_name}'\n        return normalized_name\n\n    def _get_metadata_prop_value(self, name: str, default_: str) -&gt; str:\n\"\"\"Extract metadata prop or else default if not present.\"\"\"\n        for prop in as_list(self._profile.metadata.props):\n            if prop.name == name:\n                return prop.value\n        logger.info(f'using default: {name} = {default_}')\n        return default_\n\n    def _get_disable_rules(self) -&gt; List[str]:\n\"\"\"Extract disabled rules.\"\"\"\n        value = []\n        for _import in as_list(self._profile.imports):\n            for control in as_list(_import.exclude_controls):\n                self._add_disable_rules_for_control(value, control)\n        return value\n\n    def _add_disable_rules_for_control(self, value, control):\n\"\"\"Extract disabled rules for control.\"\"\"\n        for with_id in as_list(control.with_ids):\n            name = self._format_osco_rule_name(with_id.__root__)\n            rationale = self._get_rationale_for_disable_rule()\n            entry = {'name': name, 'rationale': rationale}\n            value.append(entry)\n\n    def _get_rationale_for_set_value(self) -&gt; str:\n\"\"\"Rationale for set value.\"\"\"\n        return 'not determinable from specification'\n\n    def _get_rationale_for_disable_rule(self) -&gt; str:\n\"\"\"Rationale for disable rule.\"\"\"\n        return 'not determinable from specification'\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalProfileToOscoProfileTransformer-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalProfileToOscoProfileTransformer.__init__","title":"<code>__init__(self, extends='ocp4-cis-node', api_version='compliance.openshift.io/v1alpha1', kind='TailoredProfile', name='customized-tailored-profile', namespace='openshift-compliance')</code>  <code>special</code>","text":"<p>Initialize.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def __init__(\n    self,\n    extends='ocp4-cis-node',\n    api_version='compliance.openshift.io/v1alpha1',\n    kind='TailoredProfile',\n    name='customized-tailored-profile',\n    namespace='openshift-compliance',\n) -&gt; None:\n\"\"\"Initialize.\"\"\"\n    self._extends = extends\n    self._api_version = api_version\n    self._kind = kind\n    self._name = name\n    self._namespace = namespace\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalProfileToOscoProfileTransformer.transform","title":"<code>transform(self, profile)</code>","text":"<p>Transform the Profile into a OSCO yaml.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def transform(self, profile: Profile) -&gt; str:\n\"\"\"Transform the Profile into a OSCO yaml.\"\"\"\n    self._profile = profile\n    self._osco_version = self._get_normalized_version('osco_version', '0.1.46')\n    # set values\n    set_values = self._get_set_values()\n    # spec\n    if self._osco_version &lt; (0, 1, 40):\n        # for versions prior to 0.1.40, exclude 'description'\n        spec = {\n            'extends': self._get_metadata_prop_value('base_profile_mnemonic', self._extends),\n            'title': self._profile.metadata.title,\n            'setValues': set_values,\n        }\n    else:\n        # for versions 0.1.40 and beyond, include 'description'\n        spec = {\n            'description': self._get_metadata_prop_value('profile_mnemonic', self._name),\n            'extends': self._get_metadata_prop_value('base_profile_mnemonic', self._extends),\n            'title': self._profile.metadata.title,\n            'setValues': set_values,\n        }\n    disable_rules = self._get_disable_rules()\n    if disable_rules:\n        spec['disableRules'] = disable_rules\n    # yaml data\n    ydata = {\n        'apiVersion': self._api_version,\n        'kind': self._kind,\n        'metadata': {\n            'name': self._get_metadata_prop_value('profile_mnemonic', self._name),\n            'namespace': self._namespace,\n        },\n        'spec': spec,\n    }\n    return json.dumps(ydata)\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory","title":"<code> OscalResultsFactory        </code>","text":"<p>Build OSCO OSCAL entities.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>class OscalResultsFactory():\n\"\"\"Build OSCO OSCAL entities.\"\"\"\n\n    default_timestamp = ResultsTransformer.get_timestamp()\n\n    def __init__(self, timestamp: str = default_timestamp, checking: bool = False) -&gt; None:\n\"\"\"Initialize.\"\"\"\n        self._timestamp = timestamp\n        self._observation_list: List[Observation] = []\n        self._result_properties_list: List[Property] = []\n        self._component_map: Dict[str, SystemComponent] = {}\n        self._inventory_map: Dict[str, InventoryItem] = {}\n        self._ns = 'https://ibm.github.io/compliance-trestle/schemas/oscal/ar/osco'\n        self._checking = checking\n\n    @property\n    def components(self) -&gt; List[SystemComponent]:\n\"\"\"OSCAL components.\"\"\"\n        return list(self._component_map.values())\n\n    @property\n    def control_selections(self) -&gt; List[ControlSelection]:\n\"\"\"OSCAL control selections.\"\"\"\n        prop = []\n        prop.append(ControlSelection())\n        return prop\n\n    @property\n    def inventory(self) -&gt; ValuesView[InventoryItem]:\n\"\"\"OSCAL inventory.\"\"\"\n        return self._inventory_map.values()\n\n    @property\n    def local_definitions(self) -&gt; LocalDefinitions1:\n\"\"\"OSCAL local definitions.\"\"\"\n        prop = LocalDefinitions1()\n        prop.components = self.components\n        prop.inventory_items = list(self.inventory)\n        return prop\n\n    @property\n    def observations(self) -&gt; List[Observation]:\n\"\"\"OSCAL observations.\"\"\"\n        return self._observation_list\n\n    @property\n    def result_properties(self) -&gt; List[Property]:\n\"\"\"OSCAL result properties.\"\"\"\n        return self._result_properties_list\n\n    @property\n    def reviewed_controls(self) -&gt; ReviewedControls:\n\"\"\"OSCAL reviewed controls.\"\"\"\n        prop = ReviewedControls(control_selections=self.control_selections)\n        return prop\n\n    @property\n    def result(self) -&gt; Result:\n\"\"\"OSCAL result.\"\"\"\n        # perform result properties aggregation\n        if self.observations:\n            self._result_properties_list = TransformerHelper().remove_common_observation_properties(self.observations)\n        # produce result\n        prop = Result(\n            uuid=str(uuid.uuid4()),\n            title='OpenShift Compliance Operator',\n            description='OpenShift Compliance Operator Scan Results',\n            start=self._timestamp,\n            end=self._timestamp,\n            reviewed_controls=self.reviewed_controls,\n        )\n        if self.result_properties:\n            prop.props = self.result_properties\n        if self.inventory:\n            prop.local_definitions = self.local_definitions\n        if self.observations:\n            prop.observations = self.observations\n        return prop\n\n    @property\n    def analysis(self) -&gt; List[str]:\n\"\"\"OSCAL statistics.\"\"\"\n        analysis = []\n        analysis.append(f'inventory: {len(self.inventory)}')\n        analysis.append(f'observations: {len(self.observations)}')\n        return analysis\n\n    def _component_extract(self, rule_use: RuleUse) -&gt; None:\n\"\"\"Extract component from RuleUse.\"\"\"\n        _type = 'Service'\n        _title = f'Red Hat OpenShift Kubernetes Service Compliance Operator for {rule_use.target_type}'\n        _desc = _title\n        for component in self._component_map.values():\n            if component.type == _type and component.title == _title and component.description == _desc:\n                return\n        component_ref = str(uuid.uuid4())\n        status = Status1(state='operational')\n        component = SystemComponent(uuid=component_ref, type=_type, title=_title, description=_desc, status=status)\n        self._component_map[component_ref] = component\n\n    def _get_component_ref(self, rule_use: RuleUse) -&gt; str:\n\"\"\"Get component reference for specified RuleUse.\"\"\"\n        uuid = None\n        for component_ref, component in self._component_map.items():\n            if component.title.endswith(rule_use.target_type):\n                uuid = component_ref\n        return uuid\n\n    def _inventory_extract(self, rule_use: RuleUse) -&gt; None:\n\"\"\"Extract inventory from RuleUse.\"\"\"\n        if rule_use.inventory_key in self._inventory_map:\n            return\n        inventory = InventoryItem(uuid=str(uuid.uuid4()), description='inventory')\n        inventory.props = self._get_inventory_properties(rule_use)\n        inventory.implemented_components = [ImplementedComponent(component_uuid=self._get_component_ref(rule_use))]\n        self._inventory_map[rule_use.inventory_key] = inventory\n\n    def _get_inventory_properties(self, rule_use):\n\"\"\"Get inventory properties.\"\"\"\n        if self._checking:\n            return self._get_inventory_properties_checked(rule_use)\n        else:\n            return self._get_inventory_properties_unchecked(rule_use)\n\n    def _get_inventory_properties_checked(self, rule_use):\n\"\"\"Get inventory properties, with checking.\"\"\"\n        props = []\n        if rule_use.host_name is None:\n            props.append(Property(name='target', value=rule_use.target, ns=self._ns, class_='scc_inventory_item_id'))\n            props.append(Property(name='target_type', value=rule_use.target_type, ns=self._ns))\n        else:\n            props.append(Property(name='target', value=rule_use.target, ns=self._ns))\n            props.append(Property(name='target_type', value=rule_use.target_type, ns=self._ns))\n            props.append(\n                Property(name='host_name', value=rule_use.host_name, ns=self._ns, class_='scc_inventory_item_id')\n            )\n        return props\n\n    def _get_inventory_properties_unchecked(self, rule_use):\n\"\"\"Get observation properties, without checking.\"\"\"\n        props = []\n        if rule_use.host_name is None:\n            props.append(\n                Property.construct(name='target', value=rule_use.target, ns=self._ns, class_='scc_inventory_item_id')\n            )\n            props.append(Property.construct(name='target_type', value=rule_use.target_type, ns=self._ns))\n        else:\n            props.append(Property.construct(name='target', value=rule_use.target, ns=self._ns))\n            props.append(Property.construct(name='target_type', value=rule_use.target_type, ns=self._ns))\n            props.append(\n                Property.construct(\n                    name='host_name', value=rule_use.host_name, ns=self._ns, class_='scc_inventory_item_id'\n                )\n            )\n        return props\n\n    def _get_inventory_ref(self, rule_use: RuleUse) -&gt; str:\n\"\"\"Get inventory reference for specified RuleUse.\"\"\"\n        return self._inventory_map[rule_use.inventory_key].uuid\n\n    def _observation_extract(self, rule_use: RuleUse) -&gt; None:\n\"\"\"Extract observation from RuleUse.\"\"\"\n        observation = Observation(\n            uuid=str(uuid.uuid4()), description=rule_use.idref, methods=['TEST-AUTOMATED'], collected=self._timestamp\n        )\n        subject_reference = SubjectReference(subject_uuid=self._get_inventory_ref(rule_use), type='inventory-item')\n        observation.subjects = [subject_reference]\n        observation.props = self._get_observation_properties(rule_use)\n        self._observation_list.append(observation)\n        rule_use.observation = observation\n\n    def _get_observation_properties(self, rule_use):\n\"\"\"Get observation properties.\"\"\"\n        if self._checking:\n            return self._get_observation_properties_checked(rule_use)\n        else:\n            return self._get_observation_properties_unchecked(rule_use)\n\n    def _get_observation_properties_checked(self, rule_use):\n\"\"\"Get observation properties, with checking.\"\"\"\n        props = []\n        props.append(Property(name='scanner_name', value=rule_use.scanner_name, ns=self._ns))\n        props.append(Property(name='scanner_version', value=rule_use.scanner_version, ns=self._ns))\n        props.append(Property(name='idref', value=rule_use.idref, ns=self._ns, class_='scc_check_name_id'))\n        props.append(Property(name='version', value=rule_use.version, ns=self._ns, class_='scc_check_version'))\n        props.append(Property(name='result', value=rule_use.result, ns=self._ns, class_='scc_result'))\n        props.append(Property(name='time', value=rule_use.time, ns=self._ns, class_='scc_timestamp'))\n        props.append(Property(name='severity', value=rule_use.severity, ns=self._ns, class_='scc_check_severity'))\n        props.append(Property(name='weight', value=rule_use.weight, ns=self._ns))\n        props.append(Property(name='benchmark_id', value=rule_use.benchmark_id, ns=self._ns))\n        props.append(Property(name='benchmark_href', value=rule_use.benchmark_href, ns=self._ns))\n        props.append(Property(name='id', value=rule_use.id_, ns=self._ns, class_='scc_predefined_profile'))\n        return props\n\n    def _get_observation_properties_unchecked(self, rule_use):\n\"\"\"Get observation properties, without checking.\"\"\"\n        props = []\n        props.append(Property.construct(name='scanner_name', value=rule_use.scanner_name, ns=self._ns))\n        props.append(Property.construct(name='scanner_version', value=rule_use.scanner_version, ns=self._ns))\n        props.append(Property.construct(name='idref', value=rule_use.idref, ns=self._ns, class_='scc_check_name_id'))\n        props.append(\n            Property.construct(name='version', value=rule_use.version, ns=self._ns, class_='scc_check_version')\n        )\n        props.append(Property.construct(name='result', value=rule_use.result, ns=self._ns, class_='scc_result'))\n        props.append(Property.construct(name='time', value=rule_use.time, ns=self._ns, class_='scc_timestamp'))\n        props.append(\n            Property.construct(name='severity', value=rule_use.severity, ns=self._ns, class_='scc_check_severity')\n        )\n        props.append(Property.construct(name='weight', value=rule_use.weight, ns=self._ns))\n        props.append(Property.construct(name='benchmark_id', value=rule_use.benchmark_id, ns=self._ns))\n        props.append(Property.construct(name='benchmark_href', value=rule_use.benchmark_href, ns=self._ns))\n        props.append(Property.construct(name='id', value=rule_use.id_, ns=self._ns, class_='scc_predefined_profile'))\n        return props\n\n    def _process(self, co_result: ComplianceOperatorResult) -&gt; None:\n\"\"\"Process ingested data.\"\"\"\n        rule_use_generator = co_result.rule_use_generator()\n        for rule_use in rule_use_generator:\n            self._component_extract(rule_use)\n            self._inventory_extract(rule_use)\n            self._observation_extract(rule_use)\n\n    def ingest(self, osco_data: Dict[str, Any]) -&gt; None:\n\"\"\"Process OSCO json.\"\"\"\n        if 'data' not in osco_data.keys():\n            return\n        if 'results' not in osco_data['data']:\n            return\n        results = osco_data['data']['results']\n        self.ingest_xml(results)\n\n    def ingest_xml(self, osco_xml: str) -&gt; None:\n\"\"\"Process OSCO xml.\"\"\"\n        if not osco_xml.startswith('&lt;?xml'):\n            osco_xml = bz2.decompress(base64.b64decode(osco_xml))\n        co_result = ComplianceOperatorResult(osco_xml)\n        self._process(co_result)\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.analysis","title":"<code>analysis: List[str]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL statistics.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.components","title":"<code>components: List[trestle.oscal.assessment_results.SystemComponent]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL components.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.control_selections","title":"<code>control_selections: List[trestle.oscal.assessment_results.ControlSelection]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL control selections.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.default_timestamp","title":"<code>default_timestamp</code>","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.inventory","title":"<code>inventory: ValuesView[trestle.oscal.common.InventoryItem]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL inventory.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.local_definitions","title":"<code>local_definitions: LocalDefinitions1</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL local definitions.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.observations","title":"<code>observations: List[trestle.oscal.assessment_results.Observation]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL observations.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.result","title":"<code>result: Result</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL result.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.result_properties","title":"<code>result_properties: List[trestle.oscal.common.Property]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL result properties.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.reviewed_controls","title":"<code>reviewed_controls: ReviewedControls</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL reviewed controls.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.__init__","title":"<code>__init__(self, timestamp='2023-04-06T04:33:22+00:00', checking=False)</code>  <code>special</code>","text":"<p>Initialize.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def __init__(self, timestamp: str = default_timestamp, checking: bool = False) -&gt; None:\n\"\"\"Initialize.\"\"\"\n    self._timestamp = timestamp\n    self._observation_list: List[Observation] = []\n    self._result_properties_list: List[Property] = []\n    self._component_map: Dict[str, SystemComponent] = {}\n    self._inventory_map: Dict[str, InventoryItem] = {}\n    self._ns = 'https://ibm.github.io/compliance-trestle/schemas/oscal/ar/osco'\n    self._checking = checking\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.ingest","title":"<code>ingest(self, osco_data)</code>","text":"<p>Process OSCO json.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def ingest(self, osco_data: Dict[str, Any]) -&gt; None:\n\"\"\"Process OSCO json.\"\"\"\n    if 'data' not in osco_data.keys():\n        return\n    if 'results' not in osco_data['data']:\n        return\n    results = osco_data['data']['results']\n    self.ingest_xml(results)\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscalResultsFactory.ingest_xml","title":"<code>ingest_xml(self, osco_xml)</code>","text":"<p>Process OSCO xml.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def ingest_xml(self, osco_xml: str) -&gt; None:\n\"\"\"Process OSCO xml.\"\"\"\n    if not osco_xml.startswith('&lt;?xml'):\n        osco_xml = bz2.decompress(base64.b64decode(osco_xml))\n    co_result = ComplianceOperatorResult(osco_xml)\n    self._process(co_result)\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscoResultToOscalARTransformer","title":"<code> OscoResultToOscalARTransformer            (ResultsTransformer)         </code>","text":"<p>Interface for Osco transformer.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>class OscoResultToOscalARTransformer(ResultsTransformer):\n\"\"\"Interface for Osco transformer.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize.\"\"\"\n        self._modes = {}\n\n    @property\n    def analysis(self) -&gt; List[str]:\n\"\"\"Analysis.\"\"\"\n        return self._results_factory.analysis\n\n    @property\n    def checking(self):\n\"\"\"Return checking.\"\"\"\n        return self._modes.get('checking', False)\n\n    def set_modes(self, modes: Dict[str, Any]) -&gt; None:\n\"\"\"Keep modes info.\"\"\"\n        if modes is not None:\n            self._modes = modes\n\n    def transform(self, blob: str) -&gt; Results:\n\"\"\"Transform the blob into a Results.\n\n        The expected blob is a string that is one of:\n            - data from OpenShift Compliance Operator (json, yaml, xml)\n            - data from Auditree OSCO fetcher/check (json)\n        \"\"\"\n        results = None\n        self._results_factory = OscalResultsFactory(self.get_timestamp(), self.checking)\n        if results is None:\n            results = self._ingest_xml(blob)\n        if results is None:\n            results = self._ingest_json(blob)\n        if results is None:\n            results = self._ingest_yaml(blob)\n        return results\n\n    def _ingest_xml(self, blob: str) -&gt; Results:\n\"\"\"Ingest xml data.\"\"\"\n        # ?xml data\n        if blob.startswith('&lt;?xml'):\n            resource = blob\n            self._results_factory.ingest_xml(resource)\n        else:\n            return None\n        results = Results()\n        results.__root__.append(self._results_factory.result)\n        return results\n\n    def _ingest_json(self, blob: str) -&gt; Results:\n\"\"\"Ingest json data.\"\"\"\n        try:\n            # ? configmaps or auditree data\n            jdata = json.loads(blob)\n            # https://docs.openshift.com/container-platform/3.7/rest_api/api/v1.ConfigMap.html#Get-api-v1-namespaces-namespace-configmaps-name\n            if 'kind' in jdata.keys() and jdata['kind'] == 'ConfigMapList' and 'items' in jdata.keys():\n                items = jdata['items']\n                for item in items:\n                    if 'data' in item.keys():\n                        data = item['data']\n                        if 'results' in data:\n                            resource = item\n                            self._results_factory.ingest(resource)\n            # https://github.com/ComplianceAsCode/auditree-arboretum/blob/main/arboretum/kubernetes/fetchers/fetch_cluster_resource.py\n            else:\n                for key in jdata.keys():\n                    for group in jdata[key]:\n                        for cluster in jdata[key][group]:\n                            if 'resources' in cluster:\n                                for resource in cluster['resources']:\n                                    self._results_factory.ingest(resource)\n        except json.decoder.JSONDecodeError:\n            return None\n        results = Results()\n        results.__root__.append(self._results_factory.result)\n        return results\n\n    def _ingest_yaml(self, blob: str) -&gt; Results:\n\"\"\"Ingest yaml data.\"\"\"\n        try:\n            # ? yaml data\n            yaml = YAML(typ='safe')\n            resource = yaml.load(blob)\n            self._results_factory.ingest(resource)\n        except Exception as e:\n            raise e\n        results = Results()\n        results.__root__.append(self._results_factory.result)\n        return results\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscoResultToOscalARTransformer-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscoResultToOscalARTransformer.analysis","title":"<code>analysis: List[str]</code>  <code>property</code> <code>readonly</code>","text":"<p>Analysis.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscoResultToOscalARTransformer.checking","title":"<code>checking</code>  <code>property</code> <code>readonly</code>","text":"<p>Return checking.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscoResultToOscalARTransformer-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscoResultToOscalARTransformer.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize.\"\"\"\n    self._modes = {}\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscoResultToOscalARTransformer.set_modes","title":"<code>set_modes(self, modes)</code>","text":"<p>Keep modes info.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def set_modes(self, modes: Dict[str, Any]) -&gt; None:\n\"\"\"Keep modes info.\"\"\"\n    if modes is not None:\n        self._modes = modes\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscoResultToOscalARTransformer.transform","title":"<code>transform(self, blob)</code>","text":"<p>Transform the blob into a Results.</p> <p>The expected blob is a string that is one of:     - data from OpenShift Compliance Operator (json, yaml, xml)     - data from Auditree OSCO fetcher/check (json)</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def transform(self, blob: str) -&gt; Results:\n\"\"\"Transform the blob into a Results.\n\n    The expected blob is a string that is one of:\n        - data from OpenShift Compliance Operator (json, yaml, xml)\n        - data from Auditree OSCO fetcher/check (json)\n    \"\"\"\n    results = None\n    self._results_factory = OscalResultsFactory(self.get_timestamp(), self.checking)\n    if results is None:\n        results = self._ingest_xml(blob)\n    if results is None:\n        results = self._ingest_json(blob)\n    if results is None:\n        results = self._ingest_yaml(blob)\n    return results\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.OscoTransformer","title":"<code> OscoTransformer            (OscoResultToOscalARTransformer)         </code>","text":"<p>Legacy class name.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>class OscoTransformer(OscoResultToOscalARTransformer):\n\"\"\"Legacy class name.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.RuleUse","title":"<code> RuleUse        </code>","text":"<p>Represents one rule of OSCO data.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>class RuleUse():\n\"\"\"Represents one rule of OSCO data.\"\"\"\n\n    def __init__(self, args: Dict[str, str]) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n        self.id_ = args['id_']\n        self.target = args['target']\n        self.target_type = args['target_type']\n        self.host_name = args['host_name']\n        self.benchmark_href = args['benchmark_href']\n        self.benchmark_id = args['benchmark_id']\n        self.scanner_name = args['scanner_name']\n        self.scanner_version = args['scanner_version']\n        self.idref = args['idref']\n        self.version = args['version']\n        self.time = args['time']\n        self.result = args['result']\n        self.severity = args['severity']\n        self.weight = args['weight']\n\n    @property\n    def inventory_key(self):\n\"\"\"Derive inventory key.\"\"\"\n        if self.host_name is None:\n            # OpenScap 1.3.3\n            rval = self.target + ':' + self.target_type\n        else:\n            # OpenScap 1.3.5\n            rval = self.host_name + ':' + self.target_type\n        return rval\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.RuleUse-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.RuleUse.inventory_key","title":"<code>inventory_key</code>  <code>property</code> <code>readonly</code>","text":"<p>Derive inventory key.</p>"},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.RuleUse-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.implementations.osco/#trestle.transforms.implementations.osco.RuleUse.__init__","title":"<code>__init__(self, args)</code>  <code>special</code>","text":"<p>Initialize given specified args.</p> Source code in <code>trestle/transforms/implementations/osco.py</code> <pre><code>def __init__(self, args: Dict[str, str]) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n    self.id_ = args['id_']\n    self.target = args['target']\n    self.target_type = args['target_type']\n    self.host_name = args['host_name']\n    self.benchmark_href = args['benchmark_href']\n    self.benchmark_id = args['benchmark_id']\n    self.scanner_name = args['scanner_name']\n    self.scanner_version = args['scanner_version']\n    self.idref = args['idref']\n    self.version = args['version']\n    self.time = args['time']\n    self.result = args['result']\n    self.severity = args['severity']\n    self.weight = args['weight']\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/","title":"tanium","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium","title":"<code>trestle.transforms.implementations.tanium</code>","text":"<p>Facilitate Tanium result to NIST OSCAL transformation.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.logger","title":"<code>logger</code>","text":""},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium-classes","title":"Classes","text":""},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.RuleUse","title":"<code> RuleUse        </code>","text":"<p>Represents one row of Tanium data.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>class RuleUse():\n\"\"\"Represents one row of Tanium data.\"\"\"\n\n    def __init__(self, tanium_row: Dict[str, Any], comply: Dict[str, str], default_timestamp: str) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n        logger.debug(f'tanium-row: {tanium_row}')\n        try:\n            # level 1 keys\n            self.computer_name = tanium_row['Computer Name']\n            self.tanium_client_ip_address = tanium_row['Tanium Client IP Address']\n            self.ip_address = str(tanium_row['IP Address'])\n            self.count = str(tanium_row['Count'])\n            # comply keys\n            self.check_id = comply['Check ID']\n            self.rule_id = comply['Rule ID']\n            self.state = comply['State']\n            # defaults\n            no_results = '[no results]'\n            self.check_id_level = no_results\n            self.check_id_version = no_results\n            self.check_id_benchmark = no_results\n            self.component = no_results\n            self.component_type = no_results\n            # parse\n            if ';' in self.check_id:\n                items = self.check_id.split(';')\n                if len(items) &gt; 2:\n                    self.check_id_level = items[2]\n                if len(items) &gt; 1:\n                    self.check_id_version = items[1]\n                if len(items) &gt; 0:\n                    self.check_id_benchmark = items[0]\n                    self.component = items[0]\n                    if self.component.startswith('CIS '):\n                        self.component = self.component[len('CIS '):]\n                    if self.component.endswith(' Benchmark'):\n                        self.component = self.component[:-len(' Benchmark')]\n                    self.component_type = 'Operating System'\n            # timestamp\n            self.timestamp = comply.get('Timestamp', default_timestamp)\n            # collected\n            self.collected = default_timestamp\n        except Exception as e:\n            logger.debug(f'tanium-row: {tanium_row}')\n            logger.debug(e)\n            logger.debug(traceback.format_exc())\n            raise e\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.RuleUse-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.RuleUse.__init__","title":"<code>__init__(self, tanium_row, comply, default_timestamp)</code>  <code>special</code>","text":"<p>Initialize given specified args.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>def __init__(self, tanium_row: Dict[str, Any], comply: Dict[str, str], default_timestamp: str) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n    logger.debug(f'tanium-row: {tanium_row}')\n    try:\n        # level 1 keys\n        self.computer_name = tanium_row['Computer Name']\n        self.tanium_client_ip_address = tanium_row['Tanium Client IP Address']\n        self.ip_address = str(tanium_row['IP Address'])\n        self.count = str(tanium_row['Count'])\n        # comply keys\n        self.check_id = comply['Check ID']\n        self.rule_id = comply['Rule ID']\n        self.state = comply['State']\n        # defaults\n        no_results = '[no results]'\n        self.check_id_level = no_results\n        self.check_id_version = no_results\n        self.check_id_benchmark = no_results\n        self.component = no_results\n        self.component_type = no_results\n        # parse\n        if ';' in self.check_id:\n            items = self.check_id.split(';')\n            if len(items) &gt; 2:\n                self.check_id_level = items[2]\n            if len(items) &gt; 1:\n                self.check_id_version = items[1]\n            if len(items) &gt; 0:\n                self.check_id_benchmark = items[0]\n                self.component = items[0]\n                if self.component.startswith('CIS '):\n                    self.component = self.component[len('CIS '):]\n                if self.component.endswith(' Benchmark'):\n                    self.component = self.component[:-len(' Benchmark')]\n                self.component_type = 'Operating System'\n        # timestamp\n        self.timestamp = comply.get('Timestamp', default_timestamp)\n        # collected\n        self.collected = default_timestamp\n    except Exception as e:\n        logger.debug(f'tanium-row: {tanium_row}')\n        logger.debug(e)\n        logger.debug(traceback.format_exc())\n        raise e\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.RuleUseFactory","title":"<code> RuleUseFactory        </code>","text":"<p>Build RuleUse list.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>class RuleUseFactory():\n\"\"\"Build RuleUse list.\"\"\"\n\n    def __init__(self, timestamp: str) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n        self._timestamp = timestamp\n\n    def _make_sublist(self, tanium_row: Dict[str, Any]) -&gt; List[RuleUse]:\n\"\"\"Build RuleUse sublist from input data item.\"\"\"\n        retval = []\n        keys = tanium_row\n        for key in keys:\n            if key.startswith('Comply'):\n                break\n        comply_list = tanium_row[key]\n        for comply in comply_list:\n            rule_use = RuleUse(tanium_row, comply, self._timestamp)\n            retval.append(rule_use)\n        return retval\n\n    def make_list(self, blob: str) -&gt; List[RuleUse]:\n\"\"\"Build RuleUse list from input data.\"\"\"\n        retval = []\n        lines = blob.splitlines()\n        for line in lines:\n            line = line.strip()\n            if line:\n                jdata = json.loads(line)\n                if type(jdata) is list:\n                    for item in jdata:\n                        logger.debug(f'item: {item}')\n                        retval += self._make_sublist(item)\n                else:\n                    logger.debug(f'jdata: {jdata}')\n                    retval += self._make_sublist(jdata)\n        logger.debug(f'ru_list: {len(retval)}')\n        return retval\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.RuleUseFactory-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.RuleUseFactory.__init__","title":"<code>__init__(self, timestamp)</code>  <code>special</code>","text":"<p>Initialize given specified args.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>def __init__(self, timestamp: str) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n    self._timestamp = timestamp\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.RuleUseFactory.make_list","title":"<code>make_list(self, blob)</code>","text":"<p>Build RuleUse list from input data.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>def make_list(self, blob: str) -&gt; List[RuleUse]:\n\"\"\"Build RuleUse list from input data.\"\"\"\n    retval = []\n    lines = blob.splitlines()\n    for line in lines:\n        line = line.strip()\n        if line:\n            jdata = json.loads(line)\n            if type(jdata) is list:\n                for item in jdata:\n                    logger.debug(f'item: {item}')\n                    retval += self._make_sublist(item)\n            else:\n                logger.debug(f'jdata: {jdata}')\n                retval += self._make_sublist(jdata)\n    logger.debug(f'ru_list: {len(retval)}')\n    return retval\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory","title":"<code> TaniumOscalFactory        </code>","text":"<p>Build Tanium OSCAL entities.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>class TaniumOscalFactory():\n\"\"\"Build Tanium OSCAL entities.\"\"\"\n\n    def __init__(\n        self,\n        timestamp: str,\n        rule_use_list: List[RuleUse],\n        blocksize: int = 11000,\n        cpus_max: int = 1,\n        cpus_min: int = 1,\n        checking: bool = False,\n        caching: bool = True,\n        aggregate: bool = True\n    ) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n        self._rule_use_list = rule_use_list\n        self._timestamp = timestamp\n        self._component_map: Dict[str, SystemComponent] = {}\n        self._inventory_map: Dict[str, InventoryItem] = {}\n        self._observation_list: List[Observation] = []\n        self._ns = 'https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium'\n        self._cpus = None\n        self._checking = checking\n        self._caching = caching\n        self._aggregate = aggregate\n        self._result = None\n        # blocksize: default, min\n        self._blocksize = blocksize\n        if self._blocksize &lt; 1:\n            self._blocksize = 1\n        # cpus max: default, max, min\n        self._cpus_max = cpus_max\n        if self._cpus_max &gt; os.cpu_count():\n            self._cpus_max = os.cpu_count()\n        self._cpus_min = cpus_min\n        if self._cpus_min &gt; self._cpus_max:\n            self._cpus_min = self._cpus_max\n        if self._cpus_min &lt; 1:\n            self._cpus_min = 1\n        self._property_accounting = PropertyAccounting()\n        self._property_manager = PropertyManager(caching=caching, checking=checking)\n\n    def _is_duplicate_component(self, rule_use: RuleUse) -&gt; bool:\n\"\"\"Check for duplicate component.\"\"\"\n        retval = False\n        component_type = rule_use.component_type\n        component_title = rule_use.component\n        for component in self._component_map.values():\n            if component.type != component_type:\n                continue\n            if component.title != component_title:\n                continue\n            retval = True\n            break\n        return retval\n\n    def _derive_components(self) -&gt; None:\n\"\"\"Derive components from RuleUse list.\"\"\"\n        self._component_map: Dict[str, SystemComponent] = {}\n        for rule_use in self._rule_use_list:\n            if self._is_duplicate_component(rule_use):\n                continue\n            component_type = rule_use.component_type\n            component_title = rule_use.component\n            # See Note in _get_component_ref.\n            component_description = rule_use.component\n            component_ref = _uuid_component()\n            status = Status1(state='operational')\n            component = SystemComponent(\n                uuid=component_ref,\n                type=component_type,\n                title=component_title,\n                description=component_description,\n                status=status\n            )\n            self._component_map[component_ref] = component\n\n    def _get_component_ref(self, rule_use: RuleUse) -&gt; Optional[str]:\n\"\"\"Get component reference for specified rule use.\"\"\"\n        uuid = None\n        for component_ref, component in self._component_map.items():\n            if component.type != rule_use.component_type:\n                continue\n            if component.title != rule_use.component:\n                continue\n            # Note: currently title and description are the same,\n            # therefore checking description is not necessary.\n            uuid = component_ref\n            break\n        return uuid\n\n    def _derive_inventory(self) -&gt; None:\n\"\"\"Derive inventory from RuleUse list.\"\"\"\n        self._inventory_map: Dict[str, InventoryItem] = {}\n        for rule_use in self._rule_use_list:\n            if rule_use.tanium_client_ip_address in self._inventory_map:\n                continue\n            inventory = InventoryItem(uuid=_uuid_inventory(), description='inventory')\n            inventory.props = [\n                self._property_manager.materialize(name='Computer_Name', value=rule_use.computer_name, ns=self._ns),\n                self._property_manager.materialize(\n                    name='Tanium_Client_IP_Address',\n                    value=rule_use.tanium_client_ip_address,\n                    ns=self._ns,\n                    class_='scc_inventory_item_id'\n                ),\n                self._property_manager.materialize(name='IP_Address', value=rule_use.ip_address, ns=self._ns),\n                self._property_manager.materialize(name='Count', value=rule_use.count, ns=self._ns)\n            ]\n            component_uuid = self._get_component_ref(rule_use)\n            if component_uuid is not None:\n                inventory.implemented_components = [ImplementedComponent(component_uuid=component_uuid)]\n            self._inventory_map[rule_use.tanium_client_ip_address] = inventory\n\n    def _get_inventory_ref(self, rule_use: RuleUse) -&gt; str:\n\"\"\"Get inventory reference for specified rule use.\"\"\"\n        return self._inventory_map[rule_use.tanium_client_ip_address].uuid\n\n    def _conditional_include(\n        self,\n        props: List[Property],\n        group: str = None,\n        name: str = None,\n        value: str = None,\n        ns: str = None,\n        class_: str = None\n    ) -&gt; None:\n\"\"\"Add non-aggregated property or remember common property.\"\"\"\n        if self._aggregate:\n            if self._property_accounting.is_common_property(group=group, name=name, value=value, ns=ns, class_=class_):\n                # common property\n                self._property_manager.put_common_property(group=group, name=name, value=value, ns=ns, class_=class_)\n                return\n        # non-aggregated property\n        props.append(self._property_manager.materialize(name=name, value=value, ns=ns, class_=class_))\n\n    def _get_observtion_properties(self, rule_use: RuleUse) -&gt; List[Property]:\n\"\"\"Get observation properties.\"\"\"\n        props = []\n        group = self._get_component_ref(rule_use)\n        self._conditional_include(props=props, group=group, name='Check_ID', value=rule_use.check_id, ns=self._ns)\n        self._conditional_include(\n            props=props,\n            group=group,\n            name='Check_ID_Benchmark',\n            value=rule_use.check_id_benchmark,\n            ns=self._ns,\n            class_='scc_predefined_profile'\n        )\n        self._conditional_include(\n            props=props,\n            group=group,\n            name='Check_ID_Version',\n            value=rule_use.check_id_version,\n            ns=self._ns,\n            class_='scc_predefined_profile_version'\n        )\n        self._conditional_include(\n            props=props, group=group, name='Check_ID_Level', value=rule_use.check_id_level, ns=self._ns\n        )\n        self._conditional_include(\n            props=props,\n            group=group,\n            name='Rule_ID',\n            value=rule_use.rule_id,\n            ns=self._ns,\n            class_='scc_goal_description'\n        )\n        self._conditional_include(\n            props=props, group=group, name='Rule_ID', value=rule_use.rule_id, ns=self._ns, class_='scc_check_name_id'\n        )\n        self._conditional_include(\n            props=props, group=group, name='State', value=rule_use.state, ns=self._ns, class_='scc_result'\n        )\n        self._conditional_include(\n            props=props, group=group, name='Timestamp', value=rule_use.timestamp, ns=self._ns, class_='scc_timestamp'\n        )\n        return props\n\n    def _derive_common_property_accounting(self) -&gt; None:\n\"\"\"Derive common properties accounting from RuleUse list.\"\"\"\n        for rule_use in self._rule_use_list:\n            group = self._get_component_ref(rule_use)\n            self._property_accounting.count_group(group=group)\n            self._property_accounting.count_property(group=group, name='Check_ID', value=rule_use.check_id, ns=self._ns)\n            self._property_accounting.count_property(\n                group=group,\n                name='Check_ID_Benchmark',\n                value=rule_use.check_id_benchmark,\n                ns=self._ns,\n                class_='scc_predefined_profile'\n            )\n            self._property_accounting.count_property(\n                group=group,\n                name='Check_ID_Version',\n                value=rule_use.check_id_version,\n                ns=self._ns,\n                class_='scc_predefined_profile_version'\n            )\n            self._property_accounting.count_property(\n                group=group, name='Check_ID_Level', value=rule_use.check_id_level, ns=self._ns\n            )\n            self._property_accounting.count_property(\n                group=group, name='Rule_ID', value=rule_use.rule_id, ns=self._ns, class_='scc_goal_description'\n            )\n            self._property_accounting.count_property(\n                group=group, name='Rule_ID', value=rule_use.rule_id, ns=self._ns, class_='scc_check_name_id'\n            )\n            self._property_accounting.count_property(\n                group=group, name='State', value=rule_use.state, ns=self._ns, class_='scc_result'\n            )\n            self._property_accounting.count_property(\n                group=group, name='Timestamp', value=rule_use.timestamp, ns=self._ns, class_='scc_timestamp'\n            )\n\n    # parallel process to process one chuck of entire data set\n    def _batch_observations(self, index: int) -&gt; Dict[str, List[Observation]]:\n\"\"\"Derive batch of observations from RuleUse list.\"\"\"\n        observation_partial_map: Dict[str, List[Observation]] = {}\n        # determine which chunk to process\n        batch_size = (len(self._rule_use_list) // self._batch_workers) + 1\n        start = index * batch_size\n        end = (index + 1) * batch_size\n        end = min(end, len(self._rule_use_list))\n        logger.debug(f'start: {start} end: {end-1}')\n        # process just the one chunk\n        for i in range(start, end):\n            rule_use = self._rule_use_list[i]\n            observation = Observation(\n                uuid=_uuid_observation(),\n                description=rule_use.rule_id,\n                methods=['TEST-AUTOMATED'],\n                collected=rule_use.collected\n            )\n            subject_uuid = self._get_inventory_ref(rule_use)\n            subject_reference = SubjectReference(subject_uuid=subject_uuid, type='inventory-item')\n            observation.subjects = [subject_reference]\n            observation.props = self._get_observtion_properties(rule_use)\n            observation_partial_map[subject_uuid] = observation_partial_map.get(subject_uuid, []) + [observation]\n        return observation_partial_map\n\n    @property\n    def _batch_workers(self) -&gt; int:\n\"\"\"Calculate number of parallel processes to employ.\"\"\"\n        if self._cpus is None:\n            cpus_estimate = len(self._rule_use_list) // self._blocksize\n            self._cpus = max(min(cpus_estimate, self._cpus_max), self._cpus_min)\n            logger.debug(f'CPUs estimate: {cpus_estimate} available: {os.cpu_count()} selection: {self._cpus}')\n        return self._cpus\n\n    def _derive_observations(self) -&gt; None:\n\"\"\"Derive observations from RuleUse list.\"\"\"\n        self._observation_map = {}\n        if self._batch_workers == 1:\n            # no need for multiprocessing\n            self._observation_map = self._batch_observations(0)\n        else:\n            # use multiprocessing to perform observations creation in parallel\n            pool = multiprocessing.Pool(processes=self._batch_workers)\n            rval_list = pool.map(self._batch_observations, range(self._batch_workers))\n            # gather observations from the sundry batch workers\n            for partial_observation_map in rval_list:\n                self._observation_map = join_key_to_list_dicts(self._observation_map, partial_observation_map)\n\n    @property\n    def components(self) -&gt; List[SystemComponent]:\n\"\"\"OSCAL components.\"\"\"\n        return list(self._component_map.values())\n\n    @property\n    def inventory(self) -&gt; ValuesView[InventoryItem]:\n\"\"\"OSCAL inventory.\"\"\"\n        return self._inventory_map.values()\n\n    @property\n    def observations(self) -&gt; List[Observation]:\n\"\"\"OSCAL observations.\"\"\"\n        rval = []\n        # observations are partitioned by local-definition uuid; join them into one list\n        for key in self._observation_map:\n            list_ = self._observation_map[key]\n            for observation in list_:\n                rval.append(observation)\n        return rval\n\n    @property\n    def control_selections(self) -&gt; List[ControlSelection]:\n\"\"\"OSCAL control selections.\"\"\"\n        rval = []\n        rval.append(ControlSelection())\n        return rval\n\n    @property\n    def reviewed_controls(self) -&gt; ReviewedControls:\n\"\"\"OSCAL reviewed controls.\"\"\"\n        rval = ReviewedControls(control_selections=self.control_selections)\n        return rval\n\n    @property\n    def analysis(self) -&gt; List[str]:\n\"\"\"OSCAL statistics.\"\"\"\n        analysis = []\n        analysis.append(f'components: {len(self.components)}')\n        analysis.append(f'inventory: {len(self.inventory)}')\n        analysis.append(f'observations: {len(self.observations)}')\n        analysis.append(f'cache: requests={self._property_manager.requests} hits={self._property_manager.hits}')\n        return analysis\n\n    def _get_local_definitions(self, system_component: SystemComponent) -&gt; LocalDefinitions1:\n\"\"\"Get local definitions.\"\"\"\n        rval = LocalDefinitions1()\n        for component in self.components:\n            if component.uuid == system_component.uuid:\n                rval.components = [component]\n                rval.inventory_items = []\n                for inventory_item in self.inventory:\n                    for implemented_component in inventory_item.implemented_components:\n                        if implemented_component.component_uuid == system_component.uuid:\n                            rval.inventory_items.append(inventory_item)\n                break\n        return rval\n\n    def _get_local_definitions_uuids(self, local_definitions: LocalDefinitions1) -&gt; List[str]:\n\"\"\"Get inventory uuids for given local definitions.\"\"\"\n        rval = []\n        if local_definitions.inventory_items:\n            rval = [inventory_item.uuid for inventory_item in local_definitions.inventory_items]\n        return rval\n\n    def _get_observations_for_uuid(self, uuid_: str) -&gt; List[Observation]:\n\"\"\"Get observations for given uuid.\"\"\"\n        rval = 0\n        if uuid_ in self._observation_map:\n            rval = []\n            list_ = self._observation_map[uuid_]\n            for observation in list_:\n                rval.append(observation)\n        return rval\n\n    def _get_observations(self, local_definitions: LocalDefinitions1) -&gt; List[Observation]:\n\"\"\"Get observations for given local definitions.\"\"\"\n        rval = []\n        local_definitions_uuids = self._get_local_definitions_uuids(local_definitions)\n        for uuid_ in local_definitions_uuids:\n            observations = self._get_observations_for_uuid(uuid_)\n            if observations:\n                rval += observations\n        return rval\n\n    def _get_properties(self, group: str) -&gt; List[Property]:\n\"\"\"Get properties for given group.\"\"\"\n        return self._property_manager.get_common_properties(group)\n\n    @property\n    def results(self) -&gt; List[Result]:\n\"\"\"OSCAL result.\"\"\"\n        if self._result is None:\n            self._derive_components()\n            self._derive_inventory()\n            if self._aggregate:\n                self._derive_common_property_accounting()\n            self._derive_observations()\n        results = []\n        for component in self.components:\n            local_definitions = self._get_local_definitions(component)\n            observations = self._get_observations(local_definitions)\n            result = Result(\n                uuid=_uuid_result(),\n                title='Tanium',\n                description='Tanium',\n                start=self._timestamp,\n                end=self._timestamp,\n                reviewed_controls=self.reviewed_controls,\n                local_definitions=local_definitions,\n                observations=observations\n            )\n            component_ref = component.uuid\n            result.props = self._get_properties(component_ref)\n            results.append(result)\n        return results\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory.analysis","title":"<code>analysis: List[str]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL statistics.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory.components","title":"<code>components: List[trestle.oscal.assessment_results.SystemComponent]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL components.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory.control_selections","title":"<code>control_selections: List[trestle.oscal.assessment_results.ControlSelection]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL control selections.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory.inventory","title":"<code>inventory: ValuesView[trestle.oscal.common.InventoryItem]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL inventory.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory.observations","title":"<code>observations: List[trestle.oscal.assessment_results.Observation]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL observations.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory.results","title":"<code>results: List[trestle.oscal.assessment_results.Result]</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL result.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory.reviewed_controls","title":"<code>reviewed_controls: ReviewedControls</code>  <code>property</code> <code>readonly</code>","text":"<p>OSCAL reviewed controls.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumOscalFactory.__init__","title":"<code>__init__(self, timestamp, rule_use_list, blocksize=11000, cpus_max=1, cpus_min=1, checking=False, caching=True, aggregate=True)</code>  <code>special</code>","text":"<p>Initialize given specified args.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>def __init__(\n    self,\n    timestamp: str,\n    rule_use_list: List[RuleUse],\n    blocksize: int = 11000,\n    cpus_max: int = 1,\n    cpus_min: int = 1,\n    checking: bool = False,\n    caching: bool = True,\n    aggregate: bool = True\n) -&gt; None:\n\"\"\"Initialize given specified args.\"\"\"\n    self._rule_use_list = rule_use_list\n    self._timestamp = timestamp\n    self._component_map: Dict[str, SystemComponent] = {}\n    self._inventory_map: Dict[str, InventoryItem] = {}\n    self._observation_list: List[Observation] = []\n    self._ns = 'https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium'\n    self._cpus = None\n    self._checking = checking\n    self._caching = caching\n    self._aggregate = aggregate\n    self._result = None\n    # blocksize: default, min\n    self._blocksize = blocksize\n    if self._blocksize &lt; 1:\n        self._blocksize = 1\n    # cpus max: default, max, min\n    self._cpus_max = cpus_max\n    if self._cpus_max &gt; os.cpu_count():\n        self._cpus_max = os.cpu_count()\n    self._cpus_min = cpus_min\n    if self._cpus_min &gt; self._cpus_max:\n        self._cpus_min = self._cpus_max\n    if self._cpus_min &lt; 1:\n        self._cpus_min = 1\n    self._property_accounting = PropertyAccounting()\n    self._property_manager = PropertyManager(caching=caching, checking=checking)\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer","title":"<code> TaniumResultToOscalARTransformer            (ResultsTransformer)         </code>","text":"<p>Interface for Tanium transformer.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>class TaniumResultToOscalARTransformer(ResultsTransformer):\n\"\"\"Interface for Tanium transformer.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize.\"\"\"\n        self._modes = {}\n\n    @property\n    def analysis(self) -&gt; List[str]:\n\"\"\"Return analysis info.\"\"\"\n        return self._analysis\n\n    @property\n    def blocksize(self) -&gt; int:\n\"\"\"Return blocksize.\"\"\"\n        return self._modes.get('blocksize', 10000)\n\n    @property\n    def cpus_max(self) -&gt; int:\n\"\"\"Return cpus_max.\"\"\"\n        return self._modes.get('cpus_max', 1)\n\n    @property\n    def cpus_min(self) -&gt; int:\n\"\"\"Return cpus_min.\"\"\"\n        return self._modes.get('cpus_min', 1)\n\n    @property\n    def aggregate(self) -&gt; bool:\n\"\"\"Return aggregate.\"\"\"\n        return self._modes.get('aggregate', True)\n\n    @property\n    def caching(self) -&gt; bool:\n\"\"\"Return caching.\"\"\"\n        return self._modes.get('caching', True)\n\n    @property\n    def checking(self) -&gt; bool:\n\"\"\"Return checking.\"\"\"\n        return self._modes.get('checking', False)\n\n    def set_modes(self, modes: Dict[str, Any]) -&gt; None:\n\"\"\"Keep modes info.\"\"\"\n        if modes is not None:\n            self._modes = modes\n\n    def transform(self, blob: str) -&gt; Results:\n\"\"\"Transform the blob into a Results.\"\"\"\n        ts0 = datetime.datetime.now()\n        results = Results()\n        ru_factory = RuleUseFactory(self.get_timestamp())\n        ru_list = ru_factory.make_list(blob)\n        tanium_oscal_factory = TaniumOscalFactory(\n            self.get_timestamp(),\n            ru_list,\n            self.blocksize,\n            self.cpus_max,\n            self.cpus_min,\n            self.checking,\n            self.caching,\n            self.aggregate\n        )\n        results.__root__ = tanium_oscal_factory.results\n        ts1 = datetime.datetime.now()\n        self._analysis = tanium_oscal_factory.analysis\n        self._analysis.append(f'transform time: {ts1-ts0}')\n        return results\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.aggregate","title":"<code>aggregate: bool</code>  <code>property</code> <code>readonly</code>","text":"<p>Return aggregate.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.analysis","title":"<code>analysis: List[str]</code>  <code>property</code> <code>readonly</code>","text":"<p>Return analysis info.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.blocksize","title":"<code>blocksize: int</code>  <code>property</code> <code>readonly</code>","text":"<p>Return blocksize.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.caching","title":"<code>caching: bool</code>  <code>property</code> <code>readonly</code>","text":"<p>Return caching.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.checking","title":"<code>checking: bool</code>  <code>property</code> <code>readonly</code>","text":"<p>Return checking.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.cpus_max","title":"<code>cpus_max: int</code>  <code>property</code> <code>readonly</code>","text":"<p>Return cpus_max.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.cpus_min","title":"<code>cpus_min: int</code>  <code>property</code> <code>readonly</code>","text":"<p>Return cpus_min.</p>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize.\"\"\"\n    self._modes = {}\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.set_modes","title":"<code>set_modes(self, modes)</code>","text":"<p>Keep modes info.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>def set_modes(self, modes: Dict[str, Any]) -&gt; None:\n\"\"\"Keep modes info.\"\"\"\n    if modes is not None:\n        self._modes = modes\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumResultToOscalARTransformer.transform","title":"<code>transform(self, blob)</code>","text":"<p>Transform the blob into a Results.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>def transform(self, blob: str) -&gt; Results:\n\"\"\"Transform the blob into a Results.\"\"\"\n    ts0 = datetime.datetime.now()\n    results = Results()\n    ru_factory = RuleUseFactory(self.get_timestamp())\n    ru_list = ru_factory.make_list(blob)\n    tanium_oscal_factory = TaniumOscalFactory(\n        self.get_timestamp(),\n        ru_list,\n        self.blocksize,\n        self.cpus_max,\n        self.cpus_min,\n        self.checking,\n        self.caching,\n        self.aggregate\n    )\n    results.__root__ = tanium_oscal_factory.results\n    ts1 = datetime.datetime.now()\n    self._analysis = tanium_oscal_factory.analysis\n    self._analysis.append(f'transform time: {ts1-ts0}')\n    return results\n</code></pre>"},{"location":"api_reference/trestle.transforms.implementations.tanium/#trestle.transforms.implementations.tanium.TaniumTransformer","title":"<code> TaniumTransformer            (TaniumResultToOscalARTransformer)         </code>","text":"<p>Legacy class name.</p> Source code in <code>trestle/transforms/implementations/tanium.py</code> <pre><code>class TaniumTransformer(TaniumResultToOscalARTransformer):\n\"\"\"Legacy class name.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.results/","title":"results","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.transforms.results/#trestle.transforms.results","title":"<code>trestle.transforms.results</code>","text":"<p>Define Results class returned by transformers.</p>"},{"location":"api_reference/trestle.transforms.results/#trestle.transforms.results-classes","title":"Classes","text":""},{"location":"api_reference/trestle.transforms.results/#trestle.transforms.results.Results","title":"<code> Results            (OscalBaseModel)         </code>  <code>pydantic-model</code>","text":"<p>Transformer results as a list.</p> Source code in <code>trestle/transforms/results.py</code> <pre><code>class Results(OscalBaseModel):\n\"\"\"Transformer results as a list.\"\"\"\n\n    __root__: List[Result] = []\n</code></pre>"},{"location":"api_reference/trestle.transforms.results/#trestle.transforms.results.Results.__root__","title":"<code>__root__: List[trestle.oscal.assessment_results.Result]</code>  <code>pydantic-field</code> <code>special</code>","text":""},{"location":"api_reference/trestle.transforms.transformer_factory/","title":"transformer_factory","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory","title":"<code>trestle.transforms.transformer_factory</code>","text":"<p>Define the TransformerFactory and corresponding transformer classes it creates.</p>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory-classes","title":"Classes","text":""},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.FromOscalTransformer","title":"<code> FromOscalTransformer            (TransformerBase)         </code>","text":"<p>Abstract interface for transformers from OSCAL.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>class FromOscalTransformer(TransformerBase):\n\"\"\"Abstract interface for transformers from OSCAL.\"\"\"\n\n    @abstractmethod\n    def transform(self, obj: OscalBaseModel) -&gt; str:\n\"\"\"Transform the from OSCAL.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.FromOscalTransformer-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.FromOscalTransformer.transform","title":"<code>transform(self, obj)</code>","text":"<p>Transform the from OSCAL.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>@abstractmethod\ndef transform(self, obj: OscalBaseModel) -&gt; str:\n\"\"\"Transform the from OSCAL.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.ResultsTransformer","title":"<code> ResultsTransformer            (TransformerBase)         </code>","text":"<p>Abstract interface for transformers that specifically return Results.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>class ResultsTransformer(TransformerBase):\n\"\"\"Abstract interface for transformers that specifically return Results.\"\"\"\n\n    @abstractmethod\n    def transform(self, blob: str) -&gt; Results:\n\"\"\"Transform the blob into Results.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.ResultsTransformer-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.ResultsTransformer.transform","title":"<code>transform(self, blob)</code>","text":"<p>Transform the blob into Results.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>@abstractmethod\ndef transform(self, blob: str) -&gt; Results:\n\"\"\"Transform the blob into Results.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.ToOscalTransformer","title":"<code> ToOscalTransformer            (TransformerBase)         </code>","text":"<p>Abstract interface for transformers to OSCAL.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>class ToOscalTransformer(TransformerBase):\n\"\"\"Abstract interface for transformers to OSCAL.\"\"\"\n\n    @abstractmethod\n    def transform(self, obj: str) -&gt; OscalBaseModel:\n\"\"\"Transform the to OSCAL.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.ToOscalTransformer-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.ToOscalTransformer.transform","title":"<code>transform(self, obj)</code>","text":"<p>Transform the to OSCAL.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>@abstractmethod\ndef transform(self, obj: str) -&gt; OscalBaseModel:\n\"\"\"Transform the to OSCAL.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerBase","title":"<code> TransformerBase            (ABC)         </code>","text":"<p>Abstract base interface for all transformers.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>class TransformerBase(ABC):\n\"\"\"Abstract base interface for all transformers.\"\"\"\n\n    # the current time for consistent timestamping\n    _timestamp = datetime.datetime.utcnow().replace(microsecond=0).replace(tzinfo=datetime.timezone.utc).isoformat()\n\n    @staticmethod\n    def set_timestamp(value: str) -&gt; None:\n\"\"\"Set the default timestamp value.\"\"\"\n        datetime.datetime.strptime(value, '%Y-%m-%dT%H:%M:%S%z')\n        TransformerBase._timestamp = value\n\n    @staticmethod\n    def get_timestamp() -&gt; str:\n\"\"\"Get the default timestamp value.\"\"\"\n        return TransformerBase._timestamp\n\n    @abstractmethod\n    def transform(self, blob: Any) -&gt; Any:\n\"\"\"Transform the blob into a general OscalBaseModel.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerBase-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerBase.get_timestamp","title":"<code>get_timestamp()</code>  <code>staticmethod</code>","text":"<p>Get the default timestamp value.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>@staticmethod\ndef get_timestamp() -&gt; str:\n\"\"\"Get the default timestamp value.\"\"\"\n    return TransformerBase._timestamp\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerBase.set_timestamp","title":"<code>set_timestamp(value)</code>  <code>staticmethod</code>","text":"<p>Set the default timestamp value.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>@staticmethod\ndef set_timestamp(value: str) -&gt; None:\n\"\"\"Set the default timestamp value.\"\"\"\n    datetime.datetime.strptime(value, '%Y-%m-%dT%H:%M:%S%z')\n    TransformerBase._timestamp = value\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerBase.transform","title":"<code>transform(self, blob)</code>","text":"<p>Transform the blob into a general OscalBaseModel.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>@abstractmethod\ndef transform(self, blob: Any) -&gt; Any:\n\"\"\"Transform the blob into a general OscalBaseModel.\"\"\"\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerFactory","title":"<code> TransformerFactory        </code>","text":"<p>Perform registration and creation of transformers.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>class TransformerFactory:\n\"\"\"Perform registration and creation of transformers.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize the transformers dictionary as empty.\"\"\"\n        self._transformers: Dict[str, Type[TransformerBase]] = {}\n\n    def register_transformer(self, name: str, transformer: Type[TransformerBase]) -&gt; None:\n\"\"\"\n        Register the transformer.\n\n        This registers transformers in the factory so they may be created by name.\n\n        Args:\n            name (str): The name of the transformer.\n            transformer (TransformerBase): The transformer class to be registered.\n\n        Returns:\n            None\n        \"\"\"\n        self._transformers[name] = transformer\n\n    def get(self, name: str) -&gt; TransformerBase:\n\"\"\"\n        Create an instance of the desired transformer based its name.\n\n        Args:\n            name (str): The name of the transformer.\n\n        Returns:\n            An instance of the desired transformer.\n\n        Raises:\n            TrestleError: if the name does not exist in the registry.\n        \"\"\"\n        t = self._transformers.get(name)\n        if t is not None:\n            return t()\n        raise TrestleError(f'Error getting non-registered transform {name}')\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerFactory-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerFactory.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize the transformers dictionary as empty.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the transformers dictionary as empty.\"\"\"\n    self._transformers: Dict[str, Type[TransformerBase]] = {}\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerFactory.get","title":"<code>get(self, name)</code>","text":"<p>Create an instance of the desired transformer based its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the transformer.</p> required <p>Returns:</p> Type Description <code>TransformerBase</code> <p>An instance of the desired transformer.</p> <p>Exceptions:</p> Type Description <code>TrestleError</code> <p>if the name does not exist in the registry.</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>def get(self, name: str) -&gt; TransformerBase:\n\"\"\"\n    Create an instance of the desired transformer based its name.\n\n    Args:\n        name (str): The name of the transformer.\n\n    Returns:\n        An instance of the desired transformer.\n\n    Raises:\n        TrestleError: if the name does not exist in the registry.\n    \"\"\"\n    t = self._transformers.get(name)\n    if t is not None:\n        return t()\n    raise TrestleError(f'Error getting non-registered transform {name}')\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_factory/#trestle.transforms.transformer_factory.TransformerFactory.register_transformer","title":"<code>register_transformer(self, name, transformer)</code>","text":"<p>Register the transformer.</p> <p>This registers transformers in the factory so they may be created by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the transformer.</p> required <code>transformer</code> <code>TransformerBase</code> <p>The transformer class to be registered.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>trestle/transforms/transformer_factory.py</code> <pre><code>def register_transformer(self, name: str, transformer: Type[TransformerBase]) -&gt; None:\n\"\"\"\n    Register the transformer.\n\n    This registers transformers in the factory so they may be created by name.\n\n    Args:\n        name (str): The name of the transformer.\n        transformer (TransformerBase): The transformer class to be registered.\n\n    Returns:\n        None\n    \"\"\"\n    self._transformers[name] = transformer\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/","title":"transformer_helper","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper","title":"<code>trestle.transforms.transformer_helper</code>","text":"<p>Transformer helper functions.</p>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper-classes","title":"Classes","text":""},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyAccounting","title":"<code> PropertyAccounting        </code>","text":"<p>Property accounting class.</p> <p>Help transformers do accounting.</p> <p>Each time a new record is processed the transformer calls count_group. For each attribute on that record, the transformer calls count_property.   - If the property already exactly exists, then its count is incremented.   - Otherwise, a new entry is made and the count for that property is set to 1. When the transformer wants to know if a property (name, value, ns, and class)   is common to all records for the group, is_common_property is employed to check   that the number of records in the group is equal to the number of duplicates   there are for the property. If equal, then the property is common.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>class PropertyAccounting():\n\"\"\"Property accounting class.\n\n    Help transformers do accounting.\n\n    &gt; Each time a new record is processed the transformer calls count_group.\n    &gt; For each attribute on that record, the transformer calls count_property.\n      - If the property already exactly exists, then its count is incremented.\n      - Otherwise, a new entry is made and the count for that property is set to 1.\n    &gt; When the transformer wants to know if a property (name, value, ns, and class)\n      is common to all records for the group, is_common_property is employed to check\n      that the number of records in the group is equal to the number of duplicates\n      there are for the property. If equal, then the property is common.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize.\"\"\"\n        self._group_map: Dict[str, int] = {}\n        self._property_map: Dict[str, Dict[str:int]] = {}\n\n    def count_group(self, group: str = None) -&gt; None:\n\"\"\"Group accounting.\"\"\"\n        if group not in self._group_map:\n            self._group_map[group] = 0\n        self._group_map[group] += 1\n\n    def count_property(\n        self, group: str = None, name: str = None, value: str = None, class_: str = None, ns: str = None\n    ) -&gt; None:\n\"\"\"Property accounting.\"\"\"\n        key = _segment_separator.join([str(name), str(value), str(class_), str(ns)])\n        if group not in self._property_map:\n            self._property_map[group] = {}\n        if key not in self._property_map[group]:\n            self._property_map[group][key] = 0\n        self._property_map[group][key] += 1\n\n    def is_common_property(\n        self, group: str = None, name: str = None, value: str = None, class_: str = None, ns: str = None\n    ) -&gt; bool:\n\"\"\"Check for common property.\"\"\"\n        rval = False\n        key = _segment_separator.join([str(name), str(value), str(class_), str(ns)])\n        if group in self._group_map and key in self._property_map[group]:\n            rval = self._group_map[group] == self._property_map[group][key]\n        return rval\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyAccounting-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyAccounting.__init__","title":"<code>__init__(self)</code>  <code>special</code>","text":"<p>Initialize.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize.\"\"\"\n    self._group_map: Dict[str, int] = {}\n    self._property_map: Dict[str, Dict[str:int]] = {}\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyAccounting.count_group","title":"<code>count_group(self, group=None)</code>","text":"<p>Group accounting.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>def count_group(self, group: str = None) -&gt; None:\n\"\"\"Group accounting.\"\"\"\n    if group not in self._group_map:\n        self._group_map[group] = 0\n    self._group_map[group] += 1\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyAccounting.count_property","title":"<code>count_property(self, group=None, name=None, value=None, class_=None, ns=None)</code>","text":"<p>Property accounting.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>def count_property(\n    self, group: str = None, name: str = None, value: str = None, class_: str = None, ns: str = None\n) -&gt; None:\n\"\"\"Property accounting.\"\"\"\n    key = _segment_separator.join([str(name), str(value), str(class_), str(ns)])\n    if group not in self._property_map:\n        self._property_map[group] = {}\n    if key not in self._property_map[group]:\n        self._property_map[group][key] = 0\n    self._property_map[group][key] += 1\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyAccounting.is_common_property","title":"<code>is_common_property(self, group=None, name=None, value=None, class_=None, ns=None)</code>","text":"<p>Check for common property.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>def is_common_property(\n    self, group: str = None, name: str = None, value: str = None, class_: str = None, ns: str = None\n) -&gt; bool:\n\"\"\"Check for common property.\"\"\"\n    rval = False\n    key = _segment_separator.join([str(name), str(value), str(class_), str(ns)])\n    if group in self._group_map and key in self._property_map[group]:\n        rval = self._group_map[group] == self._property_map[group][key]\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyManager","title":"<code> PropertyManager        </code>","text":"<p>Property manager class.</p> <p>Help transformer manage properties.</p> <p>Use materialize to: fetch a property from cache (if caching), else create a new   property instance and keep in cache (if caching). Use put_common_property to: keep common properties for each group. Use get_common_properties to: recall the list of common properties for the group.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>class PropertyManager():\n\"\"\"Property manager class.\n\n    Help transformer manage properties.\n\n    &gt; Use materialize to: fetch a property from cache (if caching), else create a new\n      property instance and keep in cache (if caching).\n    &gt; Use put_common_property to: keep common properties for each group.\n    &gt; Use get_common_properties to: recall the list of common properties for the group.\n    \"\"\"\n\n    def __init__(self, caching: bool = True, checking: bool = False) -&gt; None:\n\"\"\"Initialize.\"\"\"\n        self._caching = caching\n        self._checking = checking\n        self._requests = 0\n        self._hits = 0\n        self._map_unique: Dict[str, Any] = {}\n        self._map_common: Dict[str, Dict[str, Property]] = {}\n\n    @property\n    def requests(self) -&gt; int:\n\"\"\"Cache requests.\"\"\"\n        return self._requests\n\n    @property\n    def hits(self) -&gt; int:\n\"\"\"Cache hits.\"\"\"\n        return self._hits\n\n    def materialize(self, name: str = None, value: str = None, class_: str = None, ns: str = None) -&gt; Property:\n\"\"\"Get property from cache or create new property.\"\"\"\n        self._requests += 1\n        # try fetch from cache\n        key = _segment_separator.join([str(name), str(value), str(class_), str(ns)])\n        if key in self._map_unique:\n            self._hits += 1\n            return self._map_unique[key]\n        # create new property and put into cache if caching\n        prop = self._create(name=name, value=value, class_=class_, ns=ns)\n        if self._caching:\n            self._map_unique[key] = prop\n        return prop\n\n    def put_common_property(\n        self, group: str = None, name: str = None, value: str = None, class_: str = None, ns: str = None\n    ) -&gt; Property:\n\"\"\"Remember common property.\"\"\"\n        if group not in self._map_common:\n            self._map_common[group] = {}\n        key = _segment_separator.join([str(name), str(value), str(class_), str(ns)])\n        if key not in self._map_common[group]:\n            prop = self.materialize(name, value, class_, ns)\n            self._map_common[group][key] = prop\n\n    def get_common_properties(self, group: str = None) -&gt; List[Property]:\n\"\"\"Recall common properties for the group.\"\"\"\n        rval = None\n        if group in self._map_common:\n            rval = list(self._map_common[group].values())\n        return rval\n\n    def _create(self, name: str = None, value: str = None, class_: str = None, ns: str = None) -&gt; Property:\n\"\"\"Create new property.\"\"\"\n        if self._checking:\n            return Property(name=name, value=value, class_=class_, ns=ns)\n        return Property.construct(name=name, value=value, class_=class_, ns=ns)\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyManager-attributes","title":"Attributes","text":""},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyManager.hits","title":"<code>hits: int</code>  <code>property</code> <code>readonly</code>","text":"<p>Cache hits.</p>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyManager.requests","title":"<code>requests: int</code>  <code>property</code> <code>readonly</code>","text":"<p>Cache requests.</p>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyManager-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyManager.__init__","title":"<code>__init__(self, caching=True, checking=False)</code>  <code>special</code>","text":"<p>Initialize.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>def __init__(self, caching: bool = True, checking: bool = False) -&gt; None:\n\"\"\"Initialize.\"\"\"\n    self._caching = caching\n    self._checking = checking\n    self._requests = 0\n    self._hits = 0\n    self._map_unique: Dict[str, Any] = {}\n    self._map_common: Dict[str, Dict[str, Property]] = {}\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyManager.get_common_properties","title":"<code>get_common_properties(self, group=None)</code>","text":"<p>Recall common properties for the group.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>def get_common_properties(self, group: str = None) -&gt; List[Property]:\n\"\"\"Recall common properties for the group.\"\"\"\n    rval = None\n    if group in self._map_common:\n        rval = list(self._map_common[group].values())\n    return rval\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyManager.materialize","title":"<code>materialize(self, name=None, value=None, class_=None, ns=None)</code>","text":"<p>Get property from cache or create new property.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>def materialize(self, name: str = None, value: str = None, class_: str = None, ns: str = None) -&gt; Property:\n\"\"\"Get property from cache or create new property.\"\"\"\n    self._requests += 1\n    # try fetch from cache\n    key = _segment_separator.join([str(name), str(value), str(class_), str(ns)])\n    if key in self._map_unique:\n        self._hits += 1\n        return self._map_unique[key]\n    # create new property and put into cache if caching\n    prop = self._create(name=name, value=value, class_=class_, ns=ns)\n    if self._caching:\n        self._map_unique[key] = prop\n    return prop\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.PropertyManager.put_common_property","title":"<code>put_common_property(self, group=None, name=None, value=None, class_=None, ns=None)</code>","text":"<p>Remember common property.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>def put_common_property(\n    self, group: str = None, name: str = None, value: str = None, class_: str = None, ns: str = None\n) -&gt; Property:\n\"\"\"Remember common property.\"\"\"\n    if group not in self._map_common:\n        self._map_common[group] = {}\n    key = _segment_separator.join([str(name), str(value), str(class_), str(ns)])\n    if key not in self._map_common[group]:\n        prop = self.materialize(name, value, class_, ns)\n        self._map_common[group][key] = prop\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.TransformerHelper","title":"<code> TransformerHelper        </code>","text":"<p>OSCAL transformer helper.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>class TransformerHelper():\n\"\"\"OSCAL transformer helper.\"\"\"\n\n    def remove_common_observation_properties(self, observations: List[Observation]) -&gt; List[Property]:\n\"\"\"Remove common observation properties.\"\"\"\n        common_props = []\n        props = {}\n        # count each property occurrence in each observation\n        props_occurrence_counts = self._get_property_occurrence_counts(observations)\n        # remove common properties from observation\n        for key in props_occurrence_counts.keys():\n            # skip property if not identical for each and every observation\n            if props_occurrence_counts[key] != len(observations):\n                continue\n            # remove property from each observation and keep one instance\n            for observation in observations:\n                for prop in observation.props:\n                    if key == f'{prop.name}:{prop.value}:{prop.class_}':\n                        props[key] = prop\n                        observation.props.remove(prop)\n                        break\n        # formulate list of removed properties\n        for key in props.keys():\n            common_props.append(props[key])\n        # return list of removed properties\n        return common_props\n\n    def _get_property_occurrence_counts(self, observations: List[Observation]):\n\"\"\"Count each property occurrence in each observation.\"\"\"\n        property_occurences = {}\n        for observation in observations:\n            for prop in observation.props:\n                key = f'{prop.name}:{prop.value}:{prop.class_}'\n                if key not in property_occurences.keys():\n                    property_occurences[key] = 0\n                property_occurences[key] += 1\n        return property_occurences\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.TransformerHelper-methods","title":"Methods","text":""},{"location":"api_reference/trestle.transforms.transformer_helper/#trestle.transforms.transformer_helper.TransformerHelper.remove_common_observation_properties","title":"<code>remove_common_observation_properties(self, observations)</code>","text":"<p>Remove common observation properties.</p> Source code in <code>trestle/transforms/transformer_helper.py</code> <pre><code>def remove_common_observation_properties(self, observations: List[Observation]) -&gt; List[Property]:\n\"\"\"Remove common observation properties.\"\"\"\n    common_props = []\n    props = {}\n    # count each property occurrence in each observation\n    props_occurrence_counts = self._get_property_occurrence_counts(observations)\n    # remove common properties from observation\n    for key in props_occurrence_counts.keys():\n        # skip property if not identical for each and every observation\n        if props_occurrence_counts[key] != len(observations):\n            continue\n        # remove property from each observation and keep one instance\n        for observation in observations:\n            for prop in observation.props:\n                if key == f'{prop.name}:{prop.value}:{prop.class_}':\n                    props[key] = prop\n                    observation.props.remove(prop)\n                    break\n    # formulate list of removed properties\n    for key in props.keys():\n        common_props.append(props[key])\n    # return list of removed properties\n    return common_props\n</code></pre>"},{"location":"api_reference/trestle.transforms.transformer_singleton/","title":"transformer_singleton","text":"<p>handler: python</p>"},{"location":"api_reference/trestle.transforms.transformer_singleton/#trestle.transforms.transformer_singleton","title":"<code>trestle.transforms.transformer_singleton</code>","text":"<p>Create the singleton transformer factory here.</p>"},{"location":"api_reference/trestle.transforms.transformer_singleton/#trestle.transforms.transformer_singleton.transformer_factory","title":"<code>transformer_factory</code>","text":""},{"location":"contributing/DCO/","title":"Developer Certificate of Originality","text":"<pre><code>Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n660 York Street, Suite 102,\nSan Francisco, CA 94110 USA\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\nhave the right to submit it under the open source license\nindicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\nof my knowledge, is covered under an appropriate open source\nlicense and I have the right under that license to submit that\nwork with modifications, whether created in whole or in part\nby me, under the same open source license (unless I am\npermitted to submit under a different license), as indicated\nin the file; or\n\n(c) The contribution was provided directly to me by some other\nperson who certified (a), (b) or (c) and I have not modified\nit.\n\n(d) I understand and agree that this project and the contribution\nare public and that a record of the contribution (including all\npersonal information I submit with it, including my sign-off) is\nmaintained indefinitely and may be redistributed consistent with\nthis project or the open source license(s) involved.\n</code></pre>"},{"location":"contributing/mkdocs_contributing/","title":"Contributing overview","text":""},{"location":"contributing/mkdocs_contributing/#contributing-in-general","title":"Contributing In General","text":"<p>Our project welcomes external contributions. If you have an itch, please feel free to scratch it.</p> <p>To contribute code or documentation, please submit a pull request.</p> <p>A good way to familiarize yourself with the codebase and contribution process is to look for and tackle low-hanging fruit in the issue tracker. Before embarking on a more ambitious contribution, please quickly get in touch with us.</p> <p>Note: We appreciate your effort, and want to avoid a situation where a contribution requires extensive rework (by you or by us), sits in backlog for a long time, or cannot be accepted at all!</p> <p>We have also adopted Contributor Covenant Code of Conduct.</p>"},{"location":"contributing/mkdocs_contributing/#proposing-new-features","title":"Proposing new features","text":"<p>If you would like to implement a new feature, please raise an issue labelled <code>enhancement</code> before sending a pull request so the feature can be discussed. This is to avoid you wasting your valuable time working on a feature that the project developers are not interested in accepting into the code base.</p>"},{"location":"contributing/mkdocs_contributing/#fixing-bugs","title":"Fixing bugs","text":"<p>If you would like to fix a bug, please raise an issue labelled <code>bug</code> before sending a pull request so it can be tracked.</p>"},{"location":"contributing/mkdocs_contributing/#merge-approval","title":"Merge approval","text":"<p>The project maintainers use LGTM (Looks Good To Me) in comments on the code review to indicate acceptance. A change requires LGTMs from one of the maintainers.</p> <p>For a list of the maintainers, see the maintainers page.</p>"},{"location":"contributing/mkdocs_contributing/#trestle-merging-and-release-workflow","title":"Trestle merging and release workflow","text":"<p><code>trestle</code> is operating on a simple, yet opinionated, method for continuous integration. It's designed to give developers a coherent understanding of the objectives of other past developers. The criteria for this are below. Trestle effectively uses a gitflow workflow with one modification: PR's merge into develop are squash merged as one commit.</p> <p>In trestle's CI environment this results in the following rules:</p> <ol> <li>All Commit's MUST be signed off with <code>git commit --signoff</code> irrespective of the author's affiliation. This ensures all code can be attributed.</li> <li>This is enforced by DCO bot and can be overrided by maintainers presuming at least one commit is signed-off.</li> <li>All commits SHOULD use conventional commits</li> <li>This is as github, when only one commit is in a PR, will use the native git commit message as the merge commit title.<ol> <li>When only a single commit is provided the commit MUST be an conventional commit and will be checked the <code>Lint PR</code> aciton.</li> </ol> </li> <li>All PR's title's MUST be formed as an convention commit</li> <li>This is checked by the <code>Lint PR</code> action</li> <li>All PR's to <code>develop</code> and hotfix PR's to <code>main</code> must close at least one issue by linking the PR to an issue.</li> <li>Trestle will release on demand the default approach for a hot fix should be to merge into <code>develop</code>, followed by releasing to <code>main</code>, unless this will release functionality that is not ready.</li> <li>Each feature/fix/chore (PR into develop) be represented by a single commit into develop / main with a coherent title (in the PR).</li> <li>The trestle preference for doing this is to use squash merge functionality when merging a PR into develop.</li> <li>Developers MUST pass the required CI checks for each PR.</li> <li>Developers are encouraged to use GitHub's automated merge process where possible to keep the number of active PR's low.</li> </ol>"},{"location":"contributing/mkdocs_contributing/#merge-details-for-committers","title":"Merge details for committers:","text":"<ol> <li>All merges into develop MUST be conducted by a squash-merge</li> <li>All merges from develop into main MUST be done by a merge commit (e.g. preserving the history of commits into the develop branch).</li> <li>Hotfixes into main, not via develop, MUST be done via a squash merge.</li> <li>Merge's into any branch excluding main and develop are at the developers choice.</li> <li>Use of autocommit is encouraged to ensure commit messages and squash vs merge commit are completed properly.</li> </ol>"},{"location":"contributing/mkdocs_contributing/#working-from-a-fork","title":"Working from a fork","text":"<ol> <li>In order not to break Github Actions security model SonarCloud will not run on a fork.</li> <li>Given this a maintainer MAY determine that sonar needs to be run and ask you to first merge your branch to a    staging branch, after reviewing for security risks in the CI pipeline.</li> <li>From this staging branch sonar would be run and then the code merged.</li> </ol>"},{"location":"contributing/mkdocs_contributing/#typing-docstrings-and-documentation","title":"Typing, docstrings and documentation","text":"<p><code>trestle</code> has a goal of using PEP 484 type annotations where possible / practical. The devops process does not strictly enforce typing, however, the expectation is that type coverage is added for new commits with a focus on quality over quantity (e.g. don't add <code>Any</code> everywhere just to meet coverage requirements). Python typing of functions is an active work in progress.</p> <p><code>mkbuild</code> is used to generate the trestle documenation site. The <code>mkbuild</code> website includes an API reference section generated from the code. Docstrings within the code are expected to follow google style docstrings.</p>"},{"location":"contributing/mkdocs_contributing/#legal","title":"Legal","text":"<p>Each source file must include a license header for the Apache Software License 2.0. Using the SPDX format is the simplest approach. e.g.</p> <pre><code># Copyright (c) 2020 IBM Corp. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n</code></pre> <p>We have tried to make it as easy as possible to make contributions. This applies to how we handle the legal aspects of contribution. We use the same approach - the Developer's Certificate of Origin 1.1 (DCO) - that the Linux\u00ae Kernel community uses to manage code contributions.</p> <p>We simply ask that when submitting a patch for review, the developer must include a sign-off statement in the commit message.</p> <p>Here is an example Signed-off-by line, which indicates that the submitter accepts the DCO:</p> <pre><code>Signed-off-by: John Doe &lt;john.doe@example.com&gt;\n</code></pre> <p>You can include this automatically when you commit a change to your local git repository using the following command:</p> <pre><code>git commit --signoff\n</code></pre> <p>Note that DCO signoff is enforced by DCO bot. Missing DCO's will be required to be rebased with a signed off commit before being accepted.</p>"},{"location":"contributing/mkdocs_contributing/#setup-developing-trestle","title":"Setup - Developing <code>trestle</code>","text":""},{"location":"contributing/mkdocs_contributing/#does-trestle-run-correctly-on-my-platform","title":"Does <code>trestle</code> run correctly on my platform","text":"<ul> <li>(Optional) setup a venv for python</li> <li>Run <code>make develop</code></li> <li>This will install all python dependencies</li> <li>It will also checkout the submodules required for testing.</li> <li>Run <code>make test</code></li> <li>This should run on all platforms</li> </ul>"},{"location":"contributing/mkdocs_contributing/#setting-up-vscode-for-python","title":"Setting up <code>vscode</code> for python.","text":"<ul> <li>Use the following commands to setup python:</li> </ul> <pre><code>python3 -m venv venv\n. ./venv/bin/activate\n# for zsh put .[dev] in quotes as below\npip install -q -e \".[dev]\" --upgrade --upgrade-strategy eager\n</code></pre> <ul> <li> <p>Install vscode plugin <code>Python extension for Visual Studio Code</code></p> </li> <li> <p>Enable <code>yapf</code> for code formatting</p> </li> <li> <p>Enable <code>flake8</code> for code linting</p> </li> </ul>"},{"location":"contributing/mkdocs_contributing/#testing-python-in-vscode","title":"Testing python in <code>vscode</code>","text":"<p>Tests should be in the test subdirectory. Each file should be named test_*.py and each test function should be named *_test().</p> <p>Note that with Python3 there should be no need for init.py in directories.</p> <p>Test discovery should be automatic when you select a .py file for editing. After tests are discovered a flask icon will appear on the left and you can select it to see a panel listing of your tests.  In addition your test functions will be annotated with Run/Debug so they can be launched directly from the editor.  When everything is set up properly you should be able to step through your test code - which is important.</p> <p>Sometimes the discovery fails - and you may need to resort to uninstalling the python extension and reinstalling it - perhaps also shutting down code and restarting.  This is a lightweight operation and seems to be safe and usually fixes any problems.</p> <p>Test disovery will fail or stop if any of the tests have errors in them - so be sure to monitor the Problems panel at the bottom for problems in the code.</p> <p>Note that there are many panels available in Output - so be sure to check <code>Python Test Log</code> for errors and output from the tests.</p> <p>pytest fixtures are available to allow provision of common functionality.  See conftest.py and tmp_dir for an example.</p>"},{"location":"contributing/mkdocs_contributing/#nist-reference-data-for-testing","title":"NIST reference data for testing.","text":"<p>Trestle relies on reference data from two NIST repositories for testing:</p> <ul> <li>https://github.com/usnistgov/OSCAL</li> <li>https://github.com/usnistgov/oscal-content</li> </ul> <p>Both of these repositories are submodules in the trestle project. In order to develop / test trestle the submodules must be checked out with <code>git submodule update --init</code> or <code>make submodules</code>.</p>"},{"location":"contributing/mkdocs_contributing/#code-style-and-formating","title":"Code style and formating","text":"<p><code>trestle</code> uses yapf for code formatting and flake8 for code styling.  It also uses pre-commit hooks that are integrated into the development process and the CI. When you run <code>make develop</code> you are ensuring that the pre-commit hooks are installed and updated to their latest versions for this repository. This ensures that all delivered code has been properly formatted and passes the linter rules.  See the pre-commit configuration file for details on <code>yapf</code> and <code>flake8</code> configurations.</p> <p>Since <code>yapf</code> and <code>flake8</code> are installed as part of the <code>pre-commit</code> hooks, running <code>yapf</code> and <code>flake8</code> manually must be done through <code>pre-commit</code>.  See examples below:</p> <pre><code>make code-format\nmake code-lint\n</code></pre> <p>...will run <code>yapf</code> and <code>flake8</code> on the entire repo and is equivalent to:</p> <pre><code>pre-commit run yapf --all-files\npre-commit run flake8 --all-files\n</code></pre> <p>...and when looking to limit execution to a subset of files do similar to:</p> <pre><code>pre-commit run yapf --files trestle/*\npre-commit run flake8 --files trestle/*\n</code></pre> <p>Note that in both of these cases autogenerated files under <code>trestle/oscal</code> are excluded. Note that for IDE support <code>setup.cfg</code> maintains a cache of <code>flake8</code> configuration.</p>"},{"location":"contributing/plugins/","title":"Adding plugins to trestle","text":"<p>Trestle provides a mechanism for 3rd party providers to extend its command interface via a plugin architecture. All trestle plugins that conforms to this specification will be automatically discovered by trestle if installed, and their command(s) will be added to trestle sub-commands list. Below we describe this plugin mechanism with the help of an example plugin <code>compliance-trestle-fedramp</code> that we created as a separate python project that can be installed via <code>pip</code>.</p>"},{"location":"contributing/plugins/#create-the-trestle-plugin-proejct","title":"Create the trestle plugin proejct","text":"<p>A separate plugin project needs to be created that will conatin the code for plugin and its commands. This plugin can be given any name and should be available for installation via <code>pip</code>. For example, we created a plugin project called  <code>compliance-trestle-fedramp</code> which can be installed as <code>pip install compliance-trestle-fedramp</code>. The project name doesn't need to start with <code>compliance-trestle</code>.</p>"},{"location":"contributing/plugins/#project-organization","title":"Project Organization","text":"<p>The plugin project should be organized as shown below.</p> <pre><code>compliance-trestle-fedramp\n\u251c\u2500\u2500 trestle_fedramp\n\u2502   \u251c\u2500\u2500 __init.py__\n\u2502   \u251c\u2500\u2500 commands\n|   |   \u251c\u2500\u2500 __init.py__\n|   |   \u251c\u2500\u2500 validate.py\n\u2502   \u251c\u2500\u2500 &lt;other source files or folder&gt;\n\u251c\u2500\u2500 &lt;other files or folder&gt;\n</code></pre> <p>Trestle uses a naming convention to discover the top-level module of the plugin projects. It expects the top-level module to be named <code>trestle_{plugin_name}</code>. This covention must be followed by plugins to be discoverable by trestle. In the above example, the top-level module is named as <code>trestle_fedramp</code> so that it can be autmatically discovered by trestle. All the python source files should be created inside this module (folder).</p> <p>The top-evel module should contain a <code>commands</code> directory where all the plugin command files should be stored. Each command should have its own python file. In the above exaample, <code>validate.py</code> file conatins one command for this plugin. Other python files or folders should be created in the top-level module folder, outside the <code>commands</code> folder. This helps in keeping the commands separate and in their discovery by trestle.</p>"},{"location":"contributing/plugins/#command-creation","title":"Command Creation","text":"<p>The plugin command should be created as shown in the below code snippet.</p> <pre><code>from trestle.core.commands.command_docs import CommandBase\nfrom trestle.core.commands.command_docs import CommandPlusDocs\n\nclass ValidateCmd(CommandBase):\n\"\"\"Validate contents of an OSCAL model based on FedRAMP specifications.\"\"\"\n\n    name = 'fedramp-validate'\n\n    def _init_arguments(self) -&gt; None:\n        logger.debug('Init arguments')\n        self.add_argument('-f', '--file', help='OSCAL file to validate.', type=str, required=True)\n\n        self.add_argument(\n            '-o', '--output-dir', help='Output directory for validation results.', type=str, required=True\n        )\n\n    def _run(self, args: argparse.Namespace) -&gt; int:\n        model_file = pathlib.Path(args.file).resolve()\n\n        output_dir = pathlib.Path(args.output_dir).resolve()\n        ...\n        ...\n        return 0 if valid else 1\n</code></pre> <p>There should be a command class for example, <code>ValidateCmd</code> which should either extend from <code>CommandBase</code> or <code>CommandPlusDocs</code>. Trestle uses <code>ilcli</code> package to create commands. <code>CommandBase</code> extends from <code>ilcli.Command</code> that initializes the command including help messages and input parameters. <code>CommandPlusDocs</code> in turn extends from <code>CommandBase</code>. The difference between <code>CommandBase</code> and <code>CommandPLusDocs</code> is that <code>CommandBase</code> does not require command line parameter <code>trestle-root</code> to be set or the current directory to be a valid trestle root, whereas <code>CommandPlusDocs</code> requires a valid <code>trestle-root</code> and checks for it. Hence, depending upon the requirement of the plugin command it can extend from either of these classes.</p> <p>The docstring of the command class is used as the help message for the command. Input arguments to the command should be specified in <code>_init_arguments</code> method as shown above. The acutal code of the command is contained in<code>_run</code> method. This method is called by ilcli when the command is excuted on the commandline. The command arguments can be accessed from the <code>args</code> input parameter as shown above. The command should return <code>0</code> in case of successful execution, or any number greater than 0 in case of failure. Please see <code>trestle.core.commands.common.return_codes.CmdReturnCodes</code> class for specific return codes in case of failure.</p> <p>The command class should conatin the <code>name</code> field which should be set to the desired command name. In the above example, the command is called <code>fedramp-validate</code>. This name is automatically added to the list of sub-command names of trestle during the plugin discovery process. This command can then be invoked as <code>trestle {name}</code> from the commandline e.g., <code>trestle fedramp-validate</code>. Any input parameters to the command can also be passed on the commandline after the command name.</p>"},{"location":"contributing/trestle_oscal_object_model/","title":"Using trestle as an object model for OSCAL","text":"<p>Trestle provides an object model for OSCAL to ease the development and validation of OSCAL objects that reside in the <code>trestle.oscal</code> module. This functionality, which is built on pydantic and python data classes, allows validation of the OSCAL schema and is leveraged to provide a variety of utility functions including:</p> <ul> <li>IO Support for yaml / json / python dict serialisation see <code>OscalBaseModel</code> for trestle enhancements</li> <li>The ability to generate pro-forma objects using <code>trestle.core.generate::generate_sample_model</code></li> <li>Integration into the flask api framework (demo)</li> </ul>"},{"location":"contributing/trestle_oscal_object_model/#mapping-and-variance-with-oscal-names","title":"Mapping and variance with OSCAL names.","text":"<p>The underlying object model that trestle relies on is the json schema published by NIST here. In understanding these models the model reference page is an indispensable source.</p> <p>When generating the python data class based models we have tried to be as faithful as we can to the naming convention provided by OSCAL. This is the hierarchy of rules that we have used:</p> <ol> <li>Do not include prepends from the json schema (e.g. <code>assembly_oscal-catalog_catalog</code> becomes the short name <code>catalog</code>), modules are used for scoping statements</li> <li>OSCAL modules use hyphen case (e.g. <code>system-security-plan</code>) and this is converted to CamelCase (e.g. <code>SystemSecurityPlan</code>)</li> <li>Name collisions with reserved words in python are post-pended with an underscore (e.g. <code>class</code> becomes <code>class_</code>)</li> <li>If a model is used across multiple OSCAL schemas (e.g. <code>metadata</code>) it is put into the common module(<code>trestle.oscal.common</code>), otherwise it will be scoped to a model specifically for that schema.</li> <li>Any unresolved duplicates are resolved by adding an index e.g. <code>class State1</code></li> </ol>"},{"location":"contributing/trestle_oscal_object_model/#oscal-schema-mapping","title":"OSCAL Schema mapping","text":"<p>This maps between OSCAL values and the corresponding pydantic/python data class in trestle. For example, to get a catalog you would call:</p> <pre><code>from pathlib import Path\nfrom trestle.oscal.catalog import Catalog\n\nmy_catalog = Catalog.oscal_read(Path('path/to/file.json'))\n</code></pre> Oscal schema json schema name Trestle module Trestle class name Catalog <code>catalog</code> <code>catalog</code> <code>trestle.oscal.catalog</code> Profile <code>profile</code> <code>profile</code> <code>trestle.oscal.profile</code> Component Definition <code>component-definition</code> <code>trestle.oscal.component</code> <code>ComponentDefinition</code> System Security Plan <code>system-security-plan</code> <code>trestle.oscal.ssp</code> <code>SystemSecurityPlan</code> Assessment Plan <code>assessment-plan</code> <code>trestle.oscal.assessment_plan</code> <code>AssessmentPlan</code> Assessment Results <code>assessment-results</code> <code>trestle.oscal.assessment_results</code> <code>AssessmentResults</code> Plan of action and milestones <code>plan-of-action-and-milestones</code> <code>trestle.oscal.poam</code> <code>PlanOfActionAndMilestones</code>"},{"location":"contributing/website/","title":"Developing for the trestle documentation website","text":"<p>This page describes the developing for the trestle (website) which is deployed at https://ibm.github.io/compliance-trestle.</p>"},{"location":"contributing/website/#documentation-for-use-within-the-github-project","title":"Documentation for use within the github project.","text":"<p>Github uses certain files within a project such as <code>/README.md</code>, <code>/CONTRIBUTING.md</code>, <code>LICENSE</code> which are specifically indexed by github. The current documentation website build reuses some of these files, specifically:</p> <ul> <li>Contents of <code>README.md</code></li> <li>Entirety of <code>LICENSE</code></li> <li>Entirety of <code>CONTRIBUTING.md</code></li> <li>Entirety of <code>CODE_OF_CONDUCT.md</code></li> <li>Entirety of <code>CHANGELOG.md</code></li> <li>Entirely of <code>MAINTAINERS.md</code></li> <li>Entirely of <code>DCO1.1.txt</code></li> </ul> <p>For this to work correctly no relative links within the github repository should exist. All links should be absolute to the documentation website.</p>"},{"location":"contributing/website/#build-system-and-local-testing-of-the-website","title":"Build system and local testing of the website.","text":"<p>Trestle has adopted the <code>mkdocs</code> system to generate this website using a small number of extensions to mkdocs. The website can be viewed locally from a clone of the <code>compliance-trestle</code> repo by running <code>make docs-serve</code> in the root directory bringing the website up at <code>https://localhost:8000</code>. If you experience issues run <code>make develop</code> to ensure the appropriate markdown extensions are in your python environment.</p> <p><code>make docs-serve</code> performs two actions:</p> <ul> <li>Runs the custom automation script <code>scripts/website_automation.py</code></li> <li>Serves the website on localhost.</li> </ul> <p>All documentation specific assets are stored within the <code>./docs</code> folder. The exception being <code>mkdocs.yml</code> which configures the documentation tree. Before opening a PR users should ensure:</p> <ul> <li>No warnings are generated by mkdocs</li> <li>All markdown documents within <code>./docs</code> are included in the website navigation defined in <code>mkdocs.yml</code></li> </ul>"},{"location":"contributing/website/#trestle-custom-automation","title":"<code>trestle</code> custom automation.","text":"<p>In order to streamline development, and ensure the website remains up to date, a small automation script has been built. This automation script principally ensures that:</p> <ul> <li>License is consistent with github.com</li> <li>All modules are in the reference documentation</li> </ul> <p>running <code>make docs-automation</code> will ensure that the website is ready to deploy.</p>"},{"location":"contributing/website/#building-the-models-from-the-oscal-schemas","title":"Building the models from the OSCAL schemas.","text":"<p>The creation of the OSCAL models in <code>trestle/oscal</code> is a multi-step process:</p> <ul> <li>The oscal schemas are downloaded as modules from NIST into the <code>nist-source/json/schema</code> directory.</li> <li>The script <code>scripts/gen-oscal.py</code> loads each schema file and converts it to pydantic/python with <code>datamodel-codegen</code>.</li> <li>The generated python files may need some fixup, so a separate script <code>scripts/fix_any.py</code> is run on each file.</li> <li>Note that there is one schema specific to IBM needs and it is loaded from <code>3rd-party-schema-documents/IBM_target_schema_v1.0.0.json</code>.</li> </ul> <p>The whole process is handled in the Makefile by <code>make code-gen</code>.  A normal user would never need to run this but developers may need to, particularly if there are changes to the OSCAL schemas.</p> <p>Also note that the depenedent tools, pydantic and datamodel-codegen, may get updated by doing a fresh <code>make install</code> or <code>make develop</code>, which may then result in a change to the model files.</p>"},{"location":"contributing/website/#items-handled-by-fix_anypy","title":"Items handled by <code>fix_any.py</code>.","text":"<p>The original motivation for this script was to replace numerous situations where the type assigned to a given variable was simply <code>Any</code>, which meant no type enforcement would apply for that variable, defeating the purpose of the strict type enforcement provided by Pydantic.  As of this writing the number of such cases has been reduced to just one - which is handled by the script.</p> <p>Other issues handled by the script are:</p> <ul> <li>The current OSCAL schemas have situations where objects are defined within different classes in a schema using the same name, but the contents of those classes may or may not be different.  <code>datamodel-codegen</code> handles this by creating separate classes as needed and appending 1, 2 etc. to the names, keeping them distinct.  The resulting high level classes that reference them behave as expected, but if components of those classes are added in a granular way by a user or developer, the correct index must be used.</li> <li>To reduce side-effects of the duplicate classes, classes are checked to see if they are identical or not.  If they are identical the separate 1, 2 classes are culled and references to them are pointed to the non-indexed class.</li> <li>Currently there are 5 classes that require a separate '1' version: <code>Status, Type, Entry, LocalDefinitions, and Action</code>.</li> <li>In order to guarantee there are no induced forward references in the files, the classes are reordered to minimize the need for forwards, and any that can't be avoided are explicitly provided at the bottom of the file.</li> <li>The generated files have many classes that simply have a <code>__root__</code> element defined, along with a description.  Such classes don't have particular value in such a simple form and could instead simply be defined in the parent class.</li> </ul>"},{"location":"contributing/website/#seeing-the-changes-induced-by-fix_anypy-on-the-classes","title":"Seeing the changes induced by <code>fix_any.py</code> on the classes.","text":"<p>As a convenience for developers, a separate script, <code>scripts/order_classes.py</code> is available, which orders the classes in a given file alphabetically.  This way, if you use the script on files before and after applying <code>fix_any.py</code> you can use a normal diff tool to see the changes made.  This is strictly as a development tool for doing the comparison and the resulting files will not work since they will have forward references.</p>"},{"location":"plugins/compliance-trestle-fedramp/","title":"compliance-trestle-fedramp plugin","text":"<p>This plugin provides functionality for validating an SSP for FedRAMP compliance. It provides both an API interface and a trestle command for performing this validation.</p>"},{"location":"plugins/compliance-trestle-fedramp/#trestle-fedramp-validate","title":"<code>trestle fedramp-validate</code>","text":"<p>This command allows users to validate existing OSCAL SSP file (in JSON or YAML format) for FedRAMP compliance. For example, <code>trestle fedramp-validate -f /local_dir/ssp.json -o report/</code> will validate <code>ssp.json</code> file for fedramp complaince and store the validation reports in <code>report</code> folder.</p> <p>The following options are supported:</p> <ul> <li><code>-f or --file</code>: specifies the path of an existing OSCAL SSP file. It may be an absolute or relative path. The file must be in either JSON or YAML format. This is a required option.</li> <li><code>-o or --output</code>: specifies the name of the output directory where the validation reports will be stored. It may be an absolute or relative path. The output directory should already exist. This is also a required option.</li> </ul> <p>The validation reports are created in XML and HTML format and provide details on which part of the SSP are not complaint as per FedRAMP specification.</p>"},{"location":"reference/third-party-result-schema-SCC/","title":"Schema of Assessment Results for Interchange with IBM Cloud Security and Compliance Center, SCC","text":"<p>This document depicts the structure and guidelines for creating an OSCAL result object which would be generated by various transformers for different tools such as Tanium to OSCAL and OSCO to OSCAL. Policy Validation Points (PVPs) such as toolchain that directly generate OSCAL results for sending to SCC Exchange API should follow the structure and guidelines described below.</p> <p>The overall object will be a results element of OSCAL Assessment Result schema wrapped in an outer json object as shown below.</p> <pre><code>{\n\"results\": [\n{\n\"result\": \"object\"\n},\n{\n\"result\": \"object\"\n}\n]\n}\n</code></pre> <p>Each result object represents one assessment scan and should have the required properties as per OSCAL schema. The start and end represents the start and end datetime of evidence collection activity. The end is optional. In addition to these, the result object may contain details about inventory, list of observations (checks) for each inventory, and findings for profile level controls (such as NIST).</p> <pre><code>{\n\"uuid\": \"cd54e9bf-f4d3-45d6-ae3b-6e8255847dc2\",\n\"title\": \"Tanium\",\n\"description\": \"Tanium\",\n\"start\": \"2021-04-05T20:19:11.000+00:00\",\n\"end\": \"2021-04-05T20:19:11.000+00:00\",\n\"local-definitions\": {},\n\"reviewed-controls\": {},\n\"observations\": {},\n\"findings\": {}\n}\n</code></pre> <p>The inventory should be included in local-definitions if observations are being reported, but can be omitted if only findings are being reported. As reviewed-controls is required as per OSCAL schema, an empty object should be included if only observations are being reported. Optionally, the controls for which the status is being reported in findings can be captured here. The actual assessment checks being performed on different inventory items should be captured under observations. This can be omitted if only findings are being reported. As findings is required as per OSCAL schema, an empty object can be included if only observations are being reported and no profile controls are being assessed. Otherwise, findings should include the status of profile controls.</p>"},{"location":"reference/third-party-result-schema-SCC/#general-guidance","title":"General Guidance","text":"<ol> <li> <p>All the properties in the source result (tool specific format) should be represented as properties of the right objects in OSCAL such as inventory-items, observations, etc. The properties should have a tool specific namespace to convey that the property names are exactly same as what is coming from specific tools.</p> </li> <li> <p>Not everything from the non-OSCAL results are relevant (required) by SCC. The relevant properties MUST have SCC specific class such as scc_inventory_item_id, scc_result, etc. This will help SCC identify corresponding information from different tools and handle them appropriately. SCC MUST store the original property names so that when these are retrieved by tools later, they can get back the same name-value pairs as was there in the input data.</p> </li> <li> <p>There must be a pre-defined set of properties (class values) from SCC for each result object component such as inventory-items, components, observations, etc.</p> </li> <li> <p>A property value MUST be a string of appropriate format.</p> </li> </ol>"},{"location":"reference/third-party-result-schema-SCC/#transforms","title":"Transforms","text":"<ol> <li>File Unification SCC class for OSCO and Tanium to OSCAL.xlsx contains the SCC class mapping from Tanium and OpenShift Compliance Operator results data to OSCAL. Although other    properties are constructed during transformation, only items having SCC class are shown    in the table.</li> </ol>"},{"location":"reference/third-party-result-schema-SCC/#inventory","title":"Inventory","text":"<ol> <li>Inventory is captured under local-definitions in result object. local-definitions can be used to represent inventory items, components, users, etc. For our purposes only components and inventory-items will be used. Components should be used to represent software, services, etc. whereas inventory-items represent specific machines, VMs, network devices, etc. The inventory items should be associated to a component through implemented-components as shown below.</li> </ol> <pre><code>{\n\"local-definitions\": {\n\"components\": {\n\"b3e243a1-4660-4f5a-aa85-159b4b2d69ce\": {\n\"type\": \"Operating System\",\n\"title\": \"Windows 10\",\n\"description\": \"Windows 10\",\n\"status\": {\n\"state\": \"operational\"\n}\n}\n},\n\"inventory-items\": [\n{\n\"uuid\": \"c9fb63cf-d21e-4584-88f8-44d67ea33ba0\",\n\"description\": \"inventory\",\n\"props\": [\n{\n\"name\": \"Computer Name\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"cmp-wn-2106.demo.tanium.local\"\n},\n{\n\"name\": \"Tanium Client IP Address\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"192.168.0.120\",\n\"class\": \"scc_inventory_item_id\"\n},\n{\n\"name\": \"IP Address\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"['fe80::cd44:4154:61e8:53ae', '192.168.0.120']\"\n},\n{\n\"name\": \"Count\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1\"\n}\n],\n\"implemented-components\": [\n{\n\"component-uuid\": \"b3e243a1-4660-4f5a-aa85-159b4b2d69ce\"\n}\n]\n}\n]\n}\n}\n</code></pre> <ol> <li> <p>Inventory items have one required property with class scc_inventory_item_id as shown above. Similarly in some other tool's result the scc_inventory_item_id may be specified through some other property. It is the job of the transformation code to appropriately specify class values for required properties. As shown above, non-mandatory property such as count from native result does not have any class specified.</p> </li> <li> <p>The type of the inventory item is specified by linking it to component via implemented-components.</p> </li> </ol>"},{"location":"reference/third-party-result-schema-SCC/#observation","title":"Observation","text":"<ol> <li>Loosely speaking, an observation object equates with results from a goal check, and the observation is uniquely identified by a uuid, e.g.,</li> </ol> <pre><code>{\n\"uuid\": \"00000000-0000-4000-9999-000000000016\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1_L1_Ensure_Enforce_password_history_is_set_to_24_or_more_passwords\"\n}\n</code></pre> <ol> <li>A sample observation object generated from Tanium result looks like -</li> </ol> <pre><code>{\n\"uuid\": \"74b605f8-7e8c-41b3-9514-2412692fbe01\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"fail\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-11T22:34:03+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"c8919d2b-3300-4f3f-98f6-15a7104c2e04\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-11T22:34:03.000+00:00\"\n}\n</code></pre> <ol> <li> <p>An observation has five required properties -</p> </li> <li> <p>scc_predefined_profile - identifies both Goal based Profiles (eg CIS-benchmarks, IBM BP etc) and Control/Regulation based Profiles (eg. NIST, FS Cloud etc). The way the integrators or customers will differentiate between the two types of profiles is by the OSCAL element used i.e., Goal based Profiles are defined in the observation element which carries the goal id (check id) and posture. Control/Regulation based Profiles\u00a0 are defined in the finding element which carries the control posture, the custom profile name, and the mapping of the goal results to NIST controls</p> </li> <li>scc_check_version, scc_predefined_profile_version - gives the version of the goal/profile i.e., CIS benchmark version used for check.</li> <li>scc_goal_description, scc_check_name_id - gives the specific goal check (rule) that was assessed from the scc_predefined_profile.</li> <li>scc_result - gives the outcome of performing the check. Possible values are - \"pass\", \"fail\", \"error\" , \"unknown\", \"notchecked\", \"notapplicable\".</li> <li> <p>scc_timestamp - datetime for this observation. This can be date and time when this observation was performed or reported.</p> </li> <li> <p>Targets such as systems or services MUST be a subject in the observation, which MUST be identified by a uuid-ref value pointing to the subject in local-definitions.</p> </li> </ol>"},{"location":"reference/third-party-result-schema-SCC/#finding","title":"Finding","text":"<ol> <li>A finding represents the assessment of a profile control such as NIST 800-53: AC-1 and the related observations. A sample finding object looks like -</li> </ol> <pre><code>{\n\"uuid\": \"cde35fad-3922-4046-8ef8-830e77ffd75a\",\n\"title\": \"800-53: IA-5\",\n\"description\": \"800-53: IA-5\",\n\"target\": {\n\"type\": \"statement-id\",\n\"id-ref\": \"800-53: IA-5\",\n\"props\": [\n{\n\"name\": \"Profile\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Windows 10 - NIST 800-53\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"version: 1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Custom ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"800-53: IA-5\"\n}\n],\n\"status\": \"not-satisfied\"\n},\n\"related-observations\": [\n{\n\"observation-uuid\": \"d8bd1785-b95f-45c9-9fa8-32a362845102\"\n},\n{\n\"observation-uuid\": \"d06c6f13-5006-4e2d-b3f3-5cdb577473b1\"\n}\n]\n}\n</code></pre> <ol> <li> <p>A finding has two required property scc_predefined_profile that gives the name of the profile whose control is specified in \"id-ref\", and scc_predefined_profile_version.</p> </li> <li> <p>If there is no finding associated with a PVP, a single finding will be created (to preserve valid OSCAL) where the UUID maps to a 'all zeros' UUID e.g.:</p> </li> </ol> <pre><code>{\n\"uuid\": \"00000000-0000-4000-8000-000000000000\",\n\"title\": \"No finding\",\n\"description\": \"No finding.\"\n}\n</code></pre>"},{"location":"tutorials/trestle_sample_workflow/","title":"Tutorial: Introduction to trestle workflow","text":"<p>Here are step-by-step instructions to manipulate a NIST standard OSCAL catalog using the compliance-trestle (<code>\"trestle\"</code>) tool.</p>"},{"location":"tutorials/trestle_sample_workflow/#objective","title":"Objective","text":"<p>Learn how to split and merge an OSCAL catalog json file using trestle commands and its command line interface (CLI).  Trestle simplifies the manipulation and management of large OSCAL documents by allowing controlled deconstruction into smaller components, and later reconstruction after editing those components.  And all operations guarantee that the individual files conform to the corresponding OSCAL schema to maintain integrity of the document in the process.</p> <p>This tutorial assumes you have installed Python and installed trestle in a virtual environment per the directions found here.</p> <p>The examples shown will work for linux and mac, but Windows will require the following modifications:</p> <ul> <li>use backslashes `\\` for file paths (this is optional in most cases) <li>use copy instead of cp (unless you have cp installed) <li>use md instead of mkdir (unless you have mkdir installed) <li>quotes (') are often not needed unless the text includes spaces, but if quotes are needed they should be double quotes (\")  <p>Commands are shown without prompts so they are easy to cut and paste, and responses by trestle are shown with &gt;&gt;&gt; at the start of the line.  In actual usage the &gt;&gt;&gt; would not appear.</p> <p>Be sure to include the quotes (' ') as shown in the examples, e.g. <code>merge -e 'catalog.*'</code> [On windows you should probably use double quotes (\") as needed.]</p> <p>In this tutorial you will see sections that contain dropdown that is revealed when you click on them.  Below is an example (\"Like this\").  Be sure to click on those sections to see their contents - and then close them if you like.</p> <p></p> Like this <pre><code>more\ninformation\nin\nhere\n</code></pre> <p></p>"},{"location":"tutorials/trestle_sample_workflow/#step-1-create-a-trestle-workspace-if-you-dont-have-one-already","title":"Step 1: Create a trestle workspace if you don't have one already","text":"<pre><code>mkdir my_workspace\ncd my_workspace\ntrestle init\n&gt;&gt;&gt; Initialized trestle project successfully in [user_path]/my_workspace\n</code></pre>"},{"location":"tutorials/trestle_sample_workflow/#step-2-import-a-catalog-from-the-trestle-sample-data-directory-into-your-trestle-workspace","title":"Step 2: Import a catalog from the trestle sample data directory into your trestle workspace","text":"<p>For this tutorial we will use a catalog file from NIST, but we first must <code>import</code> it into the trestle workspace.  This can be done either by first downloading the file locally and then importing it, or you can download it directly using its url address.</p> <p>We will import the file directly from the NIST OSCAL github site.  The specific catalog is NIST_SP-800-53_rev5_catalog.json</p> <p>Import the file from the url with the following command:</p> <pre><code>trestle import -f https://raw.githubusercontent.com/usnistgov/oscal-content/master/nist.gov/SP800-53/rev5/json/NIST_SP-800-53_rev5_catalog.json -o mycatalog\n</code></pre> <p>As a reminder, you could also have imported the file from a local directory on your file system, or an sftp:// address.  But the file must first be imported to the trestle workspace in order for it to be directly manipulated by trestle as in this tutorial.</p> <p>The <code>import</code> command will also check the validity of the file including the presence of any duplicate uuid's.  If the file is manually created please be sure it conforms with the current OSCAL schema (OSCAL version 1.0.4) and has no defined uuid's that are duplicates. If there are any errors the Import will fail and the file must be corrected.</p> <p></p> Your initial workspace will look like this <pre><code>my_workspace\n \u2523 .trestle\n \u2503 \u2523 .keep\n \u2503 \u2517 config.ini\n \u2523 assessment-plans\n \u2503 \u2517 .keep\n \u2523 assessment-results\n \u2503 \u2517 .keep\n \u2523 catalogs\n \u2503 \u2523 mycatalog\n \u2503 \u2503 \u2517 catalog.json\n \u2503 \u2517 .keep\n \u2523 component-definitions\n \u2503 \u2517 .keep\n \u2523 dist\n \u2503 \u2523 assessment-plans\n \u2503 \u2503 \u2517 .keep\n \u2503 \u2523 assessment-results\n \u2503 \u2503 \u2517 .keep\n \u2503 \u2523 catalogs\n \u2503 \u2503 \u2517 .keep\n \u2503 \u2523 component-definitions\n \u2503 \u2503 \u2517 .keep\n \u2503 \u2523 plan-of-action-and-milestones\n \u2503 \u2503 \u2517 .keep\n \u2503 \u2523 profiles\n \u2503 \u2503 \u2517 .keep\n \u2503 \u2523 system-security-plans\n \u2503 \u2503 \u2517 .keep\n \u2503 \u2517 target-definitions\n \u2503 \u2503 \u2517 .keep\n \u2523 plan-of-action-and-milestones\n \u2503 \u2517 .keep\n \u2523 profiles\n \u2503 \u2517 .keep\n \u2523 system-security-plans\n \u2503 \u2517 .keep\n \u2517 target-definitions\n \u2503 \u2517 .keep\n</code></pre> <p></p> <p>You will see that the directory now shows your catalog file in <code>my_workspace/catalogs/mycatalog/catalog.json</code>.  Note that the <code>.keep</code> files are simply to make sure git does not remove the directories - and can be ignored.  Also note that the json file itself is singular (catalog) while the directory above is plural (catalogs).  This convention is used throughout trestle because a given model directory like catalogs may contain several individual models - each of which is singular.  The imported catalog file size may be larger than the original due to a change in formatting, but the contents should be the same.</p> <p>From here on in this tutorial we will just focus on the catalogs directory since the others are not directly involved.</p> <p>You have now populated your trestle workspace with an OSCAL catalog that you can manipulate.  Let's start.</p>"},{"location":"tutorials/trestle_sample_workflow/#step-3-split-the-file-into-smaller-parts","title":"Step 3: Split the file into smaller parts","text":"<p>The OSCAL schema specifies that a catalog must contain metadata, groups, and back-matter - so this command will pull them out of the original file and place them in separate json files for additional manipulations.</p> <p>To begin splitting the file, first cd to the directory where <code>catalog.json</code> has been placed.</p> <pre><code>cd catalogs/mycatalog\ntrestle split -f ./catalog.json -e 'catalog.metadata,catalog.groups,catalog.back-matter'\n</code></pre> <p>Here the <code>-f</code> refers to the filename of the json catalog file, and <code>-e</code> refers to the comma-separated list of <code>elements</code> you would like to split from the file.  This list does not represent the full file contents of the source <code>catalog.json</code> file, so some contents will be left behind in a much smaller <code>catalog.json</code> file after the split.  The elements that were split off will be placed in separate json files next to the new and smaller <code>catalog.json</code> file.</p> <p></p> Your new catalogs directory with json files split out <pre><code>catalogs\n \u2517 mycatalog\n \u2503 \u2523 catalog\n \u2503 \u2503 \u2523 back-matter.json\n \u2503 \u2503 \u2523 groups.json\n \u2503 \u2503 \u2517 metadata.json\n \u2503 \u2517 catalog.json\n</code></pre> <p></p> <p>Note there still remains a catalog.json file, but it is much smaller since the bulk of its contents have been split off.</p> <p>Any split step can be reversed by a corresponding <code>merge</code> operation.  In this case we can go backwards with:</p> <pre><code>trestle merge -e 'catalog.metadata,catalog.groups,catalog.back-matter'\n</code></pre> <p>or simply</p> <pre><code>trestle merge -e 'catalog.*'\n</code></pre> <p>You can go back and forth splitting and merging, but for the next step please start with the above files split so that <code>metadata.json</code> can be further split.</p>"},{"location":"tutorials/trestle_sample_workflow/#step-4-split-the-metadata-into-constituent-files","title":"Step 4: Split the metadata into constituent files","text":"<pre><code>cd catalog\ntrestle split -f ./metadata.json -e 'metadata.roles,metadata.parties,metadata.responsible-parties'\n</code></pre> The directory will now look like this, with metadata split into files <pre><code>catalogs\n \u2517 mycatalog\n \u2503 \u2523 catalog\n \u2503 \u2503 \u2523 metadata\n \u2503 \u2503 \u2503 \u2523 parties.json\n \u2503 \u2503 \u2503 \u2523 responsible-parties.json\n \u2503 \u2503 \u2503 \u2517 roles.json\n \u2503 \u2503 \u2523 back-matter.json\n \u2503 \u2503 \u2523 groups.json\n \u2503 \u2503 \u2517 metadata.json\n \u2503 \u2517 catalog.json\n</code></pre> <p>Again there remains a metadata.json file but it is smaller than the original.</p> <p>And this step can be reversed with the following:</p> <pre><code>trestle merge -e 'metadata.roles,metadata.parties,metadata.responsible-parties'\n</code></pre> <p>or simply</p> <pre><code>trestle merge -e 'metadata.*'\n</code></pre>"},{"location":"tutorials/trestle_sample_workflow/#step-5-split-metadata-further-using-wildcards","title":"Step 5: Split metadata further using wildcards","text":"<pre><code>cd metadata\ntrestle split -f ./roles.json -e 'roles.*'\ntrestle split -f ./responsible-parties.json -e 'responsible-parties.*'\n</code></pre> The directory now looks like this, with new subdirectories containing multiple roles and responsible-parties <pre><code>catalogs\n \u2517 mycatalog\n \u2503 \u2523 catalog\n \u2503 \u2503 \u2523 metadata\n \u2503 \u2503 \u2503 \u2523 responsible-parties\n \u2503 \u2503 \u2503 \u2503 \u2523 contact__responsible-party.json\n \u2503 \u2503 \u2503 \u2503 \u2517 creator__responsible-party.json\n \u2503 \u2503 \u2503 \u2523 roles\n \u2503 \u2503 \u2503 \u2503 \u2523 00000__role.json\n \u2503 \u2503 \u2503 \u2503 \u2517 00001__role.json\n \u2503 \u2503 \u2503 \u2517 parties.json\n \u2503 \u2503 \u2523 back-matter.json\n \u2503 \u2503 \u2523 groups.json\n \u2503 \u2503 \u2517 metadata.json\n \u2503 \u2517 catalog.json\n</code></pre> <p>Note that the presence of wildcards caused new directories to be created containing the full lists of roles and responsible parties.  You can read the wildcard as split off all roles from <code>roles.json</code>.</p> <p>This split can be reversed with</p> <pre><code>trestle merge -e 'roles.*,responsible-parties.*'\n</code></pre>"},{"location":"tutorials/trestle_sample_workflow/#step-6-split-groups-and-controls-with-two-wildcards","title":"Step 6: Split groups and controls with two wildcards","text":"<p>This single command will split off all controls in all groups.  To do it you need to go back up into the catalog directory where the <code>groups.json</code> file is found:</p> <pre><code>cd ..\ntrestle split -f ./groups.json -e 'groups.*.controls.*'\n</code></pre> <p></p> Your directory is now very large with that one command! <pre><code>catalogs\n \u2517 mycatalog\n \u2503 \u2523 catalog\n \u2503 \u2503 \u2523 groups\n \u2503 \u2503 \u2503 \u2523 00000__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00011__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00012__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00013__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00014__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00015__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00016__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00017__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00018__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00019__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00020__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00021__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00022__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00023__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00024__control.json\n \u2503 \u2503 \u2503 \u2523 00001__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00005__control.json\n \u2503 \u2503 \u2503 \u2523 00002__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00011__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00012__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00013__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00014__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00015__control.json\n \u2503 \u2503 \u2503 \u2523 00003__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00008__control.json\n \u2503 \u2503 \u2503 \u2523 00004__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00011__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00012__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00013__control.json\n \u2503 \u2503 \u2503 \u2523 00005__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00011__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00012__control.json\n \u2503 \u2503 \u2503 \u2523 00006__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00011__control.json\n \u2503 \u2503 \u2503 \u2523 00007__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00009__control.json\n \u2503 \u2503 \u2503 \u2523 00008__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00006__control.json\n \u2503 \u2503 \u2503 \u2523 00009__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00007__control.json\n \u2503 \u2503 \u2503 \u2523 00010__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00011__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00012__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00013__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00014__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00015__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00016__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00017__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00018__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00019__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00020__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00021__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00022__control.json\n \u2503 \u2503 \u2503 \u2523 00011__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00010__control.json\n \u2503 \u2503 \u2503 \u2523 00012__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00011__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00012__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00013__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00014__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00015__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00016__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00017__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00018__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00019__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00020__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00021__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00022__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00023__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00024__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00025__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00026__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00027__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00028__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00029__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00030__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00031__control.json\n \u2503 \u2503 \u2503 \u2523 00013__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00008__control.json\n \u2503 \u2503 \u2503 \u2523 00014__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00007__control.json\n \u2503 \u2503 \u2503 \u2523 00015__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00009__control.json\n \u2503 \u2503 \u2503 \u2523 00016__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00011__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00012__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00013__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00014__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00015__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00016__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00017__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00018__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00019__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00020__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00021__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00022__control.json\n \u2503 \u2503 \u2503 \u2523 00017__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00011__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00012__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00013__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00014__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00015__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00016__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00017__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00018__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00019__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00020__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00021__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00022__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00023__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00024__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00025__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00026__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00027__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00028__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00029__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00030__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00031__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00032__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00033__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00034__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00035__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00036__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00037__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00038__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00039__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00040__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00041__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00042__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00043__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00044__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00045__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00046__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00047__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00048__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00049__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00050__control.json\n \u2503 \u2503 \u2503 \u2523 00018__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00011__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00012__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00013__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00014__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00015__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00016__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00017__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00018__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00019__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00020__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00021__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00022__control.json\n \u2503 \u2503 \u2503 \u2523 00019__group\n \u2503 \u2503 \u2503 \u2503 \u2517 controls\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00000__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00001__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00002__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00003__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00004__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00005__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00006__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00007__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00008__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00009__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2523 00010__control.json\n \u2503 \u2503 \u2503 \u2503 \u2503 \u2517 00011__control.json\n \u2503 \u2503 \u2503 \u2523 00000__group.json\n \u2503 \u2503 \u2503 \u2523 00001__group.json\n \u2503 \u2503 \u2503 \u2523 00002__group.json\n \u2503 \u2503 \u2503 \u2523 00003__group.json\n \u2503 \u2503 \u2503 \u2523 00004__group.json\n \u2503 \u2503 \u2503 \u2523 00005__group.json\n \u2503 \u2503 \u2503 \u2523 00006__group.json\n \u2503 \u2503 \u2503 \u2523 00007__group.json\n \u2503 \u2503 \u2503 \u2523 00008__group.json\n \u2503 \u2503 \u2503 \u2523 00009__group.json\n \u2503 \u2503 \u2503 \u2523 00010__group.json\n \u2503 \u2503 \u2503 \u2523 00011__group.json\n \u2503 \u2503 \u2503 \u2523 00012__group.json\n \u2503 \u2503 \u2503 \u2523 00013__group.json\n \u2503 \u2503 \u2503 \u2523 00014__group.json\n \u2503 \u2503 \u2503 \u2523 00015__group.json\n \u2503 \u2503 \u2503 \u2523 00016__group.json\n \u2503 \u2503 \u2503 \u2523 00017__group.json\n \u2503 \u2503 \u2503 \u2523 00018__group.json\n \u2503 \u2503 \u2503 \u2517 00019__group.json\n \u2503 \u2503 \u2523 metadata\n \u2503 \u2503 \u2503 \u2523 responsible-parties\n \u2503 \u2503 \u2503 \u2503 \u2523 contact__responsible-party.json\n \u2503 \u2503 \u2503 \u2503 \u2517 creator__responsible-party.json\n \u2503 \u2503 \u2503 \u2523 roles\n \u2503 \u2503 \u2503 \u2503 \u2523 00000__role.json\n \u2503 \u2503 \u2503 \u2503 \u2517 00001__role.json\n \u2503 \u2503 \u2503 \u2517 parties.json\n \u2503 \u2503 \u2523 back-matter.json\n \u2503 \u2503 \u2517 metadata.json\n \u2503 \u2517 catalog.json\n</code></pre> <p></p> <p>All 20 groups of controls have been split off, and each one has a corresponding directory with its full list of controls in it.</p> <p>You can then reverse the split with</p> <pre><code>trestle merge -e 'groups.*'\n</code></pre>"},{"location":"tutorials/trestle_sample_workflow/#step-7-collapse-the-entire-directory-structure-back-into-a-single-catalogjson-file-possibly-after-modifying-individual-files","title":"Step 7: Collapse the entire directory structure back into a single <code>catalog.json</code> file - possibly after modifying individual files","text":"<p>You can collapse everything back to a single <code>catalog.json</code> file after first going up one directory to the mycatalog directory</p> <pre><code>cd ..\ntrestle merge -e 'catalog.*'\n</code></pre> <p></p> After all that splitting and merging you are back to this directory structure <pre><code>catalogs\n \u2517 mycatalog\n \u2503 \u2517 catalog.json\n</code></pre> <p></p>"},{"location":"tutorials/trestle_sample_workflow/#conclusion","title":"Conclusion","text":"<p>This completes the tutorial on using <code>trestle</code> to split and merge an OSCAL catalog file.  Not shown here are modifications of the individual files that would be done in an actual use case, but note that if any changes are made that violate the OSCAL schema, <code>trestle</code> will notice them and flag them in the merge.  This way not only does <code>trestle</code> allow user-driven decomposition and aggregation of these large, complex files; it also does constant checks on the contents against the required schema to make sure no errors are introduced in the process.</p>"},{"location":"tutorials/continuous-compliance/continuous-compliance/","title":"Tutorial: What\u2019s your compliance posture?","text":""},{"location":"tutorials/continuous-compliance/continuous-compliance/#introduction","title":"Introduction","text":"<p>The cloud with its continuous integration and continuous deployment is the modern computing paradigm. There is a plethora of cloud environments: public, private, on-premise, hybrid-cloud, multi-cloud, etc. along with a corresponding contingent of vendors. The cloud offers great flexibility where you can choose just one or some combination optimal for each application. But, as demonstrated from time to time, the cloud can be a dangerous place. Hackers, bots, malware, and more are constant threats seeking to find and exploit weakness in your computing solution. To combat them there are strategies to avoid embarrassment and financial ruin from security breeches. Educating your workforce is of paramount importance. Moreover, employing a trust-but-verify strategy will go a long way toward deflecting trouble.</p> <p>The time has come for continuous auditing, and giving stakeholders (such as account owners, application owners, system owners and compliance officers) a current picture of their compliance posture:</p> <ul> <li>Are password rules being followed?</li> <li>Are deployed applications using compromised encryption algorithms?</li> <li>Has a user gotten elevated privileges?</li> <li>Are unauthorized open source projects wrongfully part of your application stack?</li> </ul> <p>Getting answers to these questions only quarterly or annually is leaving you exposed.</p> <p>Moreover, assuring continuous compliance across multiple cloud vendors can complicate matters. If each has its own compliance regime, then one must become expert in each domain\u2019s compliance solution space, or else be wedded to a single or few providers. That is not an ideal prospect.</p> <p>Common sense dictates that standardization would simplify matters. The National Institute of Standards and Technologies (NIST) is developing the Open Security Controls Assessment Language (OSCAL).</p> <p>The compliance-trestle open source github project is an effort to employ OSCAL for compliance standardization and automation. Of great utility is the trestle oscal module that facilitates transformation of data to/from Python object representations in accordance with the OSCAL schemas.</p>"},{"location":"tutorials/continuous-compliance/continuous-compliance/#simple-continuous-compliance-architecture","title":"Simple Continuous Compliance Architecture","text":"<p>Cloud Services can often be configured to monitor (and sometimes enforce) policies. Examples include OpenShift Compliance Operator and Tanium. However, the compliance reporting \u201craw\u201d data produced is unique to each.</p> <p>Two steps are needed to ascertain your compliance posture. Step 1 is to transform available compliance \u201craw\u201d data into standardized form (OSCAL). Step 2 is to examine the OSCAL data and assemble a compliance posture for the controls and components of interest. And trestle is the go-to solution.</p>"},{"location":"tutorials/continuous-compliance/continuous-compliance/#step-1-transformation","title":"Step 1 \u2013 Transformation","text":"<p>The bad news is that a transformer to OSCAL is needed for each Cloud Service type.</p> <p>However, there is plenty of good news:</p> <ul> <li>a transformer for your Cloud Service type may already exist, such as: Tanium to OSCAL, OpenShift Compliance Operator to OSCAL</li> <li>once a transformer for a Cloud Service type has been written, it can be open-sourced/re-used</li> <li>writing a transformer is fairly easy: just a few lines of Python code using trestle as a foundation</li> </ul> <p>In the case of Tanium, the OSCAL compliance data document is a System Assessment Results fragment with Findings and Observations, while in the case of OpenShift Compliance Operator there are Observations only.</p> <p>Tutorials are available to show you: how to run a transformer, how to write a transformer.</p>"},{"location":"tutorials/continuous-compliance/continuous-compliance/#step-2-reporting","title":"Step 2 \u2013 Reporting","text":"<p>Coming soon is a trestle tool to assemble the OSCAL fragments documents together using OSCAL compliance configuration data (System Assessment Plan  and System Security Plan) into a complete System Assessment Results.</p>"},{"location":"tutorials/ssp_profile_catalog_authoring/ssp_profile_catalog_authoring/","title":"Tutorial: Catalog, Profile, ComponentDefinition, and SSP Authoring","text":""},{"location":"tutorials/ssp_profile_catalog_authoring/ssp_profile_catalog_authoring/#introduction-and-background","title":"Introduction and background","text":"<p>In addition to core functionality for automated processing of OSCAL documents, Trestle has authoring tools that allow conversion of OSCAL documents to markdown for easy editing - and conversion back to OSCAL for validation and automation.  A big part of compliance involves writing guidance prose associated with controls, along with the setting of parameters and properties for those controls.  This cannot be completely automated because it requires human editing, along with human approvals of those edits.  The purpose of the authoring tools is to allow selected edits of oscal documents guided by prompts for where content is required.  This serves to streamline the edit/approval process whereby the author is presented with one markdown document per control, and it provides a view of the the key information needed during the editing process.  This greatly simplifies the editing process compared to multiple authors working together on a single large JSON document.</p> <p>The key modes of authoring are -generate and -assemble.  During -generate a JSON document is converted to markdown format, allowing authors to add or edit prose and parameter values.  After editing, the markdown can then be -assembled into the same or a new JSON document that captures the edit changes.  In a normal authoring cycle, the markdown is generated for the first time from a given JSON file, and after that there is a continuous process of editing and reassembling to keep the JSON up to date with the markdown edits.</p> <p>A third mode of authoring is -filter, where parts of a document are removed.  This allows one large master document to be represented in simpler ways with, e.g. proprietary prose culled in form intended for consumption outside a company.</p> Integration with git and CI/CD <p>The command line interface in Trestle makes a powerful combination with git and CI/CD environments (Continuous Integration, Continuous Delivery or Deployment) when the trestle commands are performed via github actions or equivalent.  This allows different classes of users based on 1) their access to the repository 2) the changes to documents they are allowed to commit, and 3) the changes they can make to actions that are triggered by a commit.  As an example, a command line option may limit the type of content added to a profile, and if disallowed changes are detected during commit - the commit will be rejected.  This, in combination with having all controls as individual markdown files organized by groups in directories, makes management and tracking of author edits robust and automatically controlled by the built-in features of the respository.</p> <p>For an example of actions triggered by a commit, a change to a control in a catalog could generate a pull request that is approved by someone with appropriate authority, and when it is later merged it triggers notification downstream to authors of profiles that import that catalog.</p> The author commands <p>The author commands are:</p> <ol> <li><code>catalog-generate</code> converts a control Catalog to individual controls in markdown format for addition or editing of guidance prose and parameters, with parameters stored in a yaml header at the top of the markdown file.  <code>catalog-assemble</code> then gathers the prose and parameters and updates the controls in the Catalog to make a new OSCAL Catalog.</li> <li><code>profile-generate</code> takes a given Profile and converts the controls represented by its resolved profile catalog to individual controls in markdown format, with sections corresponding to the content that the Profile adds to the Catalog, along with both the current values of parameters in the resolved profile catalog - and the values that are being modified by the given profile's SetParameters.  The user may edit the content or add more, and <code>profile-assemble</code> then gathers the updated content and creates a new OSCAL Profile that includes those changes.</li> <li><code>profile-resolve</code> is special as an authoring tool because it does not involve markdown and instead it simply creates a JSON resolved profile catalog from a specified JSON profile in the trestle directory.  There are options to specify whether or not parameters get replace in the control prose or not, along with any special brackets that might be desired to indicate the parameters embedded in the prose.</li> <li><code>component-generate</code> takes a given ComponentDefinition file and represents all the controls in markdown in separate directories for each Component in the file.  This allows editing of the prose on a per-component basis.  <code>component-assemble</code> then assembles the markdown for all controls in all component directories into a new, or the same, ComponentDefinition file.</li> <li><code>ssp-generate</code> takes a given Profile and an optional list of component-definitions, and represents the individual controls as markdown files with sections that prompt for prose regarding the implementation response for items in the statement of the control, with separate response sections for each component.  <code>ssp-assemble</code> then gathers the response sections and creates an OSCAL System Security Plan comprising the resolved profile catalog and the implementation responses for each component.  The list of component-definitions is optional, but without them the SSP will only have one component: <code>This System</code>.  Rules, parameters and status associated with the implemented requirements are stored in the SetParameters and Properties of the components in the component definitions and represented in the markdown, allowing changes to be made to the parameter values and status.  These edits are then included in the assembled SSP.  Note that the rules themselves may not be edited and strictly correspond to what is in the component definitions.</li> <li><code>ssp-filter</code> takes a given ssp and filters its contents based on the controls included in a provided profile, or in a list of components to be included in the final ssp.</li> </ol> <p>In summary, the <code>catalog</code> tools allow conversion of a Catalog to markdown for editing - and back again to a Catalog.  The <code>profile</code> tools similarly convert a Profile's resolved profile catalog to markdown and allow conversion to a new Profile with modified additions that get applied in resolving the profile catalog.  <code>component</code> tools perform similarly for ComponentDefinitions.  Finally, the <code>ssp</code> tools allow the addition of implementation prose to the markdown of a system security plan, which is then assembled into a JSON SSP on a by-component basis.</p> <p>Note that the original ssp implementation in trestle created SSP's by adding prose directly to the SSP markdown on a per-component basis, and there was no connection with separate ComponentDefinition JSON files.  This is now changed so that control responses can be added to the ComponentDefinition and then merged to create the SSP markdown.  In addition, rules and status are captured in the component definition as properties that propogate via markdown into the assembled SSP.  The OSCAL schema doesn't include a form of implementation status for components in the component definition, which is why trestle embeds the status value in the properties.  Similarly, rules and rule parameter values are not currently part of the schema, so they are also embedded in properties.</p> Some details of the author commands <p>The markdown files for controls usually have a YAML header at the top containing metadata about the control.  Sometimes that information is read-only and intended as additional information useful during markdown editing, but in other cases the content may be edited and incorporated as new values for the control after <code>-assemble</code>.  In addition, most <code>-generate</code> commands allow specifying a separate YAML header file containing information either needed by the command, or intended to be incorporated into the header of each control markdown file.  When generating markdown a YAML header may be optionally provided, and if so, the option <code>--overwrite-header-values</code> will cause the values in the provided YAML header to overwrite the value in the markdown file's header for any items that are common.  Otherwise the provided YAML header will simply insert any values not already in the markdown header. By default, Trestle will preserve the history of the changes in generated markdowns, however <code>--force-overwrite</code> option can be used to overwrite markdowns with content from JSON. Note that this option will completely delete all existing markdowns (in the given <code>output</code> folder) without saving any changes. To save the changes, run assemble first. Similarly, when assembling to JSON, the <code>--set-parameters</code> option will cause any changes in the header to take effect and change values in the assembled JSON for the control.  The changes can including setting parameter and property values.  The <code>--set-parameters</code> option is available only for <code>catalog-assemble</code> and <code>profile-assemble</code>.</p> <p>As described earlier, the authoring tools are designed to work well in a CI/CD environment where changes are made in a pipeline by people with different responsibilities and authority.  In this setting, changes to documents can trigger changes downstream, e.g. the editing of a control would cause an update in the catalog, which could then flow down to an updated SSP.  These changes can occur automatically via actions that restrict the potential changes to the generated documents.  Examples are the <code>--set-parameters</code> option on the <code>-assemble</code> tools, and both <code>--required-sections</code> and <code>allowed-sections</code> for <code>profile-assemble</code>.  If a document change triggers an assemble action, changes to parameters can only occur if the action has <code>--set-parameters</code> in the command.  Similarly, <code>profile-assemble</code> will fail if the sections do not meet the requirements specified in the command options.  Another feature of the <code>-assemble</code> tools is that they won't create a new OSCAL file if the output already exists and its content would not be changed.  This prevents undesired triggering of downstream actions when there is no actual change in content.</p> <p>There is a standalone demonstration of the SSP generation process with trestle in the Trestle SSP Demo, but it currently represents the earlier version of ssp authoring with trestle - prior to the link with component definitions and rules.  Nonetheless it captures the flow from OSCAL json files to a finished Word .docx file.</p> Background on underlying concepts <p>In order to understand the specific operations handled by these commands, it is helpful to clarify some of the underlying OSCAL structures and how they can be edited in markdown form.  This tutorial should be viewed in the context of the extensive documentation provided by OSCAL.</p> <p>First, a Catalog is a collection of Controls, and a Profile imports controls and allows modification and additions to the controls, but it does not create new controls.  A Profile has one or more Imports that refer either to an actual Catalog, or another Profile that itself is importing from a Catalog or Profile.  The profiles can import controls selectively from each source and make additions or modifications to properties of the controls.  The final collection of selected and modified controls represents the profile's resolved profile catalog.</p> <p>For clarity, here is a simple depicton of a catalog as a collection of controls:</p> <p></p> <p>Here is a profile pulling controls from a catalog to make a resolved profile catalog:</p> <p></p> <p>And here is a more complex situation where a single profile pulls controls from catalogs and profiles:</p> <p></p> <p>From the diagram it's clear that the profile is performing many tasks under the covers.  This is shown in an expanded view of a profile:</p> <p></p> <p>It's important to note that each profile is importing a selection of controls from each source, then making its own suggested modifications to parameters and other content in those controls.  They are suggested in the sense that downstream profiles may override those settings - with priority given to the later profiles in the pipeline.  The changes made by upstream profiles may be accepted, or overridden by better choices for a given need.  This way the catalogs themselves can remain relatively static, and individual use cases can effectively create a custom catalog based on the original controls plus modifications by  other static profiles, and/or the user's custom profile.  The authoring tools here provide ways to make those modifications, both to the catalog controls and to the profiles, and to enter the implementation responses that are needed in a System Security Plan.</p> <p>The tools are designed to be used in a continuous <code>generate-edit-assemble</code> cycle, with previous edits retained in each cycle.  Each new edit phase can add or modify the current content, allowing a new <code>generate</code> of an OSCAL json document capturing those edits.</p> <p>NOTE: We use <code>json</code> format for specifying OSCAL files in this tutorial, but it is equally applicable to <code>yaml</code> format also.</p>"},{"location":"tutorials/ssp_profile_catalog_authoring/ssp_profile_catalog_authoring/#the-author-commands-for-markdown-generation-and-assembly-to-json","title":"The author commands for markdown generation and assembly (to JSON)","text":"trestle author catalog-generate and trestle author catalog-assemble <p><code>catalog-generate</code> takes an existing json catalog and writes it out as markdown files for each control in a user-specified directory.  That directory will contain subdirectories for each group in the catalog, and those directories may contain subdirectories for groups within groups.  But controls containing controls are always split out into a series of controls in the same directory - and each control markdown file corresponds to a single control.</p> <p>We now look at the contents of a typical control markdown file.</p> <p>A Control may contain many parts, but only one of them is a Statement, which describes the function of the control.  The statement itself is broken down into separate items, each of which may contain parameter id's in \"moustache\" (<code>{{}}</code>) brackets.  Below is an example of a control as generated in markdown form by the <code>catalog-generate</code> command.</p> Control example <pre><code>---\nx-trestle-set-params:\n  ac-1_prm_1:\n    values:\n      - new value\n  ac-1_prm_2:\n    values:\n  ac-1_prm_3:\n    values:\n      - added param 3 value\n  ac-1_prm_4:\n    values:\n  ac-1_prm_5:\n    values:\n  ac-1_prm_6:\n    values:\n  ac-1_prm_7:\n    values:\nx-trestle-global:\n  sort-id: ac-01\n---\n\n# ac-1 - \\[Access Control\\] Policy and Procedures\n\n## Control Statement\n\n- \\[a.\\] Develop, document, and disseminate to {{ insert: param, ac-1_prm_1 }}:\n\n  - \\[1.\\]  {{ insert: param, ac-1_prm_2 }} access control policy that:\n\n    - \\[(a)\\] Addresses purpose, scope, roles, responsibilities, management commitment, coordination among organizational entities, and compliance; and\n    - \\[(b)\\] Is consistent with applicable laws, executive orders, directives, regulations, policies, standards, and guidelines; and\n\n  - \\[2.\\] Procedures to facilitate the implementation of the access control policy and the associated access controls;\n\n- \\[b.\\] Designate an {{ insert: param, ac-1_prm_3 }} to manage the development, documentation, and dissemination of the access control policy and procedures; and\n\n- \\[c.\\] Review and update the current access control:\n\n  - \\[1.\\] Policy {{ insert: param, ac-1_prm_4 }} and following {{ insert: param, ac-1_prm_5 }}; and\n  - \\[2.\\] Procedures {{ insert: param, ac-1_prm_6 }} and following {{ insert: param, ac-1_prm_7 }}.\n- \\[d\\] My added item\n\n## Control guidance\n\nAccess control policy and procedures address the controls in the AC family that are implemented within systems and organizations. The risk management strategy is an important factor in establishing such policies and procedures. \n</code></pre> <p>The control markdown files rely on brackets around key items that are important in defining the control's properties and structure.  <code>\\[Access Control\\]</code> at the top indicates the title of the group containing the control.  The name of the control is already known from the name of the markdown file (<code>ac-1.md</code>) and the name of the group is already known from the name of the directory containing the group's controls (<code>ac</code>) - but the group title must be indicated in the control in a special manner, hence the brackets.  The text following the group title is the title of the control itself.  All controls in a group should have the same group title or a warning will be indicated in certain trestle operations.</p> <p>In addition, each part label corresponds to the label used in the OSCAL structure for the control statement, and so must be maintained in a special manner -  hence the need for brackets on <code>\\[(a)\\]</code>.</p> <p>The items in moustaches (<code>{{}}</code>) correspond to the original prose from the control description.  The moustaches represent places to substitue parameter values, but no substitutions are ever made until the final SSP generation.  The authoring process provides multiple ways to set and change the final parameter values, as described below.</p> <p><code>catalog-generate</code> is run with the command <code>trestle author catalog-generate --name catalog_name --output markdown_dir</code>, where <code>catalog_name</code> is the name of a catalog already loaded into the trestle workspace, and <code>markdown_dir</code> is the directory into which the markdown files for the controls will be written.  A separate directory is created for each group in the catalog.</p> <p>A user then may edit the control statement for the control and add or change the contents.  In this case an added item, <code>My added item</code> is shown as item <code>d</code>.  You can then assemble the edited controls into a new catalog with the command <code>trestle author catalog-assemble --markdown markdown_dir --output new_catalog</code>.  This will load the updated control statements for each control into a new json or yaml catalog named <code>new_catalog</code>.</p> <p>As with profile and ssp generation described below, a yaml header may be provided with the <code>--yaml</code> option that is inserted into the top of each control file.  If a control file already exists, as is expected in a continuous cycle of generate-edit-assemble, then the provided header will be merged with the existing header in each control.  If a given item in the header is already present in the control, by default the values in the markdown header will be given priority, though this can be overridden by the <code>--overwrite-header-values</code> option, which will give priority to any values coming from the provided yaml header.  In all cases, values in the yaml header not already present in the markdown header will be inserted.</p> <p>In the control markdown example above, the header contains some arbitrary values along with a special <code>x-trestle-set-params</code> section containing parameters for some of the parameters in the control.  Any parameters for the control in the catalog will appear in the markdown header automatically during <code>catalog-generate</code>.  These values may be changed and values for other parameters may be inserted into the markdown header for later use during <code>catalog-assemble</code>.</p> <p>Parameters in the header are shown with a subset of their full OSCAL attributes in order to convey any values they may have along with descriptive text.  This amounts to the parameter id, its label if present, any values if present, and any select if present.  When a select is present the list of choices is provided along with the how-many option.  Note that values is a list in OSCAL, but in many cases it is a list of only one item.  As a result, for convenience the values: dictionary may either have one string value (on the same line with <code>values:</code>) or as an indented <code>-</code> list of multiple values underneath <code>values:</code>.  Multiple examples are evident in the sample above, including ac-1_prm_3, which only has a label and no values.</p> <p>Another important item in the header is the sort-id for the control.  This specifies how the controls and their parameters are ordered in any aggregated list operation.  If it is not specified for a control, the control's id is used for sorting.</p> <p>As with the other -generate tools, the <code>--force-overwrite</code> option will cause the destination markdown directory to be erased prior to generating the new markdown, so that any prior edits to the markdown will be erased.</p> <p><code>catalog-assemble</code> is run with the command <code>catalog-assemble --markdown my_md --output my_new_catalog</code>.  This will read the markdown for each control and create a new catalog based on any edits to the markdown.  Note that you may optionally provide a <code>--name</code> option specifying an original json catalog into which the updated controls are inserted, and the resulting catalog can either replace the original one or output to a different json file.  New controls may be added but existing controls may not be removed and new groups cannot be added when you are updating an existing catalog.  The main benefit of updating an existing catalog is that the original metadata and other contents of the catalog json file will be retained.  Note that you cannot create new controls that contain controls, but if an original json catalog contains controls with child controls, you can edit and update all of them as individual markdown files.  You have the option to specify a new <code>--version</code> for the catalog, and an option to regenerate the uuid's in the catalog.  Finally, you have the option to use the parameters in the markdown header to update the values in the control.  Any parameters and their values present will be added to the control, and any not present will be removed.  The parameters themselves are still present but their values are removed.</p> <p>In a typical <code>generate-edit-assemble</code> cycle, the cycle would start with an original json file containing source content and metadata and use that to generate an initial markdown directory of controls.  After editing the controls they would be assembled into into a new json file with a different name.  But once that new file exists, it can be used as the source for the next generation and the original source document is no longer needed or referred to.  For the <code>catalog-</code> editing cycle it would go as:</p> <pre><code>trestle author catalog-generate --name orig_catalog --output md_catalog\n[user edits the markdown files]\ntrestle author catalog-assemble --name orig_catalog --markdown md_catalog --output assembled_catalog\n[user makes additional markdown edits]\ntrestle author catalog-assemble --markdown md_catalog --output assembled_catalog\n</code></pre> <p>The key point here is that the first <code>-assemble</code> needs to use the original catalog for its metadata, backmatter and other items not captured in the markdown controls.  But once the output catalog has been created, by default it will be used as the \"original\" or \"parent\" catalog into which changes will be incorporated, unless a different source catalog is specified via <code>--name</code>.</p> <p>Note that <code>catalog-assemble</code> can instantiate a catalog anew from a manually created directory of markdown controls in directories corresponding to groups, but the metadata in the assembled json catalog will contain many <code>REPLACE_ME</code> items that would need to be manually edited in the json file itself.  The trestle <code>split</code> and <code>merge</code> tools may help in that case.  Once the changes have been made they will be retained if a new <code>catalog-assemble</code> happens with that same output file as the target.</p> <p>Special Note about assemble: In order to avoid triggering actions when a new file is created that has no actual changes in it, <code>catalog-assemble</code> and the other <code>-assemble</code> tools below will check to see if the output file already exists, and if so it will be examined for changes relative to the newly assembled one.  If there are no changes the file will not be written out.  Note that the check happens before any possible <code>--regeneration</code> of uuid's, and after any possible <code>--version</code> change.  This avoids the creation of a new file and new uuid's if there is no change to the version or other file contents relative to the existing output file, but if the specified <code>--version</code> is different from the one in the existing output file, or there is any other difference in the model, a new file will be written out.</p> trestle author profile-generate and trestle author profile-assemble <p>The background text above conveys how a profile pulls controls from catalogs and makes modifications to them, and the <code>trestle profile</code> tools let you change the way those modifications are made.  In addition to selecting controls and setting parameters, a profile may add new parts to a control that provide additional guidance specific to a certain use case.  <code>profile-generate</code> is run with the command, <code>trestle author profile-generate --name profile_name --output markdown_dir</code>.  It will load the specified profile name from the trestle workspace (it must have been imported into the trestle workspace prior) and create its corresponding resolved profile catalog - but without applying any of its <code>Adds</code> of additonal guidance content or <code>SetParameters</code>.  It will make all other modifications, but the <code>Adds</code> and <code>SetParameters</code> are kept separate, as shown below:</p> Example of control markdown after `profile-generate` <pre><code>---\nx-trestle-set-params:\n  # You may set values for parameters in the assembled Profile by adding\n  #\n  # profile-values:\n  #   - value 1\n  #   - value 2\n  #\n  # in the section under a parameter name\n  # The values list refers to the values in the catalog, and the profile-values represent values\n  # in SetParameters of the Profile.\n  #\n  ac-1_prm_1:\n    label: label from edit\n    profile-values:\n      - all personnel\n    values:\n      - Param_1_value_in_catalog\n    display-name: Pretty ac-1 prm 1\n  ac-1_prm_2:\n    profile-values:\n      - Organization-level\n      - System-level\n    values:\n    display-name: Pretty ac-1 prm 2\n  ac-1_prm_3:\n    profile-values:\n      - new value\n    values:\n  ac-1_prm_4:\n    profile-values:\n    values:\n  ac-1_prm_5:\n    profile-values:\n      - all meetings\n    values:\n  ac-1_prm_6:\n    profile-values:\n      - monthly\n    values:\n  ac-1_prm_7:\n    values:\nx-trestle-global:\n  profile:\n    title: Trestle test profile\n  sort-id: ac-01\nx-trestle-sections:\n  guidance: Guidance\n  implgdn: Implementation Guidance\n  expevid: Expected Evidence\n  my_guidance: My Guidance\n  a_guidance: A Guidance\n  b_guidance: B Guidance\n  NeededExtra: Needed Extra\n  a_subpart: A Subpart\n  a_subsubpart: A Subsubpart\n  b_subpart: B Subpart\n  a_by_id_subpart: a by_id subpart\nx-trestle-add-props:\n  # Add or modify control properties here\n  # Properties may be at the control or part level\n  # Add control level properties like this:\n  #   - name: ac1_new_prop\n  #     value: new property value\n  #\n  # Add properties to a statement part like this, where \"b.\" is the label of the target statement part\n  #   - name: ac1_new_prop\n  #     value: new property value\n  #     smt-part: b.\n  #\n  - name: prop_with_ns\n    value: prop with ns\n    ns: https://my_new_namespace\n  - name: prop_with_no_ns\n    value: prop with no ns\n    ns: https://my_added_namespace\n---\n\n---\n\n# ac-1 - \\[Access Control\\] Policy and Procedures\n\n## Control Statement\n\n- \\[a.\\] Develop, document, and disseminate to {{ insert: param, ac-1_prm_1 }}:\n\n  - \\[1.\\]  {{ insert: param, ac-1_prm_2 }} access control policy that:\n\n    - \\[(a)\\] Addresses purpose, scope, roles, responsibilities, management commitment, coordination among organizational entities, and compliance; and\n    - \\[(b)\\] Is consistent with applicable laws, executive orders, directives, regulations, policies, standards, and guidelines; and\n\n  - \\[2.\\] Procedures to facilitate the implementation of the access control policy and the associated access controls;\n\n- \\[b.\\] Designate an {{ insert: param, ac-1_prm_3 }} to manage the development, documentation, and dissemination of the access control policy and procedures; and\n\n- \\[c.\\] Review and update the current access control:\n\n  - \\[1.\\] Policy {{ insert: param, ac-1_prm_4 }} and following {{ insert: param, ac-1_prm_5 }}; and\n  - \\[2.\\] Procedures {{ insert: param, ac-1_prm_6 }} and following {{ insert: param, ac-1_prm_7 }}.\n\n## Control guidance\n\nAccess control policy and procedures address the controls in the AC family that are implemented within systems and organizations. The risk management strategy is an important factor in establishing such policies and procedures. Policies and procedures contribute to security and privacy assurance. Therefore, it is important that security and privacy programs collaborate on the development of access control policy and procedures. Security and privacy program policies and procedures at the organization level are preferable, in general, and may obviate the need for mission- or system-specific policies and procedures. The policy can be included as part of the general security and privacy policy or be represented by multiple policies reflecting the complex nature of organizations. Procedures can be established for security and privacy programs, for mission or business processes, and for systems, if needed. Procedures describe how the policies or controls are implemented and can be directed at the individual or role that is the object of the procedure. Procedures can be documented in system security and privacy plans or in one or more separate documents. Events that may precipitate an update to access control policy and procedures include assessment or audit findings, security incidents or breaches, or changes in laws, executive orders, directives, regulations, policies, standards, and guidelines. Simply restating controls does not constitute an organizational policy or procedure.\n\n# Editable Content\n\n&lt;!-- Make additions and edits below --&gt;\n&lt;!-- The above represents the contents of the control as received by the profile, prior to additions. --&gt;\n&lt;!-- If the profile makes additions to the control, they will appear below. --&gt;\n&lt;!-- The above markdown may not be edited but you may edit the content below, and/or introduce new additions to be made by the profile. --&gt;\n&lt;!-- If there is a yaml header at the top, parameter values may be edited. Use --set-parameters to incorporate the changes during assembly. --&gt;\n&lt;!-- The content here will then replace what is in the profile for this control, after running profile-assemble. --&gt;\n&lt;!-- The added parts in the profile for this control are below.  You may edit them and/or add new ones. --&gt;\n&lt;!-- Each addition must have a heading either of the form ## Control my_addition_name --&gt;\n&lt;!-- or ## Part a. (where the a. refers to one of the control statement labels.) --&gt;\n&lt;!-- \"## Control\" parts are new parts added after the statement part. --&gt;\n&lt;!-- \"## Part\" parts are new subparts added into the existing top-level statement part with that label. --&gt;\n&lt;!-- Subparts may be added with nested hash levels of the form ### My Subpart Name --&gt;\n&lt;!-- underneath the parent ## Control or ## Part being added --&gt;\n&lt;!-- See https://ibm.github.io/compliance-trestle/tutorials/ssp_profile_catalog_authoring/ssp_profile_catalog_authoring for guidance. --&gt;\n\n## Control Implementation Guidance\n\nDo it carefully.\n\n## Control Expected Evidence\n\nDetailed logs.\n\n## Control Needed Extra\n\nAdd prose here for required Section: Needed Extra\n\n## Control A Guidance\n\nControl level guidance\n\n### A Subpart\n\nA subpart prose\n\n#### A Subsubpart\n\nA subsubpart prose\n\n### B Subpart\n\nB subpart prose\n\n## Part a.\n\n### Subpart of top level Part a. of the control\n\nProse added as a sub-part to Part a. of the control\n</code></pre> <p>In the above markdown example, the fixed, uneditable parts of the control are output first (after the header, which can be edited), followed by a separate section marked, <code>Editable Content</code>.  And below the editable content are the individual <code>Adds</code> that the profile makes, with each one marked by a header of the form, <code>## Control guidance_name</code> or <code>## Part statement_part_label</code> followed by named subparts.  You may edit the editable content and you may add new Control guidance headers and statement sub-parts with your own new content. (Please refer to Markdown Specifications for Editable Content section below to learn more on which headers are valid in Trestle.) Then the command, <code>trestle author profile-assemble --name original_profile --markdown markdown_dir --output new_profile</code> will create a new OSCAL profile based on the original profile (specified) and the editable content in each control.</p> <p>It's important to distinguish <code>## Control My New Guidance</code> from <code>## Part a.</code>.  Parts added with <code>## Control</code> will be new parts in the control added after the control statement, along with any subparts indicated by lower hash levels in that section.  In contrast, parts added with e.g. <code>## Part c.</code> will be added by-id to the top level part in the control statement with label <code>c.</code>.  Thus \"My New Guidance\" is the title the user is assigning to a completely new part, while <code>c.</code> refers to a label corresponding the the desired control statement part.</p> <p>When new part names are created in the markdown file the title is captured along with its capitalization and spaces, but the corresponding part name will be converted to snake case by default.  However, the user may indicate a specific mapping of the long title of the part to its actual part name by providing an entry in the <code>sections</code> provided during <code>profile-assemble</code>.  For example, in the above, the <code>Needed Extra</code> part would be assigned the name <code>needed_extra</code> but if you had a section entry such as <code>n_ex:Needed Extra</code> the name <code>n_ex</code> would be assigned in the assembled json profile, so that if you used that same section entry <code>trestle</code> would know to replace the <code>n_ex</code> part with <code>Needed Extra</code> in any generated markdown.</p> <p>In a cyclic operation of <code>profile generate-edit-assemble</code> you would simply be re-writing from and to the same json profile, in which case the <code>--name</code> and <code>--output</code> are the same file.  For this reason the default value for <code>--name</code> is the given output file name specified by <code>--output</code> and you can just use <code>trestle author profile-assemble --markdown profile_md --output my_profile</code>.  This will assemble the markdown profile contents in directory <code>profile_md</code> into a json profile named <code>my_profile</code> but it will first use the existing <code>my_profile</code> json file as the parent profile and incorporate changes (due to user edits) in the markdown version of the profile.  Unlike <code>catalog-assemble</code> there must always be a parent json profile to reference during assemble, but like <code>catalog-assemble</code> an explicit value for <code>--name</code> is only needed if the parent file is different from the assembled output file.</p> <p>It's important to note that these operations only apply to the <code>Adds</code> and <code>SetParameters</code> in the profile itself - and nothing upstream of the profile is affected.  Nor is anything else in the original profile lost or altered.  In the example above, the section, <code>## Control Implementation Guidance</code> was added by editing the generated control - and after <code>profile-assemble</code> it ended up as new guidance in the assembled profile.</p> <p>As in the other commands, <code>profile-generate</code> allows specification of a yaml header with <code>--yaml-header</code>, support of the <code>--overwrite-header-values</code> flag and <code>--force-overwrite</code>.   Also, during assembly with <code>profile-assemble</code> the <code>--set-parameters</code> flag will set parameters in the profile for the control based on the header in the control markdown file.  But unlike with <code>catalog-assemble</code>, only those parameter values marked <code>profile-values</code> will be part of the assembled profile's SetParams when you assemble with the <code>--set-parameters</code> flag.  For each parameter, the \"incoming\" values for the parameters prior to any changes made by the profile are listed as <code>values:</code> and any pending changes made by the profile are listed as <code>profile-values:</code>.  If you don't use the <code>--set-parameters</code> flag then all the original SetParameters in the profile will be retained in the new, assembled profile.  But if you do set that flag, then only the header parameters with <code>profile-values:</code> will be added as SetParameters.  This lets you see all the incoming values for parameters along with any changes made by the current profile, and you can modify, add, or remove parameter settings as desired in the new profile.</p> <p>The <code>x-trestle-add-props</code> key of the yaml header allows addition of properties to the SetParameters of the profile, comprising <code>name</code>, <code>value</code>, and optionally a namespace <code>ns</code> value.  The properties may be added at the control level, or attached to a top level statment part by adding a value, <code>smt-part</code> with value <code>a.</code>, <code>b.</code> or any other label for one of the top level statement parts.</p> <p>For convenience, the <code>x-trestle-global</code> key of the yaml header contains the <code>profile-title</code> of the profile used to generate the markdown.</p> <p>Keep in mind that the header in the <code>profile-</code> tools corresponds to the <code>SetParameters</code> in the profile - and not simply the <code>Parameters</code> in the control.  For convenience the current incoming values of the control parameters, as set by any upstream profiles, are shown as <code>values</code> - but anything else associated with a parameter, such as <code>profile-values</code>, <code>label</code>, <code>choice</code> will be added to the profile's <code>SetParameters</code> during <code>profile-assemble</code> (if you use the <code>--set-parameters</code> flag.)  So entries should be set there only if you want the profile to enforce those entries as <code>SetParameters</code>.</p> <p>As with <code>catalog-assemble</code> described above, a new file is written out only if there are changes to the model relative to an existing output file, and during generate, <code>--force-overwrite</code> will first erase any existing markdown so that fresh markdown is created.</p> Use of Sections in profile-generate and profile-assemble <p>The addition of guidance sections in the <code>profile</code> tools requires special handling because the corresponding parts have both a name and a title, where the name is a short form used as an id in the json schema, while the title is the readable form intended for final presentation.  An example is <code>ImplGuidance</code> vs. <code>Implementation Guidance</code>.  The trestle authoring tools strive to make the markdown as readable as possible, therefore the headings for sections use the title - which means somehow there is a need for a mapping from the short name to the long title for each section.  This mapping is provided in several ways:  During <code>profile-generate</code> you may provide a <code>--sections \"ImplGuidance:Implementation Guidance,ExpEvidence:Expected Evidence\"</code> option that would provide title values for <code>ImplGuidance</code> and <code>ExpEvidence</code>.  This dictionary mapping is then inserted into the yaml header of each control's markdown.  You may also add this mapping directly to a yaml file that is passed in during <code>profile-generate</code>, which is preferable if the list of sections is long.  The sections should be entered in the yaml header in a section titled, <code>x-trestle-sections</code>.</p> <p>There is also a <code>--required-sections</code> option during both <code>profile-generate</code> and <code>profile-assemble</code>.  This option expects a list of sections as comma-separated short names, e.g. <code>--required-sections \"ImplGuidance,ExpEvidence\"</code>.  During <code>profile-generate</code> any required sections will have in the markdown a prompt created for guidance prose to be entered.  And during <code>profile-assemble</code> if required sections are specified, those sections must have prose filled in or it will fail with error.</p> <p>Finally, <code>profile-assemble</code> also has an <code>--allowed-sections</code> option that restricts any added guidance to only those allowed sections - and if disallowed sections are present it will fail with error.  If <code>--allowed-sections</code> is not specified then any sections found in the markdown will be added to the assembled profile.</p> <p>Note that these section options are all optional and there isn't a need to provide this form of restriction and enforcement.  But in order to have such sections read properly and mapped to the intended part names, a mapping must be provided in one of the ways described above.  And for certain workflows, if the allowed and required sections are specified by a command that is run as an action outside the user's control, it allows restriction of what changes can or must be made to a profile in terms of added guidance.</p> <p>(Note that the single quotes are required on Unix-like systems, but on Windows they are only needed if the contained string includes spaces, in which case double quotes should be used.)</p> Markdown Specifications for Editable Content. <p>For the ease of editing markdown in Github, Trestle's markdown parser follows Github Flavoured Markdown (GFM) specifications and therefore only certain Control headers will be parsed and added to the control.</p> <p>A valid control header in Trestle is the header that is correctly displayed as such when reading or previewing the edited markdown on Github website.</p> <p>In GFM, headers are considered to be any line of text that has any number of <code>#</code> symbols at the beginning. For example those are all valid headers and will be treated as such by Github:</p> <pre><code># Valid header\n## Valid header \n##### Valid header\n# Valid &lt;ins&gt; header &lt;/ins&gt; \n# Valid header &lt;!-- some comment here --&gt;\n</code></pre> <p>The headers above are valid Control headers and will be added to the control. However, there are multiple exceptions where the header will not be displayed. The header will not be displayed correctly if it is:</p> <ol> <li>Written in the HTML comments <code></code> or tags <code>&lt;ins&gt; # not a header &lt;/ins&gt;</code> as well as multi-line comments:    <pre><code>&lt;!--\n# not a header\n--&gt;\n</code></pre>    or multi-line HTML blocks:    <pre><code>&lt;dl&gt; # not a header\n# not a header\n  &lt;dt&gt;# not a header&lt;/dt&gt;\n&lt;/dl&gt;\n</code></pre></li> <li>Written in the single-line <code># not a header</code> and multi-line code blocks:    <pre><code># not a header \n</code></pre></li> <li>Written in the links <code>[# not a header](url)</code></li> <li>Trestle will also not support headers inside the blockquotes <code>&gt; # not a header</code></li> </ol> <p>In all cases above Trestle markdown parser will skip such headers and it will be not added to the control.</p> trestle author profile-resolve <p>The <code>trestle author profile-resolve</code> command is different from the <code>generate/assemble</code> commands because it doesn't involve markdown and instead it takes an input profile and creates the corresponding resolved profile catalog in <code>JSON</code> format.  In addition, it has several options for how parameters are represented in prose of the controls, and whether or not those values are substituted.</p> <p>As an example, the prose in the statement for control <code>AC-1</code> is:</p> <p><code>Develops, documents, and disseminates to {{ insert: param, ac-1_prm_1 }}:</code></p> <p>The parameter <code>ac-1_prm_1</code> has a label: <code>organization-defined personnel or roles</code> and it may or may not have a value assigned by the profile being resolved.  Suppose it has been assigned the value, <code>my prm 1 value</code>.  In that case we can either leave the prose as-is (with the parameter in \"moustache\" form) in the resolved catalog, or we can substitute the value, or we can substitute the descriptive label.  trestle supports all these options, along with an optional prefix to specify whether a value has been assigned or not - typically using the name of the organization responsible.</p> <p>The <code>--show-value -sv</code> option will cause the value for the parameter to be substituted in the prose if it is available - otherwise the list of selection options if it has any, or simply the label prose if it has no options.</p> <p>The <code>--value-assigned-prefix -vap</code> option adds a prefix to the value if the value is being assigned by the profile, and the <code>--value-not-assigned-prefix -vnap</code> will assign a prefix to parameters that do not have values assigned, along with the descriptive parameter label.</p> <p>Finally, the <code>--bracket-format -bf</code> option specifies how the parameter representation will be wrapped in braces.  The specification is done by placing characters around a single <code>.</code> symbol representing the parameter string, e.g. <code>[.]</code> will place square brackets around the parameter.</p> <p>Note that these options that specify how the parameter is represented all require <code>--show-value</code> to be True, otherwise the raw prose with the moustache is produced.</p> <p>As an example, if we use options</p> <p><code>trestle author profile-resolve -n my_profile -o my_resolved_catalog -sv -bf [.] -vap \"ACME Assignment:\" -vnap \"Assignment:\"</code></p> <p>the above prose would become:</p> <p><code>Develops, documents, and disseminates to [ACME Assignment: my prm 1 value]:</code></p> <p>(Note that you need appropriate use of quotation marks in the command for any strings that include spaces or special characters.)</p> <p>And if the parameter did not have a value assigned the result would be:</p> <p><code>Develops, documents, and disseminates to [Assignment: organization-defined personell or roles]:</code></p> <p>Finally, if the parameter already had a value specified in the catalog, the value would be shown by itself in braces:</p> <p><code>Develops, documents, and disseminates to [value in catalog]:</code></p> <p>Similar substitution happens when a parameter has choices that themselves reference a parameter, such as:</p> <pre><code>\"id\": \"ac-4.4_prm_1\",\n\"select\": {\n  \"how-many\": \"one-or-more\",\n  \"choice\": [\n    \"decrypting the information\",\n    \"blocking the flow of the encrypted information\",\n    \"terminating communications sessions attempting to pass encrypted information\",\n    \" {{ insert: param, ac-4.4_prm_2 }} \"\n  ]\n</code></pre> <p>If the statement prose for AC-4.4 is:</p> <p><code>The information system prevents encrypted information from bypassing content-checking mechanisms by {{ insert: param, ac-4.4_prm_1 }}.</code></p> <p>and if a value <code>pulling the plug</code> has been assigned to ac-4.4_prm_2, the prose will be:</p> <p><code>The information system prevents encrypted information from bypassing content-checking mechanisms by [Selection (one or more): decrypting the information, blocking the flow of the encrypted information, terminating the communications sessions attempting to pass encrypted information, [ACME Assignment: pulling the plug]].</code></p> <p>There is a separate option from <code>--show-values</code> that will instead show only the descriptive labels for the parameters - again with an optional prefix.  The options are <code>--show-labels -sl</code> and <code>--label-prefix -lp</code>.  Note that there is no need for \"assigned\" or \"not assigned\" because no values are being shown - just the labels.</p> <p>If we resolve the profile with options <code>--show-labels --label-prefix \"Label:\" --bracket-format [.]</code> the resulting prose from earlier would be:</p> <p><code>Develops, documents, and disseminates to [Label: organization-defined personnel or roles]:</code></p> <p>and any value present for the parameter would be ignored.</p> <p>Similar options apply to the <code>jinja</code> authoring commands.</p> trestle author component-generate and component-assemble <p>The <code>trestle author component-generate</code> command takes a JSON ComponentDefinition file and creates markdown for its controls in separate directories for each of the DefinedComponents in the file.  This allows specifying the implementation response and status for each component separately in separate markdown files for a control.  In addition, the markdown captures Rules in the control that specify descriptions and parameter values that apply to the expected responses.</p> <p>The command has few options compared to other author commands and only requires specifying <code>--name</code> and <code>--output</code> for the ComponentDefinition and output markdown directory, respectively.</p> <p>Here is an example of the generated markdown for the component <code>OSCO</code> in the ComponentDefinition file.  Note that this file will be under the subdirectory <code>OSCO/source_name</code> of the specified output directory - and any other DefinedComponents will have corresponding subdirectories level with the <code>OSCO</code> one.  Here <code>source_name</code> refers to the name of the profile or catalog in the ComponentDefinition that is the source for this control.  The control markdown files are written into directories split by both component name and source name.  If the source refers to a general uri and not a named profile or catalog in the trestle directory, then names such as <code>source_001</code> and <code>source_002</code> are assigned.  The actual source title can be found in the yaml header of any of the control markdown files.</p> Example of control markdown after component-generate <pre><code>---\nx-trestle-comp-def-rules:\n  comp_aa:\n    - name: top_shared_rule_1\n      description: top shared rule 1 in aa\n    - name: comp_rule_aa_1\n      description: comp rule aa 1\nx-trestle-rules-params:\n  comp_aa:\n    - name: shared_param_1\n      description: shared param 1 in aa\n      options: '[\"shared_param_1_aa_opt_1\", \"shared_param_1_aa_opt_2\"]'\n      rule-id: top_shared_rule_1\nx-trestle-comp-def-rules-param-vals:\n  # You may set new values for rule parameters by adding\n  #\n  # component-values:\n  #   - value 1\n  #   - value 2\n  #\n  # below a section of values:\n  # The values list refers to the values as set by the components, and the component-values are the new values\n  # to be placed in SetParameters of the component definition.\n  #\n  comp_aa:\n    - name: shared_param_1\n      values:\n        - shared_param_1_aa_opt_1\nx-trestle-param-values:\n  ac-1_prm_1:\n    - prof_aa val 1\n  ac-1_prm_2:\n  ac-1_prm_3:\n  ac-1_prm_4:\n  ac-1_prm_5:\n  ac-1_prm_6:\n  ac-1_prm_7:\nx-trestle-global:\n  profile:\n    title: comp prof aa\n    href: trestle://profiles/comp_prof_aa/profile.json\n  sort-id: ac-01\n---\n\n# ac-1 - \\[Access Control\\] Policy and Procedures\n\n## Control Statement\n\nThe organization:\n\n- \\[a.\\] Develop, document, and disseminate to prof_aa val 1:\n\n  - \\[1.\\] Organization-level; Mission/business process-level; System-level access control policy that:\n\n    - \\[(a)\\] Addresses purpose, scope, roles, responsibilities, management commitment, coordination among organizational entities, and compliance; and\n    - \\[(b)\\] Is consistent with applicable laws, executive orders, directives, regulations, policies, standards, and guidelines; and\n\n  - \\[2.\\] Procedures to facilitate the implementation of the access control policy and the associated access controls;\n\n- \\[b.\\] Designate an organization-defined official to manage the development, documentation, and dissemination of the access control policy and procedures; and\n\n- \\[c.\\] Review and update the current access control:\n\n  - \\[1.\\] Policy organization-defined frequency and following organization-defined events; and\n  - \\[2.\\] Procedures organization-defined frequency and following organization-defined events.\n\n## Control guidance\n\nAccess control policy and procedures address the controls in the AC family that are implemented within systems and organizations. The risk management strategy is an important factor in establishing such policies and procedures. Policies and procedures contribute to security and privacy assurance. Therefore, it is important that security and privacy programs collaborate on the development of access control policy and procedures. Security and privacy program policies and procedures at the organization level are preferable, in general, and may obviate the need for mission- or system-specific policies and procedures. The policy can be included as part of the general security and privacy policy or be represented by multiple policies reflecting the complex nature of organizations. Procedures can be established for security and privacy programs, for mission or business processes, and for systems, if needed. Procedures describe how the policies or controls are implemented and can be directed at the individual or role that is the object of the procedure. Procedures can be documented in system security and privacy plans or in one or more separate documents. Events that may precipitate an update to access control policy and procedures include assessment or audit findings, security incidents or breaches, or changes in laws, executive orders, directives, regulations, policies, standards, and guidelines. Simply restating controls does not constitute an organizational policy or procedure.\n\n______________________________________________________________________\n\n## What is the solution and how is it implemented?\n\n&lt;!-- For implementation status enter one of: implemented, partial, planned, alternative, not-applicable --&gt;\n\n&lt;!-- Note that the list of rules under ### Rules: is read-only and changes will not be captured after assembly to JSON --&gt;\n\nimp req prose for ac-1 from comp aa\n\n### Rules:\n\n- top_shared_rule_1\n\n### Implementation Status: implemented\n\n______________________________________________________________________\n\n## Implementation for part a.\n\nstatement prose for part a. from comp aa\n\n### Rules:\n\n- comp_rule_aa_1\n\n### Implementation Status: partial\n\n______________________________________________________________________\n</code></pre> <p>There is no direct way to specify rules in the ComponentDefinition, so they are specified via properties as shown here:</p> Representation of rules in the props of a ComponentDefinition <pre><code>[\n{\n\"name\": \"Rule_Id\",\n\"ns\": \"http://comp_ns\",\n\"value\": \"comp_rule_aa_1\",\n\"class\": \"Rule_Id\",\n\"remarks\": \"rule_2\"\n},\n{\n\"name\": \"Rule_Description\",\n\"ns\": \"http://comp_ns\",\n\"value\": \"comp rule aa 1\",\n\"remarks\": \"rule_2\"\n},\n{\n\"name\": \"Rule_Id\",\n\"ns\": \"http://comp_ns\",\n\"value\": \"comp_rule_aa_2\",\n\"class\": \"Rule_Id\",\n\"remarks\": \"rule_3\"\n},\n{\n\"name\": \"Rule_Description\",\n\"ns\": \"http://comp_ns\",\n\"value\": \"comp rule aa 2\",\n\"class\": \"Rule_Description\",\n\"remarks\": \"rule_3\"\n},\n{\n\"name\": \"Parameter_Id\",\n\"ns\": \"http://comp_ns\",\n\"value\": \"shared_param_1\",\n\"class\": \"Parameter_Id\",\n\"remarks\": \"rule_1\"\n},\n{\n\"name\": \"Parameter_Description\",\n\"ns\": \"http://comp_ns\",\n\"value\": \"shared param 1 in aa\",\n\"class\": \"Parameter_Description\",\n\"remarks\": \"rule_1\"\n},\n{\n\"name\": \"Parameter_Value_Alternatives\",\n\"ns\": \"http://comp_ns\",\n\"value\": \"[\\\"shared_param_1_aa_opt_1\\\", \\\"shared_param_1_aa_opt_2\\\"]\",\n\"class\": \"Parameter_Value_Alternatives\",\n\"remarks\": \"rule_1\"\n}\n],\n\"set-parameters\": [\n{\n\"param-id\": \"shared_param_1\",\n\"values\": [\n\"shared_param_1_aa_opt_1\"\n],\n\"remarks\": \"set shared param aa 1\"\n}\n]\n</code></pre> <p>In this scheme the rules have a <code>Rule_Id</code> (e.g. <code>comp_rule_aa_1</code> in this example) and an associated tag (<code>rule_2</code>) in the <code>remarks</code> section that binds the name to the description: <code>Rule_Description</code>=<code>comp rule aa 1</code>.  In addition, rules may be associated with parameters specified here with <code>Parameter_id</code>=<code>shared_param_1</code>, <code>Parameter_Description</code>=<code>shared param 1 in aa</code>, and <code>Parameter_Value_Alternatives</code>=<code>[\\\"shared_param_1_aa_opt_1\\\", \\\"shared_param_1_aa_opt_2\\\"]</code>.  <code>Parameter_Value_Alternatives</code> corresponds to possible Choices for the parameter value.</p> <p>Also shown in this JSON excerpt is a normal set-parameter used to set the value of a parameter associated with a rule id.  Thus the setting of the parameter follows the normal OSCAL schema for setting a parameter value, while the specification of the parameter and its options is specified via linked properties.</p> <p>The markdown header lists all the rules that apply to this control, along with their descriptions, and for each implementation response, the rules that apply to it are shown.  The association of an ImplementedRequirement with a rule is again done with properties as shown here:</p> Linking of ImplementedRequirement to a rule <pre><code>{\n\"implemented-requirements\": [\n{\n\"uuid\": \"ca5ea4c5-ba51-4b1d-932a-5606891b7500\",\n\"control-id\": \"ac-1\",\n\"description\": \"imp req prose for ac-1 from comp aa\",\n\"props\": [\n{\n\"name\": \"Rule_Id\",\n\"value\": \"top_shared_rule_1\"\n},\n{\n\"name\": \"implementation-status\",\n\"value\": \"implemented\"\n}\n]\n}\n]\n}\n</code></pre> <p>The values for rule parameters are specified using the normal <code>SetParameter</code> mechanism in the ControlImplementation, but it's important to note that there are two different types of <code>SetParameter</code>: Those that apply to the normal parameters of the control, and those that apply strictly to the rules.</p> <p>Note that markdown for a control is only created if there are rules associated with the control, and within the markdown the only parts written out that prompt for responses are parts that have rules assigned.  Thus the output markdown directory may be highly pruned of both controls and groups of controls if only some controls have rules associated.</p> <p>In addition, the rules should be regarded as read-only from the editing perspective, and you cannot change the rules associated with a control or its parts.  But you may edit the rule parameter values as described in the comments of the markdown file under <code>x-trestle-comp-def-rules-param-vals</code>.  You may also edit the prose and implementation status associated with a statement part at the bottom of the markdown file.</p> <p><code>trestle author component-assemble</code></p> <p>The <code>component-assemble</code> command will assemble the markdown into a ComponentDefinition file containing all the DefinedComponents in the markdown, and as usual it can either overwrite the original JSON file or create a new one.  Edits made to the prose, status and rule parameter values in the markdown and header will be captured in the assembled file, but the list of rules attached with each ImplementedRequirement is readonly and new rule associations cannot be made via markdown.</p> trestle author ssp-generate and trestle author ssp-assemble <p>The <code>ssp-generate</code> command creates markdown for an SSP (System Security Plan) from a profile, optional component definitions, and optional yaml header file.  <code>ssp-assemble</code> (described below) can then assemble the markdown files into a single json SSP file.  The profile contains a list of imports that are either a direct reference to a catalog, or an indirect reference via a profile. There may be multiple imports of either type, and referenced profiles may themselves import either catalogs or profiles.  Each profile involved may specify the controls that should be imported, along with any modifications to those controls.  This command internally creates a resolved profile catalog and generates a directory containing a set of markdown files, one for each control in the resolved catalog.  Each markdown file has the optional yaml header embedded at the start of the file.</p> <p>The component definitions specify the components of the SSP, along with metadata associated with rules and status for the implemented requirements.  The rules, rule parameters, and status values are encoded by properties within the components as described above for <code>component-generate</code>.</p> <p>Example usage for creation of the markdown:</p> <p><code>trestle author ssp-generate --profile my_prof --compdefs \"compdef_a,compdef_b\" --yaml /my_yaml_dir/header.yaml --output my_ssp</code></p> <p>In this example the profile and component definitions have previously been imported into the trestle directory.  The profile itself must be in the trestle directory, but the imported catalogs and profiles may be URI's with href's as described below.</p> <p>The generated markdown output will be placed in the trestle subdirectory <code>my_ssp</code> with a subdirectory for each control group.</p> <p>If the imported catalogs or profiles are not at the URI pointed to by the Import href of the profile then the href should be changed using the <code>trestle href</code> command.</p> <p>Similar to <code>catalog-generate</code>, the <code>--yaml</code> and <code>--overwrite-header-values</code> flag may be specified to let the input yaml header overwrite values already specified in the header of the control markdown file. Also, the <code>--force-overwrite</code> option can be used to overwrite markdowns with content from JSON.</p> <p>The resulting files look like this:</p> Example of control markdown after ssp-generate <pre><code>---\nx-trestle-comp-def-rules:\n  comp_aa:\n    - name: top_shared_rule_1\n      description: top shared rule 1 in aa\n    - name: comp_rule_aa_1\n      description: comp rule aa 1\n  comp_ab:\n    - name: top_shared_rule_1\n      description: top shared rule 1 in ab\n    - name: comp_rule_ab_1\n      description: comp rule ab 1\n  comp_ba:\n    - name: top_shared_rule_1\n      description: top shared rule 1 in ba\n  comp_bb:\n    - name: top_shared_rule_1\n      description: top shared rule 1 in bb\nx-trestle-rules-params:\n  comp_aa:\n    - name: shared_param_1\n      description: shared param 1 in aa\n      options: '[\"shared_param_1_aa_opt_1\", \"shared_param_1_aa_opt_2\"]'\n      rule-id: top_shared_rule_1\n  comp_ab:\n    - name: shared_param_1\n      description: shared param 1 in ab\n      options: '[\"shared_param_1_ab_opt_1\", \"shared_param_1_ab_opt_2\"]'\n      rule-id: top_shared_rule_1\n  comp_ba:\n    - name: shared_param_1\n      description: shared param 1 in ba\n      options: '[\"shared_param_1_ba_opt_1\", \"shared_param_1_ba_opt_2\"]'\n      rule-id: top_shared_rule_1\n  comp_bb:\n    - name: shared_param_1\n      description: shared param 1 in bb\n      options: '[\"shared_param_1_bb_opt_1\", \"shared_param_1_bb_opt_2\"]'\n      rule-id: top_shared_rule_1\nx-trestle-comp-def-rules-param-vals:\n  # You may set new values for rule parameters by adding\n  #\n  # ssp-values:\n  #   - value 1\n  #   - value 2\n  #\n  # below a section of values:\n  # The values list refers to the values as set by the components, and the ssp-values are the new values\n  # to be placed in SetParameters of the SSP.\n  #\n  comp_aa:\n    - name: shared_param_1\n      values:\n        - shared_param_1_aa_opt_1\n      ssp-values:\n        - shared_param_1_aa_opt_2\n  comp_ab:\n    - name: shared_param_1\n      values:\n        - shared_param_1_ab_opt_2\nx-trestle-set-params:\n  # You may set values for parameters in the assembled SSP by adding\n  #\n  # ssp-values:\n  #   - value 1\n  #   - value 2\n  #\n  # below a section of values:\n  # The values list refers to the values in the resolved profile catalog, and the ssp-values represent new values\n  # to be placed in SetParameters of the SSP.\n  #\n  ac-1_prm_1:\n    values:\n      - comp_prof val 1\n    display-name: AC-1 (a) (1)\n  ac-1_prm_2:\n    values:\n  ac-1_prm_3:\n    values:\n  ac-1_prm_4:\n    values:\n  ac-1_prm_5:\n    values:\n  ac-1_prm_6:\n    values:\n  ac-1_prm_7:\n    values:\nx-trestle-global:\n  profile:\n    title: comp prof aa\n    href: trestle://profiles/comp_prof/profile.json\n  sort-id: ac-01\n---\n\n# ac-1 - \\[Access Control\\] Policy and Procedures\n\n## Control Statement\n\nThe organization:\n\n- \\[a.\\] Develop, document, and disseminate to [comp_prof val 1]:\n\n  - \\[1.\\] [Organization-level; Mission/business process-level; System-level] access control policy that:\n\n    - \\[(a)\\] Addresses purpose, scope, roles, responsibilities, management commitment, coordination among organizational entities, and compliance; and\n    - \\[(b)\\] Is consistent with applicable laws, executive orders, directives, regulations, policies, standards, and guidelines; and\n\n  - \\[2.\\] Procedures to facilitate the implementation of the access control policy and the associated access controls;\n\n- \\[b.\\] Designate an [organization-defined official] to manage the development, documentation, and dissemination of the access control policy and procedures; and\n\n- \\[c.\\] Review and update the current access control:\n\n  - \\[1.\\] Policy [organization-defined frequency] and following [organization-defined events]; and\n  - \\[2.\\] Procedures [organization-defined frequency] and following [organization-defined events].\n\n## Control guidance\n\nAccess control policy and procedures address the controls in the AC family that are implemented within systems and organizations. The risk management strategy is an important factor in establishing such policies and procedures. Policies and procedures contribute to security and privacy assurance. Therefore, it is important that security and privacy programs collaborate on the development of access control policy and procedures. Security and privacy program policies and procedures at the organization level are preferable, in general, and may obviate the need for mission- or system-specific policies and procedures. The policy can be included as part of the general security and privacy policy or be represented by multiple policies reflecting the complex nature of organizations. Procedures can be established for security and privacy programs, for mission or business processes, and for systems, if needed. Procedures describe how the policies or controls are implemented and can be directed at the individual or role that is the object of the procedure. Procedures can be documented in system security and privacy plans or in one or more separate documents. Events that may precipitate an update to access control policy and procedures include assessment or audit findings, security incidents or breaches, or changes in laws, executive orders, directives, regulations, policies, standards, and guidelines. Simply restating controls does not constitute an organizational policy or procedure.\n\n______________________________________________________________________\n\n## What is the solution and how is it implemented?\n\n&lt;!-- For implementation status enter one of: implemented, partial, planned, alternative, not-applicable --&gt;\n\n&lt;!-- Note that the list of rules under ### Rules: is read-only and changes will not be captured after assembly to JSON --&gt;\n\n### This System\n\n&lt;!-- Add implementation prose for the main This System component for control: ac-1 --&gt;\n\n#### Implementation Status: planned\n\n### comp_aa\n\nimp req prose for ac-1 from comp aa\n\n#### Rules:\n\n- top_shared_rule_1\n\n#### Implementation Status: implemented\n\n### comp_ab\n\n&lt;!-- Add control implementation description here for control: ac-1 --&gt;\n\n#### Rules:\n\n- top_shared_rule_1\n\n#### Implementation Status: implemented\n\n______________________________________________________________________\n\n## Implementation for part a.\n\n### comp_aa\n\nstatement prose for part a. from comp aa\n\n#### Rules:\n\n- comp_rule_aa_1\n\n#### Implementation Status: partial\n\n### comp_ab\n\n&lt;!-- Add control implementation description here for item a. --&gt;\n\n#### Rules:\n\n- comp_rule_ab_1\n\n#### Implementation Status: partial\n\n______________________________________________________________________\n</code></pre> <p>\\ Each label in the ssp is wrapped in <code>\\[ \\]</code> to indicate it comes directly from the label in the control and is not generated by the markdown viewer.  Keep in mind that the actual label is the same but with the <code>\\[ \\]</code> removed.</p> <p>Note that for each statement in the control description there is a corresponding response section in which to provide a detailed response for later inclusion in the final ssp as the control implementation.</p> <p>Also note that the optional final sections are provided, and labeled using the title for the corresponding section.</p> <p>In addition, this is the only control markdown where the moustache (<code>{{}}</code>) items have been replaced by the corresponding parameter values in the final resolved profile catalog, surrounded by brackets, so that the prose corresponds to the final intended control and its implementation.</p> <p>The markdown can have guidance per-component in the control, as shown by the line, <code>### ACME Component</code>.  Any prose directly under a <code>##</code> implementation section will apply to the overall system component, but sections in a sub-header of the form <code>###</code> will only apply to that particular component.</p> <p>After generating the markdown for the resolved profile catalog you may then edit the files and provide text in the sections with <code>Add control implementation...</code> in them.  But do not remove the horizontal rule lines or modify/remove the lines with <code>###</code> in them, corresponding to system components.</p> <p>If you edit the control markdown files you may run <code>ssp-generate</code> again and your edits will not be overwritten.  When writing out the markdown for a control, any existing markdown for that control will be read and the response text for each part will be re-inserted into the new markdown file.  If the new markdown has added parts the original responses will be placed correctly in the new file, but if any part is removed from the source control json file then any corresponding prose will be lost after the next <code>ssp-generate</code>.</p> trestle author ssp-filter <p>Once you have an SSP in the trestle directory you can filter its contents with a profile, list of components, or list of implementation status values by using the command <code>trestle author ssp-filter</code>.  The SSP is assumed to contain a superset of the controls needed by the profile if a profile is specified, and the filter operation will generate a new SSP with only those controls needed by the profile.  If a list of component names is provided, only the specified components will appear in the system implementation of the ssp. If a list of implementation statuses is provided, controls with implementations including those statuses will appear in the control implementation of the ssp.</p> <p>The filter command is invoked as:</p> <p><code>trestle author ssp-filter --name my_ssp --profile my_profile --components comp_a:comp_b --implementation-status \"planned,partial\" --output my_culled_ssp</code></p> <p>The SSP must be present in the trestle workspace and, if filtering by profile, that profile must also be in the trestle workspace. This command will generate a new SSP in the workspace. If the profile makes reference to a control not in the SSP then the routine will fail with an error message.  Similarly, if one of the components is not present in the ssp the routine will also fail. The implementation statuses must be one of the allowed values as defined in the OSCAL SSP JSON format reference. Those include the following: implemented, partial, planned, alternative, and not-applicable. If an invalid value is provided, an error is returned.</p> Summary of options used by the catalog, profile, component and ssp authoring tools. <p>The provided options for the generation and assembly of documents in the ssp workflow is rich and powerful, but can also be confusing.  To help see how they all relate please consult the following diagram showing the required and optional command line arguments for each command.  The checkboxes indicate required and the open circles represent optional.</p> <p>The options shown are fairly consistent across the <code>-generate</code> and <code>-assemble</code> functions, but some clarification may be needed.  For <code>catalog-assemble</code> and <code>profile-assemble</code> you have the option to use an existing json file as a parent model into which new content is inserted - in memory - and the final model may either be written back into that same json file, or a different one - based on <code>--output</code>.  If you just want to keep editing and modifying the same original json file you can specify <code>--name</code> and <code>--output</code> to be the same, original json file.  But you could also direct it to a new json file while still using an original file as the \"parent.\"  A key benefit of referencing an original json file is the resuse of metadata and backmatter - along with everything else separate from the controls.</p> <p><code>ssp-generate</code> is special because it starts with a profile rather than an ssp, whereas <code>catalog-generate</code> and <code>profile-generate</code> both start with a parent model of the same type.  Nonetheless, you still have an option during <code>ssp-assemble</code> to use a given json file as the template into which new content is inserted, and once again you may overwrite that original json file or direct it to a new one using <code>--output</code>.</p> <p></p>"},{"location":"tutorials/ssp_profile_catalog_authoring/ssp_profile_catalog_authoring/#trestle-author-ssp-assemble","title":"<code>trestle author ssp-assemble</code>","text":"<p>After manually edting the markdown and providing the responses for the control implementation requirements, the markdown can be assembled into a single json SSP file with:</p> <p><code>trestle author ssp-assemble --markdown my_ssp --compdefs my_compdef_a,my_compdef_b --output my_json_ssp</code></p> <p>This will assemble the markdown files in the my_ssp directory and create a json SSP with name my_json_ssp in the system-security-plans directory.</p> <p>As indicated for <code>ssp-generate</code>, please do not alter any of the horizontal rule lines or lines indicating the part or control id, e.g. <code>### ACME Component</code>.  You may run <code>ssp-generate</code> and <code>ssp-assemble</code> repeatedly for the same markdown directory, allowing a continuous editing and updating cycle.</p> <p>As with all the <code>assemble</code> tools, you may optionally specify a <code>--name</code> for a corresponding json file into which the updates will be inserted, thereby preserving metadata and other aspects of the model.  The result can overwrite the provided model or get directed to a new model.  And the version may be updated and the uuid's regenerated.  As with the other <code>-assemble</code> tools, if an output file already exists, a new one will only be written if there are changes to the model relative to the existing file.  See <code>catalog-assemble</code> for more details.</p> <p>If you do not specify component-defintions during assembly, the markdown should not refer to any components other than <code>This System</code>.  Thus you may first generate markdown with <code>ssp-generate</code> and no component-definitions specified - and then you may assemble that ssp with <code>ssp-assemble</code> and no component-definitions specified - but only if there are no components other than <code>This System</code> referenced in the markdown.  You may add new component implementation details to the markdown later, but any new components must be defined in a component-defintion file, and that file must be specified when <code>ssp-assemble</code> is run.</p>"},{"location":"tutorials/task.csv-to-oscal-cd/transformation/","title":"Tutorial: Setup for and use of standard format csv-file to OSCAL Component Definition json-file transformer","text":"<p>Here are step by step instructions for setup and transformation of trestle standard format csv-file into OSCAL Component Definition json-file using the compliance-trestle tool.</p>"},{"location":"tutorials/task.csv-to-oscal-cd/transformation/#objective","title":"Objective","text":"<p>How to transform trestle standard format csv-file into a <code>component-definition.json</code> file.</p> <p>There are 2 short steps shown below. The first is a one-time check/set-up of your environment. The second is a one-command transformation from <code>.csv</code> to <code>component-definition.json</code>.</p> Table: expected .csv content <p>The below table represents the expectations of trestle task <code>csv-to-oscal-cd</code> for the contents of the input csv-file for synthesis of the output OSCAL Component Definition json-file.</p> <p><code>Column Name</code> is the name of the expected column in the input csv-file. Any additional columns not identified here, for example foobar, are also extracted and placed into the output json-file as component.control-implementation.prop[\"foobar\"].</p> <p><code>Component Definition Locale</code> is the <code>path</code> within the output json-file into witch the value is stashed.</p> Column Name Value Type Specification Value Description Component Definition Locale Example Value   Rule_Id String required A textual label that uniquely identifies a policy (desired state) that can be used to reference it elsewhere in this or other documents. component.control-implementation.prop[\"Rule_Id\"] password_policy_min_length_characters   Rule_Description String required A description of the policy (desired state) including information about its purpose and scope. component.control-implementation.prop[\"Rule_Description\"] Ensure password policy requires minimum length of 12 characters   Profile_Reference_URL String required A URL reference to the source catalog or profile for which this component is implementing controls for. A profile designates a selection and configuration of controls from one or more catalogs component.control-implementation.source https://github.com/usnistgov/oscal-content/blob/main/nist.gov/SP800-53/rev5/json/NIST_SP-800-53_rev5_HIGH-baseline_profile.json   Profile_Description String required A description of the profile. component.control-implementation.description NIST Special Publication 800-53 Revision 5 HIGH IMPACT BASELINE   Component_Type String required A category describing the purpose of the component. component.type Validation   Control_Mappings String List (blank separated) required A list of textual labels that uniquely identify the controls or statements that the component implements. component.control-implementation.implemented-requirement.statement.statement-id*and*component.control-implementation.implemented-requirement.control-id ia-5.1_smt.a ia-5.1   Resource String required A human readable name for the component. component.title Compliance Center   Parameter_Id String optional A textual label that uniquely identifies the parameter associated with that policy (desired state) or controls implemented by the policy (desired state).   A description of the parameter including the purpose and use of the parameter. component.control-implementation.prop[\"Parameter_Id\"]*and*component.control-implementation.set-parameter.param-id minimum_password_length   Parameter_Description String optional A description of the parameter including the purpose and use of the parameter. component.control-implementation.prop[\"Parameter_Description\"] Minimum Password   Parameter_Default_Value String optional A value recommended in this profile for the parameter of the control or policy (desired state). component.control-implementation.set-parameter.values 12   Parameter_Value_Alternatives String List (blank separated) optional ONLY for the policy (desired state) parameters: A value or set of values the parameter can take. component.control-implementation.prop[\"Parameter_Value_Alternatives\"] 12 8   Check_Id String optional A textual label that uniquely identifies a check of the policy (desired state) that can be used to reference it elsewhere in this or other documents. component.control-implementation.prop[\"Check_Id\"] check_password_policy_min_length_characters   Check_Description String optional A description of the check of the policy (desired state) including the method (interview or examine or test) and procedure details. component.control-implementation.prop[\"Check_Description\"] Check whether password policy requires minimum length of 12 characters   Fetcher String optional A textual label that uniquely identifies a collector of the actual state (evidence) associated with the policy (desired state) that can be used to reference it elsewhere in this or other documents. component.control-implementation.prop[\"Fetcher\"] fetch_password_policy_min_length_characters   Fetcher_Description String optional A description of the collector of the actual state (evidence) associated with the policy (desired state) including the method (interview or examine or API) and questionaire component.control-implementation.prop[\"Fetcher_Description\"] Fetch whether password policy requires minimum length of 12 characters   Resource_Instance_Type String optional A textual label that uniquely identifies a resource (component) type from the resource instance id. This text is part of all instance ids of a particular resource at runtime. For example the text 'db2' is part of all instance ids of resource DB2. component.control-implementation.prop[\"Resource_Instance_Type\"] DB2"},{"location":"tutorials/task.csv-to-oscal-cd/transformation/#step-1-install-trestle-in-a-python-virtual-environment","title":"Step 1: Install trestle in a Python virtual environment","text":"<p>Follow the instructions here to install trestle in a virtual environment.</p>"},{"location":"tutorials/task.csv-to-oscal-cd/transformation/#step-2-transform-profile-data-cis-benchmarks","title":"Step 2: Transform profile data (CIS benchmarks)","text":"<p>Linux, Mac</p> Windows <p>Make these changes:</p> <ul> <li>use backslashes `\\` for file paths <li>use `md` instead of mkdir -p <li>put the url in double quotes for `curl` <li>use `more` instead of cat </li> </li> </li> </li> </ul> <ul> <li>Navigate to trestle workspace.</li> </ul> <pre><code>(venv.trestle)$ cd trestle.workspace\n</code></pre> <ul> <li>View configuration information.</li> </ul> <pre><code>(venv.trestle)$ trestle task csv-to-oscal-cd -i\ntrestle.core.commands.task:101 WARNING: Config file was not configured with the appropriate section for the task: \"[task.csv-to-oscal-cd]\"\nHelp information for csv-to-oscal-cd task.\n\nPurpose: From csv produce OSCAL component_definition file.\n\n\nConfiguration flags sit under [task.csv-to-oscal-cd]:\n  title             = (required) the component definition title.\n  version           = (required) the component definition version.\n  csv-file          = (required) the path of the csv file.\n  required columns:   Rule_Id\n                      Rule_Description\n                      Profile_Reference_URL\n                      Profile_Description\n                      Component_Type\n                      Control_Mappings\n                      Resource\n  optional columns:   Parameter_Id\n                      Parameter_Description\n                      Parameter_Default_Value\n                      Parameter_Value_Alternatives\n                      Check_Id\n                      Check_Description\n                      Fetcher\n                      Fetcher_Description\n                      Resource_Instance_Type\n  output-dir        = (required) the path of the output directory for synthesized OSCAL .json files.\n  namespace         = (optional) the namespace for properties, e.g. https://ibm.github.io/compliance-trestle/schemas/oscal/cd\n  user-namespace    = (optional) the user-namespace for properties, e.g. https://ibm.github.io/compliance-trestle/schemas/oscal/cd/user-defined\n  class.column-name = (optional) the class to associate with the specified column name, e.g. class.Rule_Id = scc_class\n  output-overwrite  = (optional) true [default] or false; replace existing output when true.\n</code></pre> <ul> <li>Create data folder.</li> </ul> <pre><code>(venv.trestle)$ mkdir -p adjunct-data\n</code></pre> <ul> <li>Fetch sample csv-file.</li> </ul> <pre><code>(venv.trestle)$ curl 'https://raw.githubusercontent.com/IBM/compliance-trestle/main/docs/tutorials/task.csv-to-oscal-cd/ocp4-sample-input.csv' &gt; adjunct-data/ocp4-sample-input.csv\n</code></pre> <ul> <li>Fetch trestle task file.</li> </ul> <pre><code>(venv.trestle)$ curl 'https://raw.githubusercontent.com/IBM/compliance-trestle/main/docs/tutorials/task.csv-to-oscal-cd/demo-csv-to-oscal-cd.config' &gt; adjunct-data/task-files/demo-csv-to-oscal-cd.config\n</code></pre> demo-csv-to-oscal-cd.config <pre><code>[task.csv-to-oscal-cd]\n\ncsv-file = adjunct-data/ocp4-sample-input.csv\noutput-dir = component-definitions/ocp4-sample\ntitle = ocp4-sample\nversion = 1.0\n</code></pre> <ul> <li>Perform and validate the transform.</li> </ul> <pre><code>(venv.trestle)$ trestle task csv-to-oscal-cd -c demo-csv-to-oscal-cd.config \ninput: adjunct-data/ocp4-sample-input.csv\noutput: component-definitions/ocp4-sample/component-definition.json\nTask: csv-to-oscal-cd executed successfully.\n</code></pre> <ul> <li>View the generated OSCAL.</li> </ul> <pre><code>(venv.trestle)$ component-definitions/ocp4-sample/component-definition.json\n</code></pre> component-definition.json <pre><code>{\n  \"component-definition\": {\n    \"uuid\": \"83cc8984-b00a-4799-885c-60b689efebd0\",\n    \"metadata\": {\n      \"title\": \"ocp4-sample\",\n      \"last-modified\": \"2022-11-18T17:06:49+00:00\",\n      \"version\": \"1.0\",\n      \"oscal-version\": \"1.0.2\"\n    },\n    \"components\": [\n      {\n        \"uuid\": \"c0080494-186a-421d-9afd-f51e0359cbd8\",\n        \"type\": \"Service\",\n        \"title\": \"OSCO\",\n        \"description\": \"\",\n        \"control-implementations\": [\n          {\n            \"uuid\": \"43a69f86-a3ad-40fa-ada6-2f988b951728\",\n            \"source\": \"https://github.com/ComplianceAsCode/content/blob/master/products/ocp4/profiles/cis.profile\",\n            \"description\": \"ocp4\",\n            \"props\": [\n              {\n                \"name\": \"Rule_Id\",\n                \"value\": \"content_rule_api_server_anonymous_auth\",\n                \"remarks\": \"rule_set_0\"\n              },\n              {\n                \"name\": \"Rule_Description\",\n                \"value\": \"Ensure that the --anonymous-auth argument is set to false\",\n                \"remarks\": \"rule_set_0\"\n              },\n              {\n                \"name\": \"Check_Id\",\n                \"value\": \"xccdf_org.ssgproject.content_rule_api_server_anonymous_auth\",\n                \"remarks\": \"rule_set_0\"\n              },\n              {\n                \"name\": \"Check_Description\",\n                \"value\": \"Ensure that the --anonymous-auth argument is set to false\",\n                \"remarks\": \"rule_set_0\"\n              },\n              {\n                \"name\": \"Rule_Id\",\n                \"value\": \"content_rule_api_server_basic_auth\",\n                \"remarks\": \"rule_set_1\"\n              },\n              {\n                \"name\": \"Rule_Description\",\n                \"value\": \"Ensure that the --basic-auth-file argument is not set\",\n                \"remarks\": \"rule_set_1\"\n              },\n              {\n                \"name\": \"Check_Id\",\n                \"value\": \"xccdf_org.ssgproject.content_rule_api_server_basic_auth\",\n                \"remarks\": \"rule_set_1\"\n              },\n              {\n                \"name\": \"Check_Description\",\n                \"value\": \"Ensure that the --basic-auth-file argument is not set\",\n                \"remarks\": \"rule_set_1\"\n              },\n              {\n                \"name\": \"Rule_Id\",\n                \"value\": \"content_rule_api_server_token_auth\",\n                \"remarks\": \"rule_set_2\"\n              },\n              {\n                \"name\": \"Rule_Description\",\n                \"value\": \"Ensure that the --token-auth-file parameter is not set\",\n                \"remarks\": \"rule_set_2\"\n              },\n              {\n                \"name\": \"Check_Id\",\n                \"value\": \"xccdf_org.ssgproject.content_rule_api_server_token_auth\",\n                \"remarks\": \"rule_set_2\"\n              },\n              {\n                \"name\": \"Check_Description\",\n                \"value\": \"Ensure that the --token-auth-file parameter is not set\",\n                \"remarks\": \"rule_set_2\"\n              },\n              {\n                \"name\": \"Rule_Id\",\n                \"value\": \"content_rule_api_server_https_for_kubelet_conn\",\n                \"remarks\": \"rule_set_3\"\n              },\n              {\n                \"name\": \"Rule_Description\",\n                \"value\": \"Ensure that the --kubelet-https argument is set to true\",\n                \"remarks\": \"rule_set_3\"\n              },\n              {\n                \"name\": \"Check_Id\",\n                \"value\": \"xccdf_org.ssgproject.content_rule_api_server_https_for_kubelet_conn\",\n                \"remarks\": \"rule_set_3\"\n              },\n              {\n                \"name\": \"Check_Description\",\n                \"value\": \"Ensure that the --kubelet-https argument is set to true\",\n                \"remarks\": \"rule_set_3\"\n              }\n            ],\n            \"implemented-requirements\": [\n              {\n                \"uuid\": \"c2893d38-1be4-4b0e-a090-96e846e15a3b\",\n                \"control-id\": \"CIS-1.2.1\",\n                \"description\": \"\",\n                \"props\": [\n                  {\n                    \"name\": \"Rule_Id\",\n                    \"value\": \"content_rule_api_server_anonymous_auth\"\n                  }\n                ]\n              },\n              {\n                \"uuid\": \"3c2f7129-9724-47c0-aadb-3b3c9c44995c\",\n                \"control-id\": \"CIS-1.2.2\",\n                \"description\": \"\",\n                \"props\": [\n                  {\n                    \"name\": \"Rule_Id\",\n                    \"value\": \"content_rule_api_server_basic_auth\"\n                  }\n                ]\n              },\n              {\n                \"uuid\": \"a4e2862f-7a1b-4182-b827-f5e797f589db\",\n                \"control-id\": \"CIS-1.2.3\",\n                \"description\": \"\",\n                \"props\": [\n                  {\n                    \"name\": \"Rule_Id\",\n                    \"value\": \"content_rule_api_server_token_auth\"\n                  }\n                ]\n              },\n              {\n                \"uuid\": \"daec13ab-829e-4dd6-a9d6-9ad18391681e\",\n                \"control-id\": \"CIS-1.2.4\",\n                \"description\": \"\",\n                \"props\": [\n                  {\n                    \"name\": \"Rule_Id\",\n                    \"value\": \"content_rule_api_server_https_for_kubelet_conn\"\n                  }\n                ]\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p> </p> <p> Congratulations! You have completed this tutorial. </p> <p> </p>"},{"location":"tutorials/task.ocp4-cis-profile-to-oscal-catalog/transformation/","title":"Tutorial: Setup for and use of ComplianceAsCode profile to OSCAL Catalog transformer","text":"<p>Here are step by step instructions for setup and transformation of ComplianceAsCode profile data files into NIST standard OSCAL Catalog using the compliance-trestle tool.</p>"},{"location":"tutorials/task.ocp4-cis-profile-to-oscal-catalog/transformation/#objective","title":"Objective","text":"<p>How to transform one or more <code>.profile</code> compliance files into a standardized <code>OSCAL.json</code> file.</p> <p>There are 2 short steps shown below. The first is a one-time check/set-up of your environment. The second is a one-command transformation from <code>.profile</code> to <code>OSCAL.json</code>.</p>"},{"location":"tutorials/task.ocp4-cis-profile-to-oscal-catalog/transformation/#step-1-install-trestle-in-a-python-virtual-environment","title":"Step 1: Install trestle in a Python virtual environment","text":"<p>Follow the instructions here to install trestle in a virtual environment.</p>"},{"location":"tutorials/task.ocp4-cis-profile-to-oscal-catalog/transformation/#step-2-transform-profile-data-cis-benchmarks","title":"Step 2: Transform profile data (CIS benchmarks)","text":"<p>Linux, Mac</p> Windows <p>Make these changes:</p> <ul> <li>use backslashes `\\` for file paths <li>use `md` instead of mkdir -p <li>put the url in double quotes for `curl` <li>use `more` instead of cat </li> </li> </li> </li> </ul> <ul> <li>Navigate to trestle workspace.</li> </ul> <pre><code>(venv.trestle)$ cd trestle.workspace\n</code></pre> <ul> <li>View configuration information.</li> </ul> <pre><code>(venv.trestle)$ trestle task ocp4-cis-profile-to-oscal-catalog -i\ntrestle.core.commands.task:102 WARNING: Config file was not configured with the appropriate section for the task: \"[task.ocp4-cis-profile-to-oscal-catalog]\"\nHelp information for ocp4-cis-profile-to-oscal-catalog task.\n\nPurpose: Create catalog from from standard (e.g. CIS benchmark).\n\nConfiguration flags sit under [task.ocp4-cis-profile-to-oscal-catalog]:\n  input-dir              = (required) location to read the compliance-as-code profile files.\n  output-dir             = (required) location to write the generated catalog.json file.\n  output-overwrite       = (optional) true [default] or false; replace existing output when true.\n</code></pre> <ul> <li>Create data folders.</li> </ul> <pre><code>(venv.trestle)$ mkdir -p adjunct-data/cis-benchmarks\n(venv.trestle)$ mkdir -p adjunct-data/task-files\n</code></pre> <ul> <li>Fetch ComplianceAsCode profile data.</li> </ul> <pre><code>(venv.trestle)$ curl 'https://raw.githubusercontent.com/ComplianceAsCode/content/master/products/ocp4/profiles/cis-node.profile' &gt; adjunct-data/cis-benchmarks/cis-node.profile\n(venv.trestle)$ curl 'https://raw.githubusercontent.com/ComplianceAsCode/content/master/products/ocp4/profiles/cis-node.profile' &gt; adjunct-data/cis-benchmarks/cis.profile\n</code></pre> <ul> <li>Fetch trestle task file.</li> </ul> <pre><code>(venv.trestle)$ curl 'https://raw.githubusercontent.com/IBM/compliance-trestle/main/docs/tutorials/task.ocp4-cis-profile-to-oscal-catalog/demo-ocp4-cis-profile-to-oscal-catalog.config' &gt; adjunct-data/task-files/demo-ocp4-cis-profile-to-oscal-catalog.config\n</code></pre> demo-ocp4-cis-profile-to-oscal-catalog.config <pre><code>[task.ocp4-cis-profile-to-oscal-catalog]\n\ninput-dir = adjunct-data/cis-benchmarks\noutput-dir = catalogs/ocp4-cis\n</code></pre> <ul> <li>Perform and validate the transform.</li> </ul> <pre><code>(venv.trestle)$ trestle task ocp4-cis-profile-to-oscal-catalog -c adjunct-data/task-files/demo-ocp4-cis-profile-to-oscal-catalog.config\noutput: catalogs/ocp4-cis/catalog.json\nTask: ocp4-cis-profile-to-oscal-catalog executed successfully.\n\n(venv.trestle)$ trestle validate --all\nVALID: Model /home/&lt;user&gt;/trestle.workspace/catalogs/ocp4-cis/catalog.json passed the Validator to confirm the model passes all registered validation tests.\n</code></pre> <ul> <li>View the generated OSCAL.</li> </ul> <pre><code>(venv.trestle)$ cat catlogs/ocp4-cis/catalog.json\n</code></pre> catalog.json <pre><code>{\n  \"catalog\": {\n    \"uuid\": \"19543ebf-4667-48b7-be47-d51154f16fda\",\n    \"metadata\": {\n      \"title\": \"CIS Red Hat OpenShift Container Platform 4 Benchmark\",\n      \"last-modified\": \"2021-12-03T13:52:21+00:00\",\n      \"version\": \"0.29.0\",\n      \"oscal-version\": \"1.0.0\",\n      \"links\": [\n        {\n          \"href\": \"https://github.com/ComplianceAsCode/content/blob/master/products/ocp4/profiles/cis-node.profile\"\n        },\n        {\n          \"href\": \"https://github.com/ComplianceAsCode/content/blob/master/products/ocp4/profiles/cis.profile\"\n        }\n      ]\n    },\n    \"groups\": [\n      {\n        \"title\": \"1 Control Plane Components\",\n        \"groups\": [\n          {\n            \"title\": \"1.1 Master Node Configuration Files\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-1.1.1\",\n                \"title\": \"1.1.1 Ensure that the API server pod specification file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.2\",\n                \"title\": \"1.1.2 Ensure that the API server pod specification file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-1.1.3\",\n                \"title\": \"1.1.3 Ensure that the controller manager pod specification file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.4\",\n                \"title\": \"1.1.4 Ensure that the controller manager pod specification file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-1.1.5\",\n                \"title\": \"1.1.5 Ensure that the scheduler pod specification file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.6\",\n                \"title\": \"1.1.6 Ensure that the scheduler pod specification file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-1.1.7\",\n                \"title\": \"1.1.7 Ensure that the etcd pod specification file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.8\",\n                \"title\": \"1.1.8 Ensure that the etcd pod specification file ownership is set to root:root (Automated)\"\n              },\n              {\n                \"id\": \"CIS-1.1.9\",\n                \"title\": \"1.1.9 Ensure that the Container Network Interface file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.10\",\n                \"title\": \"1.1.10 Ensure that the Container Network Interface file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-1.1.11\",\n                \"title\": \"1.1.11 Ensure that the etcd data directory permissions are set to 700 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.12\",\n                \"title\": \"1.1.12 Ensure that the etcd data directory ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-1.1.13\",\n                \"title\": \"1.1.13 Ensure that the admin.conf file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.14\",\n                \"title\": \"1.1.14 Ensure that the admin.conf file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-1.1.15\",\n                \"title\": \"1.1.15 Ensure that the scheduler.conf file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.16\",\n                \"title\": \"1.1.16 Ensure that the scheduler.conf file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-1.1.17\",\n                \"title\": \"1.1.17 Ensure that the controller-manager.conf file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.18\",\n                \"title\": \"1.1.18 Ensure that the controller-manager.conf file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-1.1.19\",\n                \"title\": \"1.1.19 Ensure that the OpenShift PKI directory and file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-1.1.20\",\n                \"title\": \"1.1.20 Ensure that the OpenShift PKI certificate file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-1.1.21\",\n                \"title\": \"1.1.21 Ensure that the OpenShift PKI key file permissions are set to 600\"\n              }\n            ]\n          },\n          {\n            \"title\": \"1.2 API Server\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-1.2.1\",\n                \"title\": \"1.2.1 Ensure that the --anonymous-auth argument is set to false\"\n              },\n              {\n                \"id\": \"CIS-1.2.2\",\n                \"title\": \"1.2.2 Ensure that the --basic-auth-file argument is not set\"\n              },\n              {\n                \"id\": \"CIS-1.2.3\",\n                \"title\": \"1.2.3 Ensure that the --token-auth-file parameter is not set\"\n              },\n              {\n                \"id\": \"CIS-1.2.4\",\n                \"title\": \"1.2.4 Ensure that the --kubelet-https argument is set to true\"\n              },\n              {\n                \"id\": \"CIS-1.2.5\",\n                \"title\": \"1.2.5 Ensure that the --kubelet-client-certificate and --kubelet-client-key arguments are set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.6\",\n                \"title\": \"1.2.6 Ensure that the --kubelet-certificate-authority argument is set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.7\",\n                \"title\": \"1.2.7 Ensure that the --authorization-mode argument is not set to AlwaysAllow\"\n              },\n              {\n                \"id\": \"CIS-1.2.8\",\n                \"title\": \"1.2.8 Ensure that the --authorization-mode argument includes Node\"\n              },\n              {\n                \"id\": \"CIS-1.2.9\",\n                \"title\": \"1.2.9 Ensure that the --authorization-mode argument includes RBAC\"\n              },\n              {\n                \"id\": \"CIS-1.2.10\",\n                \"title\": \"1.2.10 Ensure that the admission control plugin EventRateLimit is set\"\n              },\n              {\n                \"id\": \"CIS-1.2.11\",\n                \"title\": \"1.2.11 Ensure that the admission control plugin AlwaysAdmit is not set\"\n              },\n              {\n                \"id\": \"CIS-1.2.12\",\n                \"title\": \"1.2.12 Ensure that the admission control plugin AlwaysPullImages is set\"\n              },\n              {\n                \"id\": \"CIS-1.2.13\",\n                \"title\": \"1.2.13 Ensure that the admission control plugin SecurityContextDeny is not set\"\n              },\n              {\n                \"id\": \"CIS-1.2.14\",\n                \"title\": \"1.2.14 Ensure that the admission control plugin ServiceAccount is set\"\n              },\n              {\n                \"id\": \"CIS-1.2.15\",\n                \"title\": \"1.2.15 Ensure that the admission control plugin NamespaceLifecycle is set\"\n              },\n              {\n                \"id\": \"CIS-1.2.16\",\n                \"title\": \"1.2.16 Ensure that the admission control plugin PodSecurityPolicy is set (Automated)\"\n              },\n              {\n                \"id\": \"CIS-1.2.17\",\n                \"title\": \"1.2.17 Ensure that the admission control plugin NodeRestriction is set (Automated)\"\n              },\n              {\n                \"id\": \"CIS-1.2.18\",\n                \"title\": \"1.2.18 Ensure that the --insecure-bind-address argument is not set\"\n              },\n              {\n                \"id\": \"CIS-1.2.19\",\n                \"title\": \"1.2.19 Ensure that the --insecure-port argument is set to 0\"\n              },\n              {\n                \"id\": \"CIS-1.2.20\",\n                \"title\": \"1.2.20 Ensure that the --secure-port argument is not set to 0\"\n              },\n              {\n                \"id\": \"CIS-1.2.21\",\n                \"title\": \"1.2.21 Ensure that the --profiling argument is set to false\"\n              },\n              {\n                \"id\": \"CIS-1.2.22\",\n                \"title\": \"1.2.22 Ensure that the --audit-log-path argument is set\"\n              },\n              {\n                \"id\": \"CIS-1.2.23\",\n                \"title\": \"1.2.23 Ensure that the audit logs are forwarded off the cluster for retention\"\n              },\n              {\n                \"id\": \"CIS-1.2.24\",\n                \"title\": \"1.2.24 Ensure that the --audit-log-maxbackup argument is set to 10 or as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.25\",\n                \"title\": \"1.2.25 Ensure that the --audit-log-maxsize argument is set to 100 or as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.26\",\n                \"title\": \"1.2.26 Ensure that the --request-timeout argument is set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.27\",\n                \"title\": \"1.2.27 Ensure that the --service-account-lookup argument is set to true\"\n              },\n              {\n                \"id\": \"CIS-1.2.28\",\n                \"title\": \"1.2.28 Ensure that the --service-account-key-file argument is set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.29\",\n                \"title\": \"1.2.29 Ensure that the --etcd-certfile and --etcd-keyfile arguments are set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.30\",\n                \"title\": \"1.2.30 Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.31\",\n                \"title\": \"1.2.31 Ensure that the --client-ca-file argument is set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.32\",\n                \"title\": \"1.2.32 Ensure that the --etcd-cafile argument is set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.33\",\n                \"title\": \"1.2.33 Ensure that the --encryption-provider-config argument is set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.2.34\",\n                \"title\": \"1.2.34 Ensure that encryption providers are appropriately configured\"\n              },\n              {\n                \"id\": \"CIS-1.2.35\",\n                \"title\": \"1.2.35 Ensure that the API Server only makes use of Strong Cryptographic Ciphers\"\n              }\n            ]\n          },\n          {\n            \"title\": \"1.3 Controller Manager\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-1.3.1\",\n                \"title\": \"1.3.1 Ensure that garbage collection is configured as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.3.2\",\n                \"title\": \"1.3.2 Ensure that controller manager healthz endpoints are protected by RBAC. (Automated)\"\n              },\n              {\n                \"id\": \"CIS-1.3.3\",\n                \"title\": \"1.3.3 Ensure that the --use-service-account-credentials argument is set to true\"\n              },\n              {\n                \"id\": \"CIS-1.3.4\",\n                \"title\": \"1.3.4 Ensure that the --service-account-private-key-file argument is set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.3.5\",\n                \"title\": \"1.3.5 Ensure that the --root-ca-file argument is set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-1.3.6\",\n                \"title\": \"1.3.6 Ensure that the RotateKubeletServerCertificate argument is set to true\"\n              },\n              {\n                \"id\": \"CIS-1.3.7\",\n                \"title\": \"1.3.7 Ensure that the --bind-address argument is set to 127.0.0.1\"\n              }\n            ]\n          },\n          {\n            \"title\": \"1.4 Scheduler\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-1.4.1\",\n                \"title\": \"1.4.1 Ensure that the --profiling argument is set to false  (info only)\"\n              },\n              {\n                \"id\": \"CIS-1.4.2\",\n                \"title\": \"1.4.2 Ensure that the --bind-address argument is set to 127.0.0.1\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"title\": \"2 etcd\",\n        \"controls\": [\n          {\n            \"id\": \"CIS-2.1\",\n            \"title\": \"2.1 Ensure that the --cert-file and --key-file arguments are set as appropriate\"\n          },\n          {\n            \"id\": \"CIS-2.2\",\n            \"title\": \"2.2 Ensure that the --client-cert-auth argument is set to true\"\n          },\n          {\n            \"id\": \"CIS-2.3\",\n            \"title\": \"2.3 Ensure that the --auto-tls argument is not set to true\"\n          },\n          {\n            \"id\": \"CIS-2.4\",\n            \"title\": \"2.4 Ensure that the --peer-cert-file and --peer-key-file arguments are set as appropriate\"\n          },\n          {\n            \"id\": \"CIS-2.5\",\n            \"title\": \"2.5 Ensure that the --peer-client-cert-auth argument is set to true\"\n          },\n          {\n            \"id\": \"CIS-2.6\",\n            \"title\": \"2.6 Ensure that the --peer-auto-tls argument is not set to true\"\n          },\n          {\n            \"id\": \"CIS-2.7\",\n            \"title\": \"2.7 Ensure that a unique Certificate Authority is used for etcd\"\n          }\n        ]\n      },\n      {\n        \"title\": \"3 Control Plane Configuration\",\n        \"groups\": [\n          {\n            \"title\": \"3.1 Authentication and Authorization\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-3.1.1\",\n                \"title\": \"3.1.1 Client certificate authentication should not be used for users\"\n              }\n            ]\n          },\n          {\n            \"title\": \"3.2 Logging\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-3.2.1\",\n                \"title\": \"3.2.1 Ensure that a minimal audit policy is created\"\n              },\n              {\n                \"id\": \"CIS-3.2.2\",\n                \"title\": \"3.2.2 Ensure that the audit policy covers key security concerns\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"title\": \"4 Worker Nodes\",\n        \"groups\": [\n          {\n            \"title\": \"4.1 Worker node configuration\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-4.1.1\",\n                \"title\": \"4.1.1 Ensure that the kubelet service file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-4.1.2\",\n                \"title\": \"4.1.2 Ensure that the kubelet service file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-4.1.3\",\n                \"title\": \"4.1.3 If proxy kubeconfig file exists ensure permissions are set to 644 or more restrictive (Automated)\"\n              },\n              {\n                \"id\": \"CIS-4.1.4\",\n                \"title\": \"4.1.4 If proxy kubeconfig file exists ensure ownership is set to root:root (Manual)\"\n              },\n              {\n                \"id\": \"CIS-4.1.5\",\n                \"title\": \"4.1.5 Ensure that the --kubeconfig kubelet.conf file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-4.1.6\",\n                \"title\": \"4.1.6 Ensure that the --kubeconfig kubelet.conf file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-4.1.7\",\n                \"title\": \"4.1.7 Ensure that the certificate authorities file permissions are set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-4.1.8\",\n                \"title\": \"4.1.8 Ensure that the client certificate authorities file ownership is set to root:root\"\n              },\n              {\n                \"id\": \"CIS-4.1.9\",\n                \"title\": \"4.1.9 Ensure that the kubelet --config configuration file has permissions set to 644 or more restrictive\"\n              },\n              {\n                \"id\": \"CIS-4.1.10\",\n                \"title\": \"4.1.10 Ensure that the kubelet configuration file ownership is set to root:root\"\n              }\n            ]\n          },\n          {\n            \"title\": \"4.2 Kubelet\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-4.2.1\",\n                \"title\": \"4.2.1 Ensure that the --anonymous-auth argument is set to false\"\n              },\n              {\n                \"id\": \"CIS-4.2.2\",\n                \"title\": \"4.2.2 Ensure that the --authorization-mode argument is not set to AlwaysAllow\"\n              },\n              {\n                \"id\": \"CIS-4.2.3\",\n                \"title\": \"4.2.3 Ensure that the --client-ca-file argument is set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-4.2.4\",\n                \"title\": \"4.2.4 Ensure that the --read-only-port argument is set to 0\"\n              },\n              {\n                \"id\": \"CIS-4.2.5\",\n                \"title\": \"4.2.5 Ensure that the --streaming-connection-idle-timeout argument is not set to 0\"\n              },\n              {\n                \"id\": \"CIS-4.2.6\",\n                \"title\": \"4.2.6 Ensure that the --protect-kernel-defaults argument is set to true\"\n              },\n              {\n                \"id\": \"CIS-4.2.7\",\n                \"title\": \"4.2.7 Ensure that the --make-iptables-util-chains argument is set to true\"\n              },\n              {\n                \"id\": \"CIS-4.2.8\",\n                \"title\": \"4.2.8 Ensure that the --hostname-override argument is not set\"\n              },\n              {\n                \"id\": \"CIS-4.2.9\",\n                \"title\": \"4.2.9 Ensure that the --event-qps argument is set to 0 or a level which ensures appropriate event capture\"\n              },\n              {\n                \"id\": \"CIS-4.2.10\",\n                \"title\": \"4.2.10 Ensure that the --tls-cert-file and --tls-private-key-file arguments are set as appropriate\"\n              },\n              {\n                \"id\": \"CIS-4.2.11\",\n                \"title\": \"4.2.11 Ensure that the --rotate-certificates argument is not set to false\"\n              },\n              {\n                \"id\": \"CIS-4.2.12\",\n                \"title\": \"4.2.12 Verify that the RotateKubeletServerCertificate argument is set to true\"\n              },\n              {\n                \"id\": \"CIS-4.2.13\",\n                \"title\": \"4.2.13 Ensure that the Kubelet only makes use of Strong Cryptographic Ciphers\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"title\": \"5 Policies\",\n        \"groups\": [\n          {\n            \"title\": \"5.1 RBAC and Service Accounts\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-5.1.1\",\n                \"title\": \"5.1.1 Ensure that the cluster-admin role is only used where required\"\n              },\n              {\n                \"id\": \"CIS-5.1.2\",\n                \"title\": \"5.1.2 Minimize access to secrets (info)\"\n              },\n              {\n                \"id\": \"CIS-5.1.3\",\n                \"title\": \"5.1.3 Minimize wildcard use in Roles and ClusterRoles (info)\"\n              },\n              {\n                \"id\": \"CIS-5.1.4\",\n                \"title\": \"5.1.4 Minimize access to create pods (info)\"\n              },\n              {\n                \"id\": \"CIS-5.1.5\",\n                \"title\": \"5.1.5 Ensure that default service accounts are not actively used. (info)\"\n              },\n              {\n                \"id\": \"CIS-5.1.6\",\n                \"title\": \"5.1.6 Ensure that Service Account Tokens are only mounted where necessary (info)\"\n              }\n            ]\n          },\n          {\n            \"title\": \"5.2 Pod Security Policies / Security Context Constraints\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-5.2.1\",\n                \"title\": \"5.2.1 Minimize the admission of privileged containers (info)\"\n              },\n              {\n                \"id\": \"CIS-5.2.2\",\n                \"title\": \"5.2.2 Minimize the admission of containers wishing to share the host process ID namespace (info)\"\n              },\n              {\n                \"id\": \"CIS-5.2.3\",\n                \"title\": \"5.2.3 Minimize the admission of containers wishing to share the host IPC namespace (info)\"\n              },\n              {\n                \"id\": \"CIS-5.2.4\",\n                \"title\": \"5.2.4 Minimize the admission of containers wishing to share the host network namespace (info)\"\n              },\n              {\n                \"id\": \"CIS-5.2.5\",\n                \"title\": \"5.2.5 Minimize the admission of containers with allowPrivilegeEscalation (info)\"\n              },\n              {\n                \"id\": \"CIS-5.2.6\",\n                \"title\": \"5.2.6 Minimize the admission of root containers (info)\"\n              },\n              {\n                \"id\": \"CIS-5.2.7\",\n                \"title\": \"5.2.7 Minimize the admission of containers with the NET_RAW capability (info)\"\n              },\n              {\n                \"id\": \"CIS-5.2.8\",\n                \"title\": \"5.2.8 Minimize the admission of containers with added capabilities (info)\"\n              },\n              {\n                \"id\": \"CIS-5.2.9\",\n                \"title\": \"5.2.9 Minimize the admission of containers with capabilities assigned (info)\"\n              }\n            ]\n          },\n          {\n            \"title\": \"5.3 Network Policies and CNI\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-5.3.1\",\n                \"title\": \"5.3.1 Ensure that the CNI in use supports Network Policies (info)\"\n              },\n              {\n                \"id\": \"CIS-5.3.2\",\n                \"title\": \"5.3.2 Ensure that all Namespaces have Network Policies defined\"\n              }\n            ]\n          },\n          {\n            \"title\": \"5.4 Secrets Management\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-5.4.1\",\n                \"title\": \"5.4.1 Prefer using secrets as files over secrets as environment variables (info)\"\n              },\n              {\n                \"id\": \"CIS-5.4.2\",\n                \"title\": \"5.4.2 Consider external secret storage (info)\"\n              }\n            ]\n          },\n          {\n            \"title\": \"5.5 Extensible Admission Control\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-5.5.1\",\n                \"title\": \"5.5.1 Configure Image Provenance using ImagePolicyWebhook admission controller\"\n              }\n            ]\n          },\n          {\n            \"title\": \"5.6 General Policies\",\n            \"controls\": [\n              {\n                \"id\": \"CIS-5.6.1\",\n                \"title\": \"5.6.1 Create administrative boundaries between resources using namespaces (info)\"\n              },\n              {\n                \"id\": \"CIS-5.6.2\",\n                \"title\": \"5.6.2 Ensure Seccomp Profile Pod Definitions (info)\"\n              },\n              {\n                \"id\": \"CIS-5.6.3\",\n                \"title\": \"5.6.3 Apply Security Context to your Pods and Containers (info)\"\n              },\n              {\n                \"id\": \"CIS-5.6.4\",\n                \"title\": \"5.6.4 The Default Namespace should not be used (info)\"\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p> </p> <p> Congratulations! You have completed this tutorial. </p> <p> </p>"},{"location":"tutorials/task.ocp4-cis-profile-to-oscal-cd/transformation/","title":"Tutorial: Setup for and use of ComplianceAsCode profile to OSCAL Component Definition transformer","text":"<p>Here are step by step instructions for setup and transformation of ComplianceAsCode profile data files into NIST standard OSCAL Component Definition using the compliance-trestle tool.</p>"},{"location":"tutorials/task.ocp4-cis-profile-to-oscal-cd/transformation/#objective","title":"Objective","text":"<p>How to transform one or more <code>.profile</code> compliance files into a standardized <code>OSCAL.json</code> file.</p> <p>There are 2 short steps shown below. The first is a one-time check/set-up of your environment. The second is a one-command transformation from <code>.profile</code> to <code>OSCAL.json</code>.</p>"},{"location":"tutorials/task.ocp4-cis-profile-to-oscal-cd/transformation/#step-1-install-trestle-in-a-python-virtual-environment","title":"Step 1: Install trestle in a Python virtual environment","text":"<p>Follow the instructions here to install trestle in a virtual environment.</p>"},{"location":"tutorials/task.ocp4-cis-profile-to-oscal-cd/transformation/#step-2-transform-profile-data-cis-benchmarks","title":"Step 2: Transform profile data (CIS benchmarks)","text":"<p>Linux, Mac</p> Windows <p>Make these changes:</p> <ul> <li>use backslashes `\\` for file paths <li>use `md` instead of mkdir -p <li>put the url in double quotes for `curl` <li>use `more` instead of cat </li> </li> </li> </li> </ul> <ul> <li>Navigate to trestle workspace.</li> </ul> <pre><code>(venv.trestle)$ cd trestle.workspace\n</code></pre> <ul> <li>View configuration information.</li> </ul> <pre><code>(venv.trestle)$ trestle task ocp4-cis-profile-to-oscal-cd -i\ntrestle.core.commands.task:99 WARNING: Config file was not configured with the appropriate section for the task: \"[task.ocp4-cis-profile-to-oscal-cd]\"\nHelp information for ocp4-cis-profile-to-oscal-cd task.\n\nPurpose: Create component definition from standard (e.g. CIS benchmark).\n\nConfiguration flags sit under [task.ocp4-cis-profile-to-oscal-cd]:\n  component-name         = component name, e.g. OSCO.\n  org-name               = organization name, e.g. International Business Machines.\n  org-remarks            = organization remarks, e.g. IBM.\n  folder-cac             = folder containing compliance-as-code artifacts, e.g adjunct-data/cis-benchmarks/content.\n  output-dir             = location to write the generated component-definition.json file.\n  profile-name           = profile name, e.g. OCP4 CIS-benchmark v4.\n  profile-mnemonic       = profile mnemonic, e.g. ocp4-cis-node.\n  profile-ns             = profile ns, e.g. http://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud.\n  profile-version        = profile version, e.g. 1.1.\n  profile-check-version  = profile check version, e.g. 0.1.58.\n  profile-type           = profile type, e.g. OCP4.\n  profile-list           = profile list is blank separated list of \"&lt;suffix&gt;\" for config entries: profile-file.&lt;suffix&gt;, profile-title.&lt;suffix&gt;, profile-url.&lt;suffix&gt;, e.g. cis cis-node.\n  profile-file.&lt;suffix&gt;  = path of the profile file to ingest, e.g. ${folder-cac}/products/ocp4/profiles/cis-node.profile.\n  profile-title.&lt;suffix&gt; = title of the profile, e.g. CIS Red Hat OpenShift Container Platform 4 Benchmark.\n  profile-url.&lt;suffix&gt;   = URL of the profile, e.g. https://github.com/ComplianceAsCode/content/blob/master/products/ocp4/profiles/cis.profile.\n  rule-to-parameters-map = map file for set-parameters, e.g. adjunct-data/task-files/rule2var.json.\n  selected-rules         = file with list of selected rules, e.g. adjunct-data/task-files/selected_rules.json.\n  enabled-rules          = file with list of enabled rules, e.g. adjunct-data/task-files/enabled_rules.json.\n\nNotes:\n1. If a control has selected rules but no enabled rules, then all those selected are included.\n2. If a control has selected and enabled rules, then only those enabled are included.\n3. If a control has no selected rules, then none are included regardless of enabled.\n</code></pre> <ul> <li>Create data folders.</li> </ul> <pre><code>(venv.trestle)$ mkdir -p adjunct-data/cis-benchmarks\n(venv.trestle)$ mkdir -p adjunct-data/config-files\n(venv.trestle)$ mkdir -p adjunct-data/task-files\n</code></pre> <ul> <li>Fetch ComplianceAsCode data.</li> </ul> <pre><code>(venv.trestle)$ cd adjunct-data/cis-benchmarks/\n(venv.trestle)$ git clone https://github.com/ComplianceAsCode/content.git\n(venv.trestle)$ cd -\n</code></pre> <ul> <li>Fetch trestle config and task files.</li> </ul> <pre><code>(venv.trestle)$ curl 'https://raw.githubusercontent.com/IBM/compliance-trestle/main/docs/tutorials/task.ocp4-cis-profile-to-oscal-cd/demo-ocp4-cis-profile-to-oscal-cd.config' &gt; adjunct-data/config-files/demo-ocp4-cis-profile-to-oscal-cd.config\n(venv.trestle)$ curl 'https://raw.githubusercontent.com/IBM/compliance-trestle/main/docs/tutorials/task.ocp4-cis-profile-to-oscal-cd/selected_rules.json' &gt; adjunct-data/task-files/selected_rules.json\n(venv.trestle)$ curl 'https://raw.githubusercontent.com/IBM/compliance-trestle/main/docs/tutorials/task.ocp4-cis-profile-to-oscal-cd/enabled_rules.json' &gt; adjunct-data/task-files/enabled_rules.json\n</code></pre> demo-ocp4-cis-profile-to-oscal-cd.config <pre><code>[task.ocp4-cis-profile-to-oscal-cd]\n\ncomponent-name = OSCO\n\nfolder-cac = adjunct-data/cis-benchmarks/content\n\norg-name = International Business Machines\norg-remarks = IBM\n\noutput-dir = component-definitions/ocp4-cis\n\nprofile-name = OCP4 CIS-benchmark v4\nprofile-mnemonic = ocp4-cis-node\nprofile-ns = http://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud\nprofile-version = 1.1\nprofile-check-version = 0.1.58\n\nprofile-type = OCP4\nprofile-list = cis-node cis\n\nprofile-file.cis-node = ${folder-cac}/products/ocp4/profiles/cis-node.profile\nprofile-url.cis-node = https://github.com/ComplianceAsCode/content/blob/master/products/ocp4/profiles/cis-node.profile\nprofile-title.cis-node = CIS Red Hat OpenShift Container Platform 4 Benchmark\n\nprofile-file.cis = ${folder-cac}/products/ocp4/profiles/cis.profile\nprofile-url.cis = https://github.com/ComplianceAsCode/content/blob/master/products/ocp4/profiles/cis.profile\nprofile-title.cis = CIS Red Hat OpenShift Container Platform 4 Benchmark\n\nselected-rules  = adjunct-data/task-files/selected_rules.json\nenabled-rules  = adjunct-data/task-files/enabled_rules.json\n</code></pre> selected_rules.json <pre><code>[\n\"file_permissions_kube_apiserver\",\n\"file_owner_kube_apiserver\",\n\"file_groupowner_kube_apiserver\"\n]\n</code></pre> enabled_rules.json <pre><code>[\n\"file_permissions_cni_conf\",\n\"file_permissions_multus_conf\",\n\"file_owner_cni_conf\",\n\"file_groupowner_cni_conf\",\n\"file_owner_multus_conf\",\n\"file_groupowner_multus_conf\",\n\"kubelet_eviction_thresholds_set_soft_memory_available\",\n\"kubelet_eviction_thresholds_set_soft_nodefs_available\",\n\"kubelet_eviction_thresholds_set_soft_nodefs_inodesfree\",\n\"kubelet_eviction_thresholds_set_soft_imagefs_available\",\n\"kubelet_eviction_thresholds_set_soft_imagefs_inodesfree\",\n\"kubelet_eviction_thresholds_set_hard_memory_available\",\n\"kubelet_eviction_thresholds_set_hard_nodefs_available\",\n\"kubelet_eviction_thresholds_set_hard_nodefs_inodesfree\",\n\"kubelet_eviction_thresholds_set_hard_imagefs_available\",\n\"kubelet_eviction_thresholds_set_hard_imagefs_inodesfree\",\n\"etcd_unique_ca\",\n\"file_permissions_kubelet_conf\",\n\"file_groupowner_kubelet_conf\",\n\"file_owner_kubelet_conf\",\n\"file_permissions_worker_ca\",\n\"file_owner_worker_ca\",\n\"file_groupowner_worker_ca\",\n\"kubelet_anonymous_auth\",\n\"kubelet_configure_client_ca\",\n\"kubelet_enable_streaming_connections\",\n\"kubelet_enable_iptables_util_chains\",\n\"kubelet_disable_hostname_override\",\n\"kubelet_configure_event_creation\",\n\"kubelet_configure_tls_cipher_suites\"\n]\n</code></pre> <ul> <li>Perform and validate the transform.</li> </ul> <pre><code>(venv.trestle)$ trestle task ocp4-cis-profile-to-oscal-cd -c adjunct-data/config-files/demo-ocp4-cis-profile-to-oscal-cd.config\noutput: component-definitions/ocp4-cis/component-definition.json\nTask: ocp4-cis-profile-to-oscal-cd executed successfully.\n\n(venv.trestle)$ trestle validate --all\nVALID: Model /home/&lt;user&gt;/trestle.workspace/component-definitions/ocp4-cis/component-definition.json passed the Validator to confirm the model passes all registered validation tests.\n</code></pre> <ul> <li>View the generated OSCAL.</li> </ul> <pre><code>(venv.trestle)$ cat component-definitions/ocp4-cis/component-definition.json\n</code></pre> component-definition.json <pre><code>{\n\"component-definition\": {\n\"uuid\": \"d1b961ee-188b-42b9-943d-e11dc260f9dc\",\n\"metadata\": {\n\"title\": \"Component definition for OCP4 profiles\",\n\"last-modified\": \"2022-01-06T22:43:59+00:00\",\n\"version\": \"0.33.0\",\n\"oscal-version\": \"1.0.0\",\n\"roles\": [\n{\n\"id\": \"prepared-by\",\n\"title\": \"Indicates the organization that created this content.\"\n},\n{\n\"id\": \"prepared-for\",\n\"title\": \"Indicates the organization for which this content was created..\"\n},\n{\n\"id\": \"content-approver\",\n\"title\": \"Indicates the organization responsible for all content represented in the \\\"document\\\".\"\n}\n],\n\"parties\": [\n{\n\"uuid\": \"d00dff65-e4ae-4344-a206-1e298eff9066\",\n\"type\": \"organization\",\n\"name\": \"International Business Machines\",\n\"remarks\": \"IBM\"\n},\n{\n\"uuid\": \"851b55f0-5ba6-4684-8a48-5dad22ba2625\",\n\"type\": \"organization\",\n\"name\": \"Customer\",\n\"remarks\": \"organization to be customized at account creation only for their Component Definition\"\n},\n{\n\"uuid\": \"150f9eb7-7fa5-4989-b9be-bc3cba220354\",\n\"type\": \"organization\",\n\"name\": \"ISV\",\n\"remarks\": \"organization to be customized at ISV subscription only for their Component Definition\"\n}\n],\n\"responsible-parties\": [\n{\n\"role-id\": \"prepared-by\",\n\"party-uuids\": [\n\"d00dff65-e4ae-4344-a206-1e298eff9066\"\n]\n},\n{\n\"role-id\": \"prepared-for\",\n\"party-uuids\": [\n\"851b55f0-5ba6-4684-8a48-5dad22ba2625\",\n\"150f9eb7-7fa5-4989-b9be-bc3cba220354\"\n]\n},\n{\n\"role-id\": \"content-approver\",\n\"party-uuids\": [\n\"d00dff65-e4ae-4344-a206-1e298eff9066\"\n]\n}\n]\n},\n\"components\": [\n{\n\"uuid\": \"e2ee2b93-6103-42de-b615-65b0b3ff2dc4\",\n\"type\": \"Service\",\n\"title\": \"OSCO\",\n\"description\": \"OSCO\",\n\"control-implementations\": [\n{\n\"uuid\": \"f9c2699a-2d2c-4ee2-87f3-042d1a9b3a79\",\n\"source\": \"https://github.com/ComplianceAsCode/content/blob/master/products/ocp4/profiles/cis-node.profile\",\n\"description\": \"OSCO implemented controls for CIS Red Hat OpenShift Container Platform 4 Benchmark.\",\n\"props\": [\n{\n\"name\": \"profile_name\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud\",\n\"value\": \"OCP4 CIS-benchmark v4\",\n\"class\": \"scc_profile_name\"\n},\n{\n\"name\": \"profile_mnemonic\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud\",\n\"value\": \"ocp4-cis-node\",\n\"class\": \"scc_profile_mnemonic\"\n},\n{\n\"name\": \"profile_version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud\",\n\"value\": \"1.1\",\n\"class\": \"scc_profile_version\"\n},\n{\n\"name\": \"profile_check_version\",\n\"value\": \"0.1.58\"\n}\n],\n\"implemented-requirements\": [\n{\n\"uuid\": \"97142b13-bc30-4e72-be7f-36de9149a679\",\n\"control-id\": \"CIS-1.1.1\",\n\"description\": \"Ensure that the API server pod specification file permissions are set to 644 or more restrictive\",\n\"props\": [\n{\n\"name\": \"XCCDF_rule\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud\",\n\"value\": \"xccdf_org.ssgproject.content_rule_file_permissions_kube_apiserver\",\n\"class\": \"scc_goal_name_id\",\n\"remarks\": \"Verify Permissions on the Kubernetes API Server Pod Specification File\"\n}\n],\n\"responsible-roles\": [\n{\n\"role-id\": \"prepared-by\",\n\"party-uuids\": [\n\"d00dff65-e4ae-4344-a206-1e298eff9066\"\n]\n},\n{\n\"role-id\": \"prepared-for\",\n\"party-uuids\": [\n\"851b55f0-5ba6-4684-8a48-5dad22ba2625\",\n\"150f9eb7-7fa5-4989-b9be-bc3cba220354\"\n]\n},\n{\n\"role-id\": \"content-approver\",\n\"party-uuids\": [\n\"d00dff65-e4ae-4344-a206-1e298eff9066\"\n]\n}\n]\n},\n{\n\"uuid\": \"0690e2a7-b228-4954-93fe-c1d55936cfa8\",\n\"control-id\": \"CIS-1.1.2\",\n\"description\": \"Ensure that the API server pod specification file ownership is set to root:root\",\n\"props\": [\n{\n\"name\": \"XCCDF_rule\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud\",\n\"value\": \"xccdf_org.ssgproject.content_rule_file_owner_kube_apiserver\",\n\"class\": \"scc_goal_name_id\",\n\"remarks\": \"Verify User Who Owns The Kubernetes API Server Pod Specification File\"\n}\n],\n\"responsible-roles\": [\n{\n\"role-id\": \"prepared-by\",\n\"party-uuids\": [\n\"d00dff65-e4ae-4344-a206-1e298eff9066\"\n]\n},\n{\n\"role-id\": \"prepared-for\",\n\"party-uuids\": [\n\"851b55f0-5ba6-4684-8a48-5dad22ba2625\",\n\"150f9eb7-7fa5-4989-b9be-bc3cba220354\"\n]\n},\n{\n\"role-id\": \"content-approver\",\n\"party-uuids\": [\n\"d00dff65-e4ae-4344-a206-1e298eff9066\"\n]\n}\n]\n},\n{\n\"uuid\": \"18c61fb2-8603-440d-9d9a-8d6d1e232cd3\",\n\"control-id\": \"CIS-1.1.2\",\n\"description\": \"Ensure that the API server pod specification file ownership is set to root:root\",\n\"props\": [\n{\n\"name\": \"XCCDF_rule\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ibm-cloud\",\n\"value\": \"xccdf_org.ssgproject.content_rule_file_groupowner_kube_apiserver\",\n\"class\": \"scc_goal_name_id\",\n\"remarks\": \"Verify Group Who Owns The Kubernetes API Server Pod Specification File\"\n}\n],\n\"responsible-roles\": [\n{\n\"role-id\": \"prepared-by\",\n\"party-uuids\": [\n\"d00dff65-e4ae-4344-a206-1e298eff9066\"\n]\n},\n{\n\"role-id\": \"prepared-for\",\n\"party-uuids\": [\n\"851b55f0-5ba6-4684-8a48-5dad22ba2625\",\n\"150f9eb7-7fa5-4989-b9be-bc3cba220354\"\n]\n},\n{\n\"role-id\": \"content-approver\",\n\"party-uuids\": [\n\"d00dff65-e4ae-4344-a206-1e298eff9066\"\n]\n}\n]\n}\n]\n}\n]\n}\n]\n}\n}\n</code></pre> <p> </p> <p> Congratulations! You have completed this tutorial. </p> <p> </p>"},{"location":"tutorials/task.tanium-result-to-oscal-ar/transformation/","title":"Tutorial: Setup for and use of Tanium to OSCAL transformer","text":"<p>Here are step by step instructions for setup and transformation of Tanium compliance data files into NIST standard OSCAL using the compliance-trestle tool.</p>"},{"location":"tutorials/task.tanium-result-to-oscal-ar/transformation/#objective","title":"Objective","text":"<p>How to transform a <code>Tanium.results</code> compliance file into a standardized <code>OSCAL.json</code> file.</p> <p>There are 2 short steps shown below. The first is a one-time check/set-up of your environment. The second is a one-command transformation from <code>Tanium.results</code> to <code>OSCAL.json</code>.</p>"},{"location":"tutorials/task.tanium-result-to-oscal-ar/transformation/#step-1-environment-setup","title":"Step 1: Environment setup","text":"<p>Linux, Mac</p> Windows <p>Make these changes:</p> <ul> <li>use backslashes `\\` for file paths <li>use `md` instead of mkdir -p <li>put the url in double quotes for `curl` <li>use `more` instead of cat </li> </li> </li> </li> </ul> <ul> <li>Insure you have a modern Python (3.7, 3.8, 3.9).</li> </ul> <pre><code>$ python -V\nPython 3.8.3\n</code></pre> <ul> <li>Setup a virtual environment.</li> </ul> <pre><code>$ cd\n$ python -m venv venv.trestle\n$ source venv.trestle/bin/activate\n(venv.trestle)$\n</code></pre> <ul> <li>Insure you have a modern pip (19.x or greater).</li> </ul> <pre><code>(venv.trestle)$ pip --version\npip 19.2.3 from /home...\n</code></pre> <ul> <li>Install compliance-trestle.</li> </ul> <pre><code>(venv.trestle)$ pip install compliance-trestle\nLooking in indexes: https://pypi.org/simple,...\n</code></pre> <ul> <li>Check trestle viability (and view help).</li> </ul> <pre><code>(venv.trestle)$ trestle -h\nusage: trestle [-h] {init,create,split,merge,replicate,add,remove,validate,import,task,assemble} ...\n</code></pre> <ul> <li>Create trestle workspace.</li> </ul> <pre><code>(venv.trestle)$ mkdir trestle.workspace\n(venv.trestle)$ cd trestle.workspace\n(venv.trestle)$ trestle init\nInitialized trestle project successfully in /home/&lt;user&gt;/trestle.workspace\n</code></pre>"},{"location":"tutorials/task.tanium-result-to-oscal-ar/transformation/#step-2-transform-sample","title":"Step 2: Transform sample","text":"<ul> <li>Create Tanium data folders.</li> </ul> <pre><code>(venv.trestle)$ mkdir -p tanium/tests/data/tasks/tanium/input\n</code></pre> <ul> <li>Fetch sample Tanium data file. It is a \"raw\" Tanium result for which a transformation to OSCAL is desired.</li> </ul> <pre><code>(venv.trestle)$ curl 'https://raw.githubusercontent.com/IBM/compliance-trestle/develop/tests/data/tasks/tanium/input-doc/Tanium.doc-json' &gt; tanium/tests/data/tasks/tanium/input/Tanium.doc-json\n</code></pre> sample: Tanium.doc-json <pre><code>{\n\"Computer Name\": \"RHEL8\",\n\"Tanium Client IP Address\": \"192.168.0.125\",\n\"IP Address\": [\n\"192.168.0.125\",\n\"192.168.122.1\",\n\"fe80::3c47:1aff:fe33:601\"\n],\n\"Comply - Compliance Findings\": [\n{\n\"Check ID\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\",\n\"State\": \"fail\",\n\"Rule ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\"\n},\n{\n\"Check ID\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.1.3_Ensure_mounting_of_squashfs_filesystems_is_disabled\",\n\"State\": \"fail\",\n\"Rule ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.3_Ensure_mounting_of_squashfs_filesystems_is_disabled\"\n},\n{\n\"Check ID\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.1.4_Ensure_mounting_of_udf_filesystems_is_disabled\",\n\"State\": \"fail\",\n\"Rule ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.4_Ensure_mounting_of_udf_filesystems_is_disabled\"\n},\n{\n\"Check ID\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.10_Ensure_noexec_option_set_on_vartmp_partition\",\n\"State\": \"pass\",\n\"Rule ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.10_Ensure_noexec_option_set_on_vartmp_partition\"\n},\n{\n\"Check ID\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.14_Ensure_nodev_option_set_on_home_partition\",\n\"State\": \"pass\",\n\"Rule ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.14_Ensure_nodev_option_set_on_home_partition\"\n},\n{\n\"Check ID\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.15_Ensure_nodev_option_set_on_devshm_partition\",\n\"State\": \"pass\",\n\"Rule ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.15_Ensure_nodev_option_set_on_devshm_partition\"\n},\n{\n\"Check ID\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.16_Ensure_nosuid_option_set_on_devshm_partition\",\n\"State\": \"pass\",\n\"Rule ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.16_Ensure_nosuid_option_set_on_devshm_partition\"\n},\n{\n\"Check ID\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.17_Ensure_noexec_option_set_on_devshm_partition\",\n\"State\": \"fail\",\n\"Rule ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.17_Ensure_noexec_option_set_on_devshm_partition\"\n},\n{\n\"Check ID\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.18_Ensure_nodev_option_set_on_removable_media_partitions\",\n\"State\": \"notchecked\",\n\"Rule ID\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.18_Ensure_nodev_option_set_on_removable_media_partitions\"\n}\n],\n\"Count\": \"1\"\n}\n</code></pre> <ul> <li>Fetch sample trestle tanium-result-to-oscal-ar config file. It informs the trestle command where to read input and write output.</li> </ul> <pre><code>(venv.trestle)$ curl 'https://raw.githubusercontent.com/IBM/compliance-trestle/develop/tests/data/tasks/tanium/demo-tanium-result-to-oscal-ar.config' &gt; tanium/demo-tanium-result-to-oscal-ar.config\n</code></pre> sample: demo-tanium-result-to-oscal-ar.config <pre><code>[task.tanium-result-to-oscal-ar]\n\ninput-dir =  tests/data/tasks/tanium/input\noutput-dir = tests/data/tasks/tanium/runtime\n</code></pre> <ul> <li>Perform the transform.</li> </ul> <pre><code>(venv.trestle)$ cd tanium\n(venv.trestle)$ trestle task tanium-result-to-oscal-ar -c demo-tanium-result-to-oscal-ar.config \ninput: tests/data/tasks/tanium/input/Tanium.doc-json\noutput: tests/data/tasks/tanium/runtime/Tanium.oscal.json\ninventory: 1\nobservations: 9\nTask: tanium-result-to-oscal-ar executed successfully.\n</code></pre> <ul> <li>View the generated OSCAL.</li> </ul> <pre><code>(venv.trestle)$ cat tests/data/tasks/tanium/runtime/Tanium.oscal.json\n</code></pre> sample:  Tanium.oscal.json <pre><code>{\n\"results\": [\n{\n\"uuid\": \"f79add8e-488a-45f3-9024-72ecf95c7952\",\n\"title\": \"Tanium\",\n\"description\": \"Tanium\",\n\"start\": \"2021-05-12T13:46:46.000+00:00\",\n\"end\": \"2021-05-12T13:46:46.000+00:00\",\n\"local-definitions\": {\n\"components\": {\n\"1ea447fe-a2af-4110-baae-c70ed5223261\": {\n\"type\": \"Operating System\",\n\"title\": \"Red Hat Enterprise Linux 8\",\n\"description\": \"Red Hat Enterprise Linux 8\",\n\"status\": {\n\"state\": \"operational\"\n}\n}\n},\n\"inventory-items\": [\n{\n\"uuid\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"description\": \"inventory\",\n\"props\": [\n{\n\"name\": \"Computer Name\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"RHEL8\"\n},\n{\n\"name\": \"Tanium Client IP Address\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"192.168.0.125\",\n\"class\": \"scc_inventory_item_id\"\n},\n{\n\"name\": \"IP Address\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"['192.168.0.125', '192.168.122.1', 'fe80::3c47:1aff:fe33:601']\"\n},\n{\n\"name\": \"Count\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1\"\n}\n],\n\"implemented-components\": [\n{\n\"component-uuid\": \"1ea447fe-a2af-4110-baae-c70ed5223261\"\n}\n]\n}\n]\n},\n\"reviewed-controls\": {\n\"control-selections\": [\n{}\n]\n},\n\"observations\": [\n{\n\"uuid\": \"e67f5fd9-5b1f-4134-a67e-cebdc2e5735c\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.1_Ensure_mounting_of_cramfs_filesystems_is_disabled\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"fail\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-12T13:46:46+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-12T13:46:46.000+00:00\"\n},\n{\n\"uuid\": \"6cb81459-9c25-4a8b-bf3c-d8ff08ee728c\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.3_Ensure_mounting_of_squashfs_filesystems_is_disabled\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.1.3_Ensure_mounting_of_squashfs_filesystems_is_disabled\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.3_Ensure_mounting_of_squashfs_filesystems_is_disabled\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.3_Ensure_mounting_of_squashfs_filesystems_is_disabled\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"fail\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-12T13:46:46+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-12T13:46:46.000+00:00\"\n},\n{\n\"uuid\": \"9453eaed-db41-4a20-b684-2887de2d9657\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.4_Ensure_mounting_of_udf_filesystems_is_disabled\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.1.4_Ensure_mounting_of_udf_filesystems_is_disabled\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.4_Ensure_mounting_of_udf_filesystems_is_disabled\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1.4_Ensure_mounting_of_udf_filesystems_is_disabled\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"fail\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-12T13:46:46+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-12T13:46:46.000+00:00\"\n},\n{\n\"uuid\": \"a37c2569-8695-4cfe-8b5c-bd8d6eaf9df7\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.10_Ensure_noexec_option_set_on_vartmp_partition\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.10_Ensure_noexec_option_set_on_vartmp_partition\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.10_Ensure_noexec_option_set_on_vartmp_partition\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.10_Ensure_noexec_option_set_on_vartmp_partition\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"pass\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-12T13:46:46+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-12T13:46:46.000+00:00\"\n},\n{\n\"uuid\": \"b77e1b49-a818-4d43-adaf-69effcbd9219\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.14_Ensure_nodev_option_set_on_home_partition\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.14_Ensure_nodev_option_set_on_home_partition\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.14_Ensure_nodev_option_set_on_home_partition\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.14_Ensure_nodev_option_set_on_home_partition\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"pass\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-12T13:46:46+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-12T13:46:46.000+00:00\"\n},\n{\n\"uuid\": \"ac25b329-7a4a-45f4-b42b-1cce470e237b\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.15_Ensure_nodev_option_set_on_devshm_partition\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.15_Ensure_nodev_option_set_on_devshm_partition\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.15_Ensure_nodev_option_set_on_devshm_partition\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.15_Ensure_nodev_option_set_on_devshm_partition\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"pass\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-12T13:46:46+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-12T13:46:46.000+00:00\"\n},\n{\n\"uuid\": \"f9c0f033-f08b-431d-b411-fe1f63c2c98c\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.16_Ensure_nosuid_option_set_on_devshm_partition\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.16_Ensure_nosuid_option_set_on_devshm_partition\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.16_Ensure_nosuid_option_set_on_devshm_partition\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.16_Ensure_nosuid_option_set_on_devshm_partition\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"pass\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-12T13:46:46+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-12T13:46:46.000+00:00\"\n},\n{\n\"uuid\": \"149a814e-7f80-4e6d-a613-54f027e0d663\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.17_Ensure_noexec_option_set_on_devshm_partition\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.17_Ensure_noexec_option_set_on_devshm_partition\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.17_Ensure_noexec_option_set_on_devshm_partition\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.17_Ensure_noexec_option_set_on_devshm_partition\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"fail\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-12T13:46:46+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-12T13:46:46.000+00:00\"\n},\n{\n\"uuid\": \"a0e602b5-e587-41c5-846b-675b26cf3e18\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.18_Ensure_nodev_option_set_on_removable_media_partitions\",\n\"props\": [\n{\n\"name\": \"Check ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark;1.0.0-1;Level 1 - Server;1;xccdf_org.cisecurity.benchmarks_rule_1.1.18_Ensure_nodev_option_set_on_removable_media_partitions\"\n},\n{\n\"name\": \"Check ID Benchmark\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"CIS Red Hat Enterprise Linux 8 Benchmark\",\n\"class\": \"scc_predefined_profile\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_check_version\"\n},\n{\n\"name\": \"Check ID Version\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"1.0.0-1\",\n\"class\": \"scc_predefined_profile_version\"\n},\n{\n\"name\": \"Check ID Level\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"Level 1 - Server\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.18_Ensure_nodev_option_set_on_removable_media_partitions\",\n\"class\": \"scc_goal_description\"\n},\n{\n\"name\": \"Rule ID\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.18_Ensure_nodev_option_set_on_removable_media_partitions\",\n\"class\": \"scc_check_name_id\"\n},\n{\n\"name\": \"State\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"notchecked\",\n\"class\": \"scc_result\"\n},\n{\n\"name\": \"Timestamp\",\n\"ns\": \"https://ibm.github.io/compliance-trestle/schemas/oscal/ar/tanium\",\n\"value\": \"2021-05-12T13:46:46+00:00\",\n\"class\": \"scc_timestamp\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2d33d2b0-af5c-4c37-85b1-e4f414183de2\",\n\"type\": \"inventory-item\"\n}\n],\n\"collected\": \"2021-05-12T13:46:46.000+00:00\"\n}\n],\n\"findings\": [\n{\n\"uuid\": \"00000000-0000-4000-8000-000000000000\",\n\"title\": \"No Finding.\",\n\"description\": \"No Finding.\"\n}\n]\n}\n]\n}\n</code></pre> <p> Congratulations! You have bridged Tanium data into an OSCAL Assessment Results using compliance-trestle. </p> <p> </p> <p>Newtown, Victoria</p> <p></p>"},{"location":"tutorials/task.transformer-construction/transformer-construction/","title":"Tutorial: How to build an Oscal Assessment Results \"lite\" with Trestle SDK from your posture result format","text":"<p>The compliance-trestle (trestle) project provides helpful modules to assist your standardization efforts. Discussed below are some best practices for automated bridging to NIST OSCAL.</p>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#why-nist-oscal","title":"Why NIST OSCAL?","text":"<p>The Open Security Controls Assessment Language OSCAL is a set of formats expressed in XML, JSON, and YAML that provide machine-readable representations of control catalogs, control baselines, system security plans, and assessment plans and results as adopted by the National Institute of Standards and Technology NIST.</p> <p>Standardizing to OSCAL facilitates data interchange and understandability.</p>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#objective","title":"Objective","text":"<p>The objective here is to transform your compliance data into valid OSCAL, in particular System Assessment Results SAR.</p> <p>Examples of existing transformers  included with trestle are for the OpenShift Compliance Operator OSCO and Tanium.</p>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#overview","title":"Overview","text":"<p>You have a source of compliance data that is in non-OSCAL format (spreadsheet, XML, JSON, database, object-store...) and you would like to transform into standardized form in terms of NIST OSCAL. Presumed is an existing method for obtaining the compliance data from the cloud and materializing on disk as one or more files.</p> <p></p> <ul> <li>Source files on disk (pink) is our starting point.</li> <li>OSCAL files on disk (blue) is our ending point.</li> <li>OSCAL object management and emitter Python code are provided by trestle (green).</li> <li>Transformation Python code (yellow) is to be written by you.</li> </ul> <p>Other possible code stack configurations (not shown):</p> <ul> <li>write your own command module (file interface), but use trestle logic module (data processing)</li> <li>write your own command and logic modules, but rely on trestle OSCAL support and base</li> </ul> <p>For example, one could create an auditree-arboretum harvest report (file interface) that employs the trestle osco-result-to-oscal-ar transformation (data processing) module.</p>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#choose-mapping-strategy","title":"Choose Mapping Strategy","text":"<p>There are 3 potential levels of OSCAL Assessment Results that can be emitted by your transformer. From most complex to least complex they are:</p> <ul> <li>a complete SAR</li> <li>a partial SAR comprising Findings with Observations</li> <li>a partial SAR comprising Observations only</li> </ul> <p>Below is a snippet from the SAR model with these three levels shown.</p> <p></p> <p>Although producing a complete SAR is possible, this transformation is not covered here. We focus on partial results, either Observations only or Observations with Findings.</p> <p>Based on the data in hand from your compliance data source, and additional metadata that can be made available at the time of transformation, choose the best fit.</p>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#observations-only","title":"Observations only","text":"<p>Emitting Observations only requires just rudimentary source data. For example, if each instance of source data includes not much more than:</p> <ul> <li>inventory-name: ssg-ocp4-ds-cis-111.222.333.444-pod</li> <li>rule-name: xccdf_org.ssgproject.content_rule_scheduler_profiling_argument</li> <li>rule-result: fail</li> </ul> <p>then the best mapping would be to an Observations only.</p> example snippet: instance suitable for mapping to Observation <pre><code>data: &lt;rule-result idref=\"xccdf_org.ssgproject.content_rule_scheduler_profiling_argument\"\ntime=\"2020-08-03T02:26:26+00:00\" severity=\"low\" weight=\"1.000000\"&gt; &lt;result&gt;fail&lt;/result&gt;\n&lt;/rule-result&gt;\nmetadata:\nname: ssg-ocp4-ds-cis-111.222.333.444-pod\n</code></pre> example snippet: instance OSCAL Observation <pre><code>{\n\"uuid\": \"56666738-0f9a-4e38-9aac-c0fad00a5821\",\n\"title\": \"xccdf_org.ssgproject.content_rule_scheduler_profiling_argument\",\n\"description\": \"xccdf_org.ssgproject.content_rule_scheduler_profiling_argument\",\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"56666738-0f9a-4e38-9aac-c0fad00a5821\",\n\"type\": \"component\",\n\"title\": \"Red Hat OpenShift Kubernetes\"\n},\n{\n\"uuid-ref\": \"46aADFAC-A1fd-4Cf0-a6aA-d1AfAb3e0d3e\",\n\"type\": \"inventory-item\",\n\"title\": \"Pod\",\n\"props\": [\n{\n\"name\": \"target\",\n\"value\": \"kube-br7qsa3d0vceu2so1a90-roksopensca-default-0000026b.iks.mycorp\"\n},\n{\n\"name\": \"cluster-name\",\n\"value\": \"ROKS-OpenSCAP-1\"\n},\n{\n\"name\": \"cluster-type\",\n\"value\": \"openshift\"\n},\n{\n\"name\": \"cluster-region\",\n\"value\": \"us-south\"\n}\n]\n}\n],\n\"relevant-evidence\": [\n{\n\"href\": \"https://github.mycorp.com/degenaro/evidence-locker\",\n\"description\": \"Evidence location.\",\n\"props\": [\n{\n\"name\": \"rule\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"id\",\n\"value\": \"xccdf_org.ssgproject.content_rule_scheduler_profiling_argument\"\n},\n{\n\"name\": \"time\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"timestamp\",\n\"value\": \"2020-08-03T02:26:26+00:00\"\n},\n{\n\"name\": \"result\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"result\",\n\"value\": \"fail\"\n},\n{\n\"name\": \"target\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"target\",\n\"value\": \"kube-br7qsa3d0vceu2so1a90-roksopensca-default-0000026b.iks.mycorp\"\n}\n]\n}\n]\n}\n</code></pre>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#findings-with-observations","title":"Findings with Observations","text":"<p>To additionally produce Findings, information about the controls associated with each rule-name is required. The control information can be part of the source data itself or can be provided as one or more supplemental metadata files.</p> <p>If each instance of source data includes:</p> <ul> <li>inventory-name: cmp-wn-2115.demo.tanium.local</li> <li>rule-name: xccdf_org.cisecurity.benchmarks_rule_19.7.44.2.1_L2_Ensure_Prevent_Codec_Download_is_set_to_Enabled</li> <li>rule-result: fail</li> <li>control-name: 800-53: SC-18</li> </ul> <p>then the best mapping wound be to Findings with Observations.</p> example snippet: xml instance suitable for mapping to Finding with Observation <pre><code>{\n\"IP Address\": \"10.8.68.218\",\n\"Computer Name\": \"cmp-wn-2115.demo.tanium.local\",\n\"Comply - JovalCM Results[c2dc8749]\": [\n{\n\"Benchmark\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\",\n\"Benchmark Version\": \"1.5.0.1\",\n\"Profile\": \"Windows 10 - NIST 800-53\",\n\"ID\": \"xccdf_org.cisecurity.benchmarks_rule_19.7.44.2.1_L2_Ensure_Prevent_Codec_Download_is_set_to_Enabled\",\n\"Result\": \"fail\",\n\"Custom ID\": \"800-53: SC-18\",\n\"Version\": \"version: 1\"\n}\n],\n\"Count\": \"1\",\n\"Age\": \"600\"\n}\n</code></pre> example snippet: instance OSCAL Finding <pre><code>{\n\"findings\": [\n{\n\"uuid\": \"99c0a0de-e34e-4e22-95a1-1d4f24826565\",\n\"title\": \"800-53: IA-5\",\n\"description\": \"800-53: IA-5\",\n\"collected\": \"2021-03-16T13:29:14.000+00:00\",\n\"objective-status\": {\n\"props\": [\n{\n\"name\": \"profile\",\n\"ns\": \"dns://tanium\",\n\"class\": \"source\",\n\"value\": \"NIST 800-53\"\n},\n{\n\"name\": \"id-ref\",\n\"ns\": \"dns://tanium\",\n\"class\": \"source\",\n\"value\": \"IA-5\"\n},\n{\n\"name\": \"result\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"STRVALUE\",\n\"value\": \"FAIL\"\n}\n],\n\"status\": \"not-satisfied\"\n},\n\"related-observations\": [\n{\n\"observation-uuid\": \"61092735-e365-4638-bc2c-ecd0ed407e73\"\n},\n{\n\"observation-uuid\": \"95a20b8e-ed0a-4b6c-bf87-8789265c7158\"\n}\n]\n}\n]\n}\n</code></pre> example snippet: instance OSCAL Observation <pre><code>{\n\"observations\": [\n{\n\"uuid\": \"61092735-e365-4638-bc2c-ecd0ed407e73\",\n\"description\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1_L1_Ensure_Enforce_password_history_is_set_to_24_or_more_passwords\",\n\"props\": [\n{\n\"name\": \"benchmark\",\n\"ns\": \"dns://tanium\",\n\"class\": \"source\",\n\"value\": \"CIS Microsoft Windows 10 Enterprise Release 1803 Benchmark\"\n},\n{\n\"name\": \"rule\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"id\",\n\"value\": \"xccdf_org.cisecurity.benchmarks_rule_1.1.1_L1_Ensure_Enforce_password_history_is_set_to_24_or_more_passwords\"\n},\n{\n\"name\": \"result\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"result\",\n\"value\": \"pass\"\n},\n{\n\"name\": \"time\",\n\"ns\": \"dns://xccdf\",\n\"class\": \"timestamp\",\n\"value\": \"2021-03-16T13:29:14+00:00\"\n}\n],\n\"methods\": [\n\"TEST-AUTOMATED\"\n],\n\"subjects\": [\n{\n\"uuid-ref\": \"2650b9ba-e767-4381-9a3f-127d1552d7d2\",\n\"type\": \"inventory-item\"\n}\n]\n}\n]\n}\n</code></pre> example snippet: local definitions <pre><code>{\n\"results\": [\n{\n\"uuid\": \"98028241-8705-4211-bf36-71e1f7aa6192\",\n\"title\": \"Tanium\",\n\"description\": \"Tanium\",\n\"start\": \"2021-03-16T13:29:14.000+00:00\",\n\"local-definitions\": {\n\"inventory-items\": [\n{\n\"uuid\": \"2650b9ba-e767-4381-9a3f-127d1552d7d2\",\n\"description\": \"inventory\",\n\"props\": [\n{\n\"name\": \"computer-name\",\n\"ns\": \"dns://tanium\",\n\"class\": \" inventory-item\",\n\"value\": \"cmp-wn-2106.demo.tanium.local\"\n},\n{\n\"name\": \"computer-ip\",\n\"ns\": \"dns://tanium\",\n\"class\": \" inventory-item\",\n\"value\": \"fe80::3cd5:564b:940e:49ab\"\n},\n{\n\"name\": \"profile\",\n\"ns\": \"dns://tanium\",\n\"class\": \" inventory-item\",\n\"value\": \"Windows 10\"\n}\n]\n}\n]\n}\n}\n]\n}\n</code></pre>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#implement-mapping-strategy","title":"Implement Mapping Strategy","text":"<p>The best practice for building a transformer is to employ layers. Recall that the top two layers (in yellow) are for you to implement, while the bottom two layers (in green) are provided by trestle to assist you.</p> <p>Trestle is a Python based multi-faceted platform that simplifies this task by providing a set of Python classes which enforce adherence to the OSCAL schema, insuring that the produced OSCAL validates.</p> <ul> <li>file interfacing (read/write files)</li> <li>data processing (in-memory object structure construction)</li> <li>use of OSCAL versioned platform objects (trestle base and oscal functionality)</li> </ul>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#file-interfacing","title":"File Interfacing","text":"<p>Write a command line tool, for example a trestle task or auditree-arboretum harvest report that:</p> <ul> <li>imports the commensurate data processing module</li> <li>reads the input</li> <li>send input to data processing module</li> <li>receives transformed data from data processing module</li> <li>writes the output</li> </ul>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#data-processing","title":"Data Processing","text":"<p>Write a data processing module that receives data, and optionally metadata, for transformation from native form into OSCAL. Separation from the command line file read/write mechanism allows for module re-use.</p> <p>The module should:</p> <ul> <li>import the trestle oscal module</li> <li>receive input data to be transformed</li> <li>receive metadata, optionally</li> <li>transform input into trestle oscal classes hierarchy</li> <li>send transformed OSCAL data in return</li> </ul> <p>For the Observation only case, the transform is straight forward. Code should create one Observation for each rule/result pair.</p> <p>For the Findings case, a bit more logic is required. Code should accumulate Observations for each Finding and determine an overall status for it. For example, if 15 Observations are found for Finding control AC-3, where 14 have result=PASS and 1 has result=FAIL, then the overall status for the Finding would be <code>not satisfied</code> with overall result=FAIL.</p>"},{"location":"tutorials/task.transformer-construction/transformer-construction/#examples","title":"Examples","text":"<p>There are 2 transformers in trestle. The osco-result-to-oscal-ar transformer emits OSCAL Observations, the simplest partial result.</p> <p>The tanium-result-to-oscal-ar transformer emits OSCAL Findings, a more complex partial result.</p> <p>Table of approximate lines of code.</p> task-name  OSCAL type  file interface  data processing  test cases   osco-result-to-oscal-ar  Observations only  275  350  400   tanum-to-oscal  Findings, with Observations  200  350  300"},{"location":"tutorials/task.transformer-construction/transformer-construction/#contributing","title":"Contributing","text":"<p>Consider contributing your transformer to trestle or auditree-arboretum or other appropriate open source repository.</p>"}]}